['text':'*
 *    Copyright (C) 2020-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':41,'multiline':False]['text':'
 * $_internalUnpackBucket is an internal stage for materializing time-series measurements from
 * time-series collections. It should never be used anywhere outside the MongoDB server.
 ','line_number':98,'multiline':True]['text':'
 * $_unpackBucket is an alias of $_internalUnpackBucket. It only exposes the "timeField" and the
 * "metaField" parameters and is only used for special known use cases by other MongoDB products
 * rather than user applications.
 ','line_number':107,'multiline':True]['text':'*
 * A projection can be internalized if every field corresponds to a boolean value. Note that this
 * correctly rejects dotted fieldnames, which are mapped to objects internally.
 ','line_number':121,'multiline':True]['text':'*
 * If 'src' represents an inclusion or exclusion $project, return a BSONObj representing it and a
 * bool indicating its type (true for inclusion, false for exclusion). Else return an empty BSONObj.
 ','line_number':129,'multiline':True]['text':'*
 * Creates a new DocumentSourceSort by pulling out the logic for getting maxMemoryUsageBytes.
 ','line_number':144,'multiline':True]['text':'*
 * Checks if a sort stage's pattern following our internal unpack bucket is suitable to be reordered
 * before us. The sort stage must refer exclusively to the meta field or any subfields.
 *
 * If this check is being used for lastpoint, the sort stage can also refer to the time field,
 * which should be the last field in the pattern.
 ','line_number':156,'multiline':True]['text':' If we are checking the sort pattern for the lastpoint case, 'time' is allowed.','line_number':177,'multiline':False]['text':' The time field was not the last field in the sort pattern.','line_number':184,'multiline':False]['text':' If we are checking for lastpoint, make sure we encountered the time field.','line_number':189,'multiline':False]['text':'*
 * Returns a new DocumentSort to reorder before current unpack bucket document.
 ','line_number':193,'multiline':True]['text':' After the modifications of the sortPattern are completed, for the lastPoint','line_number':232,'multiline':False]['text':' optimizations, the group field needs to be added to the beginning of the sort pattern.','line_number':233,'multiline':False]['text':' Do note that the modified sort pattern is for sorting within a group (within the bucket)','line_number':234,'multiline':False]['text':' and the plan is to do the grouping and sort within on go.','line_number':235,'multiline':False]['text':' If the group field is already in the sortPattern then it needs to moved to the first','line_number':236,'multiline':False]['text':' position. A flip in the later case is not necessary anymore as the sort order was','line_number':237,'multiline':False]['text':' already flipped.','line_number':238,'multiline':False]['text':' Example 1: $group: {a:1}, $sort{b: 1, a: -1} --> modifiedPattern: {a: -1, b: 1}','line_number':239,'multiline':False]['text':' Example 2: $group: {c:1}, $sort{d: -1, e: 1} --> modifiedPattern: {c: 1, d: -1, e: 1}','line_number':240,'multiline':False]['text':'*
 * Returns a new DocumentSourceGroup to add before current unpack bucket document.
 ','line_number':263,'multiline':True]['text':' The $first accumulator is compatible with SBE.','line_number':282,'multiline':False]['text':' Optimize the section of the pipeline before the $_internalUnpackBucket stage.','line_number':288,'multiline':False]['text':' seconds in 1 day ','line_number':301,'multiline':True]['text':' The path must be at the timeField for this re-write to be correct (and the zero','line_number':314,'multiline':False]['text':' component is always CURRENT).','line_number':315,'multiline':False]['text':' Validate the bucket boundaries align with the date produced by $dateTrunc. We don't','line_number':321,'multiline':False]['text':' have access to any documents, so 'unit' and  'binSize' must be constants or can be','line_number':322,'multiline':False]['text':' optimized to a constant. The smallest possible value for 'bucketMaxSpanSeconds' is 1 second,','line_number':323,'multiline':False]['text':' and therefore if the 'unit' is a millisecond, the rewrite does not apply.','line_number':324,'multiline':False]['text':' Confirm that the 'binSize' and 'unit' provided is a multiple of 'bucketMaxSpanSeconds',','line_number':338,'multiline':False]['text':' to ensure the predicate aligns with the bucket boundaries.','line_number':339,'multiline':False]['text':' The rewrite will result in incorrect results, if the timezone doesn't align with','line_number':350,'multiline':False]['text':' the bucket boundaries. If the bucket's boundary is greater than one hour, measurements in','line_number':351,'multiline':False]['text':' the same bucket might be considered in different groups for different timezones. For','line_number':352,'multiline':False]['text':' example, two measurements might be on the same day for one timezone but on different days','line_number':353,'multiline':False]['text':' in another timezones. So, this rewrite is restricted to buckets spanning an hour or less','line_number':354,'multiline':False]['text':' if the timezone is specified.','line_number':355,'multiline':False]['text':' seconds in 1 hour ','line_number':356,'multiline':True]['text':' If the bucket boundaries align, we should rewrite $dateTrunc to use the minimum','line_number':362,'multiline':False]['text':' timeField stored in the control field.','line_number':363,'multiline':False]['text':'_kUnit ','line_number':370,'multiline':True]['text':' _kBinSize ','line_number':371,'multiline':True]['text':' _kTimeZone ','line_number':372,'multiline':True]['text':' _kStartOfWeek ','line_number':373,'multiline':True]['text':' Returns true if all the field paths contained in the expression only reference the metaField or','line_number':376,'multiline':False]['text':' some subfield(s) of the metaField.','line_number':377,'multiline':False]['text':' Rewrites all the fields paths in the given expression that contain the metafield to use','line_number':398,'multiline':False]['text':' kBucketMetaFieldName instead.','line_number':399,'multiline':False]['text':' We need to clone here to avoid corrupting the original expression if the optimization cannot','line_number':408,'multiline':False]['text':' be made. E.g., if a subsequent group by element contains a field path that references a time','line_number':409,'multiline':False]['text':' series field.','line_number':410,'multiline':False]['text':'','line_number':411,'multiline':False]['text':' Clone by serializing and reparsing. There does not seem to be a more idiomatic way to do this','line_number':412,'multiline':False]['text':' at the moment.','line_number':413,'multiline':False]['text':' mutatedExpr may be null if the root of the expression tree was not updated, but','line_number':424,'multiline':False]['text':' clonedExpr will still have been updated in-place.','line_number':425,'multiline':False]['text':' We allow the $group stage to be rewritten if the _id field only consists of these 3 options:','line_number':440,'multiline':False]['text':' 1. If the _id field is constant.','line_number':441,'multiline':False]['text':' 2. If the _id field is an expression whose fieldPaths are at or under the metaField.','line_number':442,'multiline':False]['text':' 3. For fixed buckets collection, if the _id field is a $dateTrunc expressions on the','line_number':443,'multiline':False]['text':' timeField.','line_number':444,'multiline':False]['text':' Option 2: The only field path supported is at or under the metaField.','line_number':449,'multiline':False]['text':' Option 3: Currently the only allowed field path not on the metaField is $dateTrunc on the','line_number':454,'multiline':False]['text':' timeField if the buckets are fixed and do not use an extended range.','line_number':455,'multiline':False]['text':' We rewrite {$sum: 1} to use the bucket level field names and account for','line_number':466,'multiline':False]['text':' compressed/uncompressed buckets. The resulting MQL will look like:','line_number':467,'multiline':False]['text':'$sum : {','line_number':468,'multiline':False]['text':'  $cond: [','line_number':469,'multiline':False]['text':'    {$gte : [ "$control.version", 2 ]},','line_number':470,'multiline':False]['text':'    "$control.count",','line_number':471,'multiline':False]['text':'    {$size : {$objectToArray : "$data.t"}}]}}','line_number':472,'multiline':False]['text':' We expect most buckets to be compressed, and should just reference $control.count.','line_number':473,'multiline':False]['text':' This is either a const or a compound expression. While some such expressions (e.g: {$min:','line_number':519,'multiline':False]['text':' {$add: ['$a', 2]}}) could be re-written in terms of the min/max on the control fields, in','line_number':520,'multiline':False]['text':' general we cannot do it (e.g. {$min: {$add: ['$a', '$b']}}), so we block the re-write.','line_number':521,'multiline':False]['text':' Path can have a single component if it's using $$CURRENT or a similar variable. We don't','line_number':526,'multiline':False]['text':' support these.','line_number':527,'multiline':False]['text':' Build the paths for the bucket-level fields.','line_number':534,'multiline':False]['text':' Update aggregates to reference the meta field.','line_number':537,'multiline':False]['text':' Update aggregates to reference the control field.','line_number':544,'multiline':False]['text':' Rewrite not valid for the timeField because control.min.time contains a rounded-down','line_number':547,'multiline':False]['text':' time and not the actual min time of events in the bucket.','line_number':548,'multiline':False]['text':' Re-create the accumulator using the bucket-level paths.','line_number':567,'multiline':False]['text':' namespace','line_number':610,'multiline':False]['text':' Optimizing '_eventFilter' here duplicates predicates in $expr expressions.','line_number':638,'multiline':False]['text':' TODO SERVER-79692 remove the 'shouldOptimize' boolean.','line_number':639,'multiline':False]['text':' shouldOptimize ','line_number':640,'multiline':True]['text':' If neither "include" nor "exclude" is specified, the default is "exclude": [] and','line_number':659,'multiline':False]['text':' if that's the case, no field will be added to 'bucketSpec.fieldSet' in the for-loop below.','line_number':660,'multiline':False]['text':' Use extended-range support if any individual collection requires it, even if 'specElem'','line_number':662,'multiline':False]['text':' doesn't mention this flag.','line_number':663,'multiline':False]['text':' We only expose "timeField" and "metaField" as parameters in $_unpackBucket.','line_number':821,'multiline':False]['text':' Using the bucket span associated with the default granularity seconds.','line_number':854,'multiline':False]['text':' fixedBuckets ','line_number':857,'multiline':True]['text':' Include this flag so that 'explain' is more helpful.','line_number':894,'multiline':False]['text':' But this is not so useful for communicating from one process to another,','line_number':895,'multiline':False]['text':' because mongos and/or the primary shard don't know whether any other shard','line_number':896,'multiline':False]['text':' has extended-range data.','line_number':897,'multiline':False]['text':' MatchExpression only takes BSON documents, so we have to make one. As an','line_number':960,'multiline':False]['text':' optimization, only serialize the fields we need to do the match.','line_number':961,'multiline':False]['text':' Otherwise, fallback to unpacking every measurement in all buckets until the child stage is','line_number':981,'multiline':False]['text':' exhausted.','line_number':982,'multiline':False]['text':' Extend bucket specification of this stage to include the computed meta projections','line_number':1031,'multiline':False]['text':' that are passed through.','line_number':1032,'multiline':False]['text':' Insert extracted computed projections before the $_internalUnpackBucket.','line_number':1038,'multiline':False]['text':' Remove the next stage if it became empty after the field extraction.','line_number':1043,'multiline':False]['text':' Having an '_eventFilter' might make the unpack stage incompatible with SBE. Rather','line_number':1056,'multiline':False]['text':' than tracking the specific exprs, we temporarily reset the context to be fully SBE','line_number':1057,'multiline':False]['text':' compatible and check after parsing if the '_eventFilter' made the unpack stage','line_number':1058,'multiline':False]['text':' incompatible.','line_number':1059,'multiline':False]['text':' enableSimplification ','line_number':1067,'multiline':True]['text':' Reset the sbeCompatibility taking _eventFilter into account.','line_number':1071,'multiline':False]['text':' 'fields' are the top-level fields to be included/excluded by the unpacker. We handle the','line_number':1081,'multiline':False]['text':' special case of _id, which may be excluded in an inclusion $project (or vice versa), here.','line_number':1082,'multiline':False]['text':' Update '_bucketUnpacker' state with the new fields and behavior.','line_number':1089,'multiline':False]['text':' There is no project to internalize or there are already fields being included/excluded.','line_number':1099,'multiline':False]['text':' Check for a viable inclusion $project after the $_internalUnpackBucket.','line_number':1103,'multiline':False]['text':' Note: an $_internalUnpackBucket stage with a set of 'kInclude' fields and an event filter is','line_number':1104,'multiline':False]['text':' equivalent to [{$_internalUnpackBucket}{$project}{$match}] -- in _this_ order. That is, if','line_number':1105,'multiline':False]['text':' the $match is on a field that is not included by $project, the result must be an empty set.','line_number':1106,'multiline':False]['text':' But if the stage already has an '_eventFilter', it means we started with pipeline like','line_number':1107,'multiline':False]['text':' [{$_internalUnpackBucket}{$match}{$project}], which might return non-empty set of results, so','line_number':1108,'multiline':False]['text':' we cannot internalize the $project.','line_number':1109,'multiline':False]['text':' Attempt to get an inclusion $project representing the root-level dependencies of the pipeline','line_number':1117,'multiline':False]['text':' after the $_internalUnpackBucket. If this $project is not empty, then the dependency set was','line_number':1118,'multiline':False]['text':' finite.','line_number':1119,'multiline':False]['text':' includeEventFilter ','line_number':1120,'multiline':True]['text':' Check for a viable exclusion $project after the $_internalUnpackBucket.','line_number':1127,'multiline':False]['text':' Rewriting a group might make it incompatible with SBE (e.g. if the rewrite is using','line_number':1165,'multiline':False]['text':' accumulator exprs that are not supported in SBE yet). Rather than tracking the specific','line_number':1166,'multiline':False]['text':' exprs, we temporarily reset the context to be fully SBE compatible and check later if any of','line_number':1167,'multiline':False]['text':' the exprs created by the rewrite mark it as incompatible, so that we can transfer the flag','line_number':1168,'multiline':False]['text':' onto the group.','line_number':1169,'multiline':False]['text':' We destruct 'this' object when we replace it with the new group, so the guard has to capture','line_number':1173,'multiline':False]['text':' the context's intrusive pointer by value.','line_number':1174,'multiline':False]['text':' The computed min/max for each bucket uses the default collation. If the collation of the','line_number':1179,'multiline':False]['text':' query doesn't match the default we cannot rely on the computed values as they might differ','line_number':1180,'multiline':False]['text':' (e.g. numeric and lexicographic collations compare "5" and "10" in opposite order).','line_number':1181,'multiline':False]['text':' NB: Unfortuntealy, this means we have to forgo the optimization even if the source field is','line_number':1182,'multiline':False]['text':' numeric and not affected by the collation as we cannot know the data type until runtime.','line_number':1183,'multiline':False]['text':' If _any_ of the accumulators aren't $min/$max/$count we won't perform the re-write (some','line_number':1213,'multiline':False]['text':' other accs might be re-writable in terms of the bucket controls, we just haven't invested','line_number':1214,'multiline':False]['text':' into implementing them). $count is desugared to {$sum: 1}.','line_number':1215,'multiline':False]['text':' The exprs used in the rewritten group might or might not be supported by SBE, so we have to','line_number':1239,'multiline':False]['text':' transfer the state from the expr context onto the group.','line_number':1240,'multiline':False]['text':' Replace the current stage (DocumentSourceInternalUnpackBucket) and the following group stage','line_number':1243,'multiline':False]['text':' with the new group.','line_number':1244,'multiline':False]['text':' NB: Below this point any access to members of 'this' is invalid!','line_number':1247,'multiline':False]['text':' Optimize the new group stage.','line_number':1250,'multiline':False]['text':' Give chance to the previous stage to optimize against the new group stage.','line_number':1253,'multiline':False]['text':' skip unpack stage','line_number':1266,'multiline':False]['text':' If this is after the sort, the sort is invalidated. If it's before the sort, there's','line_number':1280,'multiline':False]['text':' no harm in keeping the boolean false.','line_number':1281,'multiline':False]['text':' We modify time field, so we can't proceed with optimization. It may be possible to','line_number':1284,'multiline':False]['text':' proceed in some cases if the modification happens before the sort, but we won't worry','line_number':1285,'multiline':False]['text':' about or bother with those - in large part because it is risky that it will change the','line_number':1286,'multiline':False]['text':' type away from a date into something with more difficult/subtle semantics.','line_number':1287,'multiline':False]['text':' To enable streaming, we need id field expression to be clustered, so that all documents','line_number':1300,'multiline':False]['text':' with the same value of this id field are in a single continious cluster. However this','line_number':1301,'multiline':False]['text':' property is hard to check for, so we check for monotonicity instead, which is stronger.','line_number':1302,'multiline':False]['text':' We optimize here to make use of constant folding.','line_number':1303,'multiline':False]['text':' We don't add monotonic::State::Constant id fields, because they are useless when','line_number':1306,'multiline':False]['text':' determining if a group batch is finished.','line_number':1307,'multiline':False]['text':' Streaming group isn't supported in SBE yet and we don't want to run the pipeline in hybrid','line_number':1324,'multiline':False]['text':' mode due to potential perf impact.','line_number':1325,'multiline':False]['text':' If this accumulator will not return a single document then we cannot rewrite this query to','line_number':1337,'multiline':False]['text':' use a $sort + a $group with $first or $last.','line_number':1338,'multiline':False]['text':' We may have a $topN or a $bottomN with n = 1; in this case, we may still be able to','line_number':1340,'multiline':False]['text':' perform the lastpoint rewrite.','line_number':1341,'multiline':False]['text':' Since this is a $const expression, the input to evaluate() should not matter.','line_number':1343,'multiline':False]['text':' Retrieve sort pattern for an equivalent $sort.','line_number':1353,'multiline':False]['text':' Retrieve equivalent accumulator statement using $first/$last for retrieving the entire','line_number':1360,'multiline':False]['text':' document.','line_number':1361,'multiline':False]['text':' Note: we don't need to preserve what the $top/$bottom accumulator outputs here. We only need','line_number':1364,'multiline':False]['text':' a $group stage with the appropriate accumulator that retrieves the bucket in some way. For','line_number':1365,'multiline':False]['text':' the rewrite we preserve the original group and insert an $group that returns all the data in','line_number':1366,'multiline':False]['text':' the $first bucket selected for each _id.','line_number':1367,'multiline':False]['text':' single ','line_number':1379,'multiline':True]['text':' single ','line_number':1382,'multiline':True]['text':' single ','line_number':1385,'multiline':True]['text':' single ','line_number':1388,'multiline':True]['text':' This isn't a topN/bottomN/top/bottom accumulator.','line_number':1391,'multiline':False]['text':' The lastpoint optimization ultimately inserts bucket-level $sort + $group to limit the amount of','line_number':1395,'multiline':False]['text':' data to be unpacked. Here we use the original $group to create a matching $sort followed by a','line_number':1396,'multiline':False]['text':' $group with $first/$last accumulator over $$ROOT as if it ran _after_ unpacking. We'll modify','line_number':1397,'multiline':False]['text':' these stages to run at the bucket-level later.','line_number':1398,'multiline':False]['text':' If we have multiple accumulators, we fail to optimize for a lastpoint query. Notice, that','line_number':1406,'multiline':False]['text':' this is too strict. The optimization can still be done for the same type of acc with','line_number':1407,'multiline':False]['text':' the same ordering. However, for this case the query can be re-written to combine the two','line_number':1408,'multiline':False]['text':' accumulators into one $top/$bottom with a concatenated 'output' array.','line_number':1409,'multiline':False]['text':' This isn't a topN/bottomN/top/bottom accumulator or N != 1.','line_number':1423,'multiline':False]['text':' The bucket-level group uses $first/$last accumulators that are supported by SBE.','line_number':1437,'multiline':False]['text':' namespace','line_number':1441,'multiline':False]['text':' A lastpoint-type aggregation must contain both a $sort and a $group stage, in that order, or','line_number':1445,'multiline':False]['text':' only a $group stage with a $top, $topN, $bottom, or $bottomN accumulator. This means we need','line_number':1446,'multiline':False]['text':' at least one stage after $_internalUnpackBucket.','line_number':1447,'multiline':False]['text':' If we only have one stage after $_internalUnpackBucket, it must be a $group for the','line_number':1452,'multiline':False]['text':' lastpoint rewrite to happen.','line_number':1453,'multiline':False]['text':' If we don't have a $sort + $group lastpoint query, we will need to replace the $group with','line_number':1457,'multiline':False]['text':' equivalent $sort + $group stages for the rewrite.','line_number':1458,'multiline':False]['text':' If the first stage is not a $group, we may have a $sort + $group lastpoint query.','line_number':1462,'multiline':False]['text':' Try to rewrite the $group to a $sort+$group-style lastpoint query before proceeding with','line_number':1466,'multiline':False]['text':' the optimization.','line_number':1467,'multiline':False]['text':' Both these stages should be discarded once we exit this function; either because the','line_number':1471,'multiline':False]['text':' rewrite failed validation checks, or because we created updated versions of these stages','line_number':1472,'multiline':False]['text':' in 'tryInsertBucketLevelSortAndGroup' below (which will be inserted into the pipeline).','line_number':1473,'multiline':False]['text':' The intrusive_ptrs above handle this deletion gracefully.','line_number':1474,'multiline':False]['text':' This $sort stage was previously followed by a $limit stage.','line_number':1484,'multiline':False]['text':' Check to see if $group uses only the specified accumulator.','line_number':1521,'multiline':False]['text':' We disallow firstpoint queries from participating in this rewrite due to the fact that we','line_number':1529,'multiline':False]['text':' round down control.min.time for buckets, which means that if we are given two buckets with','line_number':1530,'multiline':False]['text':' the same min time, we won't know which bucket contains the earliest time until we unpack','line_number':1531,'multiline':False]['text':' them and sort their measurements. Hence, this rewrite could give us an incorrect firstpoint.','line_number':1532,'multiline':False]['text':' This is a first-point query, which is disallowed.','line_number':1539,'multiline':False]['text':' This sorts on a metaField which does not match the $group's _id field.','line_number':1543,'multiline':False]['text':' Try to insert bucket-level $sort and $group stages before we unpack any buckets. We ensure','line_number':1550,'multiline':False]['text':' that the generated $group preserves all bucket fields, so that the $_internalUnpackBucket','line_number':1551,'multiline':False]['text':' stage and the original $group stage can read them.','line_number':1552,'multiline':False]['text':' Note that we don't erase any of the original stages for this rewrite. This allows us to','line_number':1570,'multiline':False]['text':' preserve the particular semantics of the original group (e.g. $top behaves differently','line_number':1571,'multiline':False]['text':' than topN with n = 1, $group accumulators have a special way of dealing with nulls, etc.)','line_number':1572,'multiline':False]['text':' without constructing a specialized projection to exactly match what the original query','line_number':1573,'multiline':False]['text':' would have returned.','line_number':1574,'multiline':False]['text':' If we lower the group at the bucket collection level to SBE we won't be able to unpack in','line_number':1584,'multiline':False]['text':' SBE due to the current limitations of 'TsBucketToCellBlockStage', but we don't want to','line_number':1585,'multiline':False]['text':' run this pipeline in hybrid mode because of the potential perf impact.','line_number':1586,'multiline':False]['text':' See ../query/timeseries/README.md for a description of all the rewrites implemented in this','line_number':1618,'multiline':False]['text':' function.','line_number':1619,'multiline':False]['text':' Some optimizations may not be safe to do if we have computed the metaField via an $addFields','line_number':1624,'multiline':False]['text':' or a computed $project. We won't do those optimizations if 'haveComputedMetaField' is true.','line_number':1625,'multiline':False]['text':' Before any other rewrites for the current stage, consider reordering with $sort.','line_number':1628,'multiline':False]['text':' We have a sort on metadata field following this stage. Reorder the two stages','line_number':1634,'multiline':False]['text':' and return a pointer to the preceding stage.','line_number':1635,'multiline':False]['text':' If the original sort had a limit that did not come from the limit value that we','line_number':1638,'multiline':False]['text':' just added above, we will not preserve that limit in the swapped sort. Instead we','line_number':1639,'multiline':False]['text':' will add a $limit to the end of the pipeline to keep the number of expected','line_number':1640,'multiline':False]['text':' results.','line_number':1641,'multiline':False]['text':' Reorder sort and current doc.','line_number':1646,'multiline':False]['text':' Try to optimize the current stage again.','line_number':1651,'multiline':False]['text':' Try to optimize the previous stage against $sort.','line_number':1654,'multiline':False]['text':' Attempt to push geoNear on the metaField past $_internalUnpackBucket.','line_number':1661,'multiline':False]['text':' Currently we only support geo indexes on the meta field, and we enforce this by','line_number':1664,'multiline':False]['text':' requiring the key field to be set so we can check before we try to look up indexes.','line_number':1665,'multiline':False]['text':' Currently we do not support query for $geoNear on a bucket','line_number':1671,'multiline':False]['text':' Make sure we actually re-write the key field for the buckets collection so we can','line_number':1679,'multiline':False]['text':' locate the index.','line_number':1680,'multiline':False]['text':' Save the source, remove it, and then push it down.','line_number':1686,'multiline':False]['text':' Don't push down query on measurements.','line_number':1693,'multiline':False]['text':' Optimize the pipeline after this stage to merge $match stages and push them forward, and to','line_number':1697,'multiline':False]['text':' take advantage of $expr rewrite optimizations.','line_number':1698,'multiline':False]['text':' If the end of the pipeline starts with a $geoNear stage, make sure it gets optimized','line_number':1706,'multiline':False]['text':' in a context where it knows there are other stages before it. It will split itself','line_number':1707,'multiline':False]['text':' up into separate $match and $sort stages. But it doesn't split itself up when it's','line_number':1708,'multiline':False]['text':' the first stage, because it expects to use a special DocumentSouceGeoNearCursor plan.','line_number':1709,'multiline':False]['text':' optimizeAt() is responsible for reordering stages, and optimize() is responsible for','line_number':1714,'multiline':False]['text':' simplifying individual stages. $sequentialCache's optimizeAt() places the stage where','line_number':1715,'multiline':False]['text':' it can cache as big a prefix of the pipeline as possible. To do so correctly, it','line_number':1716,'multiline':False]['text':' needs to look at dependencies: a stage that depends on a let-variable cannot be','line_number':1717,'multiline':False]['text':' cached. But optimize() can inline variables. Therefore, we want to avoid calling','line_number':1718,'multiline':False]['text':' optimize() before $sequentialCache has a chance to run optimizeAt().','line_number':1719,'multiline':False]['text':' Kick back out to optimizing this stage again a level up, so any matches that were','line_number':1728,'multiline':False]['text':' moved to directly after this stage can be moved before it if possible.','line_number':1729,'multiline':False]['text':' If the next stage is a limit, then push the limit above to avoid fetching more buckets than','line_number':1734,'multiline':False]['text':' necessary.','line_number':1735,'multiline':False]['text':' If _eventFilter is true, a match was present which may impact the number of','line_number':1736,'multiline':False]['text':' documents we return from limit, hence we don't want to push limit.','line_number':1737,'multiline':False]['text':' If _triedLimitPushDown is true, we have already done a limit push down and don't want to','line_number':1738,'multiline':False]['text':' push again to avoid an infinite loop.','line_number':1739,'multiline':False]['text':' Check if we can avoid unpacking if we have a group stage with min/max/count aggregates.','line_number':1749,'multiline':False]['text':' Check if the rest of the pipeline needs any fields. For example we might only be','line_number':1757,'multiline':False]['text':' interested in $count.','line_number':1758,'multiline':False]['text':' includeEventFilter ','line_number':1759,'multiline':True]['text':' Keep going for next optimization.','line_number':1766,'multiline':False]['text':' Attempt to optimize last-point type queries.','line_number':1778,'multiline':False]['text':' If we are able to rewrite the aggregation, give the resulting pipeline a chance to','line_number':1781,'multiline':False]['text':' perform further optimizations.','line_number':1782,'multiline':False]['text':' Attempt to map predicates on bucketed fields to the predicates on the control field.','line_number':1786,'multiline':False]['text':' Merge multiple following $match stages.','line_number':1788,'multiline':False]['text':' Try to create a tight bucket predicate to perform bucket level matching.','line_number':1797,'multiline':False]['text':' If we removed the _eventFilter with fixed buckets, we do not need a wholeBucketFilter.','line_number':1798,'multiline':False]['text':' enableSimplification ','line_number':1807,'multiline':True]['text':' Push the original event predicate into the unpacking stage.','line_number':1811,'multiline':False]['text':' shouldOptimize ','line_number':1812,'multiline':True]['text':' includeEventFilter ','line_number':1816,'multiline':True]['text':' Create a loose bucket predicate and push it before the unpacking stage.','line_number':1821,'multiline':False]['text':' Give other stages a chance to optimize with the new $match.','line_number':1826,'multiline':False]['text':' We have removed a $match after this stage, so we try to optimize this stage again.','line_number':1831,'multiline':False]['text':' Attempt to push down a $project on the metaField past $_internalUnpackBucket.','line_number':1835,'multiline':False]['text':' We have pushed down the entire $project. Remove the old $project from the','line_number':1844,'multiline':False]['text':' pipeline, then attempt to optimize this stage again.','line_number':1845,'multiline':False]['text':' Attempt to extract computed meta projections from subsequent $project, $addFields, or $set','line_number':1853,'multiline':False]['text':' and push them before the $_internalunpackBucket.','line_number':1854,'multiline':False]['text':' We've pushed down and removed a stage after this one. Try to optimize the new stage.','line_number':1856,'multiline':False]['text':' Attempt to build a $project based on dependency analysis or extract one from the pipeline. We','line_number':1860,'multiline':False]['text':' can internalize the result so we can handle projections during unpacking.','line_number':1861,'multiline':False]['text':' We may have removed a $project after this stage, so we try to optimize this stage','line_number':1868,'multiline':False]['text':' again.','line_number':1869,'multiline':False]['text':' Caches the SBE compatibility status when this function is called for the first time. This is','line_number':1880,'multiline':False]['text':' called before trying to push down stages to SBE.','line_number':1881,'multiline':False]['text':' Just in case that the event filter or the whole bucket filter is incompatible with','line_number':1884,'multiline':False]['text':' SBE. While optimizing pipeline, we may end up with pushing SBE-incompatible filters','line_number':1885,'multiline':False]['text':' down to the '$_internalUnpackBucket' stage. We've stored the sbeCompatibility of','line_number':1886,'multiline':False]['text':' '_eventFilter' in '_isEventFilterSbeCompatible'.','line_number':1887,'multiline':False]['text':' Currently we only support in SBE unpacking with a statically known set of fields.','line_number':1898,'multiline':False]['text':' namespace mongo','line_number':1919,'multiline':False]