['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include <pstl/glue_algorithm_defs.h>','line_number':52,'multiline':False]['text':' IWYU pragma: no_include "boost/container/detail/std_fwd.hpp"','line_number':53,'multiline':False]['text':'/ Helper function to easily wrap constants with $const.','line_number':113,'multiline':False]['text':' Other serialization policies need to include this $const in order to be unambiguous for','line_number':122,'multiline':False]['text':' re-parsing this output later. If for example the constant was '$cashMoney' - we don't want to','line_number':123,'multiline':False]['text':' misinterpret it as a field path when parsing.','line_number':124,'multiline':False]['text':' --------------------------- Expression ------------------------------ ','line_number':128,'multiline':True]['text':' Assume this is an expression like {$add: [...]}.','line_number':152,'multiline':False]['text':'*
 * Calls function 'function' with zero parameters and returns the result. If AssertionException is
 * raised during the call of 'function', adds all the context 'errorContext' to the exception.
 ','line_number':167,'multiline':True]['text':'*
 * Converts 'value' to TimeUnit for an expression named 'expressionName'. It assumes that the
 * parameter is named "unit". Throws an AssertionException if 'value' contains an invalid value.
 ','line_number':183,'multiline':True]['text':'*
 * Converts 'value' to DayOfWeek for an expression named 'expressionName' with parameter named as
 * 'parameterName'. Throws an AssertionException if 'value' contains an invalid value.
 ','line_number':197,'multiline':True]['text':' namespace','line_number':215,'multiline':False]['text':' Add this expression to the global map of operator counters for expressions.','line_number':228,'multiline':False]['text':' Look up the parser associated with the expression name.','line_number':241,'multiline':False]['text':' Increment the counter for this expression in the current context.','line_number':257,'multiline':False]['text':' Assume it's an operand that accepts a single argument.','line_number':270,'multiline':False]['text':' if we got here, this is a field path expression ','line_number':283,'multiline':True]['text':' ------------------------- Register Date Expressions ----------------------------- ','line_number':298,'multiline':True]['text':' ----------------------- ExpressionAbs ---------------------------- ','line_number':314,'multiline':True]['text':' ------------------------- ExpressionAdd ----------------------------- ','line_number':337,'multiline':True]['text':'*
 * We'll try to return the narrowest possible result value while avoiding overflow or implicit use
 * of decimal types. To do that, compute separate sums for long, double and decimal values, and
 * track the current widest type. The long sum will be converted to double when the first double
 * value is seen or when long arithmetic would overflow.
 ','line_number':341,'multiline':True]['text':'*
     * Update the internal state with another operand. It is up to the caller to validate that the
     * operand is of a proper type.
     ','line_number':349,'multiline':True]['text':' Dates are represented by the long number of milliseconds since the unix epoch, so we can','line_number':355,'multiline':False]['text':' treat them as regular numeric values for the purposes of addition after making sure that','line_number':356,'multiline':False]['text':' only one date is present in the operand list.','line_number':357,'multiline':False]['text':' If this operation widens the return type, perform any necessary type conversions.','line_number':376,'multiline':False]['text':' Int -> Long is handled by the same sum.','line_number':380,'multiline':False]['text':' Int/Long -> Double converts the existing longTotal to a doubleTotal.','line_number':383,'multiline':False]['text':' Convert the right total to NumberDecimal by looking at the old widest type.','line_number':387,'multiline':False]['text':' Perform the add operation.','line_number':405,'multiline':False]['text':' If the long long arithmetic overflows, promote the result to a NumberDouble and','line_number':409,'multiline':False]['text':' start incrementing the doubleTotal.','line_number':410,'multiline':False]['text':' If one of the operands was a date, then return long value as Date.','line_number':433,'multiline':False]['text':' Convert 'valToAdd' into the data type used for dates (long long) and add it to 'longTotal'.','line_number':453,'multiline':False]['text':' The upper bound is exclusive because it rounds up when it is cast to','line_number':467,'multiline':False]['text':' a double.','line_number':468,'multiline':False]['text':' namespace','line_number':509,'multiline':False]['text':' ------------------------- ExpressionAllElementsTrue -------------------------- ','line_number':544,'multiline':True]['text':' ------------------------- ExpressionAnd ----------------------------- ','line_number':566,'multiline':True]['text':' optimize the conjunction as much as possible ','line_number':569,'multiline':True]['text':' if the result isn't a conjunction, we can't do anything ','line_number':572,'multiline':True]['text':'
      Check the last argument on the result; if it's not constant (as
      promised by ExpressionNary::optimize(),) then there's nothing
      we can do.
    ','line_number':577,'multiline':True]['text':' ExpressionNary::optimize() generates an ExpressionConstant for {$and:[]}.','line_number':583,'multiline':False]['text':'
      Evaluate and coerce the last argument to a boolean.  If it's false,
      then we can replace this entire expression.
     ','line_number':590,'multiline':True]['text':'
      If we got here, the final operand was true, so we don't need it
      anymore.  If there was only one other operand, we don't need the
      conjunction either.  Note we still need to keep the promise that
      the result will be a boolean.
     ','line_number':601,'multiline':True]['text':'
      Remove the final "true" value, and return the new expression.

      CW TODO:
      Note that because of any implicit conversions, we may need to
      apply an implicit boolean conversion.
    ','line_number':613,'multiline':True]['text':' ------------------------- ExpressionAnyElementTrue -------------------------- ','line_number':640,'multiline':True]['text':' ---------------------- ExpressionArray --------------------------- ','line_number':662,'multiline':True]['text':' If all values in ExpressionArray are constant evaluate to ExpressionConstant.','line_number':698,'multiline':False]['text':' This should never be called, but is needed to inherit from ExpressionNary.','line_number':716,'multiline':False]['text':' ------------------------- ExpressionArrayElemAt -------------------------- ','line_number':720,'multiline':True]['text':' Positive indices that are too large are handled automatically by Value.','line_number':745,'multiline':False]['text':' Index from the back of the array.','line_number':748,'multiline':False]['text':' namespace','line_number':754,'multiline':False]['text':' ------------------------- ExpressionFirst -------------------------- ','line_number':767,'multiline':True]['text':' ------------------------- ExpressionLast -------------------------- ','line_number':780,'multiline':True]['text':' ------------------------- ExpressionObjectToArray -------------------------- ','line_number':793,'multiline':True]['text':' ------------------------- ExpressionArrayToObject -------------------------- ','line_number':826,'multiline':True]['text':' There are two accepted input formats in an array: [ [key, val] ] or [ {k:key, v:val} ]. The','line_number':844,'multiline':False]['text':' first array element determines the format for the rest of the array. Mixing input formats is','line_number':845,'multiline':False]['text':' not allowed.','line_number':846,'multiline':False]['text':' ------------------------- ExpressionBsonSize -------------------------- ','line_number':937,'multiline':True]['text':' ------------------------- ExpressionCeil -------------------------- ','line_number':955,'multiline':True]['text':' There's no point in taking the ceiling of integers or longs, it will have no effect.','line_number':958,'multiline':False]['text':' Round toward the nearest decimal with a zero exponent in the positive direction.','line_number':963,'multiline':False]['text':' -------------------- ExpressionCoerceToBool ------------------------- ','line_number':976,'multiline':True]['text':' optimize the operand ','line_number':990,'multiline':True]['text':' if the operand already produces a boolean, then we don't need this ','line_number':993,'multiline':True]['text':' LATER - Expression to support a "typeof" query? ','line_number':994,'multiline':True]['text':' When not explaining, serialize to an $and expression. When parsed, the $and expression','line_number':1012,'multiline':False]['text':' will be optimized back into a ExpressionCoerceToBool.','line_number':1013,'multiline':False]['text':' ----------------------- ExpressionCompare --------------------------- ','line_number':1018,'multiline':True]['text':' namespace','line_number':1030,'multiline':False]['text':' Lookup table for truth value returns','line_number':1062,'multiline':False]['text':' truth value for -1, 0, 1','line_number':1064,'multiline':False]['text':' reverse(b,a) returns the same as op(a,b)','line_number':1065,'multiline':False]['text':' string name with trailing '\0'','line_number':1066,'multiline':False]['text':'             -1      0      1      reverse                  name   ','line_number':1069,'multiline':True]['text':' EQ  ','line_number':1070,'multiline':True]['text':' NE  ','line_number':1071,'multiline':True]['text':' GT  ','line_number':1072,'multiline':True]['text':' GTE ','line_number':1073,'multiline':True]['text':' LT  ','line_number':1074,'multiline':True]['text':' LTE ','line_number':1075,'multiline':True]['text':' CMP is special. Only name is used.','line_number':1077,'multiline':False]['text':' CMP ','line_number':1078,'multiline':True]['text':' namespace','line_number':1080,'multiline':False]['text':' Make cmp one of 1, 0, or -1.','line_number':1088,'multiline':False]['text':' leave as 0','line_number':1090,'multiline':False]['text':' ------------------------- ExpressionConcat ----------------------------- ','line_number':1108,'multiline':True]['text':' ------------------------- ExpressionConcatArrays ----------------------------- ','line_number':1134,'multiline':True]['text':' ----------------------- ExpressionCond ------------------------------ ','line_number':1162,'multiline':True]['text':' ---------------------- ExpressionConstant --------------------------- ','line_number':1232,'multiline':True]['text':' nothing to do ','line_number':1252,'multiline':True]['text':' alias','line_number':1265,'multiline':False]['text':' ---------------------- ExpressionDateFromParts ----------------------- ','line_number':1270,'multiline':True]['text':' Helper functions also shared with ExpressionDateToParts ','line_number':1272,'multiline':True]['text':' namespace','line_number':1300,'multiline':False]['text':' Everything is a constant, so we can turn into a constant.','line_number':1456,'multiline':False]['text':' One of the evaluated inputs in nullish.','line_number':1552,'multiline':False]['text':' One of the evaluated inputs in nullish.','line_number':1574,'multiline':False]['text':' One of the evaluated inputs in nullish.','line_number':1604,'multiline':False]['text':' ---------------------- ExpressionDateFromString --------------------- ','line_number':1620,'multiline':True]['text':' Everything is a constant, so we can turn into a constant.','line_number':1702,'multiline':False]['text':' Eagerly validate the format parameter, ignoring if nullish since the input string nullish','line_number':1732,'multiline':False]['text':' behavior takes precedence.','line_number':1733,'multiline':False]['text':' Evaluate the timezone parameter before checking for nullish input, as this will throw an','line_number':1747,'multiline':False]['text':' exception for an invalid timezone string.','line_number':1748,'multiline':False]['text':' Behavior for nullish input takes precedence over other nullish elements.','line_number':1755,'multiline':False]['text':' ---------------------- ExpressionDateToParts ----------------------- ','line_number':1793,'multiline':True]['text':' Everything is a constant, so we can turn into a constant.','line_number':1851,'multiline':False]['text':' ---------------------- ExpressionDateToString ----------------------- ','line_number':1942,'multiline':True]['text':' Everything is a constant, so we can turn into a constant.','line_number':2007,'multiline':False]['text':' Eagerly validate the format parameter, ignoring if nullish since the input date nullish','line_number':2037,'multiline':False]['text':' behavior takes precedence.','line_number':2038,'multiline':False]['text':' Evaluate the timezone parameter before checking for nullish input, as this will throw an','line_number':2052,'multiline':False]['text':' exception for an invalid timezone string.','line_number':2053,'multiline':False]['text':' ----------------------- ExpressionDateDiff ---------------------------- ','line_number':2082,'multiline':True]['text':' Everything is a constant, so we can turn into a constant.','line_number':2152,'multiline':False]['text':' Because the result of this expression can be negative, this works the same way as','line_number':2268,'multiline':False]['text':' ExpressionSubtract. Edge cases with DST and other timezone changes are handled correctly','line_number':2269,'multiline':False]['text':' according to dateDiff.','line_number':2270,'multiline':False]['text':' ----------------------- ExpressionDivide ---------------------------- ','line_number':2276,'multiline':True]['text':' If, and only if, either side is decimal, return decimal.','line_number':2285,'multiline':False]['text':' ----------------------- ExpressionExp ---------------------------- ','line_number':2315,'multiline':True]['text':' $exp always returns either a double or a decimal number, as e is irrational.','line_number':2318,'multiline':False]['text':' ---------------------- ExpressionObject --------------------------- ','line_number':2330,'multiline':True]['text':' These 'push_back's must complete before we insert references to the 'children' vector','line_number':2344,'multiline':False]['text':' into the 'expressions' vector since 'push_back' invalidates references.','line_number':2345,'multiline':False]['text':' It is safe to 'std::move' 'children' since the standard guarantees the references are stable.','line_number':2352,'multiline':False]['text':' Make sure we don't have any duplicate field names.','line_number':2359,'multiline':False]['text':' Make sure this element has a valid field name. Use StringData here so that we can detect','line_number':2365,'multiline':False]['text':' if the field name contains a null byte.','line_number':2366,'multiline':False]['text':' If all values in ExpressionObject are constant evaluate to ExpressionConstant.','line_number':2395,'multiline':False]['text':' --------------------- ExpressionFieldPath --------------------------- ','line_number':2450,'multiline':True]['text':' this is the old deprecated version only used by tests not using variables','line_number':2452,'multiline':False]['text':' this is the new version that supports every syntax','line_number':2458,'multiline':False]['text':' c_str()[0] is always a valid reference.','line_number':2464,'multiline':False]['text':' need at least "$" and either "$" or a field name','line_number':2468,'multiline':False]['text':' strip off $$','line_number':2472,'multiline':False]['text':' If the variable we are parsing is a system variable, then indicate that we have seen it.','line_number':2477,'multiline':False]['text':' strip the "$" prefix','line_number':2485,'multiline':False]['text':'precomputeHashes','line_number':2505,'multiline':True]['text':' The REMOVE system variable optimizes to a constant missing value.','line_number':2516,'multiline':False]['text':' The agg system is allowed to replace the ExpressionFieldPath with an ExpressionConstant,','line_number':2522,'multiline':False]['text':' which in turn would result in a plan cache entry that inlines the value of a system','line_number':2523,'multiline':False]['text':' variable. However, the values of these system variables are not guaranteed to be constant','line_number':2524,'multiline':False]['text':' across different executions of the same query shape, so we prohibit the optimization.','line_number':2525,'multiline':False]['text':' This variable refers to the entire document, or refers to a sub-field of something','line_number':2539,'multiline':False]['text':' besides the root document. Either way we can't prove that it represents the path given by','line_number':2540,'multiline':False]['text':' 'dottedPath'.','line_number':2541,'multiline':False]['text':' Check for remaining path in each element of array','line_number':2550,'multiline':False]['text':' Note this function is very hot so it is important that is is well optimized.','line_number':2565,'multiline':False]['text':' In particular, all return paths should support RVO.','line_number':2566,'multiline':False]['text':' if we've hit the end of the path, stop ','line_number':2568,'multiline':True]['text':' Try to dive deeper','line_number':2572,'multiline':False]['text':' get the whole variable','line_number':2587,'multiline':False]['text':' ROOT is always a document so use optimized code path','line_number':2591,'multiline':False]['text':' Shared among expressions that need to serialize dotted paths and redact the path components.','line_number':2607,'multiline':False]['text':' use short form for "$$CURRENT.foo" but not just "$$CURRENT"','line_number':2610,'multiline':False]['text':' namespace','line_number':2616,'multiline':False]['text':' First handles special cases for redaction of system variables. User variables will fall','line_number':2620,'multiline':False]['text':' through to the default full redaction case.','line_number':2621,'multiline':False]['text':' Nothing to redact for builtin variables.','line_number':2624,'multiline':False]['text':' The first component of this path is a system variable, so keep that and redact','line_number':2627,'multiline':False]['text':' the rest.','line_number':2628,'multiline':False]['text':' An expression field path is either considered a rename or a computed path. We need to find','line_number':2637,'multiline':False]['text':' out which case we fall into.','line_number':2638,'multiline':False]['text':'','line_number':2639,'multiline':False]['text':' The caller has told us that renames must have 'varId' as the first component. We also check','line_number':2640,'multiline':False]['text':' that there is only one additional component---no dotted field paths are allowed!  This is','line_number':2641,'multiline':False]['text':' because dotted ExpressionFieldPaths can actually reshape the document rather than just','line_number':2642,'multiline':False]['text':' changing the field names. This can happen only if there are arrays along the dotted path.','line_number':2643,'multiline':False]['text':'','line_number':2644,'multiline':False]['text':' For example, suppose you have document {a: [{b: 1}, {b: 2}]}. The projection {"c.d": "$a.b"}','line_number':2645,'multiline':False]['text':' does *not* perform the strict rename to yield document {c: [{d: 1}, {d: 2}]}. Instead, it','line_number':2646,'multiline':False]['text':' results in the document {c: {d: [1, 2]}}. Due to this reshaping, matches expressed over "a.b"','line_number':2647,'multiline':False]['text':' before the $project is applied may not have the same behavior when expressed over "c.d" after','line_number':2648,'multiline':False]['text':' the $project is applied.','line_number':2649,'multiline':False]['text':' Add dotted renames also to complex renames, to be used prospectively in optimizations','line_number':2654,'multiline':False]['text':' (e.g., pushDotRenamedMatch).','line_number':2655,'multiline':False]['text':' We only include dotted rename paths of length 3, as current optimization are constrained','line_number':2656,'multiline':False]['text':' to accepting only such paths to avoid semantic errors from array flattening.','line_number':2657,'multiline':False]['text':' Remove the path components of 'oldName' from 'path'.','line_number':2677,'multiline':False]['text':' ------------------------- ExpressionFilter ----------------------------- ','line_number':2708,'multiline':True]['text':' "cond" must be parsed after "as" regardless of BSON order.','line_number':2718,'multiline':False]['text':' Parse "input", only has outer variables.','line_number':2747,'multiline':False]['text':' vpsSub gets our variable, vpsIn doesn't.','line_number':2750,'multiline':False]['text':' Parse "as". If "as" is not specified, then use "this" by default.','line_number':2751,'multiline':False]['text':' Parse "cond", has access to "as" variable.','line_number':2757,'multiline':False]['text':' TODO handle when _input is constant.','line_number':2786,'multiline':False]['text':' We are guaranteed at parse time that this isn't using our _varId.','line_number':2808,'multiline':False]['text':' This counter ensures we don't return more array elements than our limit arg has specified.','line_number':2825,'multiline':False]['text':' For example, given the query, {$project: {b: {$filter: {input: '$a', as: 'x', cond: {$gt:','line_number':2826,'multiline':False]['text':' ['$$x', 1]}, limit: {$literal: 3}}}}} remainingLimitCounter would be 3 and we would return up','line_number':2827,'multiline':False]['text':' to the first 3 elements matching our condition, per doc.','line_number':2828,'multiline':False]['text':' If the $filter query contains limit: null, we interpret the query as being "limit-less"','line_number':2833,'multiline':False]['text':' and therefore return all matching elements per doc.','line_number':2834,'multiline':False]['text':' ------------------------- ExpressionFloor -------------------------- ','line_number':2868,'multiline':True]['text':' Round toward the nearest decimal with a zero exponent in the negative direction.','line_number':2878,'multiline':False]['text':' There's no point in taking the floor of integers or longs, it will have no effect.','line_number':2887,'multiline':False]['text':' Round toward the nearest decimal with a zero exponent in the negative direction.','line_number':2892,'multiline':False]['text':' ------------------------- ExpressionLet ----------------------------- ','line_number':2905,'multiline':True]['text':' varsElem must be parsed before inElem regardless of BSON order.','line_number':2916,'multiline':False]['text':' parse "vars"','line_number':2933,'multiline':False]['text':' vpsSub gets our vars, vpsIn doesn't.','line_number':2934,'multiline':False]['text':' Make a place in the vector for "in".','line_number':2941,'multiline':False]['text':' only has outer vars','line_number':2953,'multiline':False]['text':' parse "in"','line_number':2957,'multiline':False]['text':' has our vars','line_number':2958,'multiline':False]['text':' we aren't binding any variables so just return the subexpression','line_number':2975,'multiline':False]['text':' It is guaranteed at parse-time that these expressions don't use the variable ids we','line_number':3005,'multiline':False]['text':' are setting','line_number':3006,'multiline':False]['text':' ------------------------- ExpressionMap ----------------------------- ','line_number':3013,'multiline':True]['text':' "in" must be parsed after "as" regardless of BSON order','line_number':3023,'multiline':False]['text':' parse "input"','line_number':3044,'multiline':False]['text':' only has outer vars','line_number':3046,'multiline':False]['text':' parse "as"','line_number':3048,'multiline':False]['text':' vpsSub gets our vars, vpsIn doesn't.','line_number':3049,'multiline':False]['text':' If "as" is not specified, then use "this" by default.','line_number':3051,'multiline':False]['text':' parse "in"','line_number':3057,'multiline':False]['text':' has access to map variable','line_number':3059,'multiline':False]['text':' TODO handle when _input is constant','line_number':3074,'multiline':False]['text':' guaranteed at parse time that this isn't using our _varId','line_number':3087,'multiline':False]['text':' can't insert missing values into array','line_number':3108,'multiline':False]['text':' Append the name of the array to the beginning of the old field path.','line_number':3137,'multiline':False]['text':' ------------------------- ExpressionMeta ----------------------------- ','line_number':3145,'multiline':True]['text':' namespace','line_number':3205,'multiline':False]['text':' Be sure that a RecordId can be represented by a long long.','line_number':3271,'multiline':False]['text':' ----------------------- ExpressionMod ---------------------------- ','line_number':3309,'multiline':True]['text':' If either side is decimal, perform the operation in decimal.','line_number':3317,'multiline':False]['text':' ensure we aren't modding by 0','line_number':3328,'multiline':False]['text':' if either is long, return long','line_number':3340,'multiline':False]['text':' lastly they must both be ints, return int','line_number':3346,'multiline':False]['text':' ------------------------- ExpressionMultiply ----------------------------- ','line_number':3370,'multiline':True]['text':'*
     * We'll try to return the narrowest possible result value.  To do that without creating
     * intermediate Values, do the arithmetic for double and integral types in parallel, tracking
     * the current narrowest type.
     ','line_number':3374,'multiline':True]['text':' This will be initialized on encountering the first decimal.','line_number':3381,'multiline':False]['text':' On finding the first decimal, convert the partial product to decimal.','line_number':3391,'multiline':False]['text':' If `productType` is not a double, it must be one of the integer types, so we','line_number':3402,'multiline':False]['text':' attempt to update `longProduct`.','line_number':3403,'multiline':False]['text':' The multiplier is either Infinity or NaN, or the `longProduct` would','line_number':3406,'multiline':False]['text':' have overflowed, so we're abandoning it.','line_number':3407,'multiline':False]['text':' namespace','line_number':3435,'multiline':False]['text':' evaluate() checks arguments left-to-right, short circuiting on the first null or non-number.','line_number':3438,'multiline':False]['text':' Imitate that behavior here.','line_number':3439,'multiline':False]['text':' ----------------------- ExpressionIfNull ---------------------------- ','line_number':3471,'multiline':True]['text':' If all the operands are constant expressions, collapse the expression into one constant','line_number':3498,'multiline':False]['text':' expression.','line_number':3499,'multiline':False]['text':' Remove all null constants, unless it is the only child or it is the last parameter','line_number':3505,'multiline':False]['text':' (<replacement-expression-if-null>). If one of the operands is a non-null constant expression,','line_number':3506,'multiline':False]['text':' remove any operands that follow it.','line_number':3507,'multiline':False]['text':' Replace $ifNull with its only child.','line_number':3526,'multiline':False]['text':' ----------------------- ExpressionIn ---------------------------- ','line_number':3538,'multiline':True]['text':' ----------------------- ExpressionIndexOfArray ------------------ ','line_number':3561,'multiline':True]['text':' namespace','line_number':3579,'multiline':False]['text':' Don't let 'endIndex' exceed the length of the array.','line_number':3624,'multiline':False]['text':'*
 * This class handles the case where IndexOfArray is given an ExpressionConstant
 * instead of using a vector and searching through it we can use a unordered_map
 * for O(1) lookup time.
 ','line_number':3631,'multiline':True]['text':' Search through the vector of indexes for first index in our range.','line_number':3653,'multiline':False]['text':' The value we are searching for exists but is not in our range.','line_number':3659,'multiline':False]['text':' Maps the values in the array to the positions at which they occur. We need to remember the','line_number':3664,'multiline':False]['text':' positions so that we can verify they are in the appropriate range.','line_number':3665,'multiline':False]['text':' This will optimize all arguments to this expression.','line_number':3670,'multiline':False]['text':' If the input array is an ExpressionConstant we can optimize using a unordered_map instead of','line_number':3675,'multiline':False]['text':' an','line_number':3676,'multiline':False]['text':' array.','line_number':3677,'multiline':False]['text':' To handle the case of duplicate values the values need to map to a vector of indecies.','line_number':3690,'multiline':False]['text':' ----------------------- ExpressionIndexOfBytes ------------------ ','line_number':3710,'multiline':True]['text':' namespace','line_number':3721,'multiline':False]['text':' Don't let 'endIndex' exceed the length of the string.','line_number':3754,'multiline':False]['text':' ----------------------- ExpressionIndexOfCP --------------------- ','line_number':3775,'multiline':True]['text':' Compute the length (in code points) of the input, and convert 'startCodePointIndex' to a byte','line_number':3804,'multiline':False]['text':' index.','line_number':3805,'multiline':False]['text':' We have determined the byte at which our search will start.','line_number':3810,'multiline':False]['text':' Don't let 'endCodePointIndex' exceed the number of code points in the string.','line_number':3825,'multiline':False]['text':' If the start index is past the end, then always return -1 since 'token' does not exist within','line_number':3830,'multiline':False]['text':' these invalid bounds.','line_number':3831,'multiline':False]['text':' If we are finding the index of "" in the string "", the below loop will not loop, so we','line_number':3837,'multiline':False]['text':' need a special case for this.','line_number':3838,'multiline':False]['text':' We must keep track of which byte, and which code point, we are examining, being careful not','line_number':3842,'multiline':False]['text':' to overflow either the length of the string or the ending code point.','line_number':3843,'multiline':False]['text':' ----------------------- ExpressionLn ---------------------------- ','line_number':3863,'multiline':True]['text':' Fall through for error case.','line_number':3870,'multiline':False]['text':' ----------------------- ExpressionLog ---------------------------- ','line_number':3884,'multiline':True]['text':' Fall through for error cases.','line_number':3908,'multiline':False]['text':' ----------------------- ExpressionLog10 ---------------------------- ','line_number':3928,'multiline':True]['text':' Fall through for error case.','line_number':3935,'multiline':False]['text':' ----------------------- ExpressionInternalFLEEqual ---------------------------- ','line_number':3950,'multiline':True]['text':' ----------------------- ExpressionInternalFLEBetween ---------------------------- ','line_number':4016,'multiline':True]['text':' ------------------------ ExpressionNary ----------------------------- ','line_number':4087,'multiline':True]['text':'*
 * Optimize a general Nary expression.
 *
 * The optimization has the following properties:
 *   1) Optimize each of the operands.
 *   2) If the operator is fully associative, flatten internal operators of the same type. I.e.:
 *      A+B+(C+D)+E => A+B+C+D+E
 *   3) If the operator is commutative & associative, group all constant operands. For example:
 *      c1 + c2 + n1 + c3 + n2 => n1 + n2 + c1 + c2 + c3
 *   4) If the operator is fully associative, execute the operation over all the contiguous constant
 *      operands and replacing them by the result. For example: c1 + c2 + n1 + c3 + c4 + n5 =>
 *      c5 = c1 + c2, c6 = c3 + c4 => c5 + n1 + c6 + n5
 *   5) If the operand is left-associative, execute the operation over all contiguous constant
 *      operands that precede the first non-constant operand. For example: c1 + c2 + n1 + c3 + c4 +
 *      n2 => c5 = c1 + c2, c5 + n1 + c3 + c4 + n5
 *
 * It returns the optimized expression. It can be exactly the same expression, a modified version
 * of the same expression or a completely different expression.
 ','line_number':4089,'multiline':True]['text':' If all the operands are constant expressions, collapse the expression into one constant','line_number':4117,'multiline':False]['text':' expression.','line_number':4118,'multiline':False]['text':' An operator cannot be left-associative and commutative, because left-associative','line_number':4124,'multiline':False]['text':' operators need to preserve their order-of-operations.','line_number':4125,'multiline':False]['text':' If the expression is associative, we can collapse all the consecutive constant operands','line_number':4128,'multiline':False]['text':' into one by applying the expression to those consecutive constant operands. If the','line_number':4129,'multiline':False]['text':' expression is also commutative we can reorganize all the operands so that all of the','line_number':4130,'multiline':False]['text':' constant ones are together (arbitrarily at the back) and we can collapse all of them into','line_number':4131,'multiline':False]['text':' one. If the operation is left-associative, then we will stop folding constants together when','line_number':4132,'multiline':False]['text':' we see the first non-constant operand.','line_number':4133,'multiline':False]['text':' If the operand is a constant one, add it to the current list of consecutive constant','line_number':4139,'multiline':False]['text':' operands.','line_number':4140,'multiline':False]['text':' If the operand is exactly the same type as the one we are currently optimizing and','line_number':4147,'multiline':False]['text':' is also associative, replace the expression for the operands it has.','line_number':4148,'multiline':False]['text':' E.g: sum(a, b, sum(c, d), e) => sum(a, b, c, d, e)','line_number':4149,'multiline':False]['text':' If the operand is not a constant nor a same-type expression and the expression is','line_number':4160,'multiline':False]['text':' not commutative, evaluate an expression of the same type as the one we are','line_number':4161,'multiline':False]['text':' optimizing on the list of consecutive constant operands and use the resulting value','line_number':4162,'multiline':False]['text':' as a constant expression operand.','line_number':4163,'multiline':False]['text':' If the list of consecutive constant operands has less than 2 operands just place','line_number':4164,'multiline':False]['text':' back the operands.','line_number':4165,'multiline':False]['text':' If the expression is left-associative, break out of the loop since we should only','line_number':4182,'multiline':False]['text':' optimize until the first non-constant.','line_number':4183,'multiline':False]['text':' Dump the remaining operands into the optimizedOperands vector that will become','line_number':4185,'multiline':False]['text':' the new _children vector.','line_number':4186,'multiline':False]['text':' build up the array ','line_number':4216,'multiline':True]['text':' ------------------------- ExpressionNot ----------------------------- ','line_number':4223,'multiline':True]['text':' -------------------------- ExpressionOr ----------------------------- ','line_number':4237,'multiline':True]['text':' optimize the disjunction as much as possible ','line_number':4251,'multiline':True]['text':' if the result isn't a disjunction, we can't do anything ','line_number':4254,'multiline':True]['text':'
      Check the last argument on the result; if it's not constant (as
      promised by ExpressionNary::optimize(),) then there's nothing
      we can do.
    ','line_number':4259,'multiline':True]['text':' ExpressionNary::optimize() generates an ExpressionConstant for {$or:[]}.','line_number':4265,'multiline':False]['text':'
      Evaluate and coerce the last argument to a boolean.  If it's true,
      then we can replace this entire expression.
     ','line_number':4272,'multiline':True]['text':'
      If we got here, the final operand was false, so we don't need it
      anymore.  If there was only one other operand, we don't need the
      conjunction either.  Note we still need to keep the promise that
      the result will be a boolean.
     ','line_number':4283,'multiline':True]['text':'
      Remove the final "false" value, and return the new expression.
    ','line_number':4295,'multiline':True]['text':'*
 * Helper for ExpressionPow to determine wither base^exp can be represented in a 64 bit int.
 *
 *'base' and 'exp' are both integers. Assumes 'exp' is in the range [0, 63].
 ','line_number':4308,'multiline':True]['text':' Array indices correspond to exponents 0 through 63. The values in each index are the min','line_number':4321,'multiline':False]['text':' and max bases, respectively, that can be raised to that exponent without overflowing a','line_number':4322,'multiline':False]['text':' 64-bit int. For max bases, this was computed by solving for b in','line_number':4323,'multiline':False]['text':' b = (2^63-1)^(1/exp) for exp = [0, 63] and truncating b. To calculate min bases, for even','line_number':4324,'multiline':False]['text':' exps the equation  used was b = (2^63-1)^(1/exp), and for odd exps the equation used was','line_number':4325,'multiline':False]['text':' b = (-2^63)^(1/exp). Since the magnitude of long min is greater than long max, the','line_number':4326,'multiline':False]['text':' magnitude of some of the min bases raised to odd exps is greater than the corresponding','line_number':4327,'multiline':False]['text':' max bases raised to the same exponents.','line_number':4328,'multiline':False]['text':' 0','line_number':4331,'multiline':False]['text':' 10','line_number':4341,'multiline':False]['text':' 20','line_number':4351,'multiline':False]['text':' 30','line_number':4361,'multiline':False]['text':' 40','line_number':4371,'multiline':False]['text':' 50','line_number':4381,'multiline':False]['text':' 60','line_number':4391,'multiline':False]['text':' namespace','line_number':4398,'multiline':False]['text':' ----------------------- ExpressionPow ---------------------------- ','line_number':4400,'multiline':True]['text':' If either argument is decimal, return a decimal.','line_number':4431,'multiline':False]['text':' pow() will cast args to doubles.','line_number':4439,'multiline':False]['text':' If either argument is a double, return a double.','line_number':4444,'multiline':False]['text':' If either number is a long, return a long. If both numbers are ints, then return an int if','line_number':4449,'multiline':False]['text':' the result fits or a long if it is too big.','line_number':4450,'multiline':False]['text':' Use this when the result cannot be represented as a long.','line_number':4461,'multiline':False]['text':' Avoid doing repeated multiplication or using std::pow if the base is -1, 0, or 1.','line_number':4466,'multiline':False]['text':' 0^0 = 1.','line_number':4469,'multiline':False]['text':' 0^x where x > 0 is 0.','line_number':4472,'multiline':False]['text':' We should have checked earlier that 0 to a negative power is banned.','line_number':4476,'multiline':False]['text':' -1^0 = -1^2 = -1^4 = -1^6 ... = 1','line_number':4481,'multiline':False]['text':' -1^1 = -1^3 = -1^5 = -1^7 ... = -1','line_number':4482,'multiline':False]['text':' If the base is not 0, 1, or -1 and the exponent is too large, or negative,','line_number':4485,'multiline':False]['text':' the result cannot be represented as a long.','line_number':4486,'multiline':False]['text':' It's still possible that the result cannot be represented as a long. If that's the case,','line_number':4490,'multiline':False]['text':' return a double.','line_number':4491,'multiline':False]['text':' Use repeated multiplication, since pow() casts args to doubles which could result in','line_number':4496,'multiline':False]['text':' loss of precision if arguments are very large.','line_number':4497,'multiline':False]['text':' 'exp' is now guaranteed to be even.','line_number':4506,'multiline':False]['text':' ------------------------- ExpressionRange ------------------------------ ','line_number':4527,'multiline':True]['text':' Cast to broader type 'int64_t' to prevent overflow during loop.','line_number':4552,'multiline':False]['text':' A step was specified by the user.','line_number':4558,'multiline':False]['text':' Calculate how much memory is needed to generate the array and avoid going over the memLimit.','line_number':4575,'multiline':False]['text':' If steps not positive then no amount of steps can get you from start to end. For example','line_number':4577,'multiline':False]['text':' with start=5, end=7, step=-1 steps would be negative and in this case we would return an','line_number':4578,'multiline':False]['text':' empty array.','line_number':4579,'multiline':False]['text':' ------------------------ ExpressionReduce ------------------------------ ','line_number':4603,'multiline':True]['text':' vpsSub is used only to parse 'in', which must have access to $$this and $$value.','line_number':4615,'multiline':False]['text':' ------------------------ ExpressionReplaceBase ------------------------ ','line_number':4683,'multiline':True]['text':' namespace','line_number':4729,'multiline':False]['text':' Throw an error if any arg is non-string, non-nullish.','line_number':4736,'multiline':False]['text':' Return null if any arg is nullish.','line_number':4750,'multiline':False]['text':' ------------------------ ExpressionReplaceOne ------------------------ ','line_number':4768,'multiline':True]['text':' An empty string matches at every position, so replaceOne should insert the replacement text','line_number':4788,'multiline':False]['text':' at position 0. input.find correctly returns position 0 when 'find' is empty, so we don't need','line_number':4789,'multiline':False]['text':' any special case to handle this.','line_number':4790,'multiline':False]['text':' ------------------------ ExpressionReplaceAll ------------------------ ','line_number':4799,'multiline':True]['text':' An empty string matches at every position, so replaceAll should insert 'replacement' at every','line_number':4814,'multiline':False]['text':' position when 'find' is empty. Handling this as a special case lets us assume 'find' is','line_number':4815,'multiline':False]['text':' nonempty in the usual case.','line_number':4816,'multiline':False]['text':' This step assumes 'find' is nonempty. If 'find' were empty then input.find would always','line_number':4837,'multiline':False]['text':' find a match at position 0, and the input would never shrink.','line_number':4838,'multiline':False]['text':' ------------------------ ExpressionReverseArray ------------------------ ','line_number':4844,'multiline':True]['text':' namespace','line_number':4886,'multiline':False]['text':' ------------------------ ExpressionSortArray ------------------------ ','line_number':4888,'multiline':True]['text':' namespace','line_number':4912,'multiline':False]['text':' ----------------------- ExpressionSetDifference ---------------------------- ','line_number':4980,'multiline':True]['text':' rhsSet serves the dual role of filtering out elements that were originally present','line_number':5004,'multiline':False]['text':' in RHS and of eleminating duplicates from LHS','line_number':5005,'multiline':False]['text':' ----------------------- ExpressionSetEquals ---------------------------- ','line_number':5018,'multiline':True]['text':' namespace','line_number':5040,'multiline':False]['text':' The $setEquals expression has at least two children, so accessing the first child without','line_number':5058,'multiline':False]['text':' check is fine.','line_number':5059,'multiline':False]['text':'*
 * If there's a constant set in the input, we can construct a hash set for the constant once during
 * optimize() and compare other sets against it, which reduces the runtime to construct the constant
 * sets over and over.
 ','line_number':5073,'multiline':True]['text':' ----------------------- ExpressionSetIntersection ---------------------------- ','line_number':5107,'multiline':True]['text':' to iterate over whichever is the smaller set','line_number':5128,'multiline':False]['text':' ----------------------- ExpressionSetIsSubset ---------------------------- ','line_number':5151,'multiline':True]['text':' do not shortcircuit when lhs.size() > rhs.size()','line_number':5155,'multiline':False]['text':' because lhs can have redundant entries','line_number':5156,'multiline':False]['text':' namespace','line_number':5164,'multiline':False]['text':'*
 * This class handles the case where the RHS set is constant.
 *
 * Since it is constant we can construct the hashset once which makes the runtime performance
 * effectively constant with respect to the size of RHS. Large, constant RHS is expected to be a
 * major use case for $redact and this has been verified to improve performance significantly.
 ','line_number':5183,'multiline':True]['text':' perfore basic optimizations','line_number':5215,'multiline':False]['text':' if ExpressionNary::optimize() created a new value, return it directly','line_number':5218,'multiline':False]['text':' ----------------------- ExpressionSetUnion ---------------------------- ','line_number':5243,'multiline':True]['text':' ----------------------- ExpressionIsArray ---------------------------- ','line_number':5268,'multiline':True]['text':' ----------------------- ExpressionInternalFindAllValuesAtPath --------','line_number':5280,'multiline':True]['text':' This expression is not part of the stable API, but can always be used. It is','line_number':5296,'multiline':False]['text':' an internal expression used only for distinct.','line_number':5297,'multiline':False]['text':' ----------------------- ExpressionSlice ---------------------------- ','line_number':5301,'multiline':True]['text':' Could be either a start index or the length from 0.','line_number':5307,'multiline':False]['text':' Only count given.','line_number':5332,'multiline':False]['text':' Negative count's start from the back. If a abs(count) is greater','line_number':5339,'multiline':False]['text':' than the','line_number':5340,'multiline':False]['text':' length of the array, return the whole array.','line_number':5341,'multiline':False]['text':' We have both a start index and a count.','line_number':5345,'multiline':False]['text':' Negative values start from the back. If a abs(start) is greater','line_number':5348,'multiline':False]['text':' than the length','line_number':5349,'multiline':False]['text':' of the array, start from 0.','line_number':5350,'multiline':False]['text':' ----------------------- ExpressionSize ---------------------------- ','line_number':5387,'multiline':True]['text':' ----------------------- ExpressionSplit --------------------------- ','line_number':5404,'multiline':True]['text':' ----------------------- ExpressionSqrt ---------------------------- ','line_number':5454,'multiline':True]['text':' NaN returns Nan without error','line_number':5463,'multiline':False]['text':' NaN returns Nan without error','line_number':5467,'multiline':False]['text':' ----------------------- ExpressionStrcasecmp ---------------------------- ','line_number':5476,'multiline':True]['text':' boost::iequals returns a bool not an int so strings must actually be allocated ','line_number':5482,'multiline':True]['text':' ----------------------- ExpressionSubstrBytes ---------------------------- ','line_number':5500,'multiline':True]['text':' If the passed length is negative, we should return the rest of the string.','line_number':5527,'multiline':False]['text':' Check the byte after the last character we'd return. If it is a continuation byte, that','line_number':5537,'multiline':False]['text':' means we're in the middle of a UTF-8 character.','line_number':5538,'multiline':False]['text':' If lower > str.length() then string::substr() will throw out_of_range, so return an','line_number':5546,'multiline':False]['text':' empty string if lower is not a valid string index.','line_number':5547,'multiline':False]['text':' $substr is deprecated in favor of $substrBytes, but for now will just parse into a $substrBytes.','line_number':5553,'multiline':False]['text':' ----------------------- ExpressionSubstrCP ---------------------------- ','line_number':5560,'multiline':True]['text':' ----------------------- ExpressionStrLenBytes ------------------------- ','line_number':5633,'multiline':True]['text':' namespace','line_number':5644,'multiline':False]['text':' -------------------------- ExpressionBinarySize ------------------------------ ','line_number':5662,'multiline':True]['text':' ----------------------- ExpressionStrLenCP ------------------------- ','line_number':5689,'multiline':True]['text':' ----------------------- ExpressionSubtract ---------------------------- ','line_number':5714,'multiline':True]['text':' If there is an overflow, convert the values to doubles.','line_number':5735,'multiline':False]['text':' check the doubleRhs should not exceed int64 limit and result will not overflow','line_number':5763,'multiline':False]['text':' 1. Get monotonic states of the both children.','line_number':5800,'multiline':False]['text':' 2. Apply monotonic::opposite to the state of the second child, because it is negated.','line_number':5801,'multiline':False]['text':' 3. Combine children. Function monotonic::combine correctly handles all the cases where, for','line_number':5802,'multiline':False]['text':' example, argumemnts are both monotonic, but in the opposite directions.','line_number':5803,'multiline':False]['text':' ------------------------- ExpressionSwitch ------------------------------ ','line_number':5809,'multiline':True]['text':' Parse each branch separately.','line_number':5844,'multiline':False]['text':' Optional, arbitrary expression.','line_number':5880,'multiline':False]['text':' The the 'default' expression is always the final child. If no 'default' expression is','line_number':5887,'multiline':False]['text':' provided, then the final child is nullptr.','line_number':5888,'multiline':False]['text':' Delete the two elements corresponding to this branch at positions 2i and 2i + 1.','line_number':5897,'multiline':False]['text':' Case is constant and evaluates to false, so it is removed.','line_number':5916,'multiline':False]['text':' Case optimized to a constant true value. Set the optimized version of the','line_number':5919,'multiline':False]['text':' corresponding 'then' expression as the new 'default'. Break out of the loop and','line_number':5920,'multiline':False]['text':' fall through to the logic to remove this and all subsequent branches.','line_number':5921,'multiline':False]['text':' Since case is not removed from the switch, its then is now optimized.','line_number':5927,'multiline':False]['text':' Erasing the rest of the cases because found a default true value.','line_number':5933,'multiline':False]['text':' If there are no cases, make the switch its default.','line_number':5940,'multiline':False]['text':' ------------------------- ExpressionToLower ----------------------------- ','line_number':5972,'multiline':True]['text':' ------------------------- ExpressionToUpper -------------------------- ','line_number':5986,'multiline':True]['text':' -------------------------- ExpressionTrim ------------------------------ ','line_number':6000,'multiline':True]['text':' ------------------------- ExpressionRound and ExpressionTrunc -------------------------- ','line_number':6099,'multiline':True]['text':' Construct 10^-precisionValue, which will be used as the quantize reference.','line_number':6145,'multiline':False]['text':' Even if the original was an int to begin with - it has to be a long now.','line_number':6176,'multiline':False]['text':' ------------------------- ExpressionType ----------------------------- ','line_number':6206,'multiline':True]['text':' ------------------------ ExpressionIsNumber --------------------------- ','line_number':6218,'multiline':True]['text':' -------------------------- ExpressionZip ------------------------------ ','line_number':6231,'multiline':True]['text':' We need to ensure defaults appear after inputs so we build them seperately and then','line_number':6244,'multiline':False]['text':' concatenate them.','line_number':6245,'multiline':False]['text':' Evaluate input values.','line_number':6305,'multiline':False]['text':' If we need default values, evaluate each expression.','line_number':6338,'multiline':False]['text':' The final output array, e.g. [[1, 2, 3], [2, 3, 4]].','line_number':6347,'multiline':False]['text':' Used to construct each array in the output, e.g. [1, 2, 3].','line_number':6350,'multiline':False]['text':' Add the value from the appropriate input array.','line_number':6360,'multiline':False]['text':' Add the corresponding default value.','line_number':6363,'multiline':False]['text':' -------------------------- ExpressionConvert ------------------------------ ','line_number':6399,'multiline':True]['text':'*
 * $convert supports a big grab bag of conversions, so ConversionTable maintains a collection of
 * conversion functions, as well as a table to organize them by inputType and targetType.
 ','line_number':6403,'multiline':True]['text':'','line_number':6412,'multiline':False]['text':' Conversions from NumberDouble','line_number':6413,'multiline':False]['text':'','line_number':6414,'multiline':False]['text':'','line_number':6429,'multiline':False]['text':' Conversions from String','line_number':6430,'multiline':False]['text':'','line_number':6431,'multiline':False]['text':'','line_number':6445,'multiline':False]['text':' Conversions from jstOID','line_number':6446,'multiline':False]['text':'','line_number':6447,'multiline':False]['text':'','line_number':6459,'multiline':False]['text':' Conversions from Bool','line_number':6460,'multiline':False]['text':'','line_number':6461,'multiline':False]['text':'','line_number':6484,'multiline':False]['text':' Conversions from Date','line_number':6485,'multiline':False]['text':'','line_number':6486,'multiline':False]['text':'','line_number':6512,'multiline':False]['text':' Conversions from bsonTimestamp','line_number':6513,'multiline':False]['text':'','line_number':6514,'multiline':False]['text':'','line_number':6520,'multiline':False]['text':' Conversions from NumberInt','line_number':6521,'multiline':False]['text':'','line_number':6522,'multiline':False]['text':'','line_number':6545,'multiline':False]['text':' Conversions from NumberLong','line_number':6546,'multiline':False]['text':'','line_number':6547,'multiline':False]['text':'','line_number':6568,'multiline':False]['text':' Conversions from NumberDecimal','line_number':6569,'multiline':False]['text':'','line_number':6570,'multiline':False]['text':'','line_number':6591,'multiline':False]['text':' Miscellaneous conversions to Bool','line_number':6592,'multiline':False]['text':'','line_number':6593,'multiline':False]['text':' Note: We can't use BSONType::MinKey (-1) or BSONType::MaxKey (127) as table indexes,','line_number':6608,'multiline':False]['text':' so we have to treat them as special cases.','line_number':6609,'multiline':False]['text':' This is a conversion from MinKey or MaxKey to Bool, which is allowed (and always','line_number':6616,'multiline':False]['text':' returns true).','line_number':6617,'multiline':False]['text':' Any other conversions involving MinKey or MaxKey (either as the target or input) are','line_number':6620,'multiline':False]['text':' illegal.','line_number':6621,'multiline':False]['text':' Performing these checks up front allows us to provide more specific error messages than','line_number':6676,'multiline':False]['text':' if we just gave the same error for any 'kInvalid' conversion.','line_number':6677,'multiline':False]['text':' NB: Decimal128::SignalingFlag has a values specifically for overflow, but it is used for','line_number':6700,'multiline':False]['text':' arithmetic with Decimal128 operands, _not_ for conversions of this style. Overflowing','line_number':6701,'multiline':False]['text':' conversions only trigger a 'kInvalid' flag.','line_number':6702,'multiline':False]['text':' Reject any strings in hex format. This check is needed because the','line_number':6782,'multiline':False]['text':' NumberParser::parse call below allows an input hex string prefixed by '0x' when','line_number':6783,'multiline':False]['text':' parsing to a double.','line_number':6784,'multiline':False]['text':' Rethrow any caught exception as a conversion failure such that 'onError' is evaluated','line_number':6803,'multiline':False]['text':' and returned.','line_number':6804,'multiline':False]['text':' Use parseArguments to allow for a singleton array, or the unwrapped version.','line_number':6824,'multiline':False]['text':' namespace','line_number':6835,'multiline':False]['text':' Also register shortcut expressions like $toInt, $toString, etc. which can be used as a shortcut','line_number':6839,'multiline':False]['text':' for $convert without an 'onNull' or 'onError'.','line_number':6840,'multiline':False]['text':' "to" evaluated to a nullish value.','line_number':6919,'multiline':False]['text':' Perform constant folding if possible. This does not support folding for $convert operations','line_number':6944,'multiline':False]['text':' that have constant _children[_kTo] and _children[_kInput] values but non-constant','line_number':6945,'multiline':False]['text':' _children[_kOnError] and _children[_kOnNull] values. Because _children[_kOnError] and','line_number':6946,'multiline':False]['text':' _children[_kOnNull] are evaluated lazily, conversions that do not used the','line_number':6947,'multiline':False]['text':' _children[_kOnError] and _children[_kOnNull] values could still be legally folded if those','line_number':6948,'multiline':False]['text':' values are not needed. Support for that case would add more complexity than it's worth,','line_number':6949,'multiline':False]['text':' though.','line_number':6950,'multiline':False]['text':' Since the 'to' field is a parameter from a set of valid values and not free user input,','line_number':6961,'multiline':False]['text':' we want to avoid boiling it down to the representative value in the query shape. The first','line_number':6962,'multiline':False]['text':' condition is so that we can keep serializing correctly whenever the 'to' field is an','line_number':6963,'multiline':False]['text':' expression that gets resolved down to a string of a valid type, or its corresponding','line_number':6964,'multiline':False]['text':' numerical value. If it's just the constant, we want to wrap it in a $const except when the','line_number':6965,'multiline':False]['text':' serialization policy is debug.','line_number':6966,'multiline':False]['text':' typeFromName() does not consider "missing" to be a valid type, but we want to accept it,','line_number':6989,'multiline':False]['text':' because it is a possible result of the $type aggregation operator.','line_number':6990,'multiline':False]['text':' This will throw if the type name is invalid.','line_number':6995,'multiline':False]['text':' namespace','line_number':7062,'multiline':False]['text':' -------------------------- ExpressionRegex ------------------------------ ','line_number':7064,'multiline':True]['text':' The 'input' parameter can be a variable and needs to be extracted from the expression','line_number':7075,'multiline':False]['text':' document even when '_preExecutionState' is present.','line_number':7076,'multiline':False]['text':' If we have a prebuilt execution state, then the 'regex' and 'options' fields are constant','line_number':7079,'multiline':False]['text':' values, and we do not need to re-compile them.','line_number':7080,'multiline':False]['text':' No match.','line_number':7106,'multiline':False]['text':' Set the start index for match to the new one.','line_number':7113,'multiline':False]['text':' Use BSONNULL placeholder for unmatched capture groups.','line_number':7121,'multiline':False]['text':' Calculate the number of capture groups present in 'pattern' and store in 'numCaptures'.','line_number':7168,'multiline':False]['text':' The 'regex' field can be a RegEx object and may have its own options...','line_number':7202,'multiline':False]['text':' ...or it can be a string field with options specified separately.','line_number':7215,'multiline':False]['text':' If 'options' is non-null, we must validate its contents even if 'regexPattern' is nullish.','line_number':7219,'multiline':False]['text':' -------------------------- ExpressionRegexFind ------------------------------ ','line_number':7294,'multiline':True]['text':' -------------------------- ExpressionRegexFindAll ------------------------------ ','line_number':7314,'multiline':True]['text':' Using do...while loop because, when input is an empty string, we still want to see if there','line_number':7335,'multiline':False]['text':' is a match.','line_number':7336,'multiline':False]['text':' This would only happen if the regex matched an empty string. In this case, even if','line_number':7351,'multiline':False]['text':' the character at startByteIndex matches the regex, we cannot return it since we are','line_number':7352,'multiline':False]['text':' already returing an empty string starting at this index. So we move on to the next','line_number':7353,'multiline':False]['text':' byte index.','line_number':7354,'multiline':False]['text':' input already exhausted','line_number':7356,'multiline':False]['text':' We don't want any overlapping sub-strings. So we move 'startBytePos' to point to the','line_number':7363,'multiline':False]['text':' byte after 'matchStr'. We move the code point index also correspondingly.','line_number':7364,'multiline':False]['text':' -------------------------- ExpressionRegexMatch ------------------------------ ','line_number':7377,'multiline':True]['text':' -------------------------- ExpressionRandom ------------------------------ ','line_number':7397,'multiline':True]['text':' ------------------------- ExpressionToHashedIndexKey -------------------------- ','line_number':7438,'multiline':True]['text':' ------------------------- ExpressionDateArithmetics -------------------------- ','line_number':7461,'multiline':True]['text':' namespace','line_number':7504,'multiline':False]['text':' Get the TimeZone object for the timezone parameter, if it is specified, or UTC otherwise.','line_number':7573,'multiline':False]['text':' ----------------------- ExpressionDateAdd ---------------------------- ','line_number':7604,'multiline':True]['text':' ----------------------- ExpressionDateSubtract ---------------------------- ','line_number':7633,'multiline':True]['text':' Long long min value cannot be negated.','line_number':7655,'multiline':False]['text':' ----------------------- ExpressionDateTrunc ---------------------------- ','line_number':7667,'multiline':True]['text':' Everything is a constant, so we can turn into a constant.','line_number':7740,'multiline':False]['text':' Convert parameter values.','line_number':7875,'multiline':False]['text':' -------------------------- ExpressionGetField ------------------------------ ','line_number':7890,'multiline':True]['text':' This may be an expression, so we should treat it as such.','line_number':7904,'multiline':False]['text':' If '_children[_kField]' is a constant expression, the parser guarantees that it evaluates to','line_number':7944,'multiline':False]['text':' a string. If it's a dynamic expression, its type can't be deduced during parsing.','line_number':7945,'multiline':False]['text':' This is a pretty unique option to serialize. It is both a constant and a field path,','line_number':7979,'multiline':False]['text':' which means that it:','line_number':7980,'multiline':False]['text':'  - should be redacted (if that option is set).','line_number':7981,'multiline':False]['text':'  - should *not* be wrapped in $const iff we are serializing for a debug string','line_number':7982,'multiline':False]['text':' However, if we are serializing for a debug string and the string looks like a field','line_number':7983,'multiline':False]['text':' reference, it should be wrapped in $const to make it unambiguous with actual field','line_number':7984,'multiline':False]['text':' references.','line_number':7985,'multiline':False]['text':' -------------------------- ExpressionSetField ------------------------------ ','line_number':8000,'multiline':True]['text':' $unsetField is syntactic sugar for $setField where value is set to $$REMOVE.','line_number':8004,'multiline':False]['text':' The 'field' argument to '$setField' must evaluate to a constant string, for example,','line_number':8045,'multiline':False]['text':' {$const: "$a.b"}. In case the user has forgotten to wrap the value into a '$const' or','line_number':8046,'multiline':False]['text':' '$literal' expression, we will raise an error with a more meaningful description.','line_number':8047,'multiline':False]['text':' The parser guarantees that the '_children[_kField]' expression evaluates to a constant','line_number':8077,'multiline':False]['text':' string.','line_number':8078,'multiline':False]['text':' Build output document and modify 'field'.','line_number':8097,'multiline':False]['text':' The parser guarantees that the '_children[_kField]' expression evaluates to a constant','line_number':8108,'multiline':False]['text':' string.','line_number':8109,'multiline':False]['text':' This is a pretty unique option to serialize. It is both a constant and a field path, which','line_number':8114,'multiline':False]['text':' means that it:','line_number':8115,'multiline':False]['text':'  - should be redacted (if that option is set).','line_number':8116,'multiline':False]['text':'  - should *not* be wrapped in $const iff we are serializing for a debug string','line_number':8117,'multiline':False]['text':' ------------------------- ExpressionTsSecond ----------------------------- ','line_number':8128,'multiline':True]['text':' ------------------------- ExpressionTsIncrement ----------------------------- ','line_number':8147,'multiline':True]['text':' ----------------------- ExpressionBitNot ---------------------------- ','line_number':8166,'multiline':True]['text':' ------------------------- $bitAnd, $bitOr, and $bitXor ------------------------ ','line_number':8188,'multiline':True]['text':' --------------------------------- Parenthesis --------------------------------------------- ','line_number':8197,'multiline':True]['text':' namespace mongo','line_number':8206,'multiline':False]