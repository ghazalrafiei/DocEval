['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "boost/system/detail/error_code.hpp"','line_number':46,'multiline':False]['text':'*
 * Checks if unique index specification is compatible with sharding configuration.
 ','line_number':164,'multiline':True]['text':'*
 * Returns true if we should build the indexes an empty collection using the IndexCatalog and
 * bypass the index build registration.
 ','line_number':184,'multiline':True]['text':' Check whether the replica set member's config has {buildIndexes:false} set, which means','line_number':197,'multiline':False]['text':' we are not allowed to build non-_id indexes on this server.','line_number':198,'multiline':False]['text':' Secondaries should not bypass index build registration (and _runIndexBuild()) for two phase','line_number':203,'multiline':False]['text':' index builds because they need to report index build progress to the primary per commit','line_number':204,'multiline':False]['text':' quorum.','line_number':205,'multiline':False]['text':' We use the fast count information, through Collection::numRecords(), to determine if the','line_number':210,'multiline':False]['text':' collection is empty. However, this information is either unavailable or inaccurate when the','line_number':211,'multiline':False]['text':' node is in certain replication states, such as recovery or rollback. In these cases, we','line_number':212,'multiline':False]['text':' have to build the index by scanning the collection.','line_number':213,'multiline':False]['text':' This check happens before spawning the index build thread. So it does not race with the','line_number':219,'multiline':False]['text':' replication recovery flag being modified.','line_number':220,'multiline':False]['text':' Now, it's fine to trust Collection::isEmpty().','line_number':225,'multiline':False]['text':' Fast counts are prone to both false positives and false negatives on unclean shutdowns. False','line_number':226,'multiline':False]['text':' negatives can cause to skip index building. And, false positives can cause mismatch in number','line_number':227,'multiline':False]['text':' of index entries among the nodes in the replica set. So, verify the collection is really','line_number':228,'multiline':False]['text':' empty by opening the WT cursor and reading the first document.','line_number':229,'multiline':False]['text':'*
 * Removes the index build from the config.system.indexBuilds collection after the primary has
 * written the commitIndexBuild or abortIndexBuild oplog entry.
 ','line_number':233,'multiline':True]['text':' Writes to the 'config.system.indexBuilds' collection are replicated and the index entry','line_number':251,'multiline':False]['text':' will be removed when the delete oplog entry is replayed at a later time.','line_number':252,'multiline':False]['text':' The index build document is not written to config.system.indexBuilds collection yet.','line_number':257,'multiline':False]['text':'*
 * Replicates a commitIndexBuild oplog entry for two-phase builds, which signals downstream
 * secondary nodes to commit the index build.
 ','line_number':276,'multiline':True]['text':' Since two phase index builds are allowed to survive replication state transitions, we should','line_number':301,'multiline':False]['text':' check if the node is currently a primary before attempting to write to the oplog.','line_number':302,'multiline':False]['text':'*
 * Replicates an abortIndexBuild oplog entry for two-phase builds, which signals downstream
 * secondary nodes to abort the index build.
 ','line_number':313,'multiline':True]['text':'*
 * Logs the index build failure error in a standard format.
 ','line_number':339,'multiline':True]['text':'*
 * Iterates over index builds with the provided function.
 ','line_number':353,'multiline':True]['text':'*
 * Updates currentOp for commitIndexBuild or abortIndexBuild.
 ','line_number':395,'multiline':True]['text':'*
 * Fetches the latest oplog entry's optime. Bypasses the oplog visibility rules.
 ','line_number':410,'multiline':True]['text':' Reset the snapshot so that it is ensured to see the latest oplog entries.','line_number':414,'multiline':False]['text':' Helpers::getLast will bypass the oplog visibility rules by doing a backwards collection','line_number':417,'multiline':False]['text':' scan.','line_number':418,'multiline':False]['text':' This operation does not perform any writes, but the index building code is sensitive to','line_number':420,'multiline':False]['text':' exceptions and we must protect it from unanticipated write conflicts from reads.','line_number':421,'multiline':False]['text':'*
 * Returns true if the index build is resumable.
 ','line_number':433,'multiline':True]['text':' This check may be unnecessary due to current criteria for resumable index build support in','line_number':448,'multiline':False]['text':' storage engine.','line_number':449,'multiline':False]['text':' The last optime could be null if the node is in initial sync while building the index.','line_number':454,'multiline':False]['text':' This check may be redundant with the 'applicationMode' check and the replication requirement','line_number':455,'multiline':False]['text':' for two phase index builds.','line_number':456,'multiline':False]['text':' When we are applying a startIndexBuild oplog entry during the oplog application phase of','line_number':462,'multiline':False]['text':' startup recovery, the last optime here derived from the local oplog may not be a valid','line_number':463,'multiline':False]['text':' optime to wait on for the majority commit point since the rest of the replica set may','line_number':464,'multiline':False]['text':' be on a different branch of history.','line_number':465,'multiline':False]['text':' Only index builds with the default "all-voters" commit quorum running on voting nodes should','line_number':478,'multiline':False]['text':' be resumable. A node that cannot contribute to the commit quorum should not be waiting for','line_number':479,'multiline':False]['text':' the majority commit point when trying to commit the index build.','line_number':480,'multiline':False]['text':' IndexBuildsOptions::commitQuorum will be set if we are primary. Otherwise, we have to check','line_number':481,'multiline':False]['text':' the config.system.indexBuilds collection.','line_number':482,'multiline':False]['text':' The commit quorum may be updated using the setIndexBuildCommitQuorum command, so we will','line_number':488,'multiline':False]['text':' rely on the deadline to unblock ourselves from the majority wait if the commit quorum is','line_number':489,'multiline':False]['text':' no longer "all-voters".','line_number':490,'multiline':False]['text':' Ensure that this node is a voting member in the replica set config.','line_number':505,'multiline':False]['text':' We cannot determine our member config, so skip the majority wait and leave this index','line_number':512,'multiline':False]['text':' build as non-resumable.','line_number':513,'multiline':False]['text':'*
 * Returns the ReadSource to be used for a drain occurring before the commit quorum has been
 * satisfied.
 ','line_number':520,'multiline':True]['text':'*
 * Returns an AutoGetCollection::Options configured to skip the RSTL if 'skipRSTL' is true.
 ','line_number':530,'multiline':True]['text':' namespace','line_number':538,'multiline':False]['text':' Must hold the global lock to ensure safe access to storageGlobalParams.dbpath.','line_number':573,'multiline':False]['text':' This parameter's validator ensures that this multiplication will not overflow.','line_number':594,'multiline':False]['text':' Avoid excessive logging when no index builds are in progress. Nothing prevents an','line_number':608,'multiline':False]['text':' index build from starting after this check.  Subsequent calls will see any','line_number':609,'multiline':False]['text':' newly-registered builds.','line_number':610,'multiline':False]['text':' Complete the index build.','line_number':668,'multiline':False]['text':' These steps are combined into a single WUOW to ensure there are no commits without the','line_number':693,'multiline':False]['text':' indexes for repair.','line_number':694,'multiline':False]['text':' We need to initialize the collection to rebuild the indexes. The collection may already','line_number':697,'multiline':False]['text':' be initialized when rebuilding multiple unfinished indexes on the same collection.','line_number':698,'multiline':False]['text':' Unfinished index builds that are not resumable will drop and recreate the index table','line_number':709,'multiline':False]['text':' using the same ident to avoid doing untimestamped writes to the catalog.','line_number':710,'multiline':False]['text':' A build UUID is present if and only if we are rebuilding a two-phase build.','line_number':726,'multiline':False]['text':' When a buildUUID is present, it must match the build UUID parameter to this','line_number':729,'multiline':False]['text':' function.','line_number':730,'multiline':False]['text':' All indexes are dropped during repair and should be rebuilt normally.','line_number':748,'multiline':False]['text':' An index build failure during recovery is fatal.','line_number':753,'multiline':False]['text':' Mark the index build setup as complete, from now on cleanup is required on failure/abort.','line_number':759,'multiline':False]['text':' The index must be unfinished or frozen if it isn't ready.','line_number':783,'multiline':False]['text':' Don't use the AutoGet helpers because they require an open database, which may not be the','line_number':811,'multiline':False]['text':' case when an index build is resumed during recovery.','line_number':812,'multiline':False]['text':' Check that the information in the durable catalog matches the resume info.','line_number':830,'multiline':False]['text':' Mark the index build setup as complete, from now on cleanup is required on failure/abort.','line_number':877,'multiline':False]['text':' The index build may already be in the midst of tearing down.','line_number':935,'multiline':False]['text':' The index build may already be in the midst of tearing down.','line_number':958,'multiline':False]['text':' Abort *all* index builds at the start of shard merge.','line_number':992,'multiline':False]['text':' Interrupts the index builder thread and waits for it to clean up. Returns true if the index was','line_number':1008,'multiline':False]['text':' aborted, and false if it was already committed or aborted.','line_number':1009,'multiline':False]['text':' Result from waiting on future.','line_number':1018,'multiline':False]['text':' Result from _runIndexBuildInner().','line_number':1019,'multiline':False]['text':' namespace','line_number':1028,'multiline':False]['text':' Signals the index build to abort iself, which may involve signalling the current primary.','line_number':1040,'multiline':False]['text':' Increase metrics only if the build was actually aborted by the above call.','line_number':1042,'multiline':False]['text':' If the index build is already finishing and thus can't be aborted, we must wait on','line_number':1069,'multiline':False]['text':' it.','line_number':1070,'multiline':False]['text':' Before returning, we must wait on all index builds which could not be aborted to finish.','line_number':1081,'multiline':False]['text':' Otherwise, index builds started before enabling user write block mode could commit after','line_number':1082,'multiline':False]['text':' enabling it.','line_number':1083,'multiline':False]['text':' namespace','line_number':1102,'multiline':False]['text':' If this is an initial syncing node, drop any conflicting ready index specs prior to','line_number':1113,'multiline':False]['text':' proceeding with building them.','line_number':1114,'multiline':False]['text':' This oplog entry is only replicated for two-phase index builds ','line_number':1162,'multiline':True]['text':' If this node's replica set config uses buildIndexes:false, then do not attempt to commit an','line_number':1176,'multiline':False]['text':' index that would have never been started.','line_number':1177,'multiline':False]['text':' There is a possibility that we cannot find an active index build with the given build UUID.','line_number':1188,'multiline':False]['text':' This can be the case when:','line_number':1189,'multiline':False]['text':'   - The index already exists during initial sync.','line_number':1190,'multiline':False]['text':'   - The index was dropped on the sync source before the collection was cloned during initial','line_number':1191,'multiline':False]['text':'   sync.','line_number':1192,'multiline':False]['text':'   - A node is restarted with unfinished index builds and --recoverFromOplogAsStandalone.','line_number':1193,'multiline':False]['text':' The oplog code will ignore the NoSuchKey error code.','line_number':1194,'multiline':False]['text':'','line_number':1195,'multiline':False]['text':' Case 1: Index already exists:','line_number':1196,'multiline':False]['text':' +-----------------------------------------+--------------------------------+','line_number':1197,'multiline':False]['text':' |               Sync Target               |          Sync Source           |','line_number':1198,'multiline':False]['text':' +-----------------------------------------+--------------------------------+','line_number':1199,'multiline':False]['text':' |                                         | startIndexBuild 'x' at TS: 1.  |','line_number':1200,'multiline':False]['text':' | Start oplog fetcher at TS: 2.           |                                |','line_number':1201,'multiline':False]['text':' |                                         | commitIndexBuild 'x' at TS: 2. |','line_number':1202,'multiline':False]['text':' | Begin cloning the collection.           |                                |','line_number':1203,'multiline':False]['text':' | Index 'x' is listed as ready, build it. |                                |','line_number':1204,'multiline':False]['text':' | Finish cloning the collection.          |                                |','line_number':1205,'multiline':False]['text':' | Start the oplog replay phase.           |                                |','line_number':1206,'multiline':False]['text':' | Apply commitIndexBuild 'x'.             |                                |','line_number':1207,'multiline':False]['text':' | --- Index build not found ---           |                                |','line_number':1208,'multiline':False]['text':' +-----------------------------------------+--------------------------------+','line_number':1209,'multiline':False]['text':'','line_number':1210,'multiline':False]['text':' Case 2: Sync source dropped the index:','line_number':1211,'multiline':False]['text':' +--------------------------------+--------------------------------+','line_number':1212,'multiline':False]['text':' |          Sync Target           |          Sync Source           |','line_number':1213,'multiline':False]['text':' +--------------------------------+--------------------------------+','line_number':1214,'multiline':False]['text':' |                                | startIndexBuild 'x' at TS: 1.  |','line_number':1215,'multiline':False]['text':' | Start oplog fetcher at TS: 2.  |                                |','line_number':1216,'multiline':False]['text':' |                                | commitIndexBuild 'x' at TS: 2. |','line_number':1217,'multiline':False]['text':' |                                | dropIndex 'x' at TS: 3.        |','line_number':1218,'multiline':False]['text':' | Begin cloning the collection.  |                                |','line_number':1219,'multiline':False]['text':' | No user indexes to build.      |                                |','line_number':1220,'multiline':False]['text':' | Finish cloning the collection. |                                |','line_number':1221,'multiline':False]['text':' | Start the oplog replay phase.  |                                |','line_number':1222,'multiline':False]['text':' | Apply commitIndexBuild 'x'.    |                                |','line_number':1223,'multiline':False]['text':' | --- Index build not found ---  |                                |','line_number':1224,'multiline':False]['text':' +--------------------------------+--------------------------------+','line_number':1225,'multiline':False]['text':'','line_number':1226,'multiline':False]['text':' Case 3: Node has unfinished index builds that are not restarted:','line_number':1227,'multiline':False]['text':' +--------------------------------+-------------------------------------------------+','line_number':1228,'multiline':False]['text':' |         Before Shutdown        |        After restart in standalone with         |','line_number':1229,'multiline':False]['text':' |                                |         --recoverFromOplogAsStandalone          |','line_number':1230,'multiline':False]['text':' +--------------------------------+-------------------------------------------------+','line_number':1231,'multiline':False]['text':' | startIndexBuild 'x' at TS: 1.  | Recovery at TS: 1.                              |','line_number':1232,'multiline':False]['text':' |                                | - Unfinished index build is not restarted.      |','line_number':1233,'multiline':False]['text':' | ***** Checkpoint taken *****   |                                                 |','line_number':1234,'multiline':False]['text':' |                                | Oplog replay operations starting with TS: 2.    |','line_number':1235,'multiline':False]['text':' | commitIndexBuild 'x' at TS: 2. | Apply commitIndexBuild 'x' oplog entry at TS: 2.|','line_number':1236,'multiline':False]['text':' |                                |                                                 |','line_number':1237,'multiline':False]['text':' |                                | ------------ Index build not found ------------ |','line_number':1238,'multiline':False]['text':' +--------------------------------+-------------------------------------------------+','line_number':1239,'multiline':False]['text':' Index builds are not restarted in standalone mode. If the node is started with','line_number':1244,'multiline':False]['text':' recoverFromOplogAsStandalone and when replaying the commitIndexBuild oplog entry for a paused','line_number':1245,'multiline':False]['text':' index, there is no active index build thread to commit.','line_number':1246,'multiline':False]['text':' Restart the 'paused' index build in the background.','line_number':1248,'multiline':False]['text':'buildsToResume=','line_number':1256,'multiline':True]['text':' Get the builder.','line_number':1258,'multiline':False]['text':' Retry until we are able to put the index build in the kApplyCommitOplogEntry state. None of','line_number':1263,'multiline':False]['text':' the conditions for retrying are common or expected to be long-lived, so we believe this to be','line_number':1264,'multiline':False]['text':' safe to poll at this frequency.','line_number':1265,'multiline':False]['text':' Result from waiting on future.','line_number':1271,'multiline':False]['text':' Result from _runIndexBuildInner().','line_number':1272,'multiline':False]['text':' Throws if there was an error building the index.','line_number':1279,'multiline':False]['text':' The index build may already be in the midst of tearing down.','line_number':1309,'multiline':False]['text':' Unfinished index builds are not restarted in standalone mode. That means there will be no','line_number':1319,'multiline':False]['text':' index builder threads to abort. Instead, we should drop the unfinished indexes that were','line_number':1320,'multiline':False]['text':' aborted.','line_number':1321,'multiline':False]['text':' The index build may already be in the midst of tearing down.','line_number':1395,'multiline':False]['text':' Retry until we are able to put the index build into the kAborted state. None of the','line_number':1457,'multiline':False]['text':' conditions for retrying are common or expected to be long-lived, so we believe this to be','line_number':1458,'multiline':False]['text':' safe to poll at this frequency.','line_number':1459,'multiline':False]['text':' It is possible to receive an abort for a non-existent index build. Abort should always','line_number':1465,'multiline':False]['text':' succeed, so suppress the error.','line_number':1466,'multiline':False]['text':' Only on single phase builds, skip RSTL to avoid deadlocks with prepare conflicts and','line_number':1481,'multiline':False]['text':' state transitions caused by taking a strong collection lock. See SERVER-42621.','line_number':1482,'multiline':False]['text':' If we are using two-phase index builds and are no longer primary after receiving an','line_number':1491,'multiline':False]['text':' abort, we cannot replicate an abortIndexBuild oplog entry. Continue holding the RSTL to','line_number':1492,'multiline':False]['text':' check the replication state and to prevent any state transitions from happening while','line_number':1493,'multiline':False]['text':' aborting the index build. Once an index build is put into kAborted, the index builder','line_number':1494,'multiline':False]['text':' thread will be torn down, and an oplog entry must be replicated. Single-phase builds do','line_number':1495,'multiline':False]['text':' not have this restriction and may be aborted after a stepDown. Initial syncing nodes need','line_number':1496,'multiline':False]['text':' to be able to abort two phase index builds during the oplog replay phase.','line_number':1497,'multiline':False]['text':' The AutoGetCollection helper takes the RSTL implicitly.','line_number':1499,'multiline':False]['text':' Override the 'signalAction' as this is an initial syncing node.','line_number':1502,'multiline':False]['text':' Don't override it if it's a rollback abort which would be explictly requested','line_number':1503,'multiline':False]['text':' by the initial sync code.','line_number':1504,'multiline':False]['text':' At this point we must continue aborting the index build.','line_number':1549,'multiline':False]['text':' At this point, the target collection and config.system.indexBuilds locks are acquired, no','line_number':1570,'multiline':False]['text':' direct lock acquisitions are expected and there are no interrupt checkpoints. However,','line_number':1571,'multiline':False]['text':' OpObservers may introduce lock acquisitions (i.e. sharding state locks) and cause an','line_number':1572,'multiline':False]['text':' interruption during cleanup. For correctness, we must perform these final writes. Temporarily','line_number':1573,'multiline':False]['text':' disable interrupts.','line_number':1574,'multiline':False]['text':' NOLINT.','line_number':1575,'multiline':False]['text':' Replicates an abortIndexBuild oplog entry and deletes the index from the durable catalog.','line_number':1582,'multiline':False]['text':' Single-phase builds are aborted on step-down, so it's possible to no longer be','line_number':1585,'multiline':False]['text':' primary after we process an abort. We must continue with the abort, but since','line_number':1586,'multiline':False]['text':' single-phase builds do not replicate abort oplog entries, this write will use a ghost','line_number':1587,'multiline':False]['text':' timestamp.','line_number':1588,'multiline':False]['text':' Deletes the index from the durable catalog.','line_number':1602,'multiline':False]['text':' Deletes the index from the durable catalog.','line_number':1620,'multiline':False]['text':' File copy based initial sync does a rollback-like operation, so we allow STARTUP2','line_number':1630,'multiline':False]['text':' to abort as well as rollback.','line_number':1631,'multiline':False]['text':' Defer cleanup until builder thread is joined.','line_number':1634,'multiline':False]['text':' In production code, we should not encounter any write conflict exceptions from','line_number':1656,'multiline':False]['text':' the abort logic. It is only through the use of a fail point that the internal write','line_number':1657,'multiline':False]['text':' conflict retry logic is disabled and we may get a WriteConflict here.','line_number':1658,'multiline':False]['text':' This index build is now in an inconsistent state and we should continue to crash the','line_number':1659,'multiline':False]['text':' server. But we will log a warning message to alert users of the CI system that this is','line_number':1660,'multiline':False]['text':' fine.','line_number':1661,'multiline':False]['text':' Wait for the builder thread to receive the signal before unregistering. Don't release the','line_number':1680,'multiline':False]['text':' Collection lock until this happens, guaranteeing the thread has stopped making progress','line_number':1681,'multiline':False]['text':' and has exited.','line_number':1682,'multiline':False]['text':' Result from waiting on future.','line_number':1684,'multiline':False]['text':' Result from _runIndexBuildInner().','line_number':1685,'multiline':False]['text':' Index builds interrupted for rollback may be resumed during recovery. We wait for the','line_number':1693,'multiline':False]['text':' builder thread to complete before persisting the in-memory state that will be used','line_number':1694,'multiline':False]['text':' to resume the index build.','line_number':1695,'multiline':False]['text':' No locks are required when aborting due to rollback. This performs no storage engine','line_number':1696,'multiline':False]['text':' writes, only cleans up the remaining in-memory state.','line_number':1697,'multiline':False]['text':' Leave it as-if kill -9 happened. Startup recovery will restart the index build.','line_number':1720,'multiline':False]['text':' We use forEachIndexBuild() to log basic details on the current index builds and don't intend','line_number':1731,'multiline':False]['text':' to modify any of the index builds, hence the no-op.','line_number':1732,'multiline':False]['text':' This would create an empty table even for FCV 4.2 to handle case where a primary node started','line_number':1746,'multiline':False]['text':' with FCV 4.2, and then upgraded FCV 4.4.','line_number':1747,'multiline':False]['text':' Under normal circumstances this should not result in a wait. The thread's opCtx should','line_number':1751,'multiline':False]['text':' be interrupted on replication state change, or finish while being primary. If this','line_number':1752,'multiline':False]['text':' results in a wait, it means the thread which started in the previous stepUp did not yet','line_number':1753,'multiline':False]['text':' exit. It should eventually exit.','line_number':1754,'multiline':False]['text':' Wait until the async thread has started and marked its opCtx to always be interrupted at','line_number':1770,'multiline':False]['text':' step-down. We ensure the RSTL is taken and no interrupts are lost.','line_number':1771,'multiline':False]['text':' We don't need to check if we are primary because the opCtx is interrupted at','line_number':1784,'multiline':False]['text':' stepdown, so it is guaranteed that if taking the locks succeeds, we are primary.','line_number':1785,'multiline':False]['text':' Take an intent lock, the actual index build should keep running in parallel.','line_number':1786,'multiline':False]['text':' This also prevents the concurrent index build from aborting or committing','line_number':1787,'multiline':False]['text':' while we check if the commit quorum has to be signaled or check the skipped','line_number':1788,'multiline':False]['text':' records.','line_number':1789,'multiline':False]['text':' The index build hasn't yet completed its initial setup, and persisted state like','line_number':1793,'multiline':False]['text':' commit quorum information is absent. There's nothing to do here.','line_number':1794,'multiline':False]['text':' The index build might have committed or aborted while looping and not holding the','line_number':1799,'multiline':False]['text':' collection lock. Re-checking if it is still active after taking locks would not','line_number':1800,'multiline':False]['text':' solve the issue, as build can still be registered as active, even if it is in an','line_number':1801,'multiline':False]['text':' aborted or committed state.','line_number':1802,'multiline':False]['text':' This reads from system.indexBuilds collection to see if commit quorum got','line_number':1808,'multiline':False]['text':' satisfied.','line_number':1809,'multiline':False]['text':' The index build has been signalled to commit. As retrying skipped','line_number':1814,'multiline':False]['text':' records during step-up is done to prevent waiting until commit time,','line_number':1815,'multiline':False]['text':' if the build has already been signalled to commit, we may skip the','line_number':1816,'multiline':False]['text':' retry during step-up.','line_number':1817,'multiline':False]['text':' If the operation context is interrupted (shutdown, stepdown, killOp),','line_number':1821,'multiline':False]['text':' stop the verification process and exit.','line_number':1822,'multiline':False]['text':' Unlike the primary, secondaries cannot fail immediately when detecting key','line_number':1829,'multiline':False]['text':' generation errors; they instead temporarily store them in the 'skipped records'','line_number':1830,'multiline':False]['text':' table, to validate them on commit. As an optimisation to potentially detect','line_number':1831,'multiline':False]['text':' errors earlier, check the table on step-up. Unlike during commit, we only check','line_number':1832,'multiline':False]['text':' key generation here, we do not actually insert the keys.','line_number':1833,'multiline':False]['text':' If the operation context is interrupted (shutdown, stepdown, killOp), stop the','line_number':1841,'multiline':False]['text':' verification process and exit.','line_number':1842,'multiline':False]['text':' Some of the checks might have opened a snapshot. Abandon it before acquiring','line_number':1845,'multiline':False]['text':' MODE_X lock during abort.','line_number':1846,'multiline':False]['text':' All other errors must be due to key generation. Abort the build now, instead of','line_number':1849,'multiline':False]['text':' failing later during the commit phase retry.','line_number':1850,'multiline':False]['text':' This will unblock the index build and allow it to complete without cleaning up.','line_number':1884,'multiline':False]['text':' Subsequently, the rollback algorithm can decide how to undo the index build depending on','line_number':1885,'multiline':False]['text':' the state of the oplog. Signals the kRollbackAbort and then waits for the thread to join.','line_number':1886,'multiline':False]['text':' The index build may already be in the midst of tearing down.','line_number':1890,'multiline':False]['text':' Leave this index build out of 'buildsStopped'.','line_number':1891,'multiline':False]['text':' Record the index builds aborted due to rollback. This allows any rollback algorithm','line_number':1901,'multiline':False]['text':' to efficiently restart all unfinished index builds without having to scan all indexes','line_number':1902,'multiline':False]['text':' in all collections.','line_number':1903,'multiline':False]['text':' This spawns a new thread and returns immediately. These index builds will resume and','line_number':1946,'multiline':False]['text':' wait for a commit or abort to be replicated.','line_number':1947,'multiline':False]['text':' Clean up the persisted Sorter data since resuming failed.','line_number':1959,'multiline':False]['text':' Don't restart an index build that was already resumed.','line_number':1990,'multiline':False]['text':' Indicate that the initialization should not generate oplog entries or timestamps for the','line_number':2004,'multiline':False]['text':' first catalog write, and that the original durable catalog entries should be dropped and','line_number':2005,'multiline':False]['text':' replaced.','line_number':2006,'multiline':False]['text':' This spawns a new thread and returns immediately. These index builds will start and wait','line_number':2008,'multiline':False]['text':' for a commit or abort to be replicated.','line_number':2009,'multiline':False]['text':' Rest of this function can throw, so ensure the build cleanup occurs.','line_number':2132,'multiline':False]['text':' As the caller has a MODE_X lock on the collection, we can safely assume they want to','line_number':2139,'multiline':False]['text':' build the index in the foreground instead of yielding during element insertion.','line_number':2140,'multiline':False]['text':' A timestamped transaction is needed to perform a catalog write that removes the index','line_number':2160,'multiline':False]['text':' entry when aborting the single-phase index build for tenant migrations only.','line_number':2161,'multiline':False]['text':' Always run single phase index build for empty collection. And, will be coordinated using','line_number':2193,'multiline':False]['text':' createIndexes oplog entry.','line_number':2194,'multiline':False]['text':' The index is already built implicitly.','line_number':2198,'multiline':False]['text':' Each index will be added to the mdb catalog using the preceding createIndexes','line_number':2202,'multiline':False]['text':' timestamp.','line_number':2203,'multiline':False]['text':' static','line_number':2218,'multiline':False]['text':' If the collection namespace is provided, add a 'createIndexes' field with the collection name','line_number':2225,'multiline':False]['text':' to allow tests to identify this op as an index build.','line_number':2226,'multiline':False]['text':' If index specs are provided, add them under the 'indexes' field.','line_number':2231,'multiline':False]['text':' This function is shared by multiple callers. Some of which have opened a transaction to','line_number':2259,'multiline':False]['text':' perform reads. This function may make mixed-mode writes. Mixed-mode assertions can only','line_number':2260,'multiline':False]['text':' be suppressed when beginning a fresh transaction.','line_number':2261,'multiline':False]['text':' Don't use the AutoGet helpers because they require an open database, which may not be the','line_number':2264,'multiline':False]['text':' case when an index build is restarted during recovery.','line_number':2265,'multiline':False]['text':' AutoGetCollection throws an exception if it is unable to look up the collection by UUID.','line_number':2341,'multiline':False]['text':' Disallow index builds on drop-pending namespaces (system.drop.*) if we are primary.','line_number':2349,'multiline':False]['text':' This check is for optimization purposes only as since this lock is released after this,','line_number':2358,'multiline':False]['text':' and is acquired again when we build the index in _setUpIndexBuild.','line_number':2359,'multiline':False]['text':' The requested index (specs) are already built or are being built. Return success','line_number':2373,'multiline':False]['text':' early (this is v4.0 behavior compatible).','line_number':2374,'multiline':False]['text':' Bypass the thread pool if we are building indexes on an empty collection.','line_number':2382,'multiline':False]['text':' Replicate this index build using the old-style createIndexes oplog entry to avoid','line_number':2387,'multiline':False]['text':' timestamping issues that would result from this empty collection optimization on a','line_number':2388,'multiline':False]['text':' secondary. If we tried to generate two phase index build startIndexBuild and','line_number':2389,'multiline':False]['text':' commitIndexBuild oplog entries, this optimization will fail to accurately timestamp','line_number':2390,'multiline':False]['text':' the catalog update when it uses the timestamp from the startIndexBuild, rather than','line_number':2391,'multiline':False]['text':' the commitIndexBuild, oplog entry.','line_number':2392,'multiline':False]['text':' The index has been registered on the Coordinator in an unstarted state. Return an','line_number':2417,'multiline':False]['text':' uninitialized Future so that the caller can set up the index build by calling','line_number':2418,'multiline':False]['text':' _setUpIndexBuild(). The completion of the index build will be communicated via a Future','line_number':2419,'multiline':False]['text':' obtained from 'replIndexBuildState->sharedPromise'.','line_number':2420,'multiline':False]['text':' We will not have a start timestamp if we are newly a secondary (i.e. we started as','line_number':2442,'multiline':False]['text':' primary but there was a stepdown). We will be unable to timestamp the initial catalog write,','line_number':2443,'multiline':False]['text':' so we must fail the index build. During initial sync, there is no commit timestamp set.','line_number':2444,'multiline':False]['text':' Change the startIndexBuild Oplog entry.','line_number':2456,'multiline':False]['text':' Two-phase index builds write a different oplog entry than the default behavior which','line_number':2457,'multiline':False]['text':' writes a no-op just to generate an optime.','line_number':2458,'multiline':False]['text':' Not primary.','line_number':2462,'multiline':False]['text':' Two phase index builds should have commit quorum set.','line_number':2466,'multiline':False]['text':' Persist the commit quorum value in the config.system.indexBuilds collection.','line_number':2473,'multiline':False]['text':' If config.system.indexBuilds is not found, convert the NamespaceNotFound','line_number':2482,'multiline':False]['text':' exception to an anonymous error code. This is to distinguish from','line_number':2483,'multiline':False]['text':' a NamespaceNotFound exception on the user collection, which callers sometimes','line_number':2484,'multiline':False]['text':' interpret as not being an error condition.','line_number':2485,'multiline':False]['text':' fromMigrate ','line_number':2495,'multiline':True]['text':' On standalones and primaries, call setUpIndexBuild(), which makes the initial catalog','line_number':2513,'multiline':False]['text':' write. On primaries, this replicates the startIndexBuild oplog entry. The start','line_number':2514,'multiline':False]['text':' timestamp is only set during oplog application.','line_number':2515,'multiline':False]['text':' If we are starting the index build as a secondary, we must suppress calls to write','line_number':2520,'multiline':False]['text':' our initial oplog entry in setUpIndexBuild().','line_number':2521,'multiline':False]['text':' Use the provided timestamp to write the initial catalog entry. This is also the','line_number':2526,'multiline':False]['text':' case when recovering from the oplog as a standalone. In general, if a timestamp','line_number':2527,'multiline':False]['text':' is provided, it should be used to avoid untimestamped writes.','line_number':2528,'multiline':False]['text':' Mark the index build setup as complete, from now on cleanup is required on failure/abort.','line_number':2549,'multiline':False]['text':' _setUpIndexBuildInner must not throw after this point, or risk secondaries getting stuck','line_number':2550,'multiline':False]['text':' applying the 'startIndexBuild' oplog entry, because throwing here would cause the node to','line_number':2551,'multiline':False]['text':' vote for abort and subsequently await the 'abortIndexBuild' entry before fulfilling the start','line_number':2552,'multiline':False]['text':' promise, while the oplog applier is waiting for the start promise.','line_number':2553,'multiline':False]['text':' Failing to establish lastOpTime before interceptors is not fatal, the index build will','line_number':2556,'multiline':False]['text':' continue as non-resumable. The build can continue as non-resumable even if this step','line_number':2557,'multiline':False]['text':' succeeds, if it timeouts during the wait for majority read concern on the timestamp','line_number':2558,'multiline':False]['text':' established here.','line_number':2559,'multiline':False]['text':' We should only set this value if this is a hybrid index build.','line_number':2562,'multiline':False]['text':' After the interceptors are set, get the latest optime in the oplog that could have','line_number':2565,'multiline':False]['text':' contained a write to this collection. We need to be holding the collection lock in X','line_number':2566,'multiline':False]['text':' mode so that we ensure that there are not any uncommitted transactions on this','line_number':2567,'multiline':False]['text':' collection.','line_number':2568,'multiline':False]['text':' It is fine to let the build continue even if we are interrupted, interrupt check before','line_number':2572,'multiline':False]['text':' actually starting the build will trigger the abort, after having signalled the start','line_number':2573,'multiline':False]['text':' promise.','line_number':2574,'multiline':False]['text':' After this point, concurrent aborts are not allowed, with the exception of a loopback','line_number':2598,'multiline':False]['text':' voteAbortIndexBuild.','line_number':2599,'multiline':False]['text':' Hold reference to the catalog for collection lookup without locks to be safe.','line_number':2601,'multiline':False]['text':' Setup is done within the index builder thread, signal to any waiters that an error','line_number':2610,'multiline':False]['text':' occurred.','line_number':2611,'multiline':False]['text':' The indexes are in the durable catalog in an unfinished state. Return an OK status so','line_number':2616,'multiline':False]['text':' that the caller can continue building the indexes by calling _runIndexBuild().','line_number':2617,'multiline':False]['text':' Unregister the index build before setting the promise, so callers do not see the build again.','line_number':2622,'multiline':False]['text':' The requested index (specs) are already built or are being built. Return success','line_number':2625,'multiline':False]['text':' early (this is v4.0 behavior compatible).','line_number':2626,'multiline':False]['text':' If the index build does not exist, do not continue building the index. This may happen if an','line_number':2645,'multiline':False]['text':' ignorable indexing error occurred during setup. The promise will have been fulfilled, but the','line_number':2646,'multiline':False]['text':' build has already been unregistered.','line_number':2647,'multiline':False]['text':' Add build UUID to lock manager diagnostic output.','line_number':2654,'multiline':False]['text':' Ensure the index build is unregistered from the Coordinator and the Promise is set with','line_number':2677,'multiline':False]['text':' the build's result so that callers are notified of the outcome.','line_number':2678,'multiline':False]['text':' Unregister first so that when we fulfill the future, the build is not observed as active.','line_number':2681,'multiline':False]['text':' During a failure, unregistering is handled by either the caller or the current thread,','line_number':2687,'multiline':False]['text':' depending on where the error originated. Signal to any waiters that an error occurred.','line_number':2688,'multiline':False]['text':' TODO(SERVER-74657): Please revisit if this thread could be made killable.','line_number':2699,'multiline':False]['text':' namespace','line_number':2709,'multiline':False]['text':' The index build aborted at an early stage before the 'startIndexBuild' oplog entry is','line_number':2719,'multiline':False]['text':' replicated: members replicating from this sync source are not aware of this index','line_number':2720,'multiline':False]['text':' build, nor has any build state been persisted locally. Unregister the index build','line_number':2721,'multiline':False]['text':' locally. In two phase index builds, any conditions causing secondaries to fail setting up','line_number':2722,'multiline':False]['text':' an index build (which must have succeeded in the primary) are assumed to eventually cause','line_number':2723,'multiline':False]['text':' the node to crash, so we do not attempt to verify this is a primary.','line_number':2724,'multiline':False]['text':' It is still possible to get a shutdown request while trying to clean-up. All shutdown','line_number':2735,'multiline':False]['text':' errors must be handled, or risk blocking shutdown due to the index build coordinator','line_number':2736,'multiline':False]['text':' waiting on index builds to finish because the index build state has not been updated','line_number':2737,'multiline':False]['text':' properly.','line_number':2738,'multiline':False]['text':' The only expected errors are shutdown errors.','line_number':2760,'multiline':False]['text':' The index builder thread can abort on its own if it is interrupted by a user killop. This','line_number':2778,'multiline':False]['text':' would prevent us from taking locks. Use a new OperationContext to abort the index build.','line_number':2779,'multiline':False]['text':' Use a new OperationContext to abort the index build since our current opCtx may be','line_number':2798,'multiline':False]['text':' interrupted. This is still susceptible to shutdown interrupts, but in that case, on server','line_number':2799,'multiline':False]['text':' restart the index build will also be restarted. This is also susceptible to user killops, but','line_number':2800,'multiline':False]['text':' in that case, we will let the error escape and the server will crash.','line_number':2801,'multiline':False]['text':' The index builder thread will need to reach out to the current primary to abort on','line_number':2804,'multiline':False]['text':' its own. This can happen if an error is thrown, it is interrupted by a user killop,','line_number':2805,'multiline':False]['text':' or is killed internally by something like the DiskSpaceMonitor. Voting for abort is','line_number':2806,'multiline':False]['text':' only allowed if the node did not previously attempt to vote for commit.','line_number':2807,'multiline':False]['text':' (Ignore FCV check): This feature flag doesn't have any upgrade/downgrade concerns.','line_number':2809,'multiline':False]['text':' Always request an abort to the primary node, even if we are primary. If','line_number':2813,'multiline':False]['text':' primary, the signal will loop back and cause an asynchronous external','line_number':2814,'multiline':False]['text':' index build abort.','line_number':2815,'multiline':False]['text':' The abort, and state clean-up, is done externally by the async','line_number':2818,'multiline':False]['text':' 'voteAbortIndexBuild' command if the node is primary itself, or by the','line_number':2819,'multiline':False]['text':' 'indexBuildAbort' oplog entry application thread on secondaries. We'll re-throw','line_number':2820,'multiline':False]['text':' our error without doing anything else, as the index build is already cleaned','line_number':2821,'multiline':False]['text':' up, and the server will terminate otherwise.','line_number':2822,'multiline':False]['text':' Take RSTL to observe and prevent replication state from changing.','line_number':2824,'multiline':False]['text':' Index builds may not fail on secondaries. If a primary replicated an','line_number':2831,'multiline':False]['text':' abortIndexBuild oplog entry, then this index build would have been externally','line_number':2832,'multiline':False]['text':' aborted.','line_number':2833,'multiline':False]['text':' Try to set index build state to in-progress, if it has been aborted or interrupted the','line_number':2854,'multiline':False]['text':' attempt will fail.','line_number':2855,'multiline':False]['text':' Index builds can safely ignore prepare conflicts and perform writes. On secondaries,','line_number':2868,'multiline':False]['text':' prepare operations wait for index builds to complete.','line_number':2869,'multiline':False]['text':' After this point, concurrent aborts are not allowed, with the exception of a loopback','line_number':2880,'multiline':False]['text':' voteAbortIndexBuild. External aborters will retry until the build is actually aborted by','line_number':2881,'multiline':False]['text':' the builder, or until the builder goes into kAwaitPrimaryAbort state, in which case an','line_number':2882,'multiline':False]['text':' external abort is allowed.','line_number':2883,'multiline':False]['text':' Merge exception status with replication index build state status. When there was an','line_number':2885,'multiline':False]['text':' external abort, the index build state already contains the abort reason as specified by','line_number':2886,'multiline':False]['text':' the external aborter and this call does not override the status. In that case, the fact','line_number':2887,'multiline':False]['text':' that this opCtx was interrupted (due to killOp) is irrelevant, as it is the means by','line_number':2888,'multiline':False]['text':' which the builder is stopped, not the actual root cause. This returns a meaningful error','line_number':2889,'multiline':False]['text':' message to the createIndexes caller in case of an external abort, e.g. a secondary voting','line_number':2890,'multiline':False]['text':' to abort the index build. Not doing so would return a generic, not too helpful "operation','line_number':2891,'multiline':False]['text':' was interrupted" error message, because the 'voteAbortIndexBuild' command kills the index','line_number':2892,'multiline':False]['text':' build's operation context.','line_number':2893,'multiline':False]['text':' No abort detected, index build returned normally.','line_number':2898,'multiline':False]['text':' Only report metrics for index builds on primaries. We are being aborted by an external','line_number':2907,'multiline':False]['text':' thread, thus we can assume it is holding the RSTL while waiting for us to exit.','line_number':2908,'multiline':False]['text':' If the index build has already been cleaned-up because it encountered an error, there is no','line_number':2918,'multiline':False]['text':' work to do. If feature flag IndexBuildGracefulErrorHandling is not enabled, the most routine','line_number':2919,'multiline':False]['text':' case is for this to be due to a self-abort caused by constraint checking during the commit','line_number':2920,'multiline':False]['text':' phase. If an external abort was requested, cleanup is handled by the requester, and there is','line_number':2921,'multiline':False]['text':' nothing to do.','line_number':2922,'multiline':False]['text':' We do not hold a collection lock here, but we are protected against the collection being','line_number':2929,'multiline':False]['text':' dropped while the index build is still registered for the collection -- until abortIndexBuild','line_number':2930,'multiline':False]['text':' is called. The collection can be renamed, but it is OK for the name to be stale just for','line_number':2931,'multiline':False]['text':' logging purposes.','line_number':2932,'multiline':False]['text':' If IndexBuildGracefulErrorHandling is not enabled, crash on unexpected build errors. When the','line_number':2947,'multiline':False]['text':' feature flag is enabled, two-phase builds can handle unexpected errors by requesting an abort','line_number':2948,'multiline':False]['text':' to the primary node. Single-phase builds can also abort immediately, as the primary or','line_number':2949,'multiline':False]['text':' standalone is the only node aware of the build.','line_number':2950,'multiline':False]['text':' Index builds only check index constraints when committing. If an error occurs at that','line_number':2953,'multiline':False]['text':' point, then the build is cleaned up while still holding the appropriate locks. The only','line_number':2954,'multiline':False]['text':' errors that we cannot anticipate are user interrupts and shutdown errors.','line_number':2955,'multiline':False]['text':' WARNING: Do not add new exemptions to this assertion! If this assertion is failing, an','line_number':2963,'multiline':False]['text':' exception escaped during this index build. The solution should not be to add an exemption','line_number':2964,'multiline':False]['text':' for that exception. We should instead address the problem by preventing that exception','line_number':2965,'multiline':False]['text':' from being thrown in the first place.','line_number':2966,'multiline':False]['text':'','line_number':2967,'multiline':False]['text':' Simultaneous index builds are not resilient to arbitrary exceptions being thrown.','line_number':2968,'multiline':False]['text':' Secondaries will only abort when the primary replicates an abortIndexBuild oplog entry,','line_number':2969,'multiline':False]['text':' and primaries should only abort when they can guarantee the node will not step down.','line_number':2970,'multiline':False]['text':'','line_number':2971,'multiline':False]['text':' At this point, an exception was thrown, we released our locks, and our index build state','line_number':2972,'multiline':False]['text':' is not resumable. If we were primary when the exception was thrown, we are no longer','line_number':2973,'multiline':False]['text':' guaranteed to be primary at this point. If we were never primary or are no longer','line_number':2974,'multiline':False]['text':' primary, we will fatally assert. If we are still primary, we can hope to quickly','line_number':2975,'multiline':False]['text':' re-acquire our locks and abort the index build without issue. We will always fatally','line_number':2976,'multiline':False]['text':' assert in debug builds.','line_number':2977,'multiline':False]['text':'','line_number':2978,'multiline':False]['text':' Solutions to fixing this failing assertion may include:','line_number':2979,'multiline':False]['text':' * Suppress the errors during the index build and re-check the assertions that lead to the','line_number':2980,'multiline':False]['text':'   error at commit time once we have acquired all of the appropriate locks in','line_number':2981,'multiline':False]['text':'   _insertKeysFromSideTablesAndCommit().','line_number':2982,'multiline':False]['text':' * Explicitly abort the index build with abortIndexBuildByBuildUUID() before performing an','line_number':2983,'multiline':False]['text':'   operation that causes the index build to throw an error.','line_number':2984,'multiline':False]['text':' Note: Even if we don't fatally assert, if the node has stepped-down from being','line_number':2991,'multiline':False]['text':' primary, then we will still crash shortly after this. As a secondary, index','line_number':2992,'multiline':False]['text':' builds must succeed, and if we are in this path, the index build failed without','line_number':2993,'multiline':False]['text':' being explicitly aborted by the primary. Only if we're lucky enough to still be','line_number':2994,'multiline':False]['text':' primary will we abort the index build without any nodes crashing.','line_number':2995,'multiline':False]['text':' Any error that escapes at this point is not fatal and can be handled by the caller.','line_number':3005,'multiline':False]['text':' The index build is not resumable if the node is in initial sync while building the index.','line_number':3042,'multiline':False]['text':' Disable resumable index build.','line_number':3049,'multiline':False]['text':' Wait indefinitely for majority commit point.','line_number':3060,'multiline':False]['text':' Setting 'deadline' to Date_t::max() achieves the same effect as boost::none in','line_number':3061,'multiline':False]['text':' ReplicationCoordinatorImpl::waitUntilMajorityOpTime(). Additionally, providing a','line_number':3062,'multiline':False]['text':' 'deadline' of Date_t::max() is given special treatment in','line_number':3063,'multiline':False]['text':' OperationContext::waitForConditionOrInterruptNoAssertUntil().','line_number':3064,'multiline':False]['text':' Since we waited for all the writes before the interceptors were established to be majority','line_number':3111,'multiline':False]['text':' committed, if we read at the majority commit point for the collection scan, then none of the','line_number':3112,'multiline':False]['text':' documents put into the sorter can be rolled back.','line_number':3113,'multiline':False]['text':' Read without a timestamp. When we commit, we block writes which guarantees all writes are','line_number':3130,'multiline':False]['text':' visible.','line_number':3131,'multiline':False]['text':' The collection scan might read with a kMajorityCommitted read source, but will restore','line_number':3134,'multiline':False]['text':' kNoTimestamp afterwards.','line_number':3135,'multiline':False]['text':'
 * First phase is doing a collection scan and inserting keys into sorter.
 * Second phase is extracting the sorted keys and writing them into the new index table.
 ','line_number':3143,'multiline':True]['text':' Collection scan and insert into index.','line_number':3151,'multiline':False]['text':' The collection scan phase of an index build is marked as low priority in order to reduce','line_number':3153,'multiline':False]['text':' impact on user operations. Other steps of the index builds such as the draining phase have','line_number':3154,'multiline':False]['text':' normal priority because index builds are required to eventually catch-up with concurrent','line_number':3155,'multiline':False]['text':' writers. Otherwise we risk never finishing the index build.','line_number':3156,'multiline':False]['text':' Wait for the last optime before the interceptors are established to be majority committed','line_number':3166,'multiline':False]['text':' while we aren't holding any locks. This will set the read source to be kMajorityCommitted','line_number':3167,'multiline':False]['text':' if it waited.','line_number':3168,'multiline':False]['text':' The collection scan phase of an index build is marked as low priority in order to reduce','line_number':3194,'multiline':False]['text':' impact on user operations. Other steps of the index builds such as the draining phase have','line_number':3195,'multiline':False]['text':' normal priority because index builds are required to eventually catch-up with concurrent','line_number':3196,'multiline':False]['text':' writers. Otherwise we risk never finishing the index build.','line_number':3197,'multiline':False]['text':' Rebuilding system indexes during startup using the IndexBuildsCoordinator is done by all','line_number':3217,'multiline':False]['text':' storage engines if they're missing.','line_number':3218,'multiline':False]['text':'
 * Third phase is catching up on all the writes that occurred during the first two phases.
 ','line_number':3228,'multiline':True]['text':' Perform the first drain while holding an intent lock.','line_number':3235,'multiline':False]['text':' Perform the second drain while stopping writes on the collection.','line_number':3270,'multiline':False]['text':' Skip RSTL to avoid deadlocks with prepare conflicts and state transitions. See','line_number':3272,'multiline':False]['text':' SERVER-42621.','line_number':3273,'multiline':False]['text':'skipRSTL=','line_number':3275,'multiline':True]['text':'*
 * Continue the third phase of catching up on all remaining writes that occurred and then commit.
 * Accepts a commit timestamp for the index (null if not available).
 ','line_number':3292,'multiline':True]['text':' Need to return the collection lock back to exclusive mode to complete the index build.','line_number':3308,'multiline':False]['text':'retry=','line_number':3310,'multiline':True]['text':' If we are no longer primary after receiving a commit quorum, we must restart and wait for a','line_number':3321,'multiline':False]['text':' new signal from a new primary because we cannot commit. Note that two-phase index builds can','line_number':3322,'multiline':False]['text':' retry because a new signal should be received. Single-phase builds will be unable to commit','line_number':3323,'multiline':False]['text':' and will self-abort.','line_number':3324,'multiline':False]['text':' While we are still holding the RSTL and before returning, ensure the metrics collected for','line_number':3335,'multiline':False]['text':' this index build are attributed to the primary that commits or aborts the index build.','line_number':3336,'multiline':False]['text':' The collection object should always exist while an index build is registered.','line_number':3347,'multiline':False]['text':' Perform the third and final drain after releasing a shared lock and reacquiring an','line_number':3356,'multiline':False]['text':' exclusive lock on the collection.','line_number':3357,'multiline':False]['text':' If we are no longer primary and a single phase index build started as primary attempts to','line_number':3368,'multiline':False]['text':' commit, trigger a self-abort.','line_number':3369,'multiline':False]['text':' Retry indexing records that failed key generation, but only if we are primary.','line_number':3377,'multiline':False]['text':' Secondaries rely on the primary's decision to commit as assurance that it has checked all','line_number':3378,'multiline':False]['text':' key generation errors on its behalf.','line_number':3379,'multiline':False]['text':' Duplicate key constraint checking phase. Duplicate key errors are tracked for','line_number':3385,'multiline':False]['text':' single-phase builds on primaries and two-phase builds in all replication states.','line_number':3386,'multiline':False]['text':' Single-phase builds on secondaries don't track duplicates so this call is a no-op. This','line_number':3387,'multiline':False]['text':' can be called for two-phase builds in all replication states except during initial sync','line_number':3388,'multiline':False]['text':' when this node is not guaranteed to be consistent.','line_number':3389,'multiline':False]['text':' If two phase index builds is enabled, index build will be coordinated using','line_number':3403,'multiline':False]['text':' startIndexBuild and commitIndexBuild oplog entries.','line_number':3404,'multiline':False]['text':' Commit index build.','line_number':3420,'multiline':False]['text':' There already is clean-up handling code up the stack, but this redundancy is introduced','line_number':3429,'multiline':False]['text':' to make sure we abort the index build as primary, by doing so while we still have the','line_number':3430,'multiline':False]['text':' locks. The caller's handling code will detect this condition and do nothing.','line_number':3431,'multiline':False]['text':' It is illegal to abort the index build at this point. Note that Interruption exceptions','line_number':3435,'multiline':False]['text':' are allowed because we cannot control them as they bypass the routine abort machinery.','line_number':3436,'multiline':False]['text':' Index build commit may not fail on secondaries because it implies diverenge with data on','line_number':3439,'multiline':False]['text':' the primary. The only exception is single-phase builds started on primaries, which may','line_number':3440,'multiline':False]['text':' fail after a state transition. In this case, we have not replicated anything to','line_number':3441,'multiline':False]['text':' roll-back. With two-phase index builds, if a primary replicated an abortIndexBuild oplog','line_number':3442,'multiline':False]['text':' entry, then this index build should have been interrupted before committing.','line_number':3443,'multiline':False]['text':' This index build failed due to an indexing error in normal circumstances. Abort while','line_number':3456,'multiline':False]['text':' still holding the RSTL and collection locks.','line_number':3457,'multiline':False]['text':' At this point, the commitIndexBuild entry has already been written and replicated. For','line_number':3462,'multiline':False]['text':' correctness, we must perform these final writes. Temporarily disable interrupts.','line_number':3463,'multiline':False]['text':' NOLINT.','line_number':3464,'multiline':False]['text':' We rely on 'collection' for any collection information because no databases are open during','line_number':3489,'multiline':False]['text':' recovery.','line_number':3490,'multiline':False]['text':' Since we are holding an exclusive collection lock to stop new writes, do not yield locks','line_number':3509,'multiline':False]['text':' while draining.','line_number':3510,'multiline':False]['text':' Commit the index build.','line_number':3520,'multiline':False]['text':' Index build is registered in manager regardless of IndexBuildsManager::setUpIndexBuild()','line_number':3547,'multiline':False]['text':' result.','line_number':3548,'multiline':False]['text':' An index build failure during recovery is fatal.','line_number':3550,'multiline':False]['text':' 'numIndexesBefore' was before we cleared any unfinished indexes, so it must be the same','line_number':3555,'multiline':False]['text':' as 'numIndexesAfter', since we're going to be building any unfinished indexes too.','line_number':3556,'multiline':False]['text':' During secondary oplog application, the index specs have already been normalized in the','line_number':3596,'multiline':False]['text':' oplog entries read from the primary. We should not be modifying the specs any further.','line_number':3597,'multiline':False]['text':' A secondary node with a subset of the indexes already built will not vote for the commit','line_number':3601,'multiline':False]['text':' quorum, which can stall the index build indefinitely on a replica set.','line_number':3602,'multiline':False]['text':'removeIndexBuildsToo=','line_number':3604,'multiline':True]['text':' Normalize the specs' collations, wildcard projections, and any other fields as applicable.','line_number':3641,'multiline':False]['text':' Remove any index specifications which already exist in the catalog.','line_number':3644,'multiline':False]['text':'removeIndexBuildsToo','line_number':3646,'multiline':True]['text':' Verify that each spec is compatible with the collection's sharding state.','line_number':3648,'multiline':False]['text':' namespace mongo','line_number':3658,'multiline':False]