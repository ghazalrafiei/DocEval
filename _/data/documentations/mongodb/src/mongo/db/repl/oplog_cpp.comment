['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: keep','line_number':46,'multiline':False]['text':' Failpoint to block after a write and its oplog entry have been written to the storage engine and','line_number':175,'multiline':False]['text':' are visible, but before we have advanced 'lastApplied' for the write.','line_number':176,'multiline':False]['text':' We do not need to notify capped waiters, as we have not yet updated oplog visibility, so','line_number':243,'multiline':False]['text':' these inserts will not be visible.  When visibility updates, it will notify capped','line_number':244,'multiline':False]['text':' waiters.','line_number':245,'multiline':False]['text':' Running shard merge during initial sync can lead to potential data loss on this node.','line_number':252,'multiline':False]['text':' So, we perform safety check during oplog catchup and at the end of initial sync','line_number':253,'multiline':False]['text':' recovery. (see recoverShardMergeRecipientAccessBlockers() for the detailed comment about the','line_number':254,'multiline':False]['text':' problematic scenario that can cause data loss.)','line_number':255,'multiline':False]['text':' If the 'o' field does not have an _id, then 'o2' should have it.','line_number':260,'multiline':False]['text':' Otherwise, the oplog entry is corrupted.','line_number':261,'multiline':False]['text':' namespace','line_number':271,'multiline':False]['text':' Uncommitted collections support creating indexes using relaxed locking if they are part of a','line_number':283,'multiline':False]['text':' multi-document transaction.','line_number':284,'multiline':False]['text':' Check if collection exists.','line_number':290,'multiline':False]['text':' Check for conflict with two-phase index builds during initial sync. It is possible that','line_number':307,'multiline':False]['text':' this index may have been dropped and recreated after inserting documents into the collection.','line_number':308,'multiline':False]['text':' This function should not be used outside oplog application. We should be able to always set','line_number':325,'multiline':False]['text':' the index build constraints to kRelax.','line_number':326,'multiline':False]['text':' Run single-phase builds synchronously with oplog batch application. For tenant migrations,','line_number':333,'multiline':False]['text':' the recipient needs to build the index on empty collections to completion within the same','line_number':334,'multiline':False]['text':' storage transaction. This is in order to eliminate a window of time where we can reload the','line_number':335,'multiline':False]['text':' catalog through startup or rollback and detect the index in an incomplete state. Before','line_number':336,'multiline':False]['text':' SERVER-72618 this was possible and would require us to remove the index from the catalog to','line_number':337,'multiline':False]['text':' allow replication recovery to rebuild it. The result of this was an untimestamped write to','line_number':338,'multiline':False]['text':' the catalog. This only applies to empty collection index builds during tenant migration and','line_number':339,'multiline':False]['text':' is resolved by calling `createIndexesOnEmptyCollection` on empty collections.','line_number':340,'multiline':False]['text':'','line_number':341,'multiline':False]['text':' Single phase builds are only used for empty collections, and to rebuild indexes admin.system','line_number':342,'multiline':False]['text':' collections. See SERVER-47439.','line_number':343,'multiline':False]['text':' Some indexing errors can be ignored during oplog application.','line_number':356,'multiline':False]['text':'*
 * @param dataImage can be BSONObj::isEmpty to signal the node is in initial sync and must
 *                  invalidate relevant image collection data.
 ','line_number':376,'multiline':True]['text':' In practice, this lock acquisition on kConfigImagesNamespace cannot block. The only time a','line_number':387,'multiline':False]['text':' stronger lock acquisition is taken on this namespace is during step up to create the','line_number':388,'multiline':False]['text':' collection.','line_number':389,'multiline':False]['text':' This code path can also be hit by things such as `applyOps` and tenant migrations.','line_number':420,'multiline':False]['text':' we write to local.oplog.rs:
     { ts : ..., v: ..., op: ..., etc }
   ts: an OpTime timestamp
   v: version
   op:
    "i" insert
    "u" update
    "d" delete
    "c" db cmd
    "n" no op
    "xi" insert global index key
    "xd" delete global index key
','line_number':424,'multiline':True]['text':' Throw TenantMigrationConflict error if the database for 'nss' is being migrated. The oplog','line_number':459,'multiline':False]['text':' entry for renameCollection has 'nss' set to the fromCollection's ns. renameCollection can be','line_number':460,'multiline':False]['text':' across databases, but a tenant will never be able to rename into a database with a different','line_number':461,'multiline':False]['text':' prefix, so it is safe to use the fromCollection's db's prefix for this check.','line_number':462,'multiline':False]['text':'','line_number':463,'multiline':False]['text':' Skip the check if this is an "abortIndexBuild" oplog entry since it is safe to the abort an','line_number':464,'multiline':False]['text':' index build on the donor after the blockTimestamp, plus if an index build fails to commit due','line_number':465,'multiline':False]['text':' to TenantMigrationConflict, we need to be able to abort the index build and clean up.','line_number':466,'multiline':False]['text':' Insert the oplog records to the respective tenants change collections.','line_number':477,'multiline':False]['text':' Set replCoord last optime only after we're sure the WUOW didn't abort and roll back.','line_number':483,'multiline':False]['text':' The `finalOpTime` may be less than the `commitTime` if multiple oplog entries','line_number':488,'multiline':False]['text':' are logging within one WriteUnitOfWork.','line_number':489,'multiline':False]['text':' Optionally hang before advancing lastApplied.','line_number':495,'multiline':False]['text':' As an optimization, we skip advancing the global timestamp. In this path on the','line_number':501,'multiline':False]['text':' primary, the caller will have already advanced the clock to at least this value when','line_number':502,'multiline':False]['text':' allocating the timestamp.','line_number':503,'multiline':False]['text':' Optimes on the primary should always represent consistent database states.','line_number':506,'multiline':False]['text':' We set the last op on the client to 'finalOpTime', because that contains the','line_number':510,'multiline':False]['text':' timestamp of the operation that the client actually performed.','line_number':511,'multiline':False]['text':' All collections should have UUIDs now, so all insert, update, and delete oplog entries should','line_number':521,'multiline':False]['text':' also have uuids. Some no-op (n) and command (c) entries may still elide the uuid field.','line_number':522,'multiline':False]['text':' For commands, the test below is on the command ns and therefore does not check for','line_number':529,'multiline':False]['text':' specific namespaces such as system.profile. This is the caller's responsibility.','line_number':530,'multiline':False]['text':' If this oplog entry is from a tenant migration, include the tenant migration','line_number':538,'multiline':False]['text':' UUID and optional donor timeline metadata.','line_number':539,'multiline':False]['text':' TODO SERVER-51301 to remove this block.','line_number':551,'multiline':False]['text':' Use OplogAccessMode::kLogOp to avoid recursive locking.','line_number':556,'multiline':False]['text':' If an OpTime is not specified (i.e. isNull), a new OpTime will be assigned to the oplog entry','line_number':560,'multiline':False]['text':' within the WUOW. If a new OpTime is assigned, it needs to be reset back to a null OpTime','line_number':561,'multiline':False]['text':' before exiting this function so that the same oplog entry instance can be reused for logOp()','line_number':562,'multiline':False]['text':' again. For example, if the WUOW gets aborted within a writeConflictRetry loop, we need to','line_number':563,'multiline':False]['text':' reset the OpTime to null so a new OpTime will be assigned on retry.','line_number':564,'multiline':False]['text':' It would be better to make the oplogEntry a const reference. But because in some cases, a','line_number':574,'multiline':False]['text':' new OpTime needs to be assigned within the WUOW as explained earlier, we instead pass','line_number':575,'multiline':False]['text':' oplogEntry by pointer and reset the OpTime to null using a ScopeGuard.','line_number':576,'multiline':False]['text':' The storage engine will assign the RecordId based on the "ts" field of the oplog entry, see','line_number':584,'multiline':False]['text':' record_id_helpers::extractKey.','line_number':585,'multiline':False]['text':' Not a retryable write.','line_number':609,'multiline':False]['text':' If the statement id is uninitialized, it must be the only one. There cannot also be','line_number':611,'multiline':False]['text':' initialized statement ids.','line_number':612,'multiline':False]['text':' not specified. pick a default size ','line_number':633,'multiline':True]['text':' First choose a minimum size.','line_number':640,'multiline':False]['text':' typically these are desktops (dev machines), so keep it smallish','line_number':643,'multiline':False]['text':' in memory: 50MB minimum size','line_number':651,'multiline':False]['text':' disk: 990MB minimum size','line_number':660,'multiline':False]['text':'-1 if call not supported.','line_number':662,'multiline':False]['text':' Round up oplog size to nearest 256 alignment. Ensures that the rollback of the 256-alignment','line_number':672,'multiline':False]['text':' requirement for capped collections that was removed in SERVER-67246 will not impact this','line_number':673,'multiline':False]['text':' important user-hidden collection. Since downgrades are blocked on this alignment check, a','line_number':674,'multiline':False]['text':' fresh install of the server would very likely lead to an inability to downgrade. Keeping the','line_number':675,'multiline':False]['text':' oplog size 256-aligned avoids this altogether.','line_number':676,'multiline':False]['text':' we use 5% of free [disk] space up to 50GB (1TB free)','line_number':687,'multiline':False]['text':' namespace','line_number':694,'multiline':False]['text':' create an oplog collection, if it doesn't yet exist. ','line_number':732,'multiline':True]['text':' sync here so we don't get any surprising lag later when we try to sync ','line_number':752,'multiline':True]['text':'callerHoldsReadLock','line_number':753,'multiline':True]['text':' -------------------------------------','line_number':765,'multiline':False]['text':' acceptableErrors are errors we accept for idempotency reasons.  Except for IndexNotFound,','line_number':812,'multiline':False]['text':' they are only valid in non-steady-state oplog application modes.  IndexNotFound is always','line_number':813,'multiline':False]['text':' allowed because index builds are not necessarily synchronized between secondary and primary.','line_number':814,'multiline':False]['text':' Sanitize storage engine options to remove options which might not apply to this node.','line_number':833,'multiline':False]['text':' See SERVER-68122.','line_number':834,'multiline':False]['text':' Mode SECONDARY steady state replication should not allow create collection to rename an','line_number':838,'multiline':False]['text':' existing collection out of the way. This leaves a collection orphaned and is a bug.','line_number':839,'multiline':False]['text':' Renaming temporarily out of the way is only allowed for oplog replay, where we expect','line_number':840,'multiline':False]['text':' any temporarily renamed aside collections to be sorted out by the time replay is','line_number':841,'multiline':False]['text':' complete.','line_number':842,'multiline':False]['text':' Check whether there is an open but empty database where the name conflicts with the new','line_number':845,'multiline':False]['text':' collection's database name. It is possible for a secondary's in-memory database state','line_number':846,'multiline':False]['text':' to diverge from the primary's, if the primary rolls back the dropDatabase oplog entry','line_number':847,'multiline':False]['text':' after closing its own in-memory database state. In this case, the primary may accept','line_number':848,'multiline':False]['text':' creating a new database with a conflicting name to what the secondary still has open.','line_number':849,'multiline':False]['text':' It is okay to simply close the empty database on the secondary in this case.','line_number':850,'multiline':False]['text':' Remove "idIndex" field from command.','line_number':861,'multiline':False]['text':' Collections clustered by _id do not need _id indexes.','line_number':871,'multiline':False]['text':' No _id index spec was provided, so we should build a v:1 _id index.','line_number':877,'multiline':False]['text':' Sanitize storage engine options to remove options which might not apply to this node.','line_number':890,'multiline':False]['text':' See SERVER-68122.','line_number':891,'multiline':False]['text':' During initial sync we could have the following three scenarios:','line_number':913,'multiline':False]['text':' * The collection is uncommitted and the index doesn't exist','line_number':914,'multiline':False]['text':' * The collection already exists and the index doesn't exist','line_number':915,'multiline':False]['text':' * Both exist','line_number':916,'multiline':False]['text':'','line_number':917,'multiline':False]['text':' The latter will cause us to return an IndexAlreadyExists error, which is an','line_number':918,'multiline':False]['text':' acceptable error. The first one is the happy expected path so let's focus on the','line_number':919,'multiline':False]['text':' other one. This case can only occur if the node is performing an initial sync and','line_number':920,'multiline':False]['text':' the source node collection performed an index drop during a later part of the','line_number':921,'multiline':False]['text':' oplog. In this scenario the index creation can early return since it knows the','line_number':922,'multiline':False]['text':' index will be deleted at a later point.','line_number':923,'multiline':False]['text':' Multi-document transactions only allow createIndexes to implicitly create a','line_number':929,'multiline':False]['text':' collection. In this case, the collection must be empty and uncommitted. We can','line_number':930,'multiline':False]['text':' then relax the locking requirements (i.e. acquire the collection lock in MODE_IX)','line_number':931,'multiline':False]['text':' to allow a prepared transaction with the uncommitted catalog write to stash its','line_number':932,'multiline':False]['text':' resources before committing. This wouldn't be possible if we held the collection','line_number':933,'multiline':False]['text':' lock in exclusive mode.','line_number':934,'multiline':False]['text':' Sanitize storage engine options to remove options which might not apply to this node.','line_number':961,'multiline':False]['text':' See SERVER-68122.','line_number':962,'multiline':False]['text':' apiStrict ','line_number':1027,'multiline':True]['text':' Oplog entries from secondary oplog application will allways have the Uuid set and','line_number':1032,'multiline':False]['text':' it is only invocations of applyOps directly that may omit it','line_number':1033,'multiline':False]['text':' Parse optime from oplog entry unless we are applying this command in standalone or on a','line_number':1066,'multiline':False]['text':' primary (replicated writes enabled).','line_number':1067,'multiline':False]['text':' deleteIndex(es) is deprecated but still works as of April 10, 2015','line_number':1076,'multiline':False]['text':' Parse optime from oplog entry unless we are applying this command in standalone or on a','line_number':1116,'multiline':False]['text':' primary (replicated writes enabled).','line_number':1117,'multiline':False]['text':' apiStrict ','line_number':1133,'multiline':True]['text':' Writes a change stream pre-image 'preImage' associated with oplog entry 'oplogEntry' and a write','line_number':1275,'multiline':False]['text':' operation to collection 'collection'. If we are writing the pre-image during oplog application','line_number':1276,'multiline':False]['text':' on a secondary for a serverless tenant migration, we will use the timestamp and applyOpsIndex','line_number':1277,'multiline':False]['text':' from the donor timeline. If we are applying this entry on a primary during tenant oplog','line_number':1278,'multiline':False]['text':' application, we skip writing of the pre-image. The op observer will handle inserting the','line_number':1279,'multiline':False]['text':' correct pre-image on the primary in this case.','line_number':1280,'multiline':False]['text':' If donorOpTime is set on the oplog entry, this is a write that is being applied on a','line_number':1287,'multiline':False]['text':' secondary during the oplog catchup phase of a tenant migration. Otherwise, we are either','line_number':1288,'multiline':False]['text':' applying a steady state write operation on a secondary or applying a write on the primary','line_number':1289,'multiline':False]['text':' during tenant migration oplog catchup.','line_number':1290,'multiline':False]['text':' namespace','line_number':1306,'multiline':False]['text':' This only being used in applyOps command which is controlled by the client, so it should','line_number':1335,'multiline':False]['text':' be unstable.','line_number':1336,'multiline':False]['text':' Relax the constraints of oplog application if the node is not a replica set member or the','line_number':1355,'multiline':False]['text':' node is in the middle of a backup and restore process.','line_number':1356,'multiline':False]['text':' During the recovery process, certain configuration collections such as','line_number':1361,'multiline':False]['text':' 'config.image_collections' are handled differently, which may result in encountering oplog','line_number':1362,'multiline':False]['text':' application failures in common scenarios, and therefore assert statements are not used.','line_number':1363,'multiline':False]['text':' Only fassert in test environment.','line_number':1373,'multiline':False]['text':' Logger for oplog constraint violations.','line_number':1388,'multiline':False]['text':' Log the violation.','line_number':1401,'multiline':False]['text':' Write a new entry to the health log.','line_number':1404,'multiline':False]['text':' Oplog constraint violations should always be marked as warning.','line_number':1408,'multiline':False]['text':' @return failure status if an update should have happened and the document DNE.','line_number':1418,'multiline':False]['text':' See replset initial sync code.','line_number':1419,'multiline':False]['text':' Get the single oplog entry to be applied or the first oplog entry of grouped inserts.','line_number':1427,'multiline':False]['text':' Choose opCounters based on running on standalone/primary or secondary by checking','line_number':1435,'multiline':False]['text':' whether writes are replicated.','line_number':1436,'multiline':False]['text':' no op','line_number':1443,'multiline':False]['text':' Invalidate the image collection if collectionUUID does not resolve and this op returns','line_number':1466,'multiline':False]['text':' a preimage or postimage. We only expect this to happen when in kInitialSync mode but','line_number':1467,'multiline':False]['text':' this can sometimes occur in recovering mode during rollback-via-refetch. In either case','line_number':1468,'multiline':False]['text':' we want to do image invalidation.','line_number':1469,'multiline':False]['text':' The feature compatibility version in the server configuration collection must not change','line_number':1509,'multiline':False]['text':' during initial sync.','line_number':1510,'multiline':False]['text':' Decide whether to timestamp the write with the 'ts' field found in the operation. In general,','line_number':1534,'multiline':False]['text':' we do this for secondary oplog application, but there are some exceptions.','line_number':1535,'multiline':False]['text':' We do not assign timestamps on replicated writes since they will get their oplog','line_number':1538,'multiline':False]['text':' timestamp once they are logged. The operation may contain a timestamp if it is part','line_number':1539,'multiline':False]['text':' of a applyOps command, but we ignore it so that we don't violate oplog ordering.','line_number':1540,'multiline':False]['text':' We do not assign timestamps to non-replicated writes that have a wrapping','line_number':1543,'multiline':False]['text':' WriteUnitOfWork, as they will get the timestamp on that WUOW. Use cases include:','line_number':1544,'multiline':False]['text':' Secondary oplog application of prepared transactions.','line_number':1545,'multiline':False]['text':' Secondary oplog application not in a WUOW uses the timestamp in the operation','line_number':1548,'multiline':False]['text':' document.','line_number':1549,'multiline':False]['text':' Only assign timestamps on standalones during replication recovery when','line_number':1552,'multiline':False]['text':' started with the 'recoverFromOplogAsStandalone' flag.','line_number':1553,'multiline':False]['text':' Should record a change stream pre-image when:','line_number':1563,'multiline':False]['text':' (1) the state of the collection is guaranteed to be consistent so it is possible to','line_number':1564,'multiline':False]['text':' compute a correct pre-image,','line_number':1565,'multiline':False]['text':' (2) and the oplog entry is not a result of chunk migration or collection resharding -','line_number':1566,'multiline':False]['text':' such entries do not get reflected as change events and it is not possible to compute a','line_number':1567,'multiline':False]['text':' correct pre-image for them.','line_number':1568,'multiline':False]['text':' We are applying this entry on the primary during tenant oplog application. Decorate the opCtx','line_number':1577,'multiline':False]['text':' with donor timeline metadata so that it will be available in the op observer and available','line_number':1578,'multiline':False]['text':' for use here when oplog entries are logged.','line_number':1579,'multiline':False]['text':' Grouped inserts.','line_number':1592,'multiline':False]['text':' Cannot apply an array insert with applyOps command.  But can apply grouped','line_number':1594,'multiline':False]['text':' inserts on primary as part of a tenant migration.','line_number':1595,'multiline':False]['text':' Applying grouped inserts on the primary as part of a tenant migration.','line_number':1610,'multiline':False]['text':' We assign new optimes as the optimes on the donor are not relevant to','line_number':1611,'multiline':False]['text':' the recipient.','line_number':1612,'multiline':False]['text':' fromMigrate ','line_number':1628,'multiline':True]['text':' Single insert.','line_number':1644,'multiline':False]['text':' No _id.','line_number':1651,'multiline':False]['text':' This indicates an issue with the upstream server:','line_number':1652,'multiline':False]['text':'     The oplog entry is corrupted; or','line_number':1653,'multiline':False]['text':'     The version of the upstream server is obsolete.','line_number':1654,'multiline':False]['text':' 1. Insert if','line_number':1660,'multiline':False]['text':'   a) we do not have a wrapping WriteUnitOfWork, which implies we are not part of','line_number':1661,'multiline':False]['text':'      an "applyOps" command, OR','line_number':1662,'multiline':False]['text':'   b) we are part of a multi-document transaction[1], OR','line_number':1663,'multiline':False]['text':'','line_number':1664,'multiline':False]['text':' 2. Upsert[2] if','line_number':1665,'multiline':False]['text':'   a) we have a wrapping WriteUnitOfWork AND we are not part of a transaction,','line_number':1666,'multiline':False]['text':'      which implies we are part of an "applyOps" command, OR','line_number':1667,'multiline':False]['text':'   b) the previous insert failed with a DuplicateKey error AND we are not part','line_number':1668,'multiline':False]['text':'      a transaction AND either we are not in steady state replication mode OR','line_number':1669,'multiline':False]['text':'      the oplogApplicationEnforcesSteadyStateConstraints parameter is false.','line_number':1670,'multiline':False]['text':'','line_number':1671,'multiline':False]['text':' [1] Transactions should not convert inserts to upserts because on secondaries','line_number':1672,'multiline':False]['text':'     they will perform a lookup that never occurred on the primary. This may cause','line_number':1673,'multiline':False]['text':'     an unintended prepare conflict and block replication. For this reason,','line_number':1674,'multiline':False]['text':'     transactions should always fail with DuplicateKey errors and never retry','line_number':1675,'multiline':False]['text':'     inserts as upserts.','line_number':1676,'multiline':False]['text':' [2] This upsert behavior exists to support idempotency guarantees outside','line_number':1677,'multiline':False]['text':'     steady-state replication and existing users of applyOps.','line_number':1678,'multiline':False]['text':' Do not use supplied timestamps if running through applyOps, as that would','line_number':1691,'multiline':False]['text':' allow a user to dictate what timestamps appear in the oplog.','line_number':1692,'multiline':False]['text':' Primaries processing inserts always pre-allocate timestamps. For parity,','line_number':1699,'multiline':False]['text':' we also pre-allocate timestamps for an `applyOps` of insert oplog','line_number':1700,'multiline':False]['text':' entries. This parity is meaningful for capped collections where the','line_number':1701,'multiline':False]['text':' insert may result in a delete that becomes replicated.','line_number':1702,'multiline':False]['text':'batchSize=','line_number':1704,'multiline':True]['text':' fromMigrate ','line_number':1710,'multiline':True]['text':' Transactions cannot be retried as upserts once they fail with a duplicate','line_number':1715,'multiline':False]['text':' key error.','line_number':1716,'multiline':False]['text':' status ','line_number':1730,'multiline':True]['text':' Continue to the next block to retry the operation as an upsert.','line_number':1739,'multiline':False]['text':' Now see if we need to do an upsert.','line_number':1746,'multiline':False]['text':' Do update on DuplicateKey errors.','line_number':1748,'multiline':False]['text':' This will only be on the _id field in replication,','line_number':1749,'multiline':False]['text':' since we disable non-_id unique constraint violations.','line_number':1750,'multiline':False]['text':' If `haveWrappingWriteUnitOfWork` is true, do not timestamp the write.','line_number':1764,'multiline':False]['text':' The o2 field may contain additional fields besides the _id (like the shard key','line_number':1799,'multiline':False]['text':' fields), but we want to do the update by just _id so we can take advantage of the','line_number':1800,'multiline':False]['text':' IDHACK.','line_number':1801,'multiline':False]['text':' If we are in steady state and the update is on a timeseries bucket collection, we can','line_number':1809,'multiline':False]['text':' enable some optimizations in diff application. In some cases, like during tenant','line_number':1810,'multiline':False]['text':' migration or $_internalApplyOplogUpdate update, we can for some reason generate','line_number':1811,'multiline':False]['text':' entries for timeseries bucket collections which still rely on the idempotency','line_number':1812,'multiline':False]['text':' guarantee, which then means we shouldn't apply these optimizations.','line_number':1813,'multiline':False]['text':' Determine if a change stream pre-image has to be recorded for the oplog entry.','line_number':1832,'multiline':False]['text':' The new version of the document to be loaded was not requested - request','line_number':1836,'multiline':False]['text':' returning of the document version before update to be used as change stream','line_number':1837,'multiline':False]['text':' pre-image.','line_number':1838,'multiline':False]['text':' Operations that were part of a retryable findAndModify have two formats for','line_number':1847,'multiline':False]['text':' replicating pre/post images. The classic format has primaries writing explicit noop','line_number':1848,'multiline':False]['text':' oplog entries that contain the necessary details for reconstructed a response to a','line_number':1849,'multiline':False]['text':' retried operation.','line_number':1850,'multiline':False]['text':'','line_number':1851,'multiline':False]['text':' In the new format, we "implicitly" replicate the necessary data. Oplog entries may','line_number':1852,'multiline':False]['text':' contain an optional field, `needsRetryImage` with a value of `preImage` or','line_number':1853,'multiline':False]['text':' `postImage`. When applying these oplog entries, we also retrieve the pre/post image','line_number':1854,'multiline':False]['text':' retrieved by the query system and write that value into `config.image_collection` as','line_number':1855,'multiline':False]['text':' part of the same oplog application transaction. The `config.image_collection`','line_number':1856,'multiline':False]['text':' documents are keyed by the oplog entries logical session id, which is the same as the','line_number':1857,'multiline':False]['text':' `config.transactions` table.','line_number':1858,'multiline':False]['text':'','line_number':1859,'multiline':False]['text':' Batches of oplog entries can contain multiple oplog entries from the same logical','line_number':1860,'multiline':False]['text':' session. Thus updates to `config.image_collection` documents can be','line_number':1861,'multiline':False]['text':' concurrent. Secondaries already coalesce (read: intentionally ignore) some writes to','line_number':1862,'multiline':False]['text':' `config.transactions`, we may also omit some writes to `config.image_collection`, so','line_number':1863,'multiline':False]['text':' long as the last write persists.  We handle this in the oplog applier by allowing','line_number':1864,'multiline':False]['text':' only one write (whether implicit update or explicit delete) to','line_number':1865,'multiline':False]['text':' config.image_collection per applier batch.  This works in the case of rollback','line_number':1866,'multiline':False]['text':' because we are only allowed to retry the latest find-and-modify operation on a','line_number':1867,'multiline':False]['text':' session; any images lost to rollback would have had the wrong transaction ID and','line_number':1868,'multiline':False]['text':' thus not been legal to use anyway','line_number':1869,'multiline':False]['text':'','line_number':1870,'multiline':False]['text':' On the primary, we are assured the writes to this collection are ordered because','line_number':1871,'multiline':False]['text':' the logical session ID being written is checked out when we do the write.','line_number':1872,'multiline':False]['text':' We can still get a write conflict on the primary as a delete done as part of expired','line_number':1873,'multiline':False]['text':' session cleanup can race with a use of the expired session.','line_number':1874,'multiline':False]['text':' Load the document version before update to be used as the change stream','line_number':1882,'multiline':False]['text':' pre-image since the update operation will load the new version of the','line_number':1883,'multiline':False]['text':' document.','line_number':1884,'multiline':False]['text':' We can't assume there was a problem when the collection is capped,','line_number':1897,'multiline':False]['text':' because the item may have been deleted by the cappedDeleter.  This','line_number':1898,'multiline':False]['text':' only matters for steady-state mode, because all errors on missing','line_number':1899,'multiline':False]['text':' updates are ignored at a higher level for recovery and initial sync.','line_number':1900,'multiline':False]['text':' was a simple { _id : ... } update criteria','line_number':1907,'multiline':False]['text':' Need to check to see if it isn't present so we can exit early with a','line_number':1915,'multiline':False]['text':' failure. Note that adds some overhead for this extra check in some','line_number':1916,'multiline':False]['text':' cases, such as an updateCriteria of the form { _id:..., { x :','line_number':1917,'multiline':False]['text':' {$size:...} } thus this is not ideal.','line_number':1918,'multiline':False]['text':' capped collections won't have an _id index','line_number':1922,'multiline':False]['text':' Otherwise, it's present; zero objects were updated because of','line_number':1932,'multiline':False]['text':' additional specifiers in the query for idempotence','line_number':1933,'multiline':False]['text':' this could happen benignly on an oplog duplicate replay of an upsert','line_number':1935,'multiline':False]['text':' (because we are idempotent), if a regular non-mod update fails the','line_number':1936,'multiline':False]['text':' item is (presumably) missing.','line_number':1937,'multiline':False]['text':' This indicates we upconverted an update to an upsert, and it did indeed','line_number':1948,'multiline':False]['text':' upsert.  In steady state mode this is unexpected.','line_number':1949,'multiline':False]['text':' status ','line_number':1958,'multiline':True]['text':' We shouldn't be doing upserts in secondary mode when enforcing steady','line_number':1960,'multiline':False]['text':' state constraints.','line_number':1961,'multiline':False]['text':' If we did not request an image because we're in','line_number':1971,'multiline':False]['text':' initial sync, the value passed in here is conveniently','line_number':1972,'multiline':False]['text':' the empty BSONObj.','line_number':1973,'multiline':False]['text':' A document version before update was loaded by the update operation.','line_number':1980,'multiline':False]['text':' Write a pre-image of a document for change streams.','line_number':1985,'multiline':False]['text':' The o field may contain additional fields besides the _id (like the shard key','line_number':2019,'multiline':False]['text':' fields), but we want to do the delete by just _id so we can take advantage of the','line_number':2020,'multiline':False]['text':' IDHACK.','line_number':2021,'multiline':False]['text':' Determine if a change stream pre-image has to be recorded for the oplog entry.','line_number':2029,'multiline':False]['text':' When in initial sync, we'll pass an empty image into','line_number':2044,'multiline':False]['text':' `writeToImageCollection`.','line_number':2045,'multiline':False]['text':' Request loading of the document version before delete operation to be','line_number':2050,'multiline':False]['text':' used as change stream pre-image.','line_number':2051,'multiline':False]['text':' Even if `result.nDeleted` is 0, we want to perform a write to the','line_number':2057,'multiline':False]['text':' imageCollection to advance the txnNumber/ts and invalidate the image.','line_number':2058,'multiline':False]['text':' This isn't strictly necessary for correctness -- the','line_number':2059,'multiline':False]['text':' `config.transactions` table is responsible for whether to retry. The','line_number':2060,'multiline':False]['text':' motivation here is to simply reduce the number of states related','line_number':2061,'multiline':False]['text':' documents in the two collections can be in.','line_number':2062,'multiline':False]['text':' It is legal for a delete operation on the pre-images collection to delete','line_number':2088,'multiline':False]['text':' zero documents - pre-image collections are not guaranteed to contain the same','line_number':2089,'multiline':False]['text':' set of documents at all times. The same holds for change-collections as they','line_number':2090,'multiline':False]['text':' both rely on unreplicated deletes when','line_number':2091,'multiline':False]['text':' "featureFlagUseUnreplicatedTruncatesForDeletions" is enabled.','line_number':2092,'multiline':False]['text':'','line_number':2093,'multiline':False]['text':' TODO SERVER-70591: Remove feature flag requirement in comment above.','line_number':2094,'multiline':False]['text':'','line_number':2095,'multiline':False]['text':' It is also legal for a delete operation on the config.image_collection (used','line_number':2096,'multiline':False]['text':' for find-and-modify retries) to delete zero documents.  Since we do not write','line_number':2097,'multiline':False]['text':' updates to this collection which are in the same batch as later deletes, a','line_number':2098,'multiline':False]['text':' rollback to the middle of a batch with both an update and a delete may result','line_number':2099,'multiline':False]['text':' in a missing document, which may be later deleted.','line_number':2100,'multiline':False]['text':' In FCV 4.4, each node is responsible for deleting the excess documents in','line_number':2104,'multiline':False]['text':' capped collections. This implies that capped deletes may not be','line_number':2105,'multiline':False]['text':' synchronized between nodes at times. When upgraded to FCV 5.0, the','line_number':2106,'multiline':False]['text':' primary will generate delete oplog entries for capped collections.','line_number':2107,'multiline':False]['text':' However, if any secondary was behind in deleting excess documents while','line_number':2108,'multiline':False]['text':' in FCV 4.4, the primary would have no way of knowing and it would delete','line_number':2109,'multiline':False]['text':' the first document it sees locally. Eventually, when secondaries step up','line_number':2110,'multiline':False]['text':' and start deleting capped documents, they will first delete previously','line_number':2111,'multiline':False]['text':' missed documents that may already be deleted on other nodes. For this','line_number':2112,'multiline':False]['text':' reason we skip returning NoSuchKey for capped collections when oplog','line_number':2113,'multiline':False]['text':' application is enforcing steady state constraints.','line_number':2114,'multiline':False]['text':' status ','line_number':2125,'multiline':True]['text':' status ','line_number':2134,'multiline':True]['text':' This error is fatal when we are enforcing steady state constraints','line_number':2138,'multiline':False]['text':' for non-capped collections.','line_number':2139,'multiline':False]['text':' Commands are processed in applyCommand_inlock().','line_number':2207,'multiline':False]['text':' Only commands are processed here.','line_number':2232,'multiline':False]['text':' Choose opCounters based on running on standalone/primary or secondary by checking','line_number':2235,'multiline':False]['text':' whether writes are replicated.','line_number':2236,'multiline':False]['text':' The feature compatibility version in the server configuration collection cannot change during','line_number':2255,'multiline':False]['text':' initial sync. We do not attempt to parse the allowlisted ops because they do not have a','line_number':2256,'multiline':False]['text':' collection namespace. If we drop the 'admin' database we will also log a 'drop' oplog entry','line_number':2257,'multiline':False]['text':' for each collection dropped. 'applyOps' and 'commitTransaction' will try to apply each','line_number':2258,'multiline':False]['text':' individual operation, and those will be caught then if they are a problem. 'abortTransaction'','line_number':2259,'multiline':False]['text':' won't ever change the server configuration collection.','line_number':2260,'multiline':False]['text':' Parse optime from oplog entry unless we are applying this command in standalone or on a','line_number':2279,'multiline':False]['text':' primary (replicated writes enabled).','line_number':2280,'multiline':False]['text':' We do not assign timestamps on replicated writes since they will get their oplog','line_number':2288,'multiline':False]['text':' timestamp once they are logged.','line_number':2289,'multiline':False]['text':' Don't assign commit timestamp for transaction commands.','line_number':2293,'multiline':False]['text':' Do not assign timestamps to non-replicated commands that have a wrapping','line_number':2303,'multiline':False]['text':' WriteUnitOfWork, as they will get the timestamp on that WUOW. Use cases include','line_number':2304,'multiline':False]['text':' secondary oplog application of prepared transactions.','line_number':2305,'multiline':False]['text':' The timestamps in the command oplog entries are always real timestamps from this','line_number':2312,'multiline':False]['text':' oplog and we should timestamp our writes with them.','line_number':2313,'multiline':False]['text':' Only assign timestamps on standalones during replication recovery when','line_number':2316,'multiline':False]['text':' started with 'recoverFromOplogAsStandalone'.','line_number':2317,'multiline':False]['text':' If 'writeTime' is not null, any writes in this scope will be given 'writeTime' as','line_number':2340,'multiline':False]['text':' their timestamp at commit.','line_number':2341,'multiline':False]['text':' Retriable error.','line_number':2345,'multiline':False]['text':' Aborting an index build involves writing to the catalog. This write needs to be','line_number':2356,'multiline':False]['text':' timestamped. It will be given 'writeTime' as the commit timestamp.','line_number':2357,'multiline':False]['text':' Aborting an index build involves writing to the catalog. This write needs to','line_number':2375,'multiline':False]['text':' be timestamped. It will be given 'writeTime' as the commit timestamp.','line_number':2376,'multiline':False]['text':' Even when enforcing steady state constraints, we must allow IndexNotFound as','line_number':2424,'multiline':False]['text':' an index may not have been built on a secondary when a command dropping it','line_number':2425,'multiline':False]['text':' comes in.','line_number':2426,'multiline':False]['text':'','line_number':2427,'multiline':False]['text':' We can never enforce constraints on "dropDatabase" because a database is an','line_number':2428,'multiline':False]['text':' ephemeral entity that can be created or destroyed (if no collections exist)','line_number':2429,'multiline':False]['text':' without an oplog entry.','line_number':2430,'multiline':False]['text':' namespace repl','line_number':2516,'multiline':False]['text':' namespace mongo','line_number':2517,'multiline':False]