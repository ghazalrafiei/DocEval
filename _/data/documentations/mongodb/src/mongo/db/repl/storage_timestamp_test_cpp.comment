['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "boost/container/detail/flat_tree.hpp"','line_number':33,'multiline':False]['text':' IWYU pragma: no_include "cxxabi.h"','line_number':41,'multiline':False]['text':' IWYU pragma: keep','line_number':44,'multiline':False]['text':' IWYU pragma: keep','line_number':162,'multiline':False]['text':' IWYU pragma: keep','line_number':169,'multiline':False]['text':' Make sure we haven't already locked this namespace. An AutoGetCollection already instantiated','line_number':199,'multiline':False]['text':' on this namespace would have a dangling Collection pointer after this function has run.','line_number':200,'multiline':False]['text':'*
 * RAII type for operating at a timestamp. Will remove any timestamping when the object destructs.
 ','line_number':265,'multiline':True]['text':' namespace','line_number':304,'multiline':False]['text':' Set up Timestamps in the past, present, and future.','line_number':333,'multiline':False]['text':' Set up mongod.','line_number':347,'multiline':False]['text':' Set up Timestamps in the past, present, and future.','line_number':354,'multiline':False]['text':' Without the const, the wrong addTicks overload is used.','line_number':359,'multiline':False]['text':' Since the Client object persists across tests, even though the global','line_number':391,'multiline':False]['text':' ReplicationCoordinator does not, we need to clear the last op associated with the client','line_number':392,'multiline':False]['text':' to avoid the invariant in ReplClientInfo::setLastOp that the optime only goes forward.','line_number':393,'multiline':False]['text':' These tests were developed prior to needing an index build entry collection. Use an','line_number':410,'multiline':False]['text':' unreplicated write block to avoid changing oplog state due to collection creation.','line_number':411,'multiline':False]['text':' Only creating new namespaces is supported. We restart the storage engine across all','line_number':444,'multiline':False]['text':' tests. If a test wants to remove data from existing collections, care must be taken','line_number':445,'multiline':False]['text':' to timestamp those deletes appropriately.','line_number':446,'multiline':False]['text':' Insert some documents.','line_number':462,'multiline':False]['text':' Build an index.','line_number':471,'multiline':False]['text':' Timestamping index completion. Primaries write an oplog entry.','line_number':492,'multiline':False]['text':' The timestamping repsponsibility is placed on the caller rather than the','line_number':501,'multiline':False]['text':' MultiIndexBlock.','line_number':502,'multiline':False]['text':' Print a stack trace to help disambiguate which `findOne` failed.','line_number':522,'multiline':False]['text':'*
     * Asserts that the given collection is in (or not in) the DurableCatalog's list of idents at
     * the
     * provided timestamp.
     ','line_number':674,'multiline':True]['text':' getCollectionIdent() returns the ident for the given namespace in the DurableCatalog.','line_number':685,'multiline':False]['text':' getAllIdents() actually looks in the RecordStore for a list of all idents, and is thus','line_number':686,'multiline':False]['text':' versioned by timestamp. We can expect a namespace to have a consistent ident across','line_number':687,'multiline':False]['text':' timestamps, provided the collection does not get renamed.','line_number':688,'multiline':False]['text':'*
     * Use `ts` = Timestamp::min to observe all indexes.
     ','line_number':703,'multiline':True]['text':'*
     * Use `ts` = Timestamp::min to observe all indexes.
     ','line_number':714,'multiline':True]['text':' Find the collection and index ident by performing a set difference on the original','line_number':722,'multiline':False]['text':' idents and the current idents.','line_number':723,'multiline':False]['text':' Find the collection and index ident by performing a set difference on the original','line_number':742,'multiline':False]['text':' idents and the current idents.','line_number':743,'multiline':False]['text':' Find the ident difference by performing a set difference on the original idents and the','line_number':760,'multiline':False]['text':' current idents.','line_number':761,'multiline':False]['text':' Find the collection and index ident difference.','line_number':775,'multiline':False]['text':' `system.profile` collections do not have an `_id` index.','line_number':780,'multiline':False]['text':' The idents are sorted, so the `collection-...` comes before `index-...`','line_number':784,'multiline':False]['text':'*
     * Note: expectedNewIndexIdents should include the _id index.
     ','line_number':791,'multiline':True]['text':' Find the collection and index ident difference.','line_number':799,'multiline':False]['text':' Index build test does not pass in a collection ident.','line_number':827,'multiline':False]['text':' `system.profile` does not have an `_id` index.','line_number':832,'multiline':False]['text':' Index build test does not pass in a collection ident.','line_number':844,'multiline':False]['text':' avoid global lock upgrade during applyOps.','line_number':909,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':911,'multiline':False]['text':' Create a new collection.','line_number':914,'multiline':False]['text':' In order for oplog application to assign timestamps, we must be in non-replicated mode','line_number':956,'multiline':False]['text':' and disable document validation.','line_number':957,'multiline':False]['text':' Create a new collection.','line_number':961,'multiline':False]['text':' Populate the "ts" field.','line_number':985,'multiline':False]['text':' Populate the "t" (term) field.','line_number':987,'multiline':False]['text':' Populate the "o" field.','line_number':989,'multiline':False]['text':' Populate the "wall" field','line_number':991,'multiline':False]['text':' Populate the other common fields.','line_number':993,'multiline':False]['text':' Insert ops to be applied.','line_number':995,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1017,'multiline':False]['text':' Create a new collection.','line_number':1020,'multiline':False]['text':' Insert some documents.','line_number':1027,'multiline':False]['text':' Delete all documents one at a time.','line_number':1041,'multiline':False]['text':' The first loop queries at `lastInsertTime` and should count all documents. Querying','line_number':1055,'multiline':False]['text':' at each successive tick counts one less document.','line_number':1056,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1063,'multiline':False]['text':' Create a new collection.','line_number':1066,'multiline':False]['text':' Insert one document that will go through a series of updates.','line_number':1073,'multiline':False]['text':' Each pair in the vector represents the update to perform at the next tick of the','line_number':1081,'multiline':False]['text':' clock. `pair.first` is the update to perform and `pair.second` is the full value of the','line_number':1082,'multiline':False]['text':' document after the transformation.','line_number':1083,'multiline':False]['text':' Querying at each successive ticks after `insertTime` sees the document transform in','line_number':1128,'multiline':False]['text':' the series.','line_number':1129,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1139,'multiline':False]['text':' Create a new collection.','line_number':1142,'multiline':False]['text':' This applyOps runs into an insert of `{_id: 0, field: 0}` followed by a second insert','line_number':1151,'multiline':False]['text':' on the same collection with `{_id: 0}`. It's expected for this second insert to be','line_number':1152,'multiline':False]['text':' turned into an upsert. The goal document does not contain `field: 0`.','line_number':1153,'multiline':False]['text':' Reading at `insertTime` should show the original document, `{_id: 0, field: 0}`.','line_number':1170,'multiline':False]['text':' Reading at `insertTime + 1` should show the second insert that got converted to an','line_number':1179,'multiline':False]['text':' upsert, `{_id: 0}`.','line_number':1180,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1190,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1219,'multiline':False]['text':' In order for applyOps to assign timestamps, we must be in non-replicated mode.','line_number':1268,'multiline':False]['text':' avoid global lock upgrade during applyOps.','line_number':1289,'multiline':False]['text':' The next logOp() call will get 'futureTs', which will be the timestamp at which we do','line_number':1370,'multiline':False]['text':' the write. Thus we expect the write to appear at 'futureTs' and not before.','line_number':1371,'multiline':False]['text':' Pretend to be a secondary.','line_number':1383,'multiline':False]['text':' task executor. not required for applyOplogBatch().','line_number':1427,'multiline':False]['text':' oplog buffer. not required for applyOplogBatch().','line_number':1428,'multiline':False]['text':' Pretend to be a secondary.','line_number':1449,'multiline':False]['text':' Use a capped collection to prevent the batch applier from grouping insert operations','line_number':1454,'multiline':False]['text':' together in the same WUOW. This test attempts to apply operations out of order, but the','line_number':1455,'multiline':False]['text':' storage engine does not allow an operation to set out-of-order timestamps in the same','line_number':1456,'multiline':False]['text':' WUOW.','line_number':1457,'multiline':False]['text':' Coerce oplog application to apply op2 before op1. This does not guarantee the actual','line_number':1494,'multiline':False]['text':' order of application however, because the oplog applier applies these operations in','line_number':1495,'multiline':False]['text':' parallel across several threads. The test accepts the possibility of a false negative','line_number':1496,'multiline':False]['text':' (test passes when it should fail) in favor of occasionally finding a true positive (test','line_number':1497,'multiline':False]['text':' fails as intended).','line_number':1498,'multiline':False]['text':' task executor. not required for applyOplogBatch().','line_number':1505,'multiline':False]['text':' oplog buffer. not required for applyOplogBatch().','line_number':1506,'multiline':False]['text':' Verify that, even though op2 was applied first, the multikey state is observed in all','line_number':1522,'multiline':False]['text':' WiredTiger transactions that can contain the data written by op1.','line_number':1523,'multiline':False]['text':' Oplog application conservatively uses the first optime in the batch, insertTime0, as','line_number':1531,'multiline':False]['text':' the point at which the index became multikey, despite the fact that the earliest op','line_number':1532,'multiline':False]['text':' which caused the index to become multikey did not occur until insertTime1. This works','line_number':1533,'multiline':False]['text':' because if we construct a query plan that incorrectly believes a particular path to','line_number':1534,'multiline':False]['text':' be multikey, the plan will still be correct (if possibly sub-optimal). Conversely, if','line_number':1535,'multiline':False]['text':' we were to construct a query plan that incorrectly believes a path is NOT multikey,','line_number':1536,'multiline':False]['text':' it could produce incorrect results.','line_number':1537,'multiline':False]['text':' Pretend to be a secondary.','line_number':1547,'multiline':False]['text':' Coerce oplog application to apply op2 before op1. This does not guarantee the actual','line_number':1587,'multiline':False]['text':' order of application however, because the oplog applier applies these operations in','line_number':1588,'multiline':False]['text':' parallel across several threads. The test accepts the possibility of a false negative','line_number':1589,'multiline':False]['text':' (test passes when it should fail) in favor of occasionally finding a true positive (test','line_number':1590,'multiline':False]['text':' fails as intended).','line_number':1591,'multiline':False]['text':' task executor. not required for applyOplogBatch().','line_number':1598,'multiline':False]['text':' oplog buffer. not required for applyOplogBatch().','line_number':1599,'multiline':False]['text':' Verify that, even though op2 was applied first, the multikey state is observed in all','line_number':1615,'multiline':False]['text':' WiredTiger transactions that can contain the data written by op1.','line_number':1616,'multiline':False]['text':' Oplog application conservatively uses the first optime in the batch, insertTime0, as','line_number':1624,'multiline':False]['text':' the point at which the index became multikey, despite the fact that the earliest op','line_number':1625,'multiline':False]['text':' which caused the index to become multikey did not occur until updateTime1. This works','line_number':1626,'multiline':False]['text':' because if we construct a query plan that incorrectly believes a particular path to','line_number':1627,'multiline':False]['text':' be multikey, the plan will still be correct (if possibly sub-optimal). Conversely, if','line_number':1628,'multiline':False]['text':' we were to construct a query plan that incorrectly believes a path is NOT multikey,','line_number':1629,'multiline':False]['text':' it could produce incorrect results.','line_number':1630,'multiline':False]['text':' Use an unreplicated collection.','line_number':1665,'multiline':False]['text':' This test does not run a real ReplicationCoordinator, so must advance the snapshot','line_number':1712,'multiline':False]['text':' manager manually.','line_number':1713,'multiline':False]['text':' Check out the session.','line_number':1733,'multiline':False]['text':' autocommit ','line_number':1740,'multiline':True]['text':' startTransaction ','line_number':1740,'multiline':True]['text':' Insert a document that will set the index as multikey.','line_number':1743,'multiline':False]['text':' Make sure the transaction committed and its writes were timestamped correctly.','line_number':1754,'multiline':False]['text':' Make sure the multikey write was timestamped correctly. For correctness, the timestamp of','line_number':1761,'multiline':False]['text':' the write that sets the multikey flag to true should be less than or equal to the first','line_number':1762,'multiline':False]['text':' write that made the index multikey, which, in this case, is the commit timestamp of the','line_number':1763,'multiline':False]['text':' transaction. In other words, it is not incorrect to assign a timestamp that is too early,','line_number':1764,'multiline':False]['text':' but it is incorrect to assign a timestamp that is too late. In this specific case, we','line_number':1765,'multiline':False]['text':' expect the write to be timestamped at the logical clock tick directly preceding the','line_number':1766,'multiline':False]['text':' commit time.','line_number':1767,'multiline':False]['text':' shouldBeMultikey ','line_number':1768,'multiline':True]['text':' shouldBeMultikey ','line_number':1769,'multiline':True]['text':' shouldBeMultikey ','line_number':1771,'multiline':True]['text':' shouldBeMultikey ','line_number':1772,'multiline':True]['text':' shouldBeMultikey ','line_number':1773,'multiline':True]['text':' appliedThrough opTime can be unset.','line_number':1839,'multiline':False]['text':'*
 * This KVDropDatabase test only exists in this file for historical reasons, the final phase of
 * timestamping `dropDatabase` side-effects no longer applies. The purpose of this test is to
 * exercise the `StorageEngine::dropDatabase` method.
 ','line_number':1844,'multiline':True]['text':' Not actually called.','line_number':1852,'multiline':False]['text':' Declare the database to be in a "synced" state, i.e: in steady-state replication.','line_number':1865,'multiline':False]['text':' This test drops collections piece-wise instead of having the "drop database" algorithm','line_number':1870,'multiline':False]['text':' perform this walk. Defensively operate on a separate DB from the other tests to ensure','line_number':1871,'multiline':False]['text':' no leftover collections carry-over.','line_number':1872,'multiline':False]['text':' `*.system.profile` does not have an `_id` index. Just create it to abide by the API. This','line_number':1881,'multiline':False]['text':' value will be the empty string. Helper methods accommodate this.','line_number':1882,'multiline':False]['text':' Save the pre-state idents so we can capture the specific idents related to collection','line_number':1888,'multiline':False]['text':' creation.','line_number':1889,'multiline':False]['text':' Non-replicated namespaces are wrapped in an unreplicated writes block. This has the','line_number':1893,'multiline':False]['text':' side-effect of not timestamping the collection creation.','line_number':1894,'multiline':False]['text':' Bind the local values to the variables in the parent scope.','line_number':1903,'multiline':False]['text':' Drop/rename `kvDropDatabase`. `system.profile` does not get dropped/renamed.','line_number':1911,'multiline':False]['text':' Reserve a tick, this represents a time after the rename in which the `kvDropDatabase`','line_number':1919,'multiline':False]['text':' ident for `kvDropDatabase` still exists.','line_number':1920,'multiline':False]['text':' If the storage engine is managing drops internally, the ident should not be visible after','line_number':1923,'multiline':False]['text':' a drop.','line_number':1924,'multiline':False]['text':' The namespace has changed, but the ident still exists as-is after the rename.','line_number':1928,'multiline':False]['text':' Assert that the idents do not exist.','line_number':1941,'multiline':False]['text':' dropDatabase must not timestamp the final write. The collection and index should seem','line_number':1946,'multiline':False]['text':' to have never existed.','line_number':1947,'multiline':False]['text':' Reset initial data timestamp to avoid unintended storage engine timestamp side effects.','line_number':1950,'multiline':False]['text':' Reconstruct the datafiles from scratch across tests.','line_number':1960,'multiline':False]['text':'*
 * This test asserts that the catalog updates that represent the beginning and end of an index
 * build are timestamped. Additionally, the index will be `multikey` and that catalog update that
 * finishes the index build will also observe the index is multikey.
 *
 * Primaries log no-ops when starting an index build to acquire a timestamp. A primary committing
 * an index build gets timestamped when the `createIndexes` command creates an oplog entry. That
 * step is mimiced here.
 *
 * Secondaries timestamp starting their index build by being in a `TimestampBlock` when the oplog
 * entry is processed. Secondaries will look at the logical clock when completing the index
 * build. This is safe so long as completion is not racing with secondary oplog application.
 ','line_number':1967,'multiline':True]['text':' Not actually called.','line_number':1983,'multiline':False]['text':' The MemberState is inspected during index builds to use a "ghost" write to timestamp','line_number':1990,'multiline':False]['text':' index completion.','line_number':1991,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2018,'multiline':False]['text':' creation.','line_number':2019,'multiline':False]['text':' Build an index on `{a: 1}`. This index will be multikey.','line_number':2022,'multiline':False]['text':' Primaries do not have a wrapping `TimestampBlock`; secondaries do.','line_number':2029,'multiline':False]['text':' Secondaries will also be in an `UnreplicatedWritesBlock` that prevents the `logOp`','line_number':2034,'multiline':False]['text':' from making creating an entry.','line_number':2035,'multiline':False]['text':' Inserting all the documents has the side-effect of setting internal state on the index','line_number':2054,'multiline':False]['text':' builder that the index is multikey.','line_number':2055,'multiline':False]['text':' All callers of `MultiIndexBlock::commit` are responsible for timestamping index','line_number':2061,'multiline':False]['text':' completion  Primaries write an oplog entry. Secondaries explicitly set a','line_number':2062,'multiline':False]['text':' timestamp.','line_number':2063,'multiline':False]['text':' The timestamping responsibility for each index is placed','line_number':2069,'multiline':False]['text':' on the caller.','line_number':2070,'multiline':False]['text':' Assert that the index entry exists after init and `ready: false`.','line_number':2091,'multiline':False]['text':' After the build completes, assert that the index is `ready: true` and multikey.','line_number':2101,'multiline':False]['text':' Reconstruct the datafiles from scratch across tests.','line_number':2124,'multiline':False]['text':' Create config.system.indexBuilds collection to store commit quorum value during index','line_number':2135,'multiline':False]['text':' building.','line_number':2136,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2162,'multiline':False]['text':' creation.','line_number':2163,'multiline':False]['text':' Ensure we have a committed snapshot to avoid ReadConcernMajorityNotAvailableYet','line_number':2166,'multiline':False]['text':' error at the beginning of the the collection scan phase.','line_number':2167,'multiline':False]['text':' Disable index build commit quorum as we don't have support of replication subsystem','line_number':2174,'multiline':False]['text':' for voting.','line_number':2175,'multiline':False]['text':' The idents are created and persisted with the "ready: false" write.','line_number':2204,'multiline':False]['text':' There should be two new index idents visible at this time.','line_number':2205,'multiline':False]['text':' Assert the `b_1` index becomes ready at the last oplog entry time.','line_number':2217,'multiline':False]['text':' Assert that the index build is removed from config.system.indexBuilds collection after','line_number':2225,'multiline':False]['text':' completion.','line_number':2226,'multiline':False]['text':' At the commitIndexBuild entry time, the index build be still be present in the','line_number':2231,'multiline':False]['text':' indexBuilds collection.','line_number':2232,'multiline':False]['text':' Fails if the collection is empty.','line_number':2235,'multiline':False]['text':' After the index build has finished, we should not see the doc in the indexBuilds','line_number':2239,'multiline':False]['text':' collection.','line_number':2240,'multiline':False]['text':' Ensure we have a committed snapshot to avoid ReadConcernMajorityNotAvailableYet','line_number':2266,'multiline':False]['text':' error at the beginning of the the collection scan phase.','line_number':2267,'multiline':False]['text':' Disable index build commit quorum as we don't have support of replication subsystem','line_number':2274,'multiline':False]['text':' for voting.','line_number':2275,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2293,'multiline':False]['text':' creation.','line_number':2294,'multiline':False]['text':' Rename collection.','line_number':2297,'multiline':False]['text':' Empty temporary collections generate createIndexes oplog entry even if the node','line_number':2308,'multiline':False]['text':' supports 2 phase index build.','line_number':2309,'multiline':False]['text':' We expect one new collection ident and one new index ident (the _id index) during this','line_number':2324,'multiline':False]['text':' rename.','line_number':2325,'multiline':False]['text':'expectedNewIndexIdents','line_number':2327,'multiline':True]['text':' We expect one new collection ident and three new index idents (including the _id index)','line_number':2329,'multiline':False]['text':' after this rename. The a_1 and b_1 index idents are created and persisted with the','line_number':2330,'multiline':False]['text':' "ready: true" write.','line_number':2331,'multiline':False]['text':'expectedNewIndexIdents','line_number':2333,'multiline':True]['text':' Assert the 'a_1' and `b_1` indexes becomes ready at the last oplog entry time.','line_number':2335,'multiline':False]['text':'*
 * This test asserts that the catalog updates that represent the beginning and end of an aborted
 * index build are timestamped. The oplog should contain two entries startIndexBuild and
 * abortIndexBuild. We will inspect the catalog at the timestamp corresponding to each of these
 * oplog entries.
 ','line_number':2347,'multiline':True]['text':' Create config.system.indexBuilds collection to store commit quorum value during index','line_number':2357,'multiline':False]['text':' building.','line_number':2358,'multiline':False]['text':' Insert two documents with the same value for field 'a' so that','line_number':2377,'multiline':False]['text':' we will fail to create a unique index.','line_number':2378,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2391,'multiline':False]['text':' creation.','line_number':2392,'multiline':False]['text':' Ensure we have a committed snapshot to avoid ReadConcernMajorityNotAvailableYet','line_number':2395,'multiline':False]['text':' error at the beginning of the the collection scan phase.','line_number':2396,'multiline':False]['text':' Disable index build commit quorum as we don't have support of replication subsystem','line_number':2402,'multiline':False]['text':' for voting.','line_number':2403,'multiline':False]['text':' Confirm that startIndexBuild and abortIndexBuild oplog entries have been written to the','line_number':2417,'multiline':False]['text':' oplog.','line_number':2418,'multiline':False]['text':' Check index state in catalog at oplog entry times for both startIndexBuild and','line_number':2430,'multiline':False]['text':' abortIndexBuild.','line_number':2431,'multiline':False]['text':' We expect one new one new index ident during this index build.','line_number':2435,'multiline':False]['text':'expectedNewIndexIdents','line_number':2437,'multiline':True]['text':' We expect all new idents to be removed after the index build has aborted.','line_number':2441,'multiline':False]['text':'expectedNewIndexIdents','line_number':2443,'multiline':True]['text':' Assert that the index build is removed from config.system.indexBuilds collection after','line_number':2446,'multiline':False]['text':' completion.','line_number':2447,'multiline':False]['text':' At the commitIndexBuild entry time, the index build be still be present in the','line_number':2452,'multiline':False]['text':' indexBuilds collection.','line_number':2453,'multiline':False]['text':' Fails if the collection is empty.','line_number':2456,'multiline':False]['text':' After the index build has finished, we should not see the doc in the indexBuilds','line_number':2460,'multiline':False]['text':' collection.','line_number':2461,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2491,'multiline':False]['text':' creation.','line_number':2492,'multiline':False]['text':' Create an index and get the ident for each index.','line_number':2497,'multiline':False]['text':' Timestamps at the completion of each index build.','line_number':2501,'multiline':False]['text':' Add the new ident to the vector and reset the current idents.','line_number':2504,'multiline':False]['text':' Ensure each index is visible at the correct timestamp, and not before.','line_number':2509,'multiline':False]['text':' Drop all of the indexes.','line_number':2519,'multiline':False]['text':' Assert that each index is dropped individually and with its own timestamp. The order of','line_number':2522,'multiline':False]['text':' dropping and creating are not guaranteed to be the same, but assert all of the created','line_number':2523,'multiline':False]['text':' indexes were also dropped.','line_number':2524,'multiline':False]['text':' Save the pre-state idents so we can capture the specific ident related to index','line_number':2563,'multiline':False]['text':' creation.','line_number':2564,'multiline':False]['text':' Create an index and get the ident for each index.','line_number':2569,'multiline':False]['text':' Timestamps at the completion of each index build.','line_number':2573,'multiline':False]['text':' Add the new ident to the vector and reset the current idents.','line_number':2576,'multiline':False]['text':' Ensure each index is visible at the correct timestamp, and not before.','line_number':2581,'multiline':False]['text':' Drop all of the indexes.','line_number':2591,'multiline':False]['text':' Assert that each index is dropped individually and with its own timestamp. The order of','line_number':2594,'multiline':False]['text':' dropping and creating are not guaranteed to be the same, but assert all of the created','line_number':2595,'multiline':False]['text':' indexes were also dropped.','line_number':2596,'multiline':False]['text':' Indexing of parallel arrays is not allowed, so these are deemed "bad".','line_number':2622,'multiline':False]['text':' NOTE: This test does not test any timestamp reads.','line_number':2627,'multiline':False]['text':' Provide a build UUID, indicating that this is a two-phase index build.','line_number':2651,'multiline':False]['text':' First, simulate being a secondary. Indexing errors are ignored.','line_number':2657,'multiline':False]['text':' There should be one skipped record from the collection scan.','line_number':2688,'multiline':False]['text':' As a primary, stop ignoring indexing errors.','line_number':2694,'multiline':False]['text':' This write will not succeed because the node is a primary and the document is not','line_number':2698,'multiline':False]['text':' indexable.','line_number':2699,'multiline':False]['text':' opDebug ','line_number':2707,'multiline':True]['text':' noWarn ','line_number':2708,'multiline':True]['text':' There should skipped records from failed collection scans and writes.','line_number':2714,'multiline':False]['text':' This fails because the bad record is still invalid.','line_number':2718,'multiline':False]['text':' Update one documents to be valid, and delete the other. These modifications are written','line_number':2727,'multiline':False]['text':' to the side writes table and must be drained.','line_number':2728,'multiline':False]['text':' This succeeds because the bad documents are now either valid or removed.','line_number':2747,'multiline':False]['text':'*
 * This test exercises the code path in which a primary performs an index build via oplog
 * application of a createIndexes oplog entry. In this code path, a primary timestamps the
 * index build through applying the oplog entry, rather than creating an oplog entry.
 ','line_number':2770,'multiline':True]['text':' Index builds expect a non-empty oplog and a valid committed snapshot.','line_number':2776,'multiline':False]['text':' In order for oplog application to assign timestamps, we must be in non-replicated mode','line_number':2790,'multiline':False]['text':' and disable document validation.','line_number':2791,'multiline':False]['text':' Create the collection and insert a document.','line_number':2804,'multiline':False]['text':' Sanity check everything exists.','line_number':2816,'multiline':False]['text':' Simulate a scenario where the node is a primary, but does not accept writes. This is','line_number':2825,'multiline':False]['text':' the only scenario in which a primary can do an index build via oplog application, since','line_number':2826,'multiline':False]['text':' the applyOps command no longer allows createIndexes (see SERVER-41554).','line_number':2827,'multiline':False]['text':' Grab the existing idents to identify the ident created by the index build.','line_number':2833,'multiline':False]['text':' Wait for the index build thread to start the collection scan before proceeding with','line_number':2846,'multiline':False]['text':' checking the catalog and applying the commitIndexBuild oplog entry.','line_number':2847,'multiline':False]['text':' There is a potential race between applying the commitIndexBuild oplog entry and the','line_number':2848,'multiline':False]['text':' transitioning the index build thread's ReplIndexBuildState from kSetup to','line_number':2849,'multiline':False]['text':' kInProgress. This is due to the commit retry logic using the ClockSourceMock, rather','line_number':2850,'multiline':False]['text':' than an actual  system clock that advances automatically, through OperationContext's','line_number':2851,'multiline':False]['text':' waitFor() function.','line_number':2852,'multiline':False]['text':' We cannot use the OperationContext to wait for the thread to reach the fail point','line_number':2865,'multiline':False]['text':' because it also uses the ClockSourceMock.','line_number':2866,'multiline':False]['text':' The index has not committed yet, so it is not ready.','line_number':2879,'multiline':False]['text':' release read lock so commit index build oplog entry can take its own locks.','line_number':2884,'multiline':False]['text':' Reacquire read lock to check index metadata.','line_number':2894,'multiline':False]['text':' The logOp() call for createCollection should have timestamp 'futureTs', which will also','line_number':2977,'multiline':False]['text':' be the timestamp at which we do the write which creates the collection. Thus we expect','line_number':2978,'multiline':False]['text':' the collection to appear at 'futureTs' and not before.','line_number':2979,'multiline':False]['text':' The index build emits three oplog entries.','line_number':2982,'multiline':False]['text':' Empty collections generate createIndexes oplog entry even if the node','line_number':2986,'multiline':False]['text':' supports 2 phase index build.','line_number':2987,'multiline':False]['text':' This is the timestamp of the startIndexBuild oplog entry, which is timestamped before the','line_number':3015,'multiline':False]['text':' index is created as part of the createIndexes oplog entry.','line_number':3016,'multiline':False]['text':' Create config.system.indexBuilds collection to store commit quorum value during index','line_number':3030,'multiline':False]['text':' building.','line_number':3031,'multiline':False]['text':' Disable index build commit quorum as we don't have support of replication subsystem for','line_number':3061,'multiline':False]['text':' voting.','line_number':3062,'multiline':False]['text':' By virtue of not crashing due to WT observing an out of order write, this test has','line_number':3093,'multiline':False]['text':' succeeded. For completeness, check the index metadata.','line_number':3094,'multiline':False]['text':' This test does not run a real ReplicationCoordinator, so must advance the snapshot','line_number':3134,'multiline':False]['text':' manager manually.','line_number':3135,'multiline':False]['text':' Start a retryable write.','line_number':3161,'multiline':False]['text':' autocommit ','line_number':3163,'multiline':True]['text':' startTransaction ','line_number':3163,'multiline':True]['text':' indexesAffected ','line_number':3201,'multiline':True]['text':' opDebug ','line_number':3202,'multiline':True]['text':' There should be no oplog entry at 'beforeOplogTs'.','line_number':3207,'multiline':False]['text':' Create a new document representing BSONObj with the above contents.','line_number':3223,'multiline':False]['text':' Enable in-place mutation for this document','line_number':3231,'multiline':False]['text':' indexesAffected ','line_number':3259,'multiline':True]['text':' opDebug ','line_number':3260,'multiline':True]['text':' There should be no oplog entry at 'beforeOplogTs'.','line_number':3266,'multiline':False]['text':' There should be no oplog entry at 'beforeOplogTs'.','line_number':3304,'multiline':False]['text':' This test does not run a real ReplicationCoordinator, so must advance the snapshot','line_number':3342,'multiline':False]['text':' manager manually.','line_number':3343,'multiline':False]['text':' autocommit ','line_number':3361,'multiline':True]['text':' startTransaction ','line_number':3361,'multiline':True]['text':' Including this class in a test fixture forces transactions to use one oplog entry per operation','line_number':3447,'multiline':False]['text':' instead of packing them into as few oplog entries as fit.  This allows testing of the timestamps','line_number':3448,'multiline':False]['text':' of multi-oplog-entry transactions.','line_number':3449,'multiline':False]['text':' Collection should be empty until commit, at which point both documents','line_number':3493,'multiline':False]['text':' should show up.','line_number':3494,'multiline':False]['text':' Implicit commit oplog entry should exist at commitEntryTs.','line_number':3503,'multiline':False]['text':' Check that the oldestActiveTxnTimestamp properly accounts for in-progress','line_number':3518,'multiline':False]['text':' transactions.','line_number':3519,'multiline':False]['text':' first oplog entry should exist at firstOplogEntryTs and after it.','line_number':3526,'multiline':False]['text':' Session state should go to inProgress at firstOplogEntryTs, then to committed','line_number':3541,'multiline':False]['text':' at commitEntryTs','line_number':3542,'multiline':False]['text':' Perform the following while ignoring prepare conflicts. These calls would','line_number':3629,'multiline':False]['text':' otherwise wait forever until the prepared transaction committed or aborted.','line_number':3630,'multiline':False]['text':' We haven't committed the prepared transaction','line_number':3643,'multiline':False]['text':' The transaction has not been committed yet and is still considered active.','line_number':3655,'multiline':False]['text':' The prepare oplog entry should exist at prepareEntryTs and onwards.','line_number':3680,'multiline':False]['text':' The commit oplog entry should exist at commitEntryTs and onwards.','line_number':3687,'multiline':False]['text':' The first oplog entry should exist at firstOplogEntryTs and onwards.','line_number':3694,'multiline':False]['text':' The prepare oplog entry should exist at prepareEntryTs and onwards.','line_number':3709,'multiline':False]['text':' The transaction is no longer considered active after being committed.','line_number':3729,'multiline':False]['text':' The session state should go to inProgress at firstOplogEntryTs, then to prepared at','line_number':3733,'multiline':False]['text':' prepareEntryTs, and then finally to committed at commitEntryTs.','line_number':3734,'multiline':False]['text':' The prepare oplog entry should exist at prepareEntryTs and onwards.','line_number':3799,'multiline':False]['text':' The abort oplog entry should exist at abortEntryTs and onwards.','line_number':3806,'multiline':False]['text':' The prepare oplog entry should exist at firstOplogEntryTs and onwards.','line_number':3820,'multiline':False]['text':' The session state should be "aborted" at abortEntryTs.','line_number':3839,'multiline':False]['text':' namespace mongo','line_number':4035,'multiline':False]