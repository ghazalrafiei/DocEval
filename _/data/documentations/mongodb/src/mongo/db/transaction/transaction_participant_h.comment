['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':'*
 * Reason a transaction was terminated.
 ','line_number':90,'multiline':True]['text':'*
 * This class maintains the state of a transaction running on a server session. It can only exist as
 * a decoration on the Session object and its state can only be modified by the thread which has the
 * session checked-out.
 *
 * Its methods are split in two groups with distinct read/write and concurrency control rules. See
 * the comments below for more information.
 ','line_number':98,'multiline':True]['text':'*
     * Indicates the state of the current multi-document transaction, if any. If the transaction is
     * in any state but kInProgress, no more operations can be collected. Once the transaction is in
     * kPrepared, the transaction is not allowed to abort outside of an 'abortTransaction' command.
     * At this point, aborting the transaction must log an 'abortTransaction' oplog entry.
     ','line_number':110,'multiline':True]['text':'*
         * Transitions the session from the current state to the new state. If transition validation
         * is not relaxed, invariants if the transition is illegal.
         ','line_number':133,'multiline':True]['text':' An optional promise that is non-none while the participant is in prepare. The promise is','line_number':184,'multiline':False]['text':' fulfilled and the optional is reset when the participant transitions out of prepare.','line_number':185,'multiline':False]['text':' An optional promise that is non-none while the participant is in progress or in prepare.','line_number':188,'multiline':False]['text':' The promise is fulfilled and the optional is reset when the participant commits or','line_number':189,'multiline':False]['text':' aborts.','line_number':190,'multiline':False]['text':' Private because any modifications should go through transitionTo.','line_number':196,'multiline':False]['text':' class TransactionState','line_number':198,'multiline':False]['text':'*
     * Holds state for a snapshot read or multi-statement transaction in between network
     * operations.
     ','line_number':210,'multiline':True]['text':'*
         * Stashes transaction state from 'opCtx' in the newly constructed TxnResources.
         * Caller must hold the Client lock associated with opCtx, attested by WithLock.
         ','line_number':218,'multiline':True]['text':' Rule of 5: because we have a class-defined destructor, we need to explicitly specify','line_number':225,'multiline':False]['text':' the move operator and move assignment operator.','line_number':226,'multiline':False]['text':'*
         * Returns a pointer to the stashed lock state, or nullptr if no stashed locks exist.
         ','line_number':230,'multiline':True]['text':'*
         * Releases stashed transaction state onto 'opCtx'. Must only be called once.
         * Ephemerally holds the Client lock associated with opCtx.
         ','line_number':241,'multiline':True]['text':'*
         * Returns the stored API parameters.
         ','line_number':247,'multiline':True]['text':'*
         * Returns the read concern arguments.
         ','line_number':254,'multiline':True]['text':' class TxnResources','line_number':271,'multiline':False]['text':'*
     *  An RAII object that will allow the current transaction to be set aside so that a separate
     *  transaction can be created. It stashes the recovery unit from the `opCtx` onto the stack and
     *  keeps using the same locker of `opCtx`. The locker opts out of two-phase locking of the
     *  current WUOW. At destruction the original transaction will be restored by unstashing the
     *  recovery unit back onto the `opCtx` and restoring the locker state relevant to the original
     *  WUOW.
     ','line_number':273,'multiline':True]['text':' class SideTransactionBlock','line_number':291,'multiline':False]['text':'*
     * Class used by observers to examine the state of a TransactionParticipant.
     ','line_number':297,'multiline':True]['text':'*
         * Returns an object containing the currently active transaction number and
         * transaction retry counter on this participant.
         ','line_number':304,'multiline':True]['text':'*
         * Returns the op time of the last committed write for this session and transaction. If no
         * write has completed yet, returns an empty timestamp.
         ','line_number':312,'multiline':True]['text':'*
         * Returns the prepare op time that was selected for the transaction, which can be Null if
         * the transaction is not prepared.
         ','line_number':320,'multiline':True]['text':'*
         * Returns whether the transaction has exceeded its expiration time.
         ','line_number':328,'multiline':True]['text':'*
         * Returns if this TransactionParticipant instance can be reaped. Always true unless there
         * is an open transaction on this session.
         ','line_number':333,'multiline':True]['text':'*
         * Returns whether we are in an open multi-document transaction, which means we have an
         * active transaction which has autocommit:false and has not been committed or aborted. It
         * is possible that the current transaction is stashed onto the stack via a
         * `SideTransactionBlock`.
         ','line_number':341,'multiline':True]['text':'*
         * If this session is holding stashed locks in txnResourceStash, reports the current state
         * of the session using the provided builder.
         ','line_number':379,'multiline':True]['text':'*
         * If this session is not holding stashed locks in txnResourceStash (transaction is active),
         * reports the current state of the session using the provided builder.
         *
         * The Client lock for the given OperationContext must be held when calling this method.
         ','line_number':386,'multiline':True]['text':'*
         * Returns the transaction number associated with the client operation that spawned this
         * transaction. ie the top-level txnNumber for a retryable write or client transaction or
         * the txnNumber in the session id for a retryable transaction. The passed in
         * txnNumberAndRetryCounter should be the active txnNumberAndRetryCounter of this
         * participant. This must be provided so this method can be used before the participant's
         * active txnNumberAndRetryCounter has been changed.
         ','line_number':394,'multiline':True]['text':'*
         * If this participant is currently running a retryable write, returns its transaction
         * number. Otherwise, returns none. That is:
         * - For an internal session for non-retryable write, always returns boost::none.
         * - For an internal session for retryable write, returns the transaction
         *   number in the session id.
         * - Otherwise, returns the active transaction number if it corresponds to a retryable
         *   write.
         ','line_number':420,'multiline':True]['text':' Reports transaction stats for both active and inactive transactions using the provided','line_number':431,'multiline':False]['text':' builder.','line_number':432,'multiline':False]['text':' class Observer','line_number':438,'multiline':False]['text':'*
     * Class used by a thread that has checked out the TransactionParticipant's session to observe
     * and modify the transaction participant.
     ','line_number':440,'multiline':True]['text':' Indicates whether the future lock requests should have timeouts.','line_number':446,'multiline':False]['text':' Indicates whether we should opt out of the ticket mechanism.','line_number':448,'multiline':False]['text':'*
         * Returns a Participant constructed with the TransactionParticipant for the session
         * checked out by the given 'opCtx', if there is one.
         ','line_number':451,'multiline':True]['text':'*
         * Asserts that the given 'opCtx' has either checked out the given session or its parent
         * session and returns a Participant constructed with the TransactionParticipant for the
         * given session.
         ','line_number':457,'multiline':True]['text':'*
         * Returns a Participant constructed with the TransactionParticipant for the given session
         * to kill.
         ','line_number':464,'multiline':True]['text':'
         * Blocking method, which loads the transaction state from storage if it has been marked as
         * needing refresh.
         *
         * In order to avoid the possibility of deadlock, this method must not be called while
         * holding a lock.
         ','line_number':474,'multiline':True]['text':'
         * Same as above, but does not retrieve full transaction history and should be called
         * only when oplog reads are not possible.
         ','line_number':483,'multiline':True]['text':'*
         * Starts a new transaction (and if the txnNumber is newer aborts any in-progress
         * transaction on the session), or continues an already active transaction.
         *
         * 'autocommit' comes from the 'autocommit' field in the original client request. The only
         * valid values are boost::none (meaning no autocommit was specified) and false (meaning
         * that this is the beginning of a multi-statement transaction).
         *
         * 'startTransaction' comes from the 'startTransaction' field in the original client
         * request. See below for the acceptable values and the meaning of the combinations of
         * autocommit, startTransaction and txnRetryCounter.
         *
         * autocommit = boost::none, startTransaction = boost::none and txnRetryCounter =
         * boost::none means retryable write.
         *
         * autocommit = false, startTransaction = boost::none and txnRetryCounter = last seen
         * txnRetryCounter means continuation of a multi-statement transaction.
         *
         * autocommit = false, startTransaction = true, txnNumber = active txnNumber and
         * txnRetryCounter > last seen txnRetryCounter (defaults to 0) means restart the existing
         * transaction as long as it has not been committed or prepared.
         *
         * autocommit = false, startTransaction = true, txnNumber > active txnNumber means abort
         * whatever transaction is in progress on the session and starts a new transaction.
         *
         * Any combination other than the ones listed above will invariant since it is expected that
         * the caller has performed the necessary customer input validations.
         *
         * Exceptions of note, which can be thrown are:
         *   - TransactionTooOld - if an attempt is made to start a transaction older than the
         * currently active one or the last one which committed
         *   - TxnRetryCounterTooOld - if an attempt is made to start or continue a transaction with
         * a txnRetryCounter less than the last seen one.
         *   - IllegalOperation - if an attempt is made to use a txnRetryCounter greater than the
         * last seen one to continue a transaction, or to restart a transaction that has already
         * been committed or prepared.
         *   - PreparedTransactionInProgress - if the transaction is in the prepared state and a new
         * transaction or retryable write is attempted
         *   - NotWritablePrimary - if the node is not a primary when this method is called.
         *   - IncompleteTransactionHistory - if an attempt is made to begin a retryable write for a
         * TransactionParticipant that is not in retryable write mode. This is expected behavior if
         * a retryable write has been upgraded to a transaction by the server, which can happen e.g.
         * when updating the shard key.
         ','line_number':489,'multiline':True]['text':'*
         * Used only by the secondary oplog application logic. Similar to 'beginOrContinue' without
         * performing any checks for whether the new txnNumber will start a transaction number in
         * the past.
         ','line_number':538,'multiline':True]['text':'*
         * If the participant is in prepare, returns a future whose promise is fulfilled when
         * the participant transitions out of prepare.
         *
         * If the participant is not in prepare, returns an immediately ready future.
         *
         * The caller should not wait on the future with the session checked out, since that
         * will prevent the promise from being able to be fulfilled, i.e., will cause a
         * deadlock.
         ','line_number':546,'multiline':True]['text':'*
         * If the participant is in progress or in prepare, returns a future whose promise is
         * fulfilled when the participant commits or aborts.
         *
         * If the participant is not in progress or in prepare, returns an immediately ready future.
         *
         * The caller should not wait on the future with the session checked out, since that
         * will prevent the promise from being able to be fulfilled, i.e., will cause a
         * deadlock.
         ','line_number':558,'multiline':True]['text':'*
         * If there is an open retryable internal transaction (i.e. one that is in progress or
         * prepare) on any internal session associated with this session, returns a future whose
         * promise is fulfilled when the transaction commits or aborts. See the header comment for
         * RetryableWriteTransactionParticipantCatalog for the definition of such sessions.
         *
         * If there is none, returns an immediately ready future.
         *
         * The caller should not wait on the future with the session checked out, since that
         * will prevent the promise from being able to be fulfilled, i.e., will cause a
         * deadlock.
         ','line_number':570,'multiline':True]['text':'*
         * Transfers management of transaction resources from the currently checked-out
         * OperationContext to the Session.
         ','line_number':585,'multiline':True]['text':'*
         * Transfers management of transaction resources from the Session to the currently
         * checked-out OperationContext.
         ','line_number':591,'multiline':True]['text':'*
         * Puts a transaction into a prepared state and returns the prepareTimestamp and the list of
         * affected namespaces.
         *
         * On secondary, the "prepareTimestamp" will be given in the oplog.
         ','line_number':597,'multiline':True]['text':'*
         * Sets the prepare optime used for recovery.
         ','line_number':606,'multiline':True]['text':'*
         * Gets the prepare optime used for recovery. Returns a null optime if unset.
         ','line_number':611,'multiline':True]['text':'*
         * Commits the transaction, including committing the write unit of work and updating
         * transaction state.
         *
         * Throws an exception if the transaction is prepared.
         ','line_number':616,'multiline':True]['text':'*
         * Commits the transaction, including committing the write unit of work and updating
         * transaction state.
         *
         * On a secondary, the "commitOplogEntryOpTime" will be the OpTime of the commitTransaction
         * oplog entry.
         *
         * Throws an exception if the transaction is not prepared or if the 'commitTimestamp' is
         * null.
         ','line_number':624,'multiline':True]['text':'
         * Aborts the transaction, releasing transaction resources.
         ','line_number':638,'multiline':True]['text':'*
         * Adds a stored operation to the list of stored operations for the current multi-document
         * (non-autocommit) transaction.  It is illegal to add operations when no multi-document
         * transaction is in progress.
         ','line_number':643,'multiline':True]['text':'*
         * Returns a reference to the stored operations for a completed multi-document
         * (non-autocommit) transaction. "Completed" implies that no more operations will be added
         * to the transaction.  It is legal to call this method only when the transaction state is
         * in progress or committed.
         ','line_number':650,'multiline':True]['text':'*
         * Returns an object containing transaction-related metadata to append on responses.
         ','line_number':658,'multiline':True]['text':'*
         * Clears the stored operations for an multi-document (non-autocommit) transaction, marking
         * the transaction as closed.  It is illegal to attempt to add operations to the transaction
         * after this is called.
         ','line_number':663,'multiline':True]['text':'*
         * Yield or reacquire locks for prepared transactions, used on replication state transition.
         ','line_number':670,'multiline':True]['text':'*
         * Called after a write under the specified transaction completes while the node is a
         * primary and specifies the statement ids which were written. Must be called while the
         * caller is still in the write's WUOW. Updates the on-disk state of the session to match
         * the specified transaction/opTime and keeps the cached state in sync.
         *
         * 'txnState' is 'none' for retryable writes.
         *
         * Throws if the session has been invalidated or the active transaction number doesn't
         * match.
         ','line_number':675,'multiline':True]['text':'*
         * Called after an entry for the specified session and transaction has been written to the
         * oplog during chunk migration, while the node is still primary. Must be called while the
         * caller is still in the oplog write's WUOW. Updates the on-disk state of the session to
         * match the specified transaction/opTime and keeps the cached state in sync.
         *
         * Throws if the session has been invalidated or the active transaction number is newer than
         * the one specified.
         ','line_number':690,'multiline':True]['text':'*
         * Checks whether the given statementId for the specified transaction has already executed
         * in any external or internal sessions associated with this session (see the header comment
         * for RetryableWriteTransactionParticipantCatalog for the definitions of these sessions)
         * and if so, returns the oplog entry which was generated by that write. If the statementId
         * hasn't executed, returns boost::none.
         *
         * Throws if this session or any of its associated sessions has been invalidated or the
         * active transaction number doesn't match.
         ','line_number':707,'multiline':True]['text':'*
         * Same as above, but returns true if the given statementId has executed without fetching
         * the oplog entry which was generated by that write.
         ','line_number':720,'multiline':True]['text':'*
         * Marks the session as requiring refresh. Used when the session state has been modified
         * externally, such as through a direct write to the transactions table.
         ','line_number':726,'multiline':True]['text':'*
         * Kills the transaction if it is running, ensuring that it releases all resources, even if
         * the transaction is in prepare().  Avoids writing any oplog entries or making any changes
         * to the transaction table.  State for prepared transactions will be re-constituted at
         * startup.  Note that we don't take any active steps to prevent continued use of this
         * TransactionParticipant after shutdown() is called, but we rely on callers to not continue
         * using the TransactionParticipant once we are in shutdown.
         ','line_number':732,'multiline':True]['text':'*
         * Returns the API parameters stored in the transaction resources stash if it exists and we
         * are not in a retryable write. Otherwise, returns the API parameters decorating the opCtx.
         ','line_number':742,'multiline':True]['text':'*
         * Locks and sets "lastWriteOpTime". The function should only advance the "lastWriteOpTime"
         * with the only exception of reseting it to null timestamp if the storage transaction is
         * aborted.
         ','line_number':748,'multiline':True]['text':'','line_number':755,'multiline':False]['text':' Methods for use in C++ unit tests, only. Beware: these methods may not adhere to the','line_number':756,'multiline':False]['text':' concurrency control rules.','line_number':757,'multiline':False]['text':'','line_number':758,'multiline':False]['text':'*
         * Used by secondary oplog application for prepared transactions or unit tests to directly
         * add the statement ids that were written.
         ','line_number':826,'multiline':True]['text':'*
         * Handles a WouldChangeOwningShard error based on whether the operation that triggered it
         * was a retryable write or in a retryable transaction.
         ','line_number':834,'multiline':True]['text':' Checks whether the given statementId for the specified transaction has already executed','line_number':843,'multiline':False]['text':' in any external or internal sessions associated with this session (see the header comment','line_number':844,'multiline':False]['text':' for RetryableWriteTransactionParticipantCatalog for the definitions of these sessions).','line_number':845,'multiline':False]['text':' If so, returns the opTime for the oplog entry that was generated by that write. If the','line_number':846,'multiline':False]['text':' statementId hasn't executed, returns boost::none.','line_number':847,'multiline':False]['text':'','line_number':848,'multiline':False]['text':' Throws if the session has been invalidated or the active transaction number doesn't','line_number':849,'multiline':False]['text':' match.','line_number':850,'multiline':False]['text':' Same as above, but only checks if the specified transaction has already executed in this','line_number':854,'multiline':False]['text':' sessions.','line_number':855,'multiline':False]['text':' Chooses a snapshot from which a new transaction will read by beginning a storage','line_number':864,'multiline':False]['text':' transaction. This is chosen based on the read concern arguments. If an atClusterTime is','line_number':865,'multiline':False]['text':' provided, it is up to the caller to ensure that timestamp is greater than or equal to the','line_number':866,'multiline':False]['text':' all-committed timestamp before calling this method (e.g. by calling','line_number':867,'multiline':False]['text':' ReplCoordinator::waitForOpTimeForRead).','line_number':868,'multiline':False]['text':' Finishes committing the multi-document transaction after the storage-transaction has been','line_number':871,'multiline':False]['text':' committed, the oplog entry has been inserted into the oplog, and the transactions table','line_number':872,'multiline':False]['text':' has been updated.','line_number':873,'multiline':False]['text':' Commits the storage-transaction on the OperationContext.','line_number':878,'multiline':False]['text':'','line_number':879,'multiline':False]['text':' This should be called *without* the Client being locked.','line_number':880,'multiline':False]['text':' Commits a "split prepared" transaction. Prepared transactions processed on secondaries','line_number':883,'multiline':False]['text':' may split the storage writes into multiple RecoveryUnits. This method will be invoked by','line_number':884,'multiline':False]['text':' a primary such that it looks for all recovery units and commits them such that they','line_number':885,'multiline':False]['text':' become visible to snapshot/timestamped readers atomically.','line_number':886,'multiline':False]['text':'','line_number':887,'multiline':False]['text':' This must be called while an OplogSlot is being held open at or earlier than the input','line_number':888,'multiline':False]['text':' `durableTimestamp`.','line_number':889,'multiline':False]['text':' Stash transaction resources.','line_number':895,'multiline':False]['text':' Abort the transaction if it's in one of the expected states and clean up the transaction','line_number':898,'multiline':False]['text':' states associated with the opCtx.  Write an abort oplog entry if specified by the','line_number':899,'multiline':False]['text':' needToWriteAbortEntry state bool.','line_number':900,'multiline':False]['text':' Aborts a "split prepared" transaction. Prepared transactions processed on secondaries may','line_number':904,'multiline':False]['text':' split the storage writes into multiple RecoveryUnits. This method will be invoked by a','line_number':905,'multiline':False]['text':' primary such that it looks for all recovery units and aborts them.','line_number':906,'multiline':False]['text':' Factors out code for clarity from _abortActiveTransaction.','line_number':911,'multiline':False]['text':' Aborts a prepared transaction.','line_number':915,'multiline':False]['text':' Releases stashed transaction resources to abort the transaction on the session.','line_number':918,'multiline':False]['text':' Clean up the transaction resources unstashed on operation context.','line_number':921,'multiline':False]['text':' Checks if the command can be run on this transaction based on the state of the','line_number':926,'multiline':False]['text':' transaction.','line_number':927,'multiline':False]['text':' Logs the transaction information if it has run slower than the global parameter slowMS.','line_number':932,'multiline':False]['text':' The transaction must be committed or aborted when this function is called.','line_number':933,'multiline':False]['text':' This method returns a string with information about a slow transaction. The format of the','line_number':940,'multiline':False]['text':' logging string produced should match the format used for slow operation logging. A','line_number':941,'multiline':False]['text':' transaction must be completed (committed or aborted) and a valid LockStats reference must','line_number':942,'multiline':False]['text':' be passed in order for this method to be called.','line_number':943,'multiline':False]['text':' Bumps up the transaction number and transaction retry counter of this transaction and','line_number':963,'multiline':False]['text':' performs the necessary cleanup.','line_number':964,'multiline':False]['text':' Asserts that there is no open retryable internal transaction (i.e. one that is in','line_number':968,'multiline':False]['text':' progress or in prepare) on any internal session associated with this session. See the','line_number':969,'multiline':False]['text':' header comment for RetryableWriteTransactionParticipantCatalog for the definition of','line_number':970,'multiline':False]['text':' such sessions.','line_number':971,'multiline':False]['text':' Asserts that the active transaction number can be reused. Below are the two cases where','line_number':975,'multiline':False]['text':' an active transaction number is allowed to be reused:','line_number':976,'multiline':False]['text':' 1. The transaction participant is in transaction mode and the transaction has been','line_number':977,'multiline':False]['text':'    aborted and not been involved in a two phase commit. This corresponds to the case','line_number':978,'multiline':False]['text':'    where a transaction is internally retried after failing with a transient error such a','line_number':979,'multiline':False]['text':'    stale config or snapshot too old or view resolution error.','line_number':980,'multiline':False]['text':' 2. The transaction participant is in retryable write mode and has not yet executed a','line_number':981,'multiline':False]['text':'    retryable write. This corresponds to the case where a retryable write is converted','line_number':982,'multiline':False]['text':'    to a transaction. The only use case of this is where the write fails with a','line_number':983,'multiline':False]['text':'    WouldChangeOwningShard error. For a retryable write being executed using internal','line_number':984,'multiline':False]['text':'    transactions, there is an additional requirement that all the internal transactions','line_number':985,'multiline':False]['text':'    have been aborted and have not been involved in a two phase commit.','line_number':986,'multiline':False]['text':' Assuming routers target primaries in increasing order of term and in the absence of','line_number':987,'multiline':False]['text':' byzantine messages, this check should never fail.','line_number':988,'multiline':False]['text':' Verifies we can begin a multi document transaction with the given txnNumber and','line_number':991,'multiline':False]['text':' txnRetryCounter. Throws if we cannot. Returns true if this is a retry of the active','line_number':992,'multiline':False]['text':' transaction and false otherwise.','line_number':993,'multiline':False]['text':' Attempt to begin or retry a retryable write at the given transaction number.','line_number':997,'multiline':False]['text':' Attempt to begin a new multi document transaction at the given transaction number and','line_number':1001,'multiline':False]['text':' transaction retry counter.','line_number':1002,'multiline':False]['text':' Attempt to continue an in-progress multi document transaction at the given transaction','line_number':1006,'multiline':False]['text':' number and transaction retry counter.','line_number':1007,'multiline':False]['text':' Implementation of public refreshFromStorageIfNeeded methods.','line_number':1011,'multiline':False]['text':' Refreshes the session that this Participant corresponds to if it requires a refresh.','line_number':1014,'multiline':False]['text':' Refreshes the external session and internal sessions associated with this session, if','line_number':1017,'multiline':False]['text':' there are any (see the header comment for RetryableWriteTransactionParticipantCatalog for','line_number':1018,'multiline':False]['text':' the definitions of these sessions).','line_number':1019,'multiline':False]['text':' Helper that invalidates the session state and activeTxnNumber. Also resets the single','line_number':1023,'multiline':False]['text':' transaction stats because the session is no longer valid.','line_number':1024,'multiline':False]['text':' Helper that resets the retryable writes state.','line_number':1027,'multiline':False]['text':' Helper that resets the transactional state. This is used when aborting a transaction,','line_number':1030,'multiline':False]['text':' invalidating a transaction, or starting a new transaction. It releases the Client lock','line_number':1031,'multiline':False]['text':' before releasing this participant's locks and aborting its storage transaction.','line_number':1032,'multiline':False]['text':' Releases the resources held in *o().txnResources to the operation context.
         * o().txnResources must be engaged prior to calling this.
         *
         * maxLockTimeout will determine whether future lock requests should have lock timeouts.
         *  - MaxLockTimeout::kNotAllowed will clear the lock timeout.
         *  - MaxLockTimeout::kAllowed will set the timeout as
         *    MaxTransactionLockRequestTimeoutMillis.
         *
         * acquireTicket will determine we should acquire ticket on unstashing the transaction
         * resources.
         *  - AcquireTicket::kSkip will not acquire ticket.
         *  - AcquireTicket::kNoSkip will retain the default behavior which is to acquire ticket.
         *
         * Below is the expected behavior.
         * -----------------------------------------------------------------------------
         * |                |                       |               |                  |
         * |                |      PRIMARY          |  SECONDARY    | STATE TRANSITION |
         * |                |                       |               |                  |
         * |----------------|-----------------------|---------------|------------------|
         * |                | Commit/   | Other Txn |               |                  |
         * |                | Abort Cmd | Cmds      |               |                  |
         * |                |-----------------------|               |                  |
         * |acquireTicket   | kSkip     |  kNoSkip  |  kNoSkip      |     kSkip        |
         * |----------------|-----------------------|---------------|------------------|
         * |maxLockTimeout  |     kAllowed          | kNotAllowed   |  kNotAllowed     |
         * -----------------------------------------------------------------------------
         ','line_number':1037,'multiline':True]['text':' class Participant','line_number':1080,'multiline':False]['text':'*
     * Returns the timestamp of the oldest oplog entry written across all open transactions, at the
     * time of the stable timestamp. Returns boost::none if there are no active transactions, or an
     * error if it fails.
     ','line_number':1098,'multiline':True]['text':'*
     * Append a no-op to the oplog, for cases where we haven't written in this unit of work but
     * want to await a write concern.
     ','line_number':1106,'multiline':True]['text':'*
     * Reserves a slot in the oplog with an open storage-transaction while it is alive. Reserves the
     * slot at construction. Aborts the storage-transaction and releases the oplog slot at
     * destruction.
     ','line_number':1113,'multiline':True]['text':'*
         * Returns the latest oplog slot reserved at construction.
         ','line_number':1123,'multiline':True]['text':' We must hold a global lock in IX mode for the lifetime of the recovery unit.','line_number':1140,'multiline':False]['text':' The global lock is also used to protect oplog writes. The lock acquisition must be','line_number':1141,'multiline':False]['text':' before reserving oplogSlots to avoid deadlocks involving the callers of','line_number':1142,'multiline':False]['text':' waitForAllEarlierOplogWritesToBeVisible().','line_number':1143,'multiline':False]['text':' class OplogSlotReserver','line_number':1147,'multiline':False]['text':'*
     * State in this struct may be read by methods of Observer or Participant, and may be written by
     * methods of Participant when they acquire the lock on the opCtx's Client. Access this inside
     * Observer and Participant using the private o() method for reading and (Participant only) the
     * o(WithLock) method for writing.
     ','line_number':1157,'multiline':True]['text':' Holds transaction resources between network operations.','line_number':1164,'multiline':False]['text':' Maintains the transaction state and the transition table for legal state transitions.','line_number':1167,'multiline':False]['text':' Tracks the last seen TxnNumber and TxnRetryCounter for the session. The txn number is','line_number':1170,'multiline':False]['text':' always >= to the transaction number in the last written txn record. When it is > than','line_number':1171,'multiline':False]['text':' that in the last written txn record, this means a new transaction has begun on the','line_number':1172,'multiline':False]['text':' session, but it hasn't yet performed any writes. The txnRetryCounter should always be','line_number':1173,'multiline':False]['text':' kUninitializedTxnRetryCounter for a retryable write, and non-negative for a','line_number':1174,'multiline':False]['text':' multi-statement transaction.','line_number':1175,'multiline':False]['text':' Caches what is known to be the last optime written for the active transaction.','line_number':1179,'multiline':False]['text':' Set when a snapshot read / transaction begins. Alleviates cache pressure by limiting how','line_number':1182,'multiline':False]['text':' long a snapshot will remain open and available. Checked in combination with _txnState to','line_number':1183,'multiline':False]['text':' determine whether the transaction should be aborted.  This is unset until a transaction','line_number':1184,'multiline':False]['text':' begins on the session, and then reset only when new transactions begin.','line_number':1185,'multiline':False]['text':' Track the prepareOpTime, the OpTime of the 'prepare' oplog entry for a transaction.','line_number':1188,'multiline':False]['text':' The prepare optime of the transaction. This is exposed to consumers who may need to know','line_number':1191,'multiline':False]['text':' the optime of the prepare oplog entry during replication recovery. It is stored','line_number':1192,'multiline':False]['text':' separately from the 'prepareOpTime' since it serves a different purpose and may be','line_number':1193,'multiline':False]['text':' updated at different times.','line_number':1194,'multiline':False]['text':' Tracks and updates transaction metrics upon the appropriate transaction event.','line_number':1197,'multiline':False]['text':' Contains a list of affected namespaces to be reported to transaction coordinator.','line_number':1200,'multiline':False]['text':' Maintains a copy of ReadConcernArgs, this allows the worker thread to perform','line_number':1203,'multiline':False]['text':' intermediate changes to its own ReadConcernArgs when fetching the transaction state or','line_number':1204,'multiline':False]['text':' reading retryability history. Those changes would race with monitoring and are inocuous','line_number':1205,'multiline':False]['text':' in nature.','line_number':1206,'multiline':False]['text':'','line_number':1207,'multiline':False]['text':' This value is set at the beginning of a transaction and reflects the user's ReadConcern','line_number':1208,'multiline':False]['text':' preferences.','line_number':1209,'multiline':False]['text':'*
     * State in this struct may be read and written by methods of the Participant, only. It may
     * access the struct via the private p() accessor. No further locking is required in methods of
     * the Participant.
     ','line_number':1213,'multiline':True]['text':' Specifies whether the session information needs to be refreshed from storage','line_number':1219,'multiline':False]['text':' Only set if the server is shutting down and it has been ensured that no new requests will','line_number':1222,'multiline':False]['text':' be accepted. Ensures that any transaction resources will not be stashed from the','line_number':1223,'multiline':False]['text':' operation context onto the transaction participant when the session is checked-in so that','line_number':1224,'multiline':False]['text':' locks can automatically get freed.','line_number':1225,'multiline':False]['text':' Holds oplog data for operations which have been applied in the current multi-document','line_number':1228,'multiline':False]['text':' transaction.','line_number':1229,'multiline':False]['text':' The autocommit setting of this transaction. Should always be false for multi-statement','line_number':1232,'multiline':False]['text':' transaction. Currently only needed for diagnostics reporting.','line_number':1233,'multiline':False]['text':'','line_number':1236,'multiline':False]['text':' Retryable writes state','line_number':1237,'multiline':False]['text':'','line_number':1238,'multiline':False]['text':' Set to true if incomplete history is detected. For example, when the oplog to a write was','line_number':1240,'multiline':False]['text':' truncated because it was too old.','line_number':1241,'multiline':False]['text':' For the active txn, tracks which statement ids have been committed and at which oplog','line_number':1244,'multiline':False]['text':' opTime. Used for fast retryability check and retrieving the previous write's data without','line_number':1245,'multiline':False]['text':' having to scan through the oplog.','line_number':1246,'multiline':False]['text':' Set to true if we need to write an "abort" oplog entry in the case of an abort.  This','line_number':1249,'multiline':False]['text':' is the case when we have (or may have) written or replicated an oplog entry for the','line_number':1250,'multiline':False]['text':' transaction.','line_number':1251,'multiline':False]['text':' class TransactionParticipant','line_number':1255,'multiline':False]['text':'*
 * When a client runs a retryable write command with session id {_id: ..., uid: ...}, each write
 * statement in the command is executed as follows:
 * - If the statement translates to multiple reads and writes, it is executed using a transaction
 *   in an internal session with session id {id: ..., uid: ..., txnNumber: ..., txnUUID: ...}, where
 *   the 'txnNumber' in the session id is the transaction number of the command and 'txnUUID' is an
 *   internally generated uuid. Such a transaction is referred to as retryable internal transaction.
 * - Otherwise, the statement is executed as a single write in the original session.
 * These internal/child sessions are tracked with separate Sessions and TransactionParticipants
 * (i.e. config.transactions documents) from those of the external/original/parent session. However,
 * they share write history and txnNumber with the original session.
 *
 * This class tracks the TransactionParticipants for a retrayble write command running on a
 * session to allow for "cross-session" write history lookup and state validation. That is, if
 * there is an active retryable write command on the session, the catalog stores the txnNumber and
 * participants for the retryable write. Otherwise, the txnNumber is set to kUninitializedTxnNumber
 * and the catalog contains no participants. To avoid duplicated maintenance work, parent and child
 * sessions share a catalog. Refresh occurs when any of the sessions is checked out for the the
 * first time and after any of the sessions gets invalidated. It is reset and repopulated as a new
 * transaction or retryable write starts.
 *
 * The catalog can only exist as a decoration on the Session object and can only be accessed and
 * modified by the thread which has the session checked-out.
 ','line_number':1257,'multiline':True]['text':'*
     * Adds the given participant to the catalog and sets the txnNumber to that of the retryable
     * write running on the participant. If a participant with the same session id already exists,
     * invariants that it corresponds to the same TransactionParticipant.
     ','line_number':1299,'multiline':True]['text':'*
     * Resets the txnNumber and participants in this catalog. Called when a new transaction starts
     * on the session.
     ','line_number':1306,'multiline':True]['text':'*
     * Marks this catalog as having been refreshed. That is, no refresh is needed unless one of the
     * participants is later marked as requiring a refresh. Throws an invariant error if any of the
     * participants requires a refresh.
     ','line_number':1312,'multiline':True]['text':'*
     * Resets this catalog and marks it as requiring a refresh.
     ','line_number':1319,'multiline':True]['text':'*
     * Returns true if none of the participants in the catalog requires a refresh and the catalog
     * itself has not been explicitly marked as requiring a refresh.
     ','line_number':1324,'multiline':True]['text':'*
     * If a transaction in the catalog conflicts with the incoming transaction and this is the first
     * time that has happened, the conflicting transaction is aborted, on the assumption that the
     * new transaction is likely from a fresher client and the client of the conflicting transaction
     * has give up (e.g. crashed). To prevent livelocks if both clients are alive and retrying,
     * RetryableTransactionInProgress is thrown on subsequent calls, forcing the incoming
     * transaction to wait for the conflicting to complete.
     ','line_number':1330,'multiline':True]['text':'*
     * Aborts any child transactions that are logically superseded by the incoming transaction, ie
     * retryable transactions where the txnNumber in their session id < the top-level txnNumber for
     * a retryable write / client transaction or the session id txnNumber for a retryable
     * transaction.
     ','line_number':1343,'multiline':True]['text':' Set true after an incoming retryable transaction has conflicted with an open transaction in','line_number':1356,'multiline':False]['text':' this catalog.','line_number':1357,'multiline':False]['text':'*
 * Returns maximum number of operations to pack into a single oplog entry,
 * when multi-oplog format for transactions is in use.
 *
 * Stop packing when either number of transaction operations is reached, or when the
 * next one would make the total size of operations larger than the maximum BSON Object
 * User Size. We rely on the headroom between BSONObjMaxUserSize and
 * BSONObjMaxInternalSize to cover the BSON overhead and the other "applyOps" entry
 * fields. But if a single operation in the set exceeds BSONObjMaxUserSize, we still fit
 * it, as a single max-length operation should be able to be packed into an "applyOps"
 * entry.
 ','line_number':1361,'multiline':True]['text':'*
 * Returns maximum size (bytes) of operations to pack into a single oplog entry,
 * when multi-oplog format for transactions is in use.
 *
 * Refer to getMaxNumberOfTransactionOperationsInSingleOplogEntry() comments for a
 * description on packing transaction operations into "applyOps" entries.
 ','line_number':1375,'multiline':True]['text':' namespace mongo','line_number':1384,'multiline':False]