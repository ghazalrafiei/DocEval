['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "cxxabi.h"','line_number':34,'multiline':False]['text':' IWYU pragma: keep','line_number':50,'multiline':False]['text':' IWYU pragma: keep','line_number':57,'multiline':False]['text':' for dlfcn.h and backtrace','line_number':73,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' Sampling heap profiler','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':' Intercepts allocate and free calls to track approximate number of live allocated bytes','line_number':79,'multiline':False]['text':' associated with each allocating stack trace at each point in time.','line_number':80,'multiline':False]['text':'','line_number':81,'multiline':False]['text':' Hooks into tcmalloc via the MallocHook interface, but has no dependency','line_number':82,'multiline':False]['text':' on any allocator internals; could be used with any allocator via similar','line_number':83,'multiline':False]['text':' hooks, or via shims.','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':' Adds no space overhead to each allocated object - allocated objects','line_number':86,'multiline':False]['text':' and associated stack traces are recorded in separate pre-allocated','line_number':87,'multiline':False]['text':' fixed-size hash tables. Size of the separate hash tables is configurable','line_number':88,'multiline':False]['text':' but something on the order of tens of MB should suffice for most purposes.','line_number':89,'multiline':False]['text':'','line_number':90,'multiline':False]['text':' Performance overhead is small because it only samples a fraction of the allocations.','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':' Samples allocate calls every so many bytes allocated.','line_number':93,'multiline':False]['text':'   * a stack trace is obtained, and entered in a stack hash table if it's a new stack trace','line_number':94,'multiline':False]['text':'   * the number of active bytes charged to that stack trace is increased','line_number':95,'multiline':False]['text':'   * the allocated object, stack trace, and number of bytes is recorded in an object hash table','line_number':96,'multiline':False]['text':' For each free call if the freed object is in the object hash table.','line_number':97,'multiline':False]['text':'   * the number of active bytes charged to the allocating stack trace is decreased','line_number':98,'multiline':False]['text':'   * the object is removed from the object hash table','line_number':99,'multiline':False]['text':'','line_number':100,'multiline':False]['text':' Enable at startup time (only) with','line_number':101,'multiline':False]['text':'     mongod --setParameter heapProfilingEnabled=true','line_number':102,'multiline':False]['text':'','line_number':103,'multiline':False]['text':' If enabled, adds a heapProfile section to serverStatus as follows:','line_number':104,'multiline':False]['text':'','line_number':105,'multiline':False]['text':' heapProfile: {','line_number':106,'multiline':False]['text':'     stats: {','line_number':107,'multiline':False]['text':'         //  internal stats related to heap profiling process (collisions, number of stacks, etc.)','line_number':108,'multiline':False]['text':'     }','line_number':109,'multiline':False]['text':'     stacks: {','line_number':110,'multiline':False]['text':'         stack_n_: {             // one for each stack _n_','line_number':111,'multiline':False]['text':'             activeBytes: ...,   // number of active bytes allocated by this stack','line_number':112,'multiline':False]['text':'             stack: [            // the stack itself','line_number':113,'multiline':False]['text':'                 "frame0",','line_number':114,'multiline':False]['text':'                 "frame1",','line_number':115,'multiline':False]['text':'                 ...','line_number':116,'multiline':False]['text':'            ]','line_number':117,'multiline':False]['text':'        }','line_number':118,'multiline':False]['text':'    }','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':' Each new stack encountered is also logged to mongod log with a message like','line_number':121,'multiline':False]['text':'     .... stack_n_: {0: "frame0", 1: "frame1", ...}','line_number':122,'multiline':False]['text':'','line_number':123,'multiline':False]['text':' Can be used in one of two ways:','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':' Via FTDC - strings are not captured by FTDC, so the information','line_number':126,'multiline':False]['text':' recorded in FTDC for each sample is essentially of the form','line_number':127,'multiline':False]['text':' {stack_n_: activeBytes} for each stack _n_. The timeseries tool','line_number':128,'multiline':False]['text':' will present one graph per stack, identified by the label stack_n_,','line_number':129,'multiline':False]['text':' showing active bytes that were allocated by that stack at each','line_number':130,'multiline':False]['text':' point in time. The mappings from stack_n_ to the actual stack can','line_number':131,'multiline':False]['text':' be found in mongod log.','line_number':132,'multiline':False]['text':'','line_number':133,'multiline':False]['text':' Via serverStatus - the serverStatus section described above','line_number':134,'multiline':False]['text':' contains complete information, including the stack trace.  It can','line_number':135,'multiline':False]['text':' be obtained and examined manually, and can be further processed by','line_number':136,'multiline':False]['text':' tools.','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' We will need about 1 active ObjInfo for every sampleIntervalBytes live bytes,','line_number':139,'multiline':False]['text':' so max active memory we can handle is sampleIntervalBytes * kMaxObjInfos.','line_number':140,'multiline':False]['text':' With the current defaults of','line_number':141,'multiline':False]['text':'     kMaxObjInfos = 1024 * 1024','line_number':142,'multiline':False]['text':'     sampleIntervalBytes = 256 * 1024','line_number':143,'multiline':False]['text':' the following information is computed and logged on startup (see HeapProfiler()):','line_number':144,'multiline':False]['text':'     maxActiveMemory 262144 MB','line_number':145,'multiline':False]['text':'     objTableSize 72 MB','line_number':146,'multiline':False]['text':'     stackTableSize 16.6321MB','line_number':147,'multiline':False]['text':' So the defaults allow handling very large memories at a reasonable sampling interval','line_number':148,'multiline':False]['text':' and acceptable size overhead for the hash tables.','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' Simple wrapper for the demangler, particularly its buffer space.','line_number':155,'multiline':False]['text':' TODO SERVER-44010: Consider replacing this custom implementation with a generic one.','line_number':179,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' Simple hash table maps Key->Value.','line_number':181,'multiline':False]['text':' All storage is pre-allocated at creation.','line_number':182,'multiline':False]['text':' Access functions take a hash specifying a bucket as the first parameter to avoid re-computing','line_number':183,'multiline':False]['text':' hash unnecessarily; caller must ensure that hash is correctly computed from the appropriate Key.','line_number':184,'multiline':False]['text':' Key must implement operator== to support find().','line_number':185,'multiline':False]['text':' Key and Value must both support assignment to allow copying key and value into table on insert.','line_number':186,'multiline':False]['text':'','line_number':187,'multiline':False]['text':' Concurrency rules:','line_number':188,'multiline':False]['text':'     Reads (find(), isBucketEmpty(), forEach()) MAY be called concurrently with each other.','line_number':189,'multiline':False]['text':'     Writes (insert(), remove()) may NOT be called concurrently with each other.','line_number':190,'multiline':False]['text':'     Concurrency of reads and writes is as follows:','line_number':191,'multiline':False]['text':'         find() may NOT be called concurrently with any write.','line_number':192,'multiline':False]['text':'         isBucketEmpty() MAY be called concurrently with any write.','line_number':193,'multiline':False]['text':'         forEach()','line_number':194,'multiline':False]['text':'             MAY be called concurrently with insert() but NOT remove()','line_number':195,'multiline':False]['text':'             does not provide snapshot semantics wrt set of entries traversed','line_number':196,'multiline':False]['text':'             caller must ensure safety wrt concurrent modification of Value of existing entry','line_number':197,'multiline':False]['text':'','line_number':198,'multiline':False]['text':' NOLINT','line_number':211,'multiline':False]['text':' NOLINT','line_number':212,'multiline':False]['text':' we allocate storage for this many entries on creation','line_number':216,'multiline':False]['text':' number of entries currently in use  NOLINT','line_number':217,'multiline':False]['text':' number of buckets, computed as numEntries * loadFactor','line_number':218,'multiline':False]['text':' pre-allocate buckets and entries','line_number':220,'multiline':False]['text':' NOLINT','line_number':221,'multiline':False]['text':' first entry that's never been used  NOLINT','line_number':224,'multiline':False]['text':' linked list of entries returned to us by removeEntry','line_number':225,'multiline':False]['text':' NOLINT','line_number':232,'multiline':False]['text':' Allocate a new entry in the specified hash bucket.','line_number':237,'multiline':False]['text':' Stores a copy of the specified Key and Value.','line_number':238,'multiline':False]['text':' Returns a pointer to the newly allocated Value, or nullptr if out of space.','line_number':239,'multiline':False]['text':' signal that the entry is well-formed and may be traversed','line_number':254,'multiline':False]['text':' Find the entry containing Key in the specified hash bucket.','line_number':262,'multiline':False]['text':' Returns a pointer to the corresponding Value object, or nullptr if not found.','line_number':263,'multiline':False]['text':' Remove an entry specified by key.','line_number':272,'multiline':False]['text':' first signal entry is invalid as it may get reused','line_number':279,'multiline':False]['text':' Traverse the array of pre-allocated entries, calling f(key, value) on each valid entry.','line_number':288,'multiline':False]['text':' This may be called concurrently with insert() but not remove()','line_number':289,'multiline':False]['text':'     atomic entry.valid ensures that it will see only well-formed entries','line_number':290,'multiline':False]['text':'     nextEntry is atomic to guard against torn reads as nextEntry is updated','line_number':291,'multiline':False]['text':' Note however it is not guaranteed to provide snapshot semantics wrt the set of entries,','line_number':292,'multiline':False]['text':' and caller must ensure safety wrt concurrent updates to the Value of an entry','line_number':293,'multiline':False]['text':' only traverse well-formed entries','line_number':298,'multiline':False]['text':' Determines whether the specified hash bucket is empty. May be called concurrently with','line_number':303,'multiline':False]['text':' insert() and remove(). Concurrent visibility on other threads is guaranteed because','line_number':304,'multiline':False]['text':' buckets[hash] is atomic.','line_number':305,'multiline':False]['text':' Number of entries.','line_number':311,'multiline':False]['text':' Highwater mark of number of entries used, for reporting stats.','line_number':316,'multiline':False]['text':' Returns total allocated size of the hash table, for reporting stats.','line_number':321,'multiline':False]['text':' 0: sampling internally disabled','line_number':330,'multiline':False]['text':' 1: sample every allocation - byte accurate but slow and big','line_number':331,'multiline':False]['text':' >1: sample ever sampleIntervalBytes bytes allocated - less accurate but fast and small','line_number':332,'multiline':False]['text':' NOLINT','line_number':333,'multiline':False]['text':' guards updates to both object and stack hash tables','line_number':335,'multiline':False]['text':' NOLINT','line_number':336,'multiline':False]['text':' guards against races updating the StackInfo bson representation','line_number':337,'multiline':False]['text':' NOLINT','line_number':338,'multiline':False]['text':' cumulative bytes allocated - determines when samples are taken','line_number':340,'multiline':False]['text':' NOLINT','line_number':341,'multiline':False]['text':' estimated currently active bytes - sum of activeBytes for all stacks','line_number':343,'multiline':False]['text':'','line_number':346,'multiline':False]['text':' Hash table of stacks','line_number':347,'multiline':False]['text':'','line_number':348,'multiline':False]['text':' per-frame information is just the IP','line_number':350,'multiline':False]['text':' max number of unique call sites we handle','line_number':352,'multiline':False]['text':' keep loading <50%','line_number':353,'multiline':False]['text':' max depth of stack','line_number':354,'multiline':False]['text':' stack HashTable Key','line_number':356,'multiline':False]['text':' Stack HashTable Value.','line_number':376,'multiline':False]['text':' used for stack short name','line_number':378,'multiline':False]['text':' number of live allocated bytes charged to this stack','line_number':379,'multiline':False]['text':' true when stack has been logged once.','line_number':380,'multiline':False]['text':' The stack HashTable itself.','line_number':386,'multiline':False]['text':' frames to skip at top and bottom of backtrace when reporting stacks','line_number':389,'multiline':False]['text':'','line_number':394,'multiline':False]['text':' Hash table of allocated objects.','line_number':395,'multiline':False]['text':'','line_number':396,'multiline':False]['text':' maximum tracked allocations','line_number':398,'multiline':False]['text':' keep hash table loading <25%','line_number':399,'multiline':False]['text':' Obj HashTable Key.','line_number':401,'multiline':False]['text':' Obj HashTable Value.','line_number':416,'multiline':False]['text':' The obj HashTable itself.','line_number':425,'multiline':False]['text':' If we encounter an error that doesn't allow us to proceed, for','line_number':429,'multiline':False]['text':' example out of space for new hash table entries, we internally','line_number':430,'multiline':False]['text':' disable profiling and then log an error message.','line_number':431,'multiline':False]['text':'','line_number':437,'multiline':False]['text':' Record an allocation.','line_number':438,'multiline':False]['text':'','line_number':439,'multiline':False]['text':' still profiling?','line_number':441,'multiline':False]['text':' Sample every sampleIntervalBytes bytes of allocation.','line_number':445,'multiline':False]['text':' We charge each sampled stack with the amount of memory allocated since the last sample','line_number':446,'multiline':False]['text':' this could grossly overcharge any given stack sample, but on average over a large','line_number':447,'multiline':False]['text':' number of samples will be correct.','line_number':448,'multiline':False]['text':' Get backtrace.','line_number':456,'multiline':False]['text':' Compute backtrace hash.','line_number':460,'multiline':False]['text':' Now acquire lock.','line_number':463,'multiline':False]['text':' Look up stack in stackHashTable.','line_number':466,'multiline':False]['text':' If new stack, store in stackHashTable.','line_number':469,'multiline':False]['text':'stackNum','line_number':471,'multiline':True]['text':' Count the bytes.','line_number':479,'multiline':False]['text':' Enter obj in objHashTable.','line_number':483,'multiline':False]['text':'','line_number':492,'multiline':False]['text':' Record a freed object.','line_number':493,'multiline':False]['text':'','line_number':494,'multiline':False]['text':' still profiling?','line_number':496,'multiline':False]['text':' Compute hash, quick return before locking if bucket is empty (common case).','line_number':500,'multiline':False]['text':' This is crucial for performance because we need to check the hash table on every _free.','line_number':501,'multiline':False]['text':' Visibility of the bucket entry if the _alloc was done on a different thread is','line_number':502,'multiline':False]['text':' guaranteed because isEmptyBucket consults an atomic pointer.','line_number':503,'multiline':False]['text':' Now acquire lock.','line_number':509,'multiline':False]['text':' Remove the object from the hash bucket if present.','line_number':512,'multiline':False]['text':'','line_number':521,'multiline':False]['text':' Generate bson representation of stack.','line_number':522,'multiline':False]['text':'','line_number':523,'multiline':False]['text':' Upgrade frameString to symbol name.','line_number':540,'multiline':False]['text':' Further upgrade frameString to demangled name.','line_number':543,'multiline':False]['text':' We strip function parameters as they are very verbose and not useful.','line_number':544,'multiline':False]['text':' Fall back to frameString as stringified `void*`.','line_number':552,'multiline':False]['text':'','line_number':565,'multiline':False]['text':' Generate serverStatus section.','line_number':566,'multiline':False]['text':'','line_number':567,'multiline':False]['text':' first time only','line_number':569,'multiline':False]['text':' In order to reduce load on ftdc we track the stacks we deem important enough to emit','line_number':571,'multiline':False]['text':' once a stack is deemed "important" it remains important from that point on.','line_number':572,'multiline':False]['text':' "Important" is a sticky quality to improve the stability of the set of stacks we emit,','line_number':573,'multiline':False]['text':' and we always emit them in stackNum order, greatly improving ftdc compression efficiency.','line_number':574,'multiline':False]['text':' samples currently included in importantStacks','line_number':582,'multiline':False]['text':' reset every 4 hours at default 1 sample / sec','line_number':583,'multiline':False]['text':' compute and log some informational stats first time through','line_number':586,'multiline':False]['text':' print a stack trace to log somap for post-facto symbolization','line_number':598,'multiline':False]['text':' Stats subsection.','line_number':604,'multiline':False]['text':' Guard against races updating the StackInfo bson representation.','line_number':614,'multiline':False]['text':' Traverse stackHashTable accumulating potential stacks to emit.','line_number':617,'multiline':False]['text':' We do this traversal without locking hashtable_mutex because we need to use the heap.','line_number':618,'multiline':False]['text':' forEach guarantees this is safe wrt to insert(), and we never call remove().','line_number':619,'multiline':False]['text':' We use stackinfo_mutex to ensure safety wrt concurrent updates to the StackInfo objects.','line_number':620,'multiline':False]['text':' We can get skew between entries, which is ok.','line_number':621,'multiline':False]['text':' snapshot `info->activeBytes` because it changes during sort.','line_number':624,'multiline':False]['text':' Sort the stacks and find enough stacks to account for at least 99% of the active bytes','line_number':642,'multiline':False]['text':' deem any stack that has ever met this criterion as "important".','line_number':643,'multiline':False]['text':' Using heap structure to avoid comparing elements that won't make the cut anyway.','line_number':644,'multiline':False]['text':' Build the stacks subsection by emitting the "important" stacks.','line_number':663,'multiline':False]['text':' importantStacks grows monotonically, so it can accumulate unneeded stacks,','line_number':675,'multiline':False]['text':' so we clear it periodically.','line_number':676,'multiline':False]['text':'','line_number':684,'multiline':False]['text':' Static hooks to give to the allocator.','line_number':685,'multiline':False]['text':'','line_number':686,'multiline':False]['text':' Set sample interval from the parameter.','line_number':700,'multiline':False]['text':' This is our only allocator dependency - ifdef and change as','line_number':703,'multiline':False]['text':' appropriate for other allocators, using hooks or shims.','line_number':704,'multiline':False]['text':' For tcmalloc we skip two frames that are internal to the allocator','line_number':705,'multiline':False]['text':' so that the top frame is the public tc_* function.','line_number':706,'multiline':False]['text':'','line_number':719,'multiline':False]['text':' serverStatus section','line_number':720,'multiline':False]['text':'','line_number':721,'multiline':False]['text':'','line_number':739,'multiline':False]['text':' startup','line_number':740,'multiline':False]['text':'','line_number':741,'multiline':False]['text':' namespace','line_number':751,'multiline':False]['text':' namespace mongo','line_number':752,'multiline':False]['text':' MONGO_HAVE_HEAP_PROFILER','line_number':754,'multiline':False]