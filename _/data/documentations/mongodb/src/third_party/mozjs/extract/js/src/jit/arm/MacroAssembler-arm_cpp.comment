['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':25,'multiline':False]['text':' js::jit::JitActivation','line_number':27,'multiline':False]['text':' In order to be used for a DTRD memory function, the two target registers','line_number':42,'multiline':False]['text':' need to be a) Adjacent, with the tag larger than the payload, and b)','line_number':43,'multiline':False]['text':' Aligned to a multiple of two.','line_number':44,'multiline':False]['text':' Note that C++ bool is only 1 byte, so zero extend it to clear the','line_number':55,'multiline':False]['text':' higher-order bits.','line_number':56,'multiline':False]['text':' Direct conversions aren't possible.','line_number':62,'multiline':False]['text':' Direct conversions aren't possible.','line_number':94,'multiline':False]['text':' Direct conversions aren't possible.','line_number':104,'multiline':False]['text':' Checks whether a double is representable as a 32-bit integer. If so, the','line_number':116,'multiline':False]['text':' integer is written to the output register. Otherwise, a bailout is taken to','line_number':117,'multiline':False]['text':' the given snapshot. This function overwrites the scratch float register.','line_number':118,'multiline':False]['text':' Convert the floating point value to an integer, if it did not fit, then','line_number':122,'multiline':False]['text':' when we convert it *back* to a float, it will have a different value,','line_number':123,'multiline':False]['text':' which we can test.','line_number':124,'multiline':False]['text':' Move the value into the dest register.','line_number':131,'multiline':False]['text':' Test and bail for -0.0, when integer result is 0. Move the top word','line_number':140,'multiline':False]['text':' of the double into the output reg, if it is non-zero, then the','line_number':141,'multiline':False]['text':' original value was -0.0.','line_number':142,'multiline':False]['text':' Checks whether a float32 is representable as a 32-bit integer. If so, the','line_number':149,'multiline':False]['text':' integer is written to the output register. Otherwise, a bailout is taken to','line_number':150,'multiline':False]['text':' the given snapshot. This function overwrites the scratch float register.','line_number':151,'multiline':False]['text':' Converting the floating point value to an integer and then converting it','line_number':155,'multiline':False]['text':' back to a float32 would not work, as float to int32 conversions are','line_number':156,'multiline':False]['text':' clamping (e.g. float(INT32_MAX + 1) would get converted into INT32_MAX','line_number':157,'multiline':False]['text':' and then back to float(INT32_MAX + 1)).  If this ever happens, we just','line_number':158,'multiline':False]['text':' bail out.','line_number':159,'multiline':False]['text':' Store the result','line_number':166,'multiline':False]['text':' Bail out in the clamped cases.','line_number':174,'multiline':False]['text':' Test and bail for -0.0, when integer result is 0. Move the float into','line_number':181,'multiline':False]['text':' the output reg, and if it is non-zero then the original value was','line_number':182,'multiline':False]['text':' -0.0','line_number':183,'multiline':False]['text':' Direct conversions aren't possible.','line_number':200,'multiline':False]['text':' For the most part, there is no good reason to set the condition codes for','line_number':225,'multiline':False]['text':' the first instruction. We can do better things if the second instruction','line_number':226,'multiline':False]['text':' doesn't have a dest, such as check for overflow by doing first operation','line_number':227,'multiline':False]['text':' don't do second operation if first operation overflowed. This preserves','line_number':228,'multiline':False]['text':' the overflow condition code. Unfortunately, it is horribly brittle.','line_number':229,'multiline':False]['text':' ma_mov should be used for moves.','line_number':238,'multiline':False]['text':' As it turns out, if you ask for a compare-like instruction you *probably*','line_number':243,'multiline':False]['text':' want it to set condition codes.','line_number':244,'multiline':False]['text':' The operator gives us the ability to determine how this can be used.','line_number':247,'multiline':False]['text':' One instruction: If we can encode it using an imm8m, then do so.','line_number':249,'multiline':False]['text':' One instruction, negated:','line_number':255,'multiline':False]['text':' 'add r1, r2, -15' can be replaced with 'sub r1, r2, 15'.','line_number':260,'multiline':False]['text':' The dest can be replaced (InvalidReg => scratch).','line_number':261,'multiline':False]['text':' This is useful if we wish to negate tst. tst has an invalid (aka not','line_number':262,'multiline':False]['text':' used) dest, but its negation bic requires a dest.','line_number':263,'multiline':False]['text':' Start by attempting to generate a two instruction form. Some things','line_number':269,'multiline':False]['text':' cannot be made into two-inst forms correctly. Namely, adds dest, src,','line_number':270,'multiline':False]['text':' 0xffff. Since we want the condition codes (and don't know which ones','line_number':271,'multiline':False]['text':' will be checked), we need to assume that the overflow flag will be','line_number':272,'multiline':False]['text':' checked and add{,s} dest, src, 0xff00; add{,s} dest, dest, 0xff is not','line_number':273,'multiline':False]['text':' guaranteed to set the overflof flag the same as the (theoretical) one','line_number':274,'multiline':False]['text':' instruction variant.','line_number':275,'multiline':False]['text':' And try with its negative.','line_number':280,'multiline':False]['text':' static ','line_number':319,'multiline':True]['text':' The current instruction must be an actual instruction,','line_number':324,'multiline':False]['text':' not automatically-inserted boilerplate.','line_number':325,'multiline':False]['text':' Try mov with Imm8 operand.','line_number':359,'multiline':False]['text':' Try mvn with Imm8 operand.','line_number':366,'multiline':False]['text':' Try movw/movt.','line_number':373,'multiline':False]['text':' ARMv7 supports movw/movt. movw zero-extends its 16 bit argument,','line_number':375,'multiline':False]['text':' so we can set the register this way. movt leaves the bottom 16','line_number':376,'multiline':False]['text':' bits in tact, so we always need a movw.','line_number':377,'multiline':False]['text':' If we don't have movw/movt, we need a load.','line_number':385,'multiline':False]['text':' Shifts (just a move with a shifting op2)','line_number':400,'multiline':False]['text':' Shifts (just a move with a shifting op2)','line_number':421,'multiline':False]['text':' Move not (dest <- ~src)','line_number':444,'multiline':False]['text':' Negate (dest <- -src), src is a register, rather than a general op2.','line_number':450,'multiline':False]['text':' And.','line_number':461,'multiline':False]['text':' Bit clear (dest <- dest & ~imm) or (dest <- src1 & ~src2).','line_number':484,'multiline':False]['text':' Exclusive or.','line_number':491,'multiline':False]['text':' Or.','line_number':514,'multiline':False]['text':' Arithmetic-based ops.','line_number':537,'multiline':False]['text':' Add with carry.','line_number':538,'multiline':False]['text':' Add.','line_number':555,'multiline':False]['text':' Subtract with carry.','line_number':583,'multiline':False]['text':' Subtract.','line_number':600,'multiline':False]['text':' Reverse subtract.','line_number':628,'multiline':False]['text':' Reverse subtract with carry.','line_number':651,'multiline':False]['text':' Compares/tests.','line_number':668,'multiline':False]['text':' Compare negative (sets condition codes as src1 + src2 would).','line_number':669,'multiline':False]['text':' Compare (src - src2).','line_number':683,'multiline':False]['text':' ImmTag comparisons can always be done without use of a scratch register.','line_number':690,'multiline':False]['text':' Test for equality, (src1 ^ src2).','line_number':727,'multiline':False]['text':' Test (src1 & src2).','line_number':741,'multiline':False]['text':' TODO: this operation is illegal on armv6 and earlier','line_number':770,'multiline':False]['text':' if src2 == scratch or src2 == dest.','line_number':771,'multiline':False]['text':' We wish to compute x % (1<<y) - 1 for a known constant, y.','line_number':821,'multiline':False]['text':'','line_number':822,'multiline':False]['text':' 1. Let b = (1<<y) and C = (1<<y)-1, then think of the 32 bit dividend as','line_number':823,'multiline':False]['text':' a number in base b, namely c_0*1 + c_1*b + c_2*b^2 ... c_n*b^n','line_number':824,'multiline':False]['text':'','line_number':825,'multiline':False]['text':' 2. Since both addition and multiplication commute with modulus:','line_number':826,'multiline':False]['text':'   x % C == (c_0 + c_1*b + ... + c_n*b^n) % C ==','line_number':827,'multiline':False]['text':'    (c_0 % C) + (c_1%C) * (b % C) + (c_2 % C) * (b^2 % C)...','line_number':828,'multiline':False]['text':'','line_number':829,'multiline':False]['text':' 3. Since b == C + 1, b % C == 1, and b^n % C == 1 the whole thing','line_number':830,'multiline':False]['text':' simplifies to: c_0 + c_1 + c_2 ... c_n % C','line_number':831,'multiline':False]['text':'','line_number':832,'multiline':False]['text':' Each c_n can easily be computed by a shift/bitextract, and the modulus','line_number':833,'multiline':False]['text':' can be maintained by simply subtracting by C whenever the number gets','line_number':834,'multiline':False]['text':' over C.','line_number':835,'multiline':False]['text':' Register 'hold' holds -1 if the value was negative, 1 otherwise. The','line_number':839,'multiline':False]['text':' scratch reg holds the remaining bits that have not been processed lr','line_number':840,'multiline':False]['text':' serves as a temporary location to store extracted bits into as well as','line_number':841,'multiline':False]['text':' holding the trial subtraction as a temp value dest is the accumulator','line_number':842,'multiline':False]['text':' (and holds the final result)','line_number':843,'multiline':False]['text':'','line_number':844,'multiline':False]['text':' Move the whole value into tmp, setting the codition codes so we can muck','line_number':845,'multiline':False]['text':' with them later.','line_number':846,'multiline':False]['text':' Zero out the dest.','line_number':848,'multiline':False]['text':' Set the hold appropriately.','line_number':850,'multiline':False]['text':' Begin the main loop.','line_number':855,'multiline':False]['text':' Extract the bottom bits.','line_number':858,'multiline':False]['text':' Add those bits to the accumulator.','line_number':860,'multiline':False]['text':' Do a trial subtraction, this is the same operation as cmp, but we store','line_number':862,'multiline':False]['text':' the dest.','line_number':863,'multiline':False]['text':' If (sum - C) > 0, store sum - C back into sum, thus performing a modulus.','line_number':865,'multiline':False]['text':' Get rid of the bits that we extracted before, and set the condition','line_number':867,'multiline':False]['text':' codes.','line_number':868,'multiline':False]['text':' If the shift produced zero, finish, otherwise, continue in the loop.','line_number':870,'multiline':False]['text':' Check the hold to see if we need to negate the result. Hold can only be','line_number':874,'multiline':False]['text':' 1 or -1, so this will never set the 0 flag.','line_number':875,'multiline':False]['text':' If the hold was non-zero, negate the result to be in line with what JS','line_number':877,'multiline':False]['text':' wants this will set the condition codes if we try to negate.','line_number':878,'multiline':False]['text':' Since the Zero flag is not set by the compare, we can *only* set the Zero','line_number':880,'multiline':False]['text':' flag in the rsb, so Zero is set iff we negated zero (e.g. the result of','line_number':881,'multiline':False]['text':' the computation was -0.0).','line_number':882,'multiline':False]['text':' Division','line_number':897,'multiline':False]['text':' Miscellaneous instructions.','line_number':908,'multiline':False]['text':' int c = __clz(a & -a);','line_number':915,'multiline':False]['text':' return a ? 31 - c : c;','line_number':916,'multiline':False]['text':' Memory.','line_number':923,'multiline':False]['text':' Shortcut for when we know we're transferring 32 bits of data.','line_number':924,'multiline':False]['text':' Undefined behavior if rm == rt/rt2.','line_number':993,'multiline':False]['text':' Specialty for moving N bits of data, where n == 8,16,32,64.','line_number':1008,'multiline':False]['text':' No scratch register is required if scale is TimesOne.','line_number':1029,'multiline':False]['text':' We can encode this as a standard ldr.','line_number':1056,'multiline':False]['text':' This encodes as a single instruction, Emulating mode's behavior','line_number':1059,'multiline':False]['text':' in a multi-instruction sequence is not necessary.','line_number':1060,'multiline':False]['text':' We cannot encode this offset in a single ldr. For mode == index,','line_number':1064,'multiline':False]['text':' try to encode it as |add scratch, base, imm; ldr dest, [scratch,','line_number':1065,'multiline':False]['text':' +offset]|. This does not wark for mode == PreIndex or mode == PostIndex.','line_number':1066,'multiline':False]['text':' PreIndex is simple, just do the add into the base register first,','line_number':1067,'multiline':False]['text':' then do a PreIndex'ed load. PostIndexed loads can be tricky.','line_number':1068,'multiline':False]['text':' Normally, doing the load with an index of 0, then doing an add would','line_number':1069,'multiline':False]['text':' work, but if the destination is the PC, you don't get to execute the','line_number':1070,'multiline':False]['text':' instruction after the branch, which will lead to the base register','line_number':1071,'multiline':False]['text':' not being updated correctly. Explicitly handle this case, without','line_number':1072,'multiline':False]['text':' doing anything fancy, then handle all of the other cases.','line_number':1073,'multiline':False]['text':' mode == Offset','line_number':1075,'multiline':False]['text':'  add   scratch, base, offset_hi','line_number':1076,'multiline':False]['text':'  ldr   dest, [scratch, +offset_lo]','line_number':1077,'multiline':False]['text':'','line_number':1078,'multiline':False]['text':' mode == PreIndex','line_number':1079,'multiline':False]['text':'  add   base, base, offset_hi','line_number':1080,'multiline':False]['text':'  ldr   dest, [base, +offset_lo]!','line_number':1081,'multiline':False]['text':' At this point, both off - bottom and off + neg_bottom will be','line_number':1089,'multiline':False]['text':' reasonable-ish quantities.','line_number':1090,'multiline':False]['text':'','line_number':1091,'multiline':False]['text':' Note a neg_bottom of 0x1000 can not be encoded as an immediate','line_number':1092,'multiline':False]['text':' negative offset in the instruction and this occurs when bottom is','line_number':1093,'multiline':False]['text':' zero, so this case is guarded against below.','line_number':1094,'multiline':False]['text':' sub_off = bottom - off','line_number':1096,'multiline':False]['text':' - sub_off = off - bottom','line_number':1098,'multiline':False]['text':' sub_off = -neg_bottom - off','line_number':1104,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1107,'multiline':False]['text':' - sub_off = neg_bottom + off','line_number':1109,'multiline':False]['text':' sub_off = off - bottom','line_number':1115,'multiline':False]['text':'  sub_off = off - bottom','line_number':1118,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1124,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1127,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1129,'multiline':False]['text':' Should attempt to use the extended load/store instructions.','line_number':1140,'multiline':False]['text':' We cannot encode this offset in a single extldr. Try to encode it as','line_number':1146,'multiline':False]['text':' an add scratch, base, imm; extldr dest, [scratch, +offset].','line_number':1147,'multiline':False]['text':' At this point, both off - bottom and off + neg_bottom will be','line_number':1150,'multiline':False]['text':' reasonable-ish quantities.','line_number':1151,'multiline':False]['text':'','line_number':1152,'multiline':False]['text':' Note a neg_bottom of 0x100 can not be encoded as an immediate','line_number':1153,'multiline':False]['text':' negative offset in the instruction and this occurs when bottom is','line_number':1154,'multiline':False]['text':' zero, so this case is guarded against below.','line_number':1155,'multiline':False]['text':' sub_off = bottom - off','line_number':1157,'multiline':False]['text':' - sub_off = off - bottom','line_number':1160,'multiline':False]['text':' sub_off = -neg_bottom - off','line_number':1165,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1168,'multiline':False]['text':' - sub_off = neg_bottom + off','line_number':1170,'multiline':False]['text':' sub_off = off - bottom','line_number':1176,'multiline':False]['text':' sub_off = off - bottom','line_number':1179,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1184,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1187,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1189,'multiline':False]['text':' pc <- [sp]; sp += n','line_number':1207,'multiline':False]['text':' Pushing sp is not well-defined: use two instructions.','line_number':1225,'multiline':False]['text':' Barriers','line_number':1243,'multiline':False]['text':' Branches when done from within arm-specific code.','line_number':1260,'multiline':False]['text':' An immediate pool is used for easier patching.','line_number':1270,'multiline':False]['text':' This is almost NEVER necessary: we'll basically never be calling a label,','line_number':1274,'multiline':False]['text':' except possibly in the crazy bailout-table case.','line_number':1275,'multiline':False]['text':' VFP/ALU','line_number':1284,'multiline':False]['text':' To zero a register, load 1.0, then execute dN <- dN - dN','line_number':1386,'multiline':False]['text':' Fall back to putting the value in a pool.','line_number':1399,'multiline':False]['text':' To zero a register, load 1.0, then execute sN <- sN - sN.','line_number':1408,'multiline':False]['text':' Note that the vimm immediate float32 instruction encoding differs','line_number':1414,'multiline':False]['text':' from the vimm immediate double encoding, but this difference matches','line_number':1415,'multiline':False]['text':' the difference in the floating point formats, so it is possible to','line_number':1416,'multiline':False]['text':' convert the float32 to a double and then use the double encoding','line_number':1417,'multiline':False]['text':' paths. It is still necessary to firstly check that the double low','line_number':1418,'multiline':False]['text':' word is zero because some float32 numbers set these bits and this can','line_number':1419,'multiline':False]['text':' not be ignored.','line_number':1420,'multiline':False]['text':' Fall back to putting the value in a pool.','line_number':1431,'multiline':False]['text':' We cannot encode this offset in a a single ldr. Try to encode it as an','line_number':1545,'multiline':False]['text':' add scratch, base, imm; ldr dest, [scratch, +offset].','line_number':1546,'multiline':False]['text':' At this point, both off - bottom and off + neg_bottom will be','line_number':1549,'multiline':False]['text':' reasonable-ish quantities.','line_number':1550,'multiline':False]['text':'','line_number':1551,'multiline':False]['text':' Note a neg_bottom of 0x400 can not be encoded as an immediate negative','line_number':1552,'multiline':False]['text':' offset in the instruction and this occurs when bottom is zero, so this','line_number':1553,'multiline':False]['text':' case is guarded against below.','line_number':1554,'multiline':False]['text':' sub_off = bottom - off','line_number':1556,'multiline':False]['text':' - sub_off = off - bottom','line_number':1559,'multiline':False]['text':' sub_off = -neg_bottom - off','line_number':1563,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1566,'multiline':False]['text':' - sub_off = neg_bottom + off','line_number':1568,'multiline':False]['text':' sub_off = off - bottom','line_number':1573,'multiline':False]['text':' sub_off = off - bottom','line_number':1576,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1580,'multiline':False]['text':' Guarded against by: bottom != 0','line_number':1583,'multiline':False]['text':' sub_off = neg_bottom + off','line_number':1585,'multiline':False]['text':' Safe to use scratch as dest, since ma_add() overwrites dest at the end','line_number':1591,'multiline':False]['text':' and can't use it as internal scratch since it may also == base.','line_number':1592,'multiline':False]['text':' Without an offset, no second scratch register is necessary.','line_number':1634,'multiline':False]['text':' descriptor_','line_number':1647,'multiline':False]['text':' ARMv7 does not have LSL on an index register with an extended load.','line_number':1720,'multiline':False]['text':' ARMv7 does not have LSL on an index register with an extended load.','line_number':1750,'multiline':False]['text':' We don't have LSL on index register yet.','line_number':1780,'multiline':False]['text':' Use dest as a scratch register.','line_number':1829,'multiline':False]['text':' Use dest as a scratch register.','line_number':1836,'multiline':False]['text':' VFP instructions don't even support register Base + register Index modes,','line_number':1855,'multiline':False]['text':' so just add the index, then handle the offset like normal.','line_number':1856,'multiline':False]['text':' VFP instructions don't even support register Base + register Index modes,','line_number':1880,'multiline':False]['text':' so just add the index, then handle the offset like normal.','line_number':1881,'multiline':False]['text':' VFP instructions don't even support register Base + register Index modes,','line_number':1904,'multiline':False]['text':' so just add the index, then handle the offset like normal.','line_number':1905,'multiline':False]['text':' We don't have LSL on index register yet.','line_number':1981,'multiline':False]['text':' We don't have LSL on index register yet.','line_number':2002,'multiline':False]['text':' Note: this function clobbers the input register.','line_number':2118,'multiline':False]['text':' Convert the double into an unsigned fixed point value with 24 bits of','line_number':2128,'multiline':False]['text':' precision. The resulting number will look like 0xII.DDDDDD','line_number':2129,'multiline':False]['text':' Move the fixed point value into an integer register.','line_number':2133,'multiline':False]['text':' See if this value *might* have been an exact integer after adding','line_number':2141,'multiline':False]['text':' 0.5. This tests the 1/2 through 1/16,777,216th places, but 0.5 needs','line_number':2142,'multiline':False]['text':' to be tested out to the 1/140,737,488,355,328th place.','line_number':2143,'multiline':False]['text':' Convert to a uint8 by shifting out all of the fraction bits.','line_number':2145,'multiline':False]['text':' If any of the bottom 24 bits were non-zero, then we're good, since','line_number':2147,'multiline':False]['text':' this number can't be exactly XX.0','line_number':2148,'multiline':False]['text':' If the lower 32 bits of the double were 0, then this was an exact number,','line_number':2152,'multiline':False]['text':' and it should be even.','line_number':2153,'multiline':False]['text':' Do the add, in place so we can reference it later.','line_number':2163,'multiline':False]['text':' Do the conversion to an integer.','line_number':2165,'multiline':False]['text':' Copy the converted value out.','line_number':2167,'multiline':False]['text':' NaN => 0','line_number':2170,'multiline':False]['text':' NaN','line_number':2171,'multiline':False]['text':' Convert it back to see if we got the same value back.','line_number':2175,'multiline':False]['text':' Do the check.','line_number':2177,'multiline':False]['text':' First or second is NaN, result is NaN.','line_number':2278,'multiline':False]['text':' Make sure we handle -0 and 0 right.','line_number':2280,'multiline':False]['text':' Check for zero.','line_number':2285,'multiline':False]['text':' First wasn't 0 or -0, so just return it.','line_number':2288,'multiline':False]['text':' So now both operands are either -0 or 0.','line_number':2290,'multiline':False]['text':' -0 + -0 = -0 and -0 + 0 = 0.','line_number':2292,'multiline':False]['text':' If the first argument is the NaN, return it; otherwise return the second','line_number':2302,'multiline':False]['text':' operand.','line_number':2303,'multiline':False]['text':' First or second is NaN, result is NaN.','line_number':2325,'multiline':False]['text':' Make sure we handle -0 and 0 right.','line_number':2327,'multiline':False]['text':' Check for zero.','line_number':2332,'multiline':False]['text':' First wasn't 0 or -0, so just return it.','line_number':2335,'multiline':False]['text':' So now both operands are either -0 or 0.','line_number':2337,'multiline':False]['text':' -0 + -0 = -0 and -0 + 0 = 0.','line_number':2339,'multiline':False]['text':' See comment in minMaxDouble.','line_number':2349,'multiline':False]['text':' Compare the doubles, setting vector status flags.','line_number':2362,'multiline':False]['text':' Move vector status bits to normal status flags.','line_number':2369,'multiline':False]['text':' Compare the doubles, setting vector status flags.','line_number':2375,'multiline':False]['text':' Move vector status bits to normal status flags.','line_number':2382,'multiline':False]['text':' Register-based tests.','line_number':2463,'multiline':False]['text':' Unboxing code.','line_number':2755,'multiline':False]['text':' Spectre mitigation: We zero the payload if the tag does not match the','line_number':2768,'multiline':False]['text':' expected type and if this is a pointer type.','line_number':2769,'multiline':False]['text':' We zero the destination register and move the payload into it if','line_number':2775,'multiline':False]['text':' the tag corresponds to the given type.','line_number':2776,'multiline':False]['text':' Spectre mitigation: We zero the payload if the tag does not match the','line_number':2790,'multiline':False]['text':' expected type and if this is a pointer type.','line_number':2791,'multiline':False]['text':' We zero the destination register and move the payload into it if','line_number':2797,'multiline':False]['text':' the tag corresponds to the given type.','line_number':2798,'multiline':False]['text':' If the source is 0, then subtract the dest from itself, producing 0.','line_number':2866,'multiline':False]['text':' Transfer the integral value to a floating point register.','line_number':2872,'multiline':False]['text':' Convert the value to a double.','line_number':2876,'multiline':False]['text':' If the source is 0, then subtract the dest from itself, producing 0.','line_number':2885,'multiline':False]['text':' Transfer the integral value to a floating point register.','line_number':2891,'multiline':False]['text':' Convert the value to a float.','line_number':2895,'multiline':False]['text':' If it's an int, convert to a double.','line_number':2907,'multiline':False]['text':' Not an int, just load as double.','line_number':2919,'multiline':False]['text':' If it's an int, convert it to double.','line_number':2937,'multiline':False]['text':' Since we only have one scratch register, we need to stomp over it with','line_number':2940,'multiline':False]['text':' the tag.','line_number':2941,'multiline':False]['text':' Implicitly requires NUNBOX32_PAYLOAD_OFFSET == 0: no offset provided','line_number':2945,'multiline':False]['text':' Not an int, just load as double.','line_number':2950,'multiline':False]['text':' First, recompute the offset that had been stored in the scratch register','line_number':2952,'multiline':False]['text':' since the scratch register was overwritten loading in the type.','line_number':2953,'multiline':False]['text':' Treat the value as a boolean, and set condition codes accordingly.','line_number':2964,'multiline':False]['text':'///////////////////////////////////////////////////////////////','line_number':3006,'multiline':False]['text':' X86/X64-common (ARM too now) interface.','line_number':3007,'multiline':False]['text':'///////////////////////////////////////////////////////////////','line_number':3008,'multiline':False]['text':' If the offset register is the same as one of the destination','line_number':3049,'multiline':False]['text':' registers, LDRD's behavior is undefined. Use the scratch','line_number':3050,'multiline':False]['text':' register to avoid this.','line_number':3051,'multiline':False]['text':' TODO: copy this code into a generic function that acts on all sequences','line_number':3076,'multiline':False]['text':' of memory accesses','line_number':3077,'multiline':False]['text':' If the value we want is in two consecutive registers starting with an','line_number':3079,'multiline':False]['text':' even register, they can be combined as a single ldrd.','line_number':3080,'multiline':False]['text':' If the value is lower than the type, then we may be able to use an ldm','line_number':3088,'multiline':False]['text':' instruction.','line_number':3089,'multiline':False]['text':' Turns out each of the 4 value -8, -4, 0, 4 corresponds exactly','line_number':3093,'multiline':False]['text':' with one of LDM{DB, DA, IA, IB}','line_number':3094,'multiline':False]['text':' Ensure that loading the payload does not erase the pointer to the Value','line_number':3128,'multiline':False]['text':' in memory.','line_number':3129,'multiline':False]['text':' If NUNBOX32_PAYLOAD_OFFSET is not zero, the memory operand [base + index','line_number':3201,'multiline':False]['text':' << shift + imm] cannot be encoded into a single instruction, and cannot','line_number':3202,'multiline':False]['text':' be integrated into the as_dtr call.','line_number':3203,'multiline':False]['text':' If an offset is used, modify the base so that a [base + index << shift]','line_number':3206,'multiline':False]['text':' instruction format can be used.','line_number':3207,'multiline':False]['text':' Restore the original value of the base, if necessary.','line_number':3215,'multiline':False]['text':' If NUNBOX32_PAYLOAD_OFFSET is not zero, the memory operand [base + index','line_number':3228,'multiline':False]['text':' << shift + imm] cannot be encoded into a single instruction, and cannot','line_number':3229,'multiline':False]['text':' be integrated into the as_dtr call.','line_number':3230,'multiline':False]['text':' Save/restore the base if the BaseIndex has an offset, as above.','line_number':3233,'multiline':False]['text':' Technically, shift > -32 can be handle by changing LSL to ASR, but should','line_number':3238,'multiline':False]['text':' never come up, and this is one less code path to get wrong.','line_number':3239,'multiline':False]['text':' Reserve space for exception information.','line_number':3312,'multiline':False]['text':' Call the handler.','line_number':3319,'multiline':False]['text':' Invalid kind.','line_number':3355,'multiline':False]['text':' No exception handler. Load the error value, load the new stack pointer','line_number':3357,'multiline':False]['text':' and return from the entry frame.','line_number':3358,'multiline':False]['text':' We're going to be returning by the ion calling convention, which returns','line_number':3367,'multiline':False]['text':' by ??? (for now, I think ldr pc, [sp]!)','line_number':3368,'multiline':False]['text':' If we found a catch handler, this must be a baseline frame. Restore state','line_number':3371,'multiline':False]['text':' and jump to the catch block.','line_number':3372,'multiline':False]['text':' If we found a finally block, this must be a baseline frame. Push two','line_number':3384,'multiline':False]['text':' values expected by JSOp::Retsub: BooleanValue(true) and the exception.','line_number':3385,'multiline':False]['text':' Only used in debug mode. Return BaselineFrame->returnValue() to the','line_number':3402,'multiline':False]['text':' caller.','line_number':3403,'multiline':False]['text':' If profiling is enabled, then update the lastProfilingFrame to refer to','line_number':3417,'multiline':False]['text':' caller frame before returning.','line_number':3418,'multiline':False]['text':' Test if profiler enabled.','line_number':3421,'multiline':False]['text':' If we are bailing out to baseline to handle an exception, jump to the','line_number':3432,'multiline':False]['text':' bailout tail stub. Load 1 (true) in ReturnReg to indicate success.','line_number':3433,'multiline':False]['text':' If we are throwing and the innermost frame was a wasm frame, reset SP and','line_number':3444,'multiline':False]['text':' FP; SP is pointing to the unwound return address to the wasm entry, so','line_number':3445,'multiline':False]['text':' we can just ret().','line_number':3446,'multiline':False]['text':' Found a wasm catch handler, restore state and jump to it.','line_number':3457,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3503,'multiline':False]['text':' The argument is a positive number, truncation is the path to glory. Since','line_number':3506,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':3507,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':3508,'multiline':False]['text':' that clamps to INT_MAX.','line_number':3509,'multiline':False]['text':' Move the top word of the double into the output reg, if it is non-zero,','line_number':3517,'multiline':False]['text':' then the original value was -0.0.','line_number':3518,'multiline':False]['text':' Negative case, negate, then start dancing.','line_number':3525,'multiline':False]['text':' Negate the output. Since INT_MIN < -INT_MAX, even after adding 1, the','line_number':3532,'multiline':False]['text':' result will still be a negative number.','line_number':3533,'multiline':False]['text':' Flip the negated input back to its original value.','line_number':3535,'multiline':False]['text':' If the result looks non-negative, then this value didn't actually fit','line_number':3537,'multiline':False]['text':' into the int range, and special handling is required. Zero is also caught','line_number':3538,'multiline':False]['text':' by this case, but floor of a negative number should never be zero.','line_number':3539,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3553,'multiline':False]['text':' The argument is a positive number, truncation is the path to glory; Since','line_number':3556,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':3557,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':3558,'multiline':False]['text':' that clamps to INT_MAX.','line_number':3559,'multiline':False]['text':' Move the top word of the double into the output reg, if it is non-zero,','line_number':3570,'multiline':False]['text':' then the original value was -0.0.','line_number':3571,'multiline':False]['text':' Negative case, negate, then start dancing.','line_number':3579,'multiline':False]['text':' Negate the output. Since INT_MIN < -INT_MAX, even after adding 1, the','line_number':3589,'multiline':False]['text':' result will still be a negative number.','line_number':3590,'multiline':False]['text':' Flip the negated input back to its original value.','line_number':3592,'multiline':False]['text':' If the result looks non-negative, then this value didn't actually fit','line_number':3594,'multiline':False]['text':' into the int range, and special handling is required. Zero is also caught','line_number':3595,'multiline':False]['text':' by this case, but floor of a negative number should never be zero.','line_number':3596,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3609,'multiline':False]['text':' We are in the ]-Inf; 0[ range','line_number':3616,'multiline':False]['text':' If we are in the ]-1; 0[ range => bailout','line_number':3617,'multiline':False]['text':' We are in the ]-Inf; -1] range: ceil(x) == -floor(-x) and floor can be','line_number':3622,'multiline':False]['text':' computed with direct truncation here (x > 0).','line_number':3623,'multiline':False]['text':' Test for 0.0 / -0.0: if the top word of the input double is not zero,','line_number':3632,'multiline':False]['text':' then it was -0 and we need to bail out.','line_number':3633,'multiline':False]['text':' We are in the ]0; +inf] range: truncate integer values, maybe add 1 for','line_number':3640,'multiline':False]['text':' non integer values, maybe bail if overflow.','line_number':3641,'multiline':False]['text':' Bail out if the add overflowed or the result is non positive.','line_number':3648,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3663,'multiline':False]['text':' We are in the ]-Inf; 0[ range','line_number':3668,'multiline':False]['text':' If we are in the ]-1; 0[ range => bailout','line_number':3669,'multiline':False]['text':' We are in the ]-Inf; -1] range: ceil(x) == -floor(-x) and floor can be','line_number':3677,'multiline':False]['text':' computed with direct truncation here (x > 0).','line_number':3678,'multiline':False]['text':' Test for 0.0 / -0.0: if the top word of the input double is not zero,','line_number':3692,'multiline':False]['text':' then it was -0 and we need to bail out.','line_number':3693,'multiline':False]['text':' We are in the ]0; +inf] range: truncate integer values, maybe add 1 for','line_number':3701,'multiline':False]['text':' non integer values, maybe bail if overflow.','line_number':3702,'multiline':False]['text':' Bail on overflow or non-positive result.','line_number':3715,'multiline':False]['text':' Emit a B that can be toggled to a CMP. See ToggleToJmp(), ToggleToCmp().','line_number':3725,'multiline':False]['text':' Do a compare based on the original value, then do most other things based','line_number':3752,'multiline':False]['text':' on the shifted value.','line_number':3753,'multiline':False]['text':' Since we already know the sign bit, flip all numbers to be positive,','line_number':3755,'multiline':False]['text':' stored in tmp.','line_number':3756,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3761,'multiline':False]['text':' The argument is a positive number, truncation is the path to glory; Since','line_number':3764,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':3765,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':3766,'multiline':False]['text':' that clamps to INT_MAX.','line_number':3767,'multiline':False]['text':' Add the biggest number less than 0.5 (not 0.5, because adding that to','line_number':3769,'multiline':False]['text':' the biggest number less than 0.5 would undesirably round up to 1), and','line_number':3770,'multiline':False]['text':' store the result into tmp.','line_number':3771,'multiline':False]['text':' Move the top word of the double into the output reg, if it is non-zero,','line_number':3782,'multiline':False]['text':' then the original value was -0.0','line_number':3783,'multiline':False]['text':' Negative case, negate, then start dancing. This number may be positive,','line_number':3790,'multiline':False]['text':' since we added 0.5.','line_number':3791,'multiline':False]['text':' Add 0.5 to negative numbers, store the result into tmp','line_number':3793,'multiline':False]['text':' -output is now a correctly rounded value, unless the original value was','line_number':3800,'multiline':False]['text':' exactly halfway between two integers, at which point, it has been rounded','line_number':3801,'multiline':False]['text':' away from zero, when it should be rounded towards \infty.','line_number':3802,'multiline':False]['text':' Negate the output. Since INT_MIN < -INT_MAX, even after adding 1, the','line_number':3806,'multiline':False]['text':' result will still be a negative number.','line_number':3807,'multiline':False]['text':' If the result looks non-negative, then this value didn't actually fit','line_number':3810,'multiline':False]['text':' into the int range, and special handling is required, or it was zero,','line_number':3811,'multiline':False]['text':' which means the result is actually -0.0 which also requires special','line_number':3812,'multiline':False]['text':' handling.','line_number':3813,'multiline':False]['text':' Do a compare based on the original value, then do most other things based','line_number':3827,'multiline':False]['text':' on the shifted value.','line_number':3828,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3833,'multiline':False]['text':' The argument is a positive number, truncation is the path to glory; Since','line_number':3836,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':3837,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':3838,'multiline':False]['text':' that clamps to INT_MAX.','line_number':3839,'multiline':False]['text':' Add the biggest number less than 0.5f (not 0.5f, because adding that to','line_number':3841,'multiline':False]['text':' the biggest number less than 0.5f would undesirably round up to 1), and','line_number':3842,'multiline':False]['text':' store the result into tmp.','line_number':3843,'multiline':False]['text':' Note: it doesn't matter whether x + .5 === x or not here, as it doesn't','line_number':3847,'multiline':False]['text':' affect the semantics of the float to unsigned conversion (in particular,','line_number':3848,'multiline':False]['text':' we are not applying any fixup after the operation).','line_number':3849,'multiline':False]['text':' Move the whole float32 into the output reg, if it is non-zero, then the','line_number':3858,'multiline':False]['text':' original value was -0.0.','line_number':3859,'multiline':False]['text':' Add 0.5 to negative numbers, storing the result into tmp.','line_number':3867,'multiline':False]['text':' Adding 0.5 to a float input has chances to yield the wrong result, if','line_number':3872,'multiline':False]['text':' the input is too large. In this case, skip the -1 adjustment made below.','line_number':3873,'multiline':False]['text':' Negative case, negate, then start dancing. This number may be positive,','line_number':3876,'multiline':False]['text':' since we added 0.5.','line_number':3877,'multiline':False]['text':' /!\ The conditional jump afterwards depends on these two instructions','line_number':3878,'multiline':False]['text':'     *not* setting the status flags. They need to not change after the','line_number':3879,'multiline':False]['text':'     comparison above.','line_number':3880,'multiline':False]['text':' -output is now a correctly rounded value, unless the original value was','line_number':3887,'multiline':False]['text':' exactly halfway between two integers, at which point, it has been rounded','line_number':3888,'multiline':False]['text':' away from zero, when it should be rounded towards \infty.','line_number':3889,'multiline':False]['text':' Negate the output. Since INT_MIN < -INT_MAX, even after adding 1, the','line_number':3894,'multiline':False]['text':' result will still be a negative number.','line_number':3895,'multiline':False]['text':' If the result looks non-negative, then this value didn't actually fit','line_number':3899,'multiline':False]['text':' into the int range, and special handling is required, or it was zero,','line_number':3900,'multiline':False]['text':' which means the result is actually -0.0 which also requires special','line_number':3901,'multiline':False]['text':' handling.','line_number':3902,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3915,'multiline':False]['text':' We are in the ]-Inf; 0[ range','line_number':3922,'multiline':False]['text':' If we are in the ]-1; 0[ range => bailout','line_number':3923,'multiline':False]['text':' We are in the ]-Inf; -1] range: trunc(x) == -floor(-x) and floor can be','line_number':3928,'multiline':False]['text':' computed with direct truncation here (x > 0).','line_number':3929,'multiline':False]['text':' Test for 0.0 / -0.0: if the top word of the input double is not zero,','line_number':3937,'multiline':False]['text':' then it was -0 and we need to bail out.','line_number':3938,'multiline':False]['text':' We are in the ]0; +inf] range: truncation is the path to glory. Since','line_number':3945,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':3946,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':3947,'multiline':False]['text':' that clamps to INT_MAX.','line_number':3948,'multiline':False]['text':' NaN is always a bail condition, just bail directly.','line_number':3965,'multiline':False]['text':' We are in the ]-Inf; 0[ range','line_number':3970,'multiline':False]['text':' If we are in the ]-1; 0[ range => bailout','line_number':3971,'multiline':False]['text':' We are in the ]-Inf; -1] range: trunc(x) == -floor(-x) and floor can be','line_number':3979,'multiline':False]['text':' computed with direct truncation here (x > 0).','line_number':3980,'multiline':False]['text':' Test for 0.0 / -0.0: if the top word of the input double is not zero,','line_number':3994,'multiline':False]['text':' then it was -0 and we need to bail out.','line_number':3995,'multiline':False]['text':' We are in the ]0; +inf] range: truncation is the path to glory; Since','line_number':4003,'multiline':False]['text':' it is known to be > 0.0, explicitly convert to a larger range, then a','line_number':4004,'multiline':False]['text':' value that rounds to INT_MAX is explicitly different from an argument','line_number':4005,'multiline':False]['text':' The argument is a positive number,','line_number':4008,'multiline':False]['text':' that clamps to INT_MAX.','line_number':4009,'multiline':False]['text':'{{{ check_macroassembler_style','line_number':4059,'multiline':False]['text':' ===============================================================','line_number':4060,'multiline':False]['text':' MacroAssembler high-level usage.','line_number':4061,'multiline':False]['text':' ===============================================================','line_number':4067,'multiline':False]['text':' Stack manipulation functions.','line_number':4068,'multiline':False]['text':' It's possible that the logic is just fine as it is if the reduced set','line_number':4099,'multiline':False]['text':' maps SIMD pairs to plain doubles and transferMultipleByRuns() stores','line_number':4100,'multiline':False]['text':' and loads doubles.','line_number':4101,'multiline':False]['text':' See above.','line_number':4144,'multiline':False]['text':' "The amount of space actually used does not exceed what','line_number':4157,'multiline':False]['text':' `PushRegsInMaskSizeInBytes` claims will be used."','line_number':4158,'multiline':False]['text':' See above.','line_number':4171,'multiline':False]['text':' ARM can load multiple registers at once, but only if we want back all','line_number':4176,'multiline':False]['text':' the registers we previously saved to the stack.','line_number':4177,'multiline':False]['text':' ===============================================================','line_number':4274,'multiline':False]['text':' Simple call functions.','line_number':4275,'multiline':False]['text':' For now, assume that it'll be nearby.','line_number':4283,'multiline':False]['text':' The caller ensures that the call is always in range using thunks (below)','line_number':4315,'multiline':False]['text':' as necessary.','line_number':4316,'multiline':False]['text':' documentation ','line_number':4317,'multiline':True]['text':' The goal of the thunk is to be able to jump to any address without the','line_number':4334,'multiline':False]['text':' usual 32MiB branch range limitation. Additionally, to make the thunk','line_number':4335,'multiline':False]['text':' simple to use, the thunk does not use the constant pool or require','line_number':4336,'multiline':False]['text':' patching an absolute address. Instead, a relative offset is used which','line_number':4337,'multiline':False]['text':' can be patched during compilation.','line_number':4338,'multiline':False]['text':' Inhibit pools since these three words must be contiguous so that the offset','line_number':4340,'multiline':False]['text':' calculations below are valid.','line_number':4341,'multiline':False]['text':' When pc is used, the read value is the address of the instruction + 8.','line_number':4344,'multiline':False]['text':' This is exactly the address of the uint32 word we want to load.','line_number':4345,'multiline':False]['text':' Branch by making pc the destination register.','line_number':4349,'multiline':False]['text':' Allocate space which will be patched by patchFarJump().','line_number':4352,'multiline':False]['text':' When pc is read as the operand of the add, its value is the address of','line_number':4367,'multiline':False]['text':' the add instruction + 8.','line_number':4368,'multiline':False]['text':' max number of instructions in scope = ','line_number':4374,'multiline':True]['text':' ===============================================================','line_number':4398,'multiline':False]['text':' ABI function calls.','line_number':4399,'multiline':False]['text':' Force sp to be aligned.','line_number':4406,'multiline':False]['text':' sizeof(intptr_t) accounts for the saved stack pointer pushed by','line_number':4416,'multiline':False]['text':' setupUnalignedABICall.','line_number':4417,'multiline':False]['text':' Position all arguments.','line_number':4429,'multiline':False]['text':' Save the lr register if we need to preserve it.','line_number':4443,'multiline':False]['text':' Calls to native functions in wasm pass through a thunk which already','line_number':4455,'multiline':False]['text':' fixes up the return value for us.','line_number':4456,'multiline':False]['text':' Move double from r0/r1 to ReturnFloatReg.','line_number':4460,'multiline':False]['text':' Move float32 from r0 to ReturnFloatReg.','line_number':4464,'multiline':False]['text':' While the x86 supports pop esp, on ARM that isn't well defined, so','line_number':4477,'multiline':False]['text':' just do it manually.','line_number':4478,'multiline':False]['text':' Load the callee in r12, as above.','line_number':4489,'multiline':False]['text':' Load the callee in r12, no instruction between the ldr and call should','line_number':4499,'multiline':False]['text':' clobber it. Note that we can't use fun.base because it may be one of the','line_number':4500,'multiline':False]['text':' IntArg registers clobbered before the call.','line_number':4501,'multiline':False]['text':' ===============================================================','line_number':4512,'multiline':False]['text':' Jit Frames.','line_number':4513,'multiline':False]['text':' On ARM any references to the pc, adds an additional 8 to it, which','line_number':4516,'multiline':False]['text':' correspond to 2 instructions of 4 bytes.  Thus we use an additional nop','line_number':4517,'multiline':False]['text':' to pad until we reach the pushed pc.','line_number':4518,'multiline':False]['text':'','line_number':4519,'multiline':False]['text':' Note: In practice this should not be necessary, as this fake return','line_number':4520,'multiline':False]['text':' address is never used for resuming any execution. Thus theoriticaly we','line_number':4521,'multiline':False]['text':' could just do a Push(pc), and ignore the nop as well as the pool.','line_number':4522,'multiline':False]['text':' actually pushes $pc + 8.','line_number':4525,'multiline':False]['text':' ===============================================================','line_number':4539,'multiline':False]['text':' Move instructions','line_number':4540,'multiline':False]['text':' Either one or both of the source registers could be the same as a','line_number':4576,'multiline':False]['text':' destination register.','line_number':4577,'multiline':False]['text':' If both are, this is just a swap of two registers.','line_number':4580,'multiline':False]['text':' If only one is, copy that source first.','line_number':4589,'multiline':False]['text':' ===============================================================','line_number':4611,'multiline':False]['text':' Branch functions','line_number':4612,'multiline':False]['text':' If cond == NotEqual, branch when a.payload != b.payload || a.tag !=','line_number':4671,'multiline':False]['text':' b.tag. If the payloads are equal, compare the tags. If the payloads are','line_number':4672,'multiline':False]['text':' not equal, short circuit true (NotEqual).','line_number':4673,'multiline':False]['text':'','line_number':4674,'multiline':False]['text':' If cand == Equal, branch when a.payload == b.payload && a.tag == b.tag.','line_number':4675,'multiline':False]['text':' If the payloads are equal, compare the tags. If the payloads are not','line_number':4676,'multiline':False]['text':' equal, short circuit false (NotEqual).','line_number':4677,'multiline':False]['text':' ========================================================================','line_number':4689,'multiline':False]['text':' Memory access primitives.','line_number':4690,'multiline':False]['text':' Store the type tag if needed.','line_number':4700,'multiline':False]['text':' Store the payload.','line_number':4705,'multiline':False]['text':' isUnsigned= ','line_number':4751,'multiline':True]['text':' isUnsigned= ','line_number':4759,'multiline':True]['text':' isUnsigned= ','line_number':4767,'multiline':True]['text':' isUnsigned= ','line_number':4775,'multiline':True]['text':' ========================================================================','line_number':4843,'multiline':False]['text':' Primitive atomic operations.','line_number':4844,'multiline':False]['text':' General algorithm:','line_number':4872,'multiline':False]['text':'','line_number':4873,'multiline':False]['text':'     ...    ptr, <addr>         ; compute address of item','line_number':4874,'multiline':False]['text':'     dmb','line_number':4875,'multiline':False]['text':' L0  ldrex* output, [ptr]','line_number':4876,'multiline':False]['text':'     sxt*   output, output, 0   ; sign-extend if applicable','line_number':4877,'multiline':False]['text':'     *xt*   tmp, oldval, 0      ; sign-extend or zero-extend if applicable','line_number':4878,'multiline':False]['text':'     cmp    output, tmp','line_number':4879,'multiline':False]['text':'     bne    L1                  ; failed - values are different','line_number':4880,'multiline':False]['text':'     strex* tmp, newval, [ptr]','line_number':4881,'multiline':False]['text':'     cmp    tmp, 1','line_number':4882,'multiline':False]['text':'     beq    L0                  ; failed - location is dirty, retry','line_number':4883,'multiline':False]['text':' L1  dmb','line_number':4884,'multiline':False]['text':'','line_number':4885,'multiline':False]['text':' Discussion here:  http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html.','line_number':4886,'multiline':False]['text':' However note that that discussion uses 'isb' as the trailing fence.','line_number':4887,'multiline':False]['text':' I've not quite figured out why, and I've gone with dmb here which','line_number':4888,'multiline':False]['text':' is safe.  Also see the LLVM source, which uses 'dmb ish' generally.','line_number':4889,'multiline':False]['text':' (Apple's Swift CPU apparently handles ish in a non-default, faster','line_number':4890,'multiline':False]['text':' way.)','line_number':4891,'multiline':False]['text':' Bug 1077321: We may further optimize for ARMv8 (AArch32) here.','line_number':5006,'multiline':False]['text':' General algorithm:','line_number':5079,'multiline':False]['text':'','line_number':5080,'multiline':False]['text':'     ...    ptr, <addr>         ; compute address of item','line_number':5081,'multiline':False]['text':'     dmb','line_number':5082,'multiline':False]['text':' L0  ldrex* output, [ptr]','line_number':5083,'multiline':False]['text':'     sxt*   output, output, 0   ; sign-extend if applicable','line_number':5084,'multiline':False]['text':'     OP     tmp, output, value  ; compute value to store','line_number':5085,'multiline':False]['text':'     strex* tmp2, tmp, [ptr]    ; tmp2 required by strex','line_number':5086,'multiline':False]['text':'     cmp    tmp2, 1','line_number':5087,'multiline':False]['text':'     beq    L0                  ; failed - location is dirty, retry','line_number':5088,'multiline':False]['text':'     dmb                        ; ordering barrier required','line_number':5089,'multiline':False]['text':'','line_number':5090,'multiline':False]['text':' Also see notes above at compareExchange re the barrier strategy.','line_number':5091,'multiline':False]['text':'','line_number':5092,'multiline':False]['text':' Observe that the value being operated into the memory element need','line_number':5093,'multiline':False]['text':' not be sign-extended because no OP will make use of bits to the','line_number':5094,'multiline':False]['text':' left of the bits indicated by the width of the element, and neither','line_number':5095,'multiline':False]['text':' output nor the bits stored are affected by OP.','line_number':5096,'multiline':False]['text':' Rd must differ from the two other arguments to strex.','line_number':5161,'multiline':False]['text':' Uses both scratch registers, one for the address and one for a temp,','line_number':5209,'multiline':False]['text':' but needs two temps for strex:','line_number':5210,'multiline':False]['text':'','line_number':5211,'multiline':False]['text':'     ...    ptr, <addr>         ; compute address of item','line_number':5212,'multiline':False]['text':'     dmb','line_number':5213,'multiline':False]['text':' L0  ldrex* temp, [ptr]','line_number':5214,'multiline':False]['text':'     OP     temp, temp, value   ; compute value to store','line_number':5215,'multiline':False]['text':'     strex* temp2, temp, [ptr]','line_number':5216,'multiline':False]['text':'     cmp    temp2, 1','line_number':5217,'multiline':False]['text':'     beq    L0                  ; failed - location is dirty, retry','line_number':5218,'multiline':False]['text':'     dmb                        ; ordering barrier required','line_number':5219,'multiline':False]['text':' Rd must differ from the two other arguments to strex.','line_number':5276,'multiline':False]['text':' Rd (temp) must differ from the two other arguments to strex.','line_number':5385,'multiline':False]['text':' We could avoid this pair requirement but in that case we would end up','line_number':5504,'multiline':False]['text':' with two moves in the loop to preserve the loaded value in output.  The','line_number':5505,'multiline':False]['text':' prize would be less register spilling around this op since the pair','line_number':5506,'multiline':False]['text':' requirement will tend to force more spilling.','line_number':5507,'multiline':False]['text':' Rd (temp) must differ from the two other arguments to strex.','line_number':5549,'multiline':False]['text':' ========================================================================','line_number':5603,'multiline':False]['text':' JS atomic operations.','line_number':5604,'multiline':False]['text':' ========================================================================','line_number':5705,'multiline':False]['text':' Primitive atomic operations.','line_number':5706,'multiline':False]['text':' ========================================================================','line_number':5730,'multiline':False]['text':' Convert floating point.','line_number':5731,'multiline':False]['text':' Currently this helper can't handle this situation.','line_number':5778,'multiline':False]['text':' Ensure that the output registers are saved and restored properly,','line_number':5788,'multiline':False]['text':' Currently this helper can't handle this situation.','line_number':5836,'multiline':False]['text':' Ensure that the output registers are saved and restored properly,','line_number':5844,'multiline':False]['text':' ========================================================================','line_number':5881,'multiline':False]['text':' Spectre Mitigations.','line_number':5882,'multiline':False]['text':' Spectre mitigation recommended by ARM for cases where csel/cmov cannot be','line_number':5885,'multiline':False]['text':' used.','line_number':5886,'multiline':False]['text':'}}} check_macroassembler_style','line_number':5945,'multiline':False]['text':' ARM conversion instructions clamp the value to ensure it fits within the','line_number':5955,'multiline':False]['text':' target's type bounds, so every time we see those, we need to check the','line_number':5956,'multiline':False]['text':' input. A NaN check is not necessary because NaN is converted to zero and','line_number':5957,'multiline':False]['text':' on a zero result we branch out of line to do further processing anyway.','line_number':5958,'multiline':False]['text':' int32_t(UINT32_MAX) == -1.','line_number':5971,'multiline':False]['text':' vcvt* converts NaN into 0, so check for NaNs here.','line_number':5980,'multiline':False]['text':' On ARM, saturating truncation codegen handles saturating itself rather','line_number':6015,'multiline':False]['text':' than relying on out-of-line fixup code.','line_number':6016,'multiline':False]['text':' Eagerly take care of NaNs.','line_number':6025,'multiline':False]['text':' Handle special values.','line_number':6036,'multiline':False]['text':' By default test for the following inputs and bail:','line_number':6039,'multiline':False]['text':' signed:   ] -Inf, INTXX_MIN - 1.0 ] and [ INTXX_MAX + 1.0 : +Inf [','line_number':6040,'multiline':False]['text':' unsigned: ] -Inf, -1.0 ] and [ UINTXX_MAX + 1.0 : +Inf [','line_number':6041,'multiline':False]['text':' Note: we cannot always represent those exact values. As a result','line_number':6042,'multiline':False]['text':' this changes the actual comparison a bit.','line_number':6043,'multiline':False]['text':' In the float32/double range there exists no value between','line_number':6052,'multiline':False]['text':' INT64_MIN and INT64_MIN - 1.0. Making INT64_MIN the lower-bound.','line_number':6053,'multiline':False]['text':' In the float32 range there exists no value between','line_number':6064,'multiline':False]['text':' INT32_MIN and INT32_MIN - 1.0. Making INT32_MIN the lower-bound.','line_number':6065,'multiline':False]['text':' We had an actual correct value, get back to where we were.','line_number':6092,'multiline':False]['text':' Handle errors.','line_number':6095,'multiline':False]['text':' Maybe add the offset.','line_number':6117,'multiline':False]['text':' signed = ','line_number':6136,'multiline':True]['text':' FP loads can't use VLDR as that has stringent alignment checks and will','line_number':6164,'multiline':False]['text':' SIGBUS on unaligned accesses.  Choose a different strategy depending on','line_number':6165,'multiline':False]['text':' the available hardware. We don't gate Wasm on the presence of NEON.','line_number':6166,'multiline':False]['text':' NEON available: The VLD1 multiple-single-elements variant will only','line_number':6168,'multiline':False]['text':' trap if SCTRL.A==1, but we already assume (for integer accesses) that','line_number':6169,'multiline':False]['text':' the hardware/OS handles that transparently.','line_number':6170,'multiline':False]['text':'','line_number':6171,'multiline':False]['text':' An additional complication is that if we're targeting the high single','line_number':6172,'multiline':False]['text':' then an unaligned load is not possible, and we may need to go via the','line_number':6173,'multiline':False]['text':' FPR scratch.','line_number':6174,'multiline':False]['text':' NEON not available: Load to GPR scratch, move to FPR destination.  We','line_number':6183,'multiline':False]['text':' don't have adjacent scratches for the f64, so use individual LDRs,','line_number':6184,'multiline':False]['text':' not LDRD.','line_number':6185,'multiline':False]['text':' The trap information is associated with the load of the high word,','line_number':6193,'multiline':False]['text':' which must be done first.','line_number':6194,'multiline':False]['text':' Maybe add the offset.','line_number':6228,'multiline':False]['text':' We need to store the high word of an Int64 first, so always adjust the','line_number':6231,'multiline':False]['text':' pointer to point to the high word in this case.  The adjustment is always','line_number':6232,'multiline':False]['text':' OK because wasmMaxOffsetGuardLimit is computed so that we can add up to','line_number':6233,'multiline':False]['text':' sizeof(LargestValue)-1 without skipping past the guard page, and we','line_number':6234,'multiline':False]['text':' assert above that offset < wasmMaxOffsetGuardLimit.','line_number':6235,'multiline':False]['text':' bits ','line_number':6248,'multiline':True]['text':' signed ','line_number':6248,'multiline':True]['text':' bits ','line_number':6254,'multiline':True]['text':' signed ','line_number':6254,'multiline':True]['text':' See comments above at wasmLoadImpl for more about this logic.','line_number':6264,'multiline':False]['text':' NEON not available: Move FPR to GPR scratch, store GPR.  We have only','line_number':6274,'multiline':False]['text':' one scratch to hold the value, so for f64 we must do two separate','line_number':6275,'multiline':False]['text':' moves.  That's OK - this is really a corner case.  If we really cared','line_number':6276,'multiline':False]['text':' we would pass in a temp to avoid the second move.','line_number':6277,'multiline':False]['text':' The trap information is associated with the store of the high word,','line_number':6284,'multiline':False]['text':' which must be done first.','line_number':6285,'multiline':False]['text':' see AsmJSStoreHeap;','line_number':6299,'multiline':False]['text':' bits ','line_number':6302,'multiline':True]