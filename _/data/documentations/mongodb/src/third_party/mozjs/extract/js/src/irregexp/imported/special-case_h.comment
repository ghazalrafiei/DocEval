['text':' Copyright 2019 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]['text':' Use of this source code is governed by a BSD-style license that can be','line_number':2,'multiline':False]['text':' found in the LICENSE file.','line_number':3,'multiline':False]['text':' Sets of Unicode characters that need special handling under "i" mode','line_number':18,'multiline':False]['text':' For non-unicode ignoreCase matches (aka "i", not "iu"), ECMA 262','line_number':20,'multiline':False]['text':' defines slightly different case-folding rules than Unicode. An','line_number':21,'multiline':False]['text':' input character should match a pattern character if the result of','line_number':22,'multiline':False]['text':' the Canonicalize algorithm is the same for both characters.','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' Roughly speaking, for "i" regexps, Canonicalize(c) is the same as','line_number':25,'multiline':False]['text':' c.toUpperCase(), unless a) c.toUpperCase() is a multi-character','line_number':26,'multiline':False]['text':' string, or b) c is non-ASCII, and c.toUpperCase() is ASCII. See','line_number':27,'multiline':False]['text':' https://tc39.es/ecma262/#sec-runtime-semantics-canonicalize-ch for','line_number':28,'multiline':False]['text':' the precise definition.','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' While compiling such regular expressions, we need to compute the','line_number':31,'multiline':False]['text':' set of characters that should match a given input character. (See','line_number':32,'multiline':False]['text':' GetCaseIndependentLetters and CharacterRange::AddCaseEquivalents.)','line_number':33,'multiline':False]['text':' For almost all characters, this can be efficiently computed using','line_number':34,'multiline':False]['text':' UnicodeSet::closeOver(USET_CASE_INSENSITIVE). These sets represent','line_number':35,'multiline':False]['text':' the remaining special cases.','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' For a character c, the rules are as follows:','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' 1. If c is in neither IgnoreSet nor SpecialAddSet, then calling','line_number':40,'multiline':False]['text':'    UnicodeSet::closeOver(USET_CASE_INSENSITIVE) on a UnicodeSet','line_number':41,'multiline':False]['text':'    containing c will produce the set of characters that should','line_number':42,'multiline':False]['text':'    match /c/i (or /[c]/i), and only those characters.','line_number':43,'multiline':False]['text':'','line_number':44,'multiline':False]['text':' 2. If c is in IgnoreSet, then the only character it should match is','line_number':45,'multiline':False]['text':'    itself. However, closeOver will add additional incorrect','line_number':46,'multiline':False]['text':'    matches. For example, consider SHARP S: 'ß' (U+00DF) and 'ẞ'','line_number':47,'multiline':False]['text':'    (U+1E9E). Although closeOver('ß') = "ßẞ", uppercase('ß') is','line_number':48,'multiline':False]['text':'    "SS".  Step 3.e therefore requires that 'ß' canonicalizes to','line_number':49,'multiline':False]['text':'    itself, and should not match 'ẞ'. In these cases, we can skip','line_number':50,'multiline':False]['text':'    the closeOver entirely, because it will never add an equivalent','line_number':51,'multiline':False]['text':'    character.','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':' 3. If c is in SpecialAddSet, then it should match at least one','line_number':54,'multiline':False]['text':'    character other than itself. However, closeOver will add at','line_number':55,'multiline':False]['text':'    least one additional incorrect match. For example, consider the','line_number':56,'multiline':False]['text':'    letter 'k'. Closing over 'k' gives "kKK" (lowercase k, uppercase','line_number':57,'multiline':False]['text':'    K, U+212A KELVIN SIGN). However, because of step 3.g, KELVIN','line_number':58,'multiline':False]['text':'    SIGN should not match either of the other two characters. As a','line_number':59,'multiline':False]['text':'    result, "k" and "K" are in SpecialAddSet (and KELVIN SIGN is in','line_number':60,'multiline':False]['text':'    IgnoreSet). To find the correct matches for characters in','line_number':61,'multiline':False]['text':'    SpecialAddSet, we closeOver the original character, but filter','line_number':62,'multiline':False]['text':'    out the results that do not have the same canonical value.','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':' The contents of these sets are calculated at build time by','line_number':65,'multiline':False]['text':' src/regexp/gen-regexp-special-case.cc, which generates','line_number':66,'multiline':False]['text':' gen/src/regexp/special-case.cc. This is done by iterating over the','line_number':67,'multiline':False]['text':' result of closeOver for each BMP character, and finding sets for','line_number':68,'multiline':False]['text':' which at least one character has a different canonical value than','line_number':69,'multiline':False]['text':' another character. Characters that match no other characters in','line_number':70,'multiline':False]['text':' their equivalence class are added to IgnoreSet. Characters that','line_number':71,'multiline':False]['text':' match at least one other character are added to SpecialAddSet.','line_number':72,'multiline':False]['text':' This implements ECMAScript 2020 21.2.2.8.2 (Runtime Semantics:','line_number':79,'multiline':False]['text':' Canonicalize) step 3, which is used to determine whether','line_number':80,'multiline':False]['text':' characters match when ignoreCase is true and unicode is false.','line_number':81,'multiline':False]['text':' a. Assert: ch is a UTF-16 code unit.','line_number':83,'multiline':False]['text':' b. Let s be the String value consisting of the single code unit ch.','line_number':86,'multiline':False]['text':' c. Let u be the same result produced as if by performing the algorithm','line_number':89,'multiline':False]['text':' for String.prototype.toUpperCase using s as the this value.','line_number':90,'multiline':False]['text':' d. Assert: Type(u) is String.','line_number':91,'multiline':False]['text':' e. If u does not consist of a single code unit, return ch.','line_number':94,'multiline':False]['text':' f. Let cu be u's single code unit element.','line_number':99,'multiline':False]['text':' g. If the value of ch >= 128 and the value of cu < 128, return ch.','line_number':102,'multiline':False]['text':' h. Return cu.','line_number':107,'multiline':False]['text':' namespace internal','line_number':112,'multiline':False]['text':' namespace v8','line_number':113,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':115,'multiline':False]['text':' V8_REGEXP_SPECIAL_CASE_H_','line_number':117,'multiline':False]