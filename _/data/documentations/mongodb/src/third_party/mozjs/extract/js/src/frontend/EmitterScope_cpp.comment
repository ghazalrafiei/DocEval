['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JSMSG_*','line_number':13,'multiline':False]['text':' ClassBodyLexicalEnvironmentObject','line_number':14,'multiline':False]['text':' js_*_str','line_number':16,'multiline':False]['text':' If we're compiling module, enclosingScope is nullptr and it means empty','line_number':57,'multiline':False]['text':' global scope.','line_number':58,'multiline':False]['text':' See also the assertion in CompilationStencil::instantiateStencils.','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':' Global script also uses enclosingScope == nullptr, but it shouldn't call','line_number':61,'multiline':False]['text':' checkEnvironmentChainLength.','line_number':62,'multiline':False]['text':' There is an enclosing scope with access to the same frame.','line_number':109,'multiline':False]['text':' We are currently compiling the enclosing script, look in the','line_number':114,'multiline':False]['text':' enclosing BCE.','line_number':115,'multiline':False]['text':' NOTE: A value of Nothing for the ScopeIndex will occur when the enclosing','line_number':127,'multiline':False]['text':' scope is the empty-global-scope. This is only allowed for self-hosting','line_number':128,'multiline':False]['text':' code.','line_number':129,'multiline':False]['text':' The enclosing script is already compiled or the current script is the','line_number':135,'multiline':False]['text':' global script.','line_number':136,'multiline':False]['text':' static ','line_number':140,'multiline':True]['text':' '.generator' cannot be accessed by name.','line_number':143,'multiline':False]['text':' Start searching in the current compilation.','line_number':153,'multiline':False]['text':' If the name is not found in the current compilation, walk the Scope','line_number':174,'multiline':False]['text':' chain encompassing the compilation.','line_number':175,'multiline':False]['text':' Each script has its own frame. A free name that is accessed','line_number':186,'multiline':False]['text':' from an inner script must not be a frame slot access. If this','line_number':187,'multiline':False]['text':' assertion is hit, it is a bug in the free name analysis in the','line_number':188,'multiline':False]['text':' parser.','line_number':189,'multiline':False]['text':' It is always correct to not cache the location. Ignore OOMs to make','line_number':192,'multiline':False]['text':' lookups infallible.','line_number':193,'multiline':False]['text':' Only the self-hosted top-level script uses this. If this changes, you must','line_number':202,'multiline':False]['text':' update ScopeStencil::enclosing.','line_number':203,'multiline':False]['text':' Lexical bindings throw ReferenceErrors if they are used before','line_number':245,'multiline':False]['text':' initialization. See ES6 8.1.1.1.6.','line_number':246,'multiline':False]['text':'','line_number':247,'multiline':False]['text':' For completeness, lexical bindings are initialized in ES6 by calling','line_number':248,'multiline':False]['text':' InitializeBinding, after which touching the binding will no longer','line_number':249,'multiline':False]['text':' throw reference errors. See 13.1.11, 9.2.13, 13.6.3.4, 13.6.4.6,','line_number':250,'multiline':False]['text':' 13.6.4.8, 13.14.5, 15.1.8, and 15.2.0.15.','line_number':251,'multiline':False]['text':'','line_number':252,'multiline':False]['text':' This code is also used to reset `var`s to `undefined` when entering an','line_number':253,'multiline':False]['text':' extra body var scope; and to clear slots when leaving a block, in','line_number':254,'multiline':False]['text':' generators and async functions, to avoid keeping garbage alive','line_number':255,'multiline':False]['text':' indefinitely.','line_number':256,'multiline':False]['text':' Resolve bindings.','line_number':344,'multiline':False]['text':' isNamedLambda = ','line_number':347,'multiline':True]['text':' After interning the VM scope we can get the scope index.','line_number':376,'multiline':False]['text':' Lexical scopes need notes to be mapped from a pc.','line_number':382,'multiline':False]['text':' Put frame slots in TDZ. Environment slots are poisoned during','line_number':387,'multiline':False]['text':' environment creation.','line_number':388,'multiline':False]['text':'','line_number':389,'multiline':False]['text':' This must be done after appendScopeNote to be considered in the extent','line_number':390,'multiline':False]['text':' of the scope.','line_number':391,'multiline':False]['text':' Resolve bindings.','line_number':408,'multiline':False]['text':' After interning the VM scope we can get the scope index.','line_number':440,'multiline':False]['text':'','line_number':441,'multiline':False]['text':' ClassBody uses PushClassBodyEnv, however, PopLexicalEnv supports both','line_number':442,'multiline':False]['text':' cases and doesn't need extra specialization.','line_number':443,'multiline':False]['text':' Lexical scopes need notes to be mapped from a pc.','line_number':449,'multiline':False]['text':' isNamedLambda = ','line_number':466,'multiline':True]['text':' The lambda name, if not closed over, is accessed via JSOp::Callee and','line_number':469,'multiline':False]['text':' not a frame slot. Do not update frame slot information.','line_number':470,'multiline':False]['text':' If there are parameter expressions, there is an extra var scope.','line_number':499,'multiline':False]['text':' Resolve body-level bindings, if there are any.','line_number':508,'multiline':False]['text':' The only duplicate bindings that occur are simple formal','line_number':522,'multiline':False]['text':' parameters, in which case the last position counts, so update the','line_number':523,'multiline':False]['text':' location.','line_number':524,'multiline':False]['text':' If the function's scope may be extended at runtime due to sloppy direct','line_number':544,'multiline':False]['text':' eval, any names beyond the function scope must be accessed dynamically as','line_number':545,'multiline':False]['text':' we don't know if the name will become a 'var' binding due to direct eval.','line_number':546,'multiline':False]['text':' If the function is standalone, the enclosing scope is either an empty','line_number':550,'multiline':False]['text':' global or non-syntactic scope, and there's no static bindings.','line_number':551,'multiline':False]['text':' In case of parameter expressions, the parameters are lexical','line_number':561,'multiline':False]['text':' bindings and have TDZ.','line_number':562,'multiline':False]['text':' The extra var scope is never popped once it's entered. It replaces the','line_number':604,'multiline':False]['text':' function scope as the var emitter scope.','line_number':605,'multiline':False]['text':' Resolve body-level bindings, if there are any.','line_number':612,'multiline':False]['text':' If any of the bound slots were previously used, reset them to undefined.','line_number':631,'multiline':False]['text':' This doesn't break TDZ for let/const/class bindings because there aren't','line_number':632,'multiline':False]['text':' any in extra body var scopes. We assert above that bi.kind() is Var.','line_number':633,'multiline':False]['text':' If the extra var scope may be extended at runtime due to sloppy','line_number':644,'multiline':False]['text':' direct eval, any names beyond the var scope must be accessed','line_number':645,'multiline':False]['text':' dynamically as we don't know if the name will become a 'var' binding','line_number':646,'multiline':False]['text':' due to direct eval.','line_number':647,'multiline':False]['text':' Create and intern the VM scope.','line_number':652,'multiline':False]['text':' The extra var scope needs a note to be mapped from a pc.','line_number':671,'multiline':False]['text':' TODO-Stencil','line_number':683,'multiline':False]['text':'   This is another snapshot-sensitive location.','line_number':684,'multiline':False]['text':'   The incoming atoms from the global scope object should be snapshotted.','line_number':685,'multiline':False]['text':'   For now, converting them to ParserAtoms here individually.','line_number':686,'multiline':False]['text':' In self-hosting, it is incorrect to consult the global scope because','line_number':695,'multiline':False]['text':' self-hosted scripts are cloned into their target compartments before','line_number':696,'multiline':False]['text':' they are run. Instead of Global, Intrinsic is used for all names.','line_number':697,'multiline':False]['text':'','line_number':698,'multiline':False]['text':' Intrinsic lookups are redirected to the special intrinsics holder','line_number':699,'multiline':False]['text':' in the global object, into which any missing values are cloned','line_number':700,'multiline':False]['text':' lazily upon first access.','line_number':701,'multiline':False]['text':' See: JSScript::outermostScope.','line_number':717,'multiline':False]['text':' Resolve binding names.','line_number':721,'multiline':False]['text':'','line_number':722,'multiline':False]['text':' NOTE: BytecodeEmitter::emitDeclarationInstantiation will emit the','line_number':723,'multiline':False]['text':'       redeclaration check and initialize these bindings.','line_number':724,'multiline':False]['text':' Note that to save space, we don't add free names to the cache for','line_number':734,'multiline':False]['text':' global scopes. They are assumed to be global vars in the syntactic','line_number':735,'multiline':False]['text':' global scope, dynamic accesses under non-syntactic global scope.','line_number':736,'multiline':False]['text':' Create the `var` scope. Note that there is also a lexical scope, created','line_number':755,'multiline':False]['text':' separately in emitScript().','line_number':756,'multiline':False]['text':' For simplicity, treat all free name lookups in nonstrict eval scripts as','line_number':787,'multiline':False]['text':' dynamic.','line_number':788,'multiline':False]['text':' NOTE: BytecodeEmitter::emitDeclarationInstantiation will emit the','line_number':797,'multiline':False]['text':'       redeclaration check and initialize these bindings for sloppy','line_number':798,'multiline':False]['text':'       eval.','line_number':799,'multiline':False]['text':' As an optimization, if the eval does not have its own var','line_number':801,'multiline':False]['text':' environment and is directly enclosed in a global scope, then all','line_number':802,'multiline':False]['text':' free name lookups are global.','line_number':803,'multiline':False]['text':' Resolve body-level bindings, if there are any.','line_number':822,'multiline':False]['text':' Modules are toplevel, so any free names are global.','line_number':854,'multiline':False]['text':' Put lexical frame slots in TDZ. Environment slots are poisoned during','line_number':857,'multiline':False]['text':' environment creation.','line_number':858,'multiline':False]['text':' Create and intern the VM scope creation data.','line_number':865,'multiline':False]['text':' 'with' make all accesses dynamic and unanalyzable.','line_number':886,'multiline':False]['text':' If we aren't leaving the scope due to a non-local jump (e.g., break),','line_number':916,'multiline':False]['text':' we must be the innermost scope.','line_number':917,'multiline':False]['text':' Finish up the scope if we are leaving it in LIFO fashion.','line_number':961,'multiline':False]['text':' Popping scopes due to non-local jumps generate additional scope','line_number':963,'multiline':False]['text':' notes. See NonLocalExitControl::prepareForNonLocalJump.','line_number':964,'multiline':False]['text':' The extra function var scope is never popped once it's pushed,','line_number':967,'multiline':False]['text':' so its scope note extends until the end of any possible code.','line_number':968,'multiline':False]['text':' static ','line_number':998,'multiline':True]['text':' Private Brand checking relies on the ability to construct a new','line_number':1015,'multiline':False]['text':' environment coordinate for a name at a fixed offset, which will','line_number':1016,'multiline':False]['text':' correspond to the private brand for that class.','line_number':1017,'multiline':False]['text':'','line_number':1018,'multiline':False]['text':' If our name lookup isn't a fixed location, we must construct a','line_number':1019,'multiline':False]['text':' new environment coordinate, using information available from our private','line_number':1020,'multiline':False]['text':' field cache. (See cachePrivateFieldsForEval, and Bug 1638309).','line_number':1021,'multiline':False]['text':'','line_number':1022,'multiline':False]['text':' This typically involves a DebugEnvironmentProxy, so we need to use a','line_number':1023,'multiline':False]['text':' DebugEnvironmentCoordinate.','line_number':1024,'multiline':False]['text':'','line_number':1025,'multiline':False]['text':' See also Bug 793345 which argues that we should remove the','line_number':1026,'multiline':False]['text':' DebugEnvironmentProxy.','line_number':1027,'multiline':False]['text':' Private fields don't require brand checking and can be correctly','line_number':1032,'multiline':False]['text':' code-generated with dynamic name lookup bytecode we have today. However,','line_number':1033,'multiline':False]['text':' for that to happen we first need to figure out if we have a Private','line_number':1034,'multiline':False]['text':' method or private field, which we cannot disambiguate based on the','line_number':1035,'multiline':False]['text':' dynamic lookup.','line_number':1036,'multiline':False]['text':'','line_number':1037,'multiline':False]['text':' However, this is precisely the case that the private field eval case can','line_number':1038,'multiline':False]['text':' help us handle. It knows the truth about these private bindings.','line_number':1039,'multiline':False]['text':' To construct the brand check there are two hop values required:','line_number':1047,'multiline':False]['text':'','line_number':1048,'multiline':False]['text':' 1. Compilation Hops: The number of environment hops required to get to','line_number':1049,'multiline':False]['text':'    the compilation enclosing environment.','line_number':1050,'multiline':False]['text':' 2. "external hops", to get from compilation enclosing debug environment','line_number':1051,'multiline':False]['text':'     to the environment that actually contains our brand. This is','line_number':1052,'multiline':False]['text':'     determined by the cacheEntry. This traversal will bypass a Debug','line_number':1053,'multiline':False]['text':'     environment proxy, which is why need to use','line_number':1054,'multiline':False]['text':'     DebugEnvironmentCoordinate.','line_number':1055,'multiline':False]['text':' If we have a FrameSlot, then our innermost emitter scope must be a','line_number':1076,'multiline':False]['text':' class body scope, and we can generate an environment coordinate with','line_number':1077,'multiline':False]['text':' hops=0 to find the associated brand location.','line_number':1078,'multiline':False]['text':' The target scope must be an intra-frame enclosing scope of this','line_number':1093,'multiline':False]['text':' one. Count the number of extra hops to reach it.','line_number':1094,'multiline':False]['text':' Caches are prepopulated with bound names. So if the name is bound in a','line_number':1102,'multiline':False]['text':' particular scope, it must already be in the cache. Furthermore, don't','line_number':1103,'multiline':False]['text':' consult the fallback location as we only care about binding names.','line_number':1104,'multiline':False]