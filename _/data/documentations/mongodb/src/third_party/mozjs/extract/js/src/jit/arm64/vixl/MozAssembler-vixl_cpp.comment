['text':' Copyright 2015, ARM Limited','line_number':1,'multiline':False]['text':' All rights reserved.','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':4,'multiline':False]['text':' modification, are permitted provided that the following conditions are met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'   * Redistributions of source code must retain the above copyright notice,','line_number':7,'multiline':False]['text':'     this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'   * Redistributions in binary form must reproduce the above copyright notice,','line_number':9,'multiline':False]['text':'     this list of conditions and the following disclaimer in the documentation','line_number':10,'multiline':False]['text':'     and/or other materials provided with the distribution.','line_number':11,'multiline':False]['text':'   * Neither the name of ARM Limited nor the names of its contributors may be','line_number':12,'multiline':False]['text':'     used to endorse or promote products derived from this software without','line_number':13,'multiline':False]['text':'     specific prior written permission.','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS CONTRIBUTORS "AS IS" AND','line_number':16,'multiline':False]['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED','line_number':17,'multiline':False]['text':' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE','line_number':18,'multiline':False]['text':' DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE','line_number':19,'multiline':False]['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':20,'multiline':False]['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR','line_number':21,'multiline':False]['text':' SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER','line_number':22,'multiline':False]['text':' CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,','line_number':23,'multiline':False]['text':' OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':24,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':25,'multiline':False]['text':' Assembler','line_number':34,'multiline':False]['text':' Unbound Label Representation.','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' We can have multiple branches using the same label before it is bound.','line_number':43,'multiline':False]['text':' Assembler::bind() must then be able to enumerate all the branches and patch','line_number':44,'multiline':False]['text':' them to target the final label location.','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' When a Label is unbound with uses, its offset is pointing to the tip of a','line_number':47,'multiline':False]['text':' linked list of uses. The uses can be branches or adr/adrp instructions. In','line_number':48,'multiline':False]['text':' the case of branches, the next member in the linked list is simply encoded','line_number':49,'multiline':False]['text':' as the branch target. For adr/adrp, the relative pc offset is encoded in the','line_number':50,'multiline':False]['text':' immediate field as a signed instruction offset.','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' In both cases, the end of the list is encoded as a 0 pc offset, i.e. the','line_number':53,'multiline':False]['text':' tail is pointing to itself.','line_number':54,'multiline':False]['text':' Raw encoded offset.','line_number':62,'multiline':False]['text':' End of the list is encoded as 0.','line_number':64,'multiline':False]['text':' The encoded offset is the number of instructions to move.','line_number':67,'multiline':False]['text':' A common implementation for the LinkAndGet<Type>OffsetTo helpers.','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' If the label is bound, returns the offset as a multiple of 1 << elementShift.','line_number':89,'multiline':False]['text':' Otherwise, links the instruction to the label and returns the raw offset to','line_number':90,'multiline':False]['text':' encode. (This will be an instruction count.)','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':' The offset is calculated by aligning the PC and label addresses down to a','line_number':93,'multiline':False]['text':' multiple of 1 << elementShift, then calculating the (scaled) offset between','line_number':94,'multiline':False]['text':' them. This matches the semantics of adrp, for example. (Assuming that the','line_number':95,'multiline':False]['text':' assembler buffer is page-aligned, which it probably isn't.)','line_number':96,'multiline':False]['text':'','line_number':97,'multiline':False]['text':' For an unbound label, the returned offset will be encodable in the provided','line_number':98,'multiline':False]['text':' branch range. If the label is already bound, the caller is expected to make','line_number':99,'multiline':False]['text':' sure that it is in range, and emit the necessary branch instrutions if it','line_number':100,'multiline':False]['text':' isn't.','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':' The label is bound: all uses are already linked.','line_number':111,'multiline':False]['text':' Keep track of short-range branches targeting unbound labels. We may need','line_number':117,'multiline':False]['text':' to insert veneers in PatchShortRangeBranchToVeneer() below.','line_number':118,'multiline':False]['text':' This is the last possible branch target.','line_number':120,'multiline':False]['text':' The label is unbound and previously unused: Store the offset in the label','line_number':126,'multiline':False]['text':' itself for patching by bind().','line_number':127,'multiline':False]['text':' The label is unbound and has multiple users. Create a linked list between','line_number':133,'multiline':False]['text':' the branches, and update the linked list head in the label struct. This is','line_number':134,'multiline':False]['text':' not always trivial since the branches in the linked list have limited','line_number':135,'multiline':False]['text':' ranges.','line_number':136,'multiline':False]['text':' What is the earliest buffer offset that would be reachable by the branch','line_number':138,'multiline':False]['text':' we're about to add?','line_number':139,'multiline':False]['text':' If the existing instruction at the head of the list is within reach of the','line_number':143,'multiline':False]['text':' new branch, we can simply insert the new branch at the front of the list.','line_number':144,'multiline':False]['text':' The label already has a linked list of uses, but we can't reach the head','line_number':152,'multiline':False]['text':' of the list with the allowed branch range. Insert this branch at a','line_number':153,'multiline':False]['text':' different position in the list.','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':' Find an existing branch, exbr, such that:','line_number':156,'multiline':False]['text':'','line_number':157,'multiline':False]['text':' 1.  The new branch can be reached by exbr, and either','line_number':158,'multiline':False]['text':' 2a. The new branch can reach exbr's target, or','line_number':159,'multiline':False]['text':' 2b. The exbr branch is at the end of the list.','line_number':160,'multiline':False]['text':'','line_number':161,'multiline':False]['text':' Then the new branch can be inserted after exbr in the linked list.','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':' We know that it is always possible to find an exbr branch satisfying these','line_number':164,'multiline':False]['text':' conditions because of the PatchShortRangeBranchToVeneer() mechanism. All','line_number':165,'multiline':False]['text':' branches are guaranteed to either be able to reach the end of the','line_number':166,'multiline':False]['text':' assembler buffer, or they will be pointing to an unconditional branch that','line_number':167,'multiline':False]['text':' can.','line_number':168,'multiline':False]['text':'','line_number':169,'multiline':False]['text':' In particular, the end of the list is always a viable candidate, so we'll','line_number':170,'multiline':False]['text':' just get that.','line_number':171,'multiline':False]['text':' This branch becomes the new end of the list.','line_number':180,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':219,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':226,'multiline':False]['text':' No need for EmitBranch(): no immediate offset needs fixing.','line_number':233,'multiline':False]['text':' No need for EmitBranch(): no immediate offset needs fixing.','line_number':240,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':256,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':273,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':290,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':309,'multiline':False]['text':' Encode the relative offset from the inserted branch to the label.','line_number':328,'multiline':False]['text':' Encode the relative offset from the inserted adr to the label.','line_number':347,'multiline':False]['text':' Encode the relative offset from the inserted adr to the label.','line_number':367,'multiline':False]['text':' If the operation is NOT, invert the operation and immediate.','line_number':427,'multiline':False]['text':' Immediate can be encoded in the instruction.','line_number':435,'multiline':False]['text':' This case is handled in the macro assembler.','line_number':438,'multiline':False]['text':' Store the js::jit::PoolEntry index into the instruction.','line_number':472,'multiline':False]['text':' finishPool() will walk over all literal load instructions','line_number':473,'multiline':False]['text':' and use PatchConstantPoolLoad() to patch to the final relative offset.','line_number':474,'multiline':False]['text':' The load currently contains the js::jit::PoolEntry's index,','line_number':482,'multiline':False]['text':' as written by InsertIndexIntoTag().','line_number':483,'multiline':False]['text':' Each entry in the literal pool is uint32_t-sized,','line_number':486,'multiline':False]['text':' but literals may use multiple entries.','line_number':487,'multiline':False]['text':' Nothing uses the return value.','line_number':492,'multiline':False]['text':' Reconstruct the position of the branch from (rangeIdx, deadline).','line_number':499,'multiline':False]['text':' Verify that the branch range matches what's encoded.','line_number':505,'multiline':False]['text':' We want to insert veneer after branch in the linked list of instructions','line_number':508,'multiline':False]['text':' that use the same unbound label.','line_number':509,'multiline':False]['text':' The veneer should be an unconditional branch.','line_number':510,'multiline':False]['text':' If offset is 0, this is the end of the linked list.','line_number':513,'multiline':False]['text':' Make the offset relative to veneer so it targets the same instruction','line_number':515,'multiline':False]['text':' as branchInst.','line_number':516,'multiline':False]['text':' Now point branchInst at veneer. See also SetNextLink() above.','line_number':523,'multiline':False]['text':' The size should take into account the pool header.','line_number':531,'multiline':False]['text':' The size is in units of Instruction (4bytes), not byte.','line_number':532,'multiline':False]['text':' "Natural" guards are part of the normal instruction stream,','line_number':537,'multiline':False]['text':' while "non-natural" guards are inserted for the sole purpose','line_number':538,'multiline':False]['text':' of skipping around a pool.','line_number':539,'multiline':False]['text':' Get the total size of the pool.','line_number':584,'multiline':False]['text':' namespace vixl','line_number':610,'multiline':False]