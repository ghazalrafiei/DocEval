['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
**********************************************************************
*   Copyright (C) 2001-2015 IBM and others. All rights reserved.
**********************************************************************
*   Date        Name        Description
*  07/02/2001   synwee      Creation.
**********************************************************************
','line_number':3,'multiline':True]['text':' don't use Boyer-Moore','line_number':29,'multiline':False]['text':' (and if we decide to turn this on again there are several new TODOs that will need to be addressed)','line_number':30,'multiline':False]['text':' internal definition ---------------------------------------------------','line_number':33,'multiline':False]['text':' internal methods -------------------------------------------------','line_number':41,'multiline':False]['text':'*
* Fast collation element iterator setOffset.
* This function does not check for bounds.
* @param coleiter collation element iterator
* @param offset to set
','line_number':43,'multiline':True]['text':' Note: Not "fast" any more after the 2013 collation rewrite.','line_number':53,'multiline':False]['text':' We do not want to expose more internals than necessary.','line_number':54,'multiline':False]['text':'*
* Getting the mask for collation strength
* @param strength collation strength
* @return collation element mask
','line_number':59,'multiline':True]['text':'*
* @param ce 32-bit collation element
* @return hash code
','line_number':79,'multiline':True]['text':'*
* Initializing the fcd tables.
* Internal method, status assumed to be a success.
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
','line_number':106,'multiline':True]['text':'*
* Gets the fcd value for a character at the argument index.
* This method takes into accounts of the supplementary characters.
* @param str UTF16 string where character for fcd retrieval resides
* @param offset position of the character whose fcd is to be retrieved, to be
*               overwritten with the next character position, taking
*               surrogate characters into consideration.
* @param strlength length of the argument string
* @return fcd value
','line_number':121,'multiline':True]['text':'*
* Getting the modified collation elements taking into account the collation
* attributes
* @param strsrch string search data
* @param sourcece
* @return the modified collation element
','line_number':141,'multiline':True]['text':' note for tertiary we can't use the collator->tertiaryMask, that','line_number':151,'multiline':False]['text':' is a preprocessed mask that takes into account case options. since','line_number':152,'multiline':False]['text':' we are only concerned with exact matches, we don't need that.','line_number':153,'multiline':False]['text':' alternate handling here, since only the 16 most significant digits','line_number':157,'multiline':False]['text':' is only used, we can safely do a compare without masking','line_number':158,'multiline':False]['text':' if the ce is a variable, we mask and get only the primary values','line_number':159,'multiline':False]['text':' no shifting to quartenary is required since all primary values','line_number':160,'multiline':False]['text':' less than variabletop will need to be masked off anyway.','line_number':161,'multiline':False]['text':'*
* Allocate a memory and returns NULL if it failed.
* Internal method, status assumed to be a success.
* @param size to allocate
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return newly allocated array, NULL otherwise
','line_number':177,'multiline':True]['text':'*
* Adds a uint32_t value to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param offset destination offset to add value
* @param destinationlength target array size, return value for the new size
* @param value to be added
* @param increments incremental size expected
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return new destination array, destination if there was no new allocation
','line_number':195,'multiline':True]['text':'*
* Adds a uint64_t value to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param offset destination offset to add value
* @param destinationlength target array size, return value for the new size
* @param value to be added
* @param increments incremental size expected
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return new destination array, destination if there was no new allocation
','line_number':235,'multiline':True]['text':'*
* Initializing the ce table for a pattern.
* Stores non-ignorable collation keys.
* Table size will be estimated by the size of the pattern text. Table
* expansion will be perform as we go along. Adding 1 to ensure that the table
* size definitely increases.
* Internal method, status assumed to be a success.
* @param strsrch string search data
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return total number of expansions
','line_number':279,'multiline':True]['text':' status will be checked in ucol_next(..) later and if it is an','line_number':304,'multiline':False]['text':' error UCOL_NULLORDER the result of ucol_next(..) and 0 will be','line_number':305,'multiline':False]['text':' returned.','line_number':306,'multiline':False]['text':'*
* Initializing the pce table for a pattern.
* Stores non-ignorable collation keys.
* Table size will be estimated by the size of the pattern text. Table
* expansion will be perform as we go along. Adding 1 to ensure that the table
* size definitely increases.
* Internal method, status assumed to be a success.
* @param strsrch string search data
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return total number of expansions
','line_number':351,'multiline':True]['text':' status will be checked in ucol_next(..) later and if it is an','line_number':376,'multiline':False]['text':' error UCOL_NULLORDER the result of ucol_next(..) and 0 will be','line_number':377,'multiline':False]['text':' returned.','line_number':378,'multiline':False]['text':' ** Should processed CEs be signed or unsigned?','line_number':397,'multiline':False]['text':' ** (the rest of the code in this file seems to play fast-and-loose with','line_number':398,'multiline':False]['text':' **  whether a CE is signed or unsigned. For example, look at routine above this one.)','line_number':399,'multiline':False]['text':'result += (uint16_t)(ucol_getMaxExpansion(coleiter, ce) - 1);','line_number':418,'multiline':False]['text':'*
* Initializes the pattern struct.
* Internal method, status assumed to be success.
* @param strsrch UStringSearch data storage
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return expansionsize the total expansion size of the pattern
','line_number':428,'multiline':True]['text':' Since the strength is primary, accents are ignored in the pattern.','line_number':445,'multiline':False]['text':' ** HACK **','line_number':458,'multiline':False]['text':' since intializePattern is an internal method status is a success.','line_number':467,'multiline':False]['text':'*
* Initializing shift tables, with the default values.
* If a corresponding default value is 0, the shift table is not set.
* @param shift table for forwards shift
* @param backshift table for backwards shift
* @param cetable table containing pattern ce
* @param cesize size of the pattern ces
* @param expansionsize total size of the expansions
* @param defaultforward the default forward value
* @param defaultbackward the default backward value
','line_number':471,'multiline':True]['text':' estimate the value to shift. to do that we estimate the smallest','line_number':489,'multiline':False]['text':' number of characters to give the relevant ces, ie approximately','line_number':490,'multiline':False]['text':' the number of ces minus their expansion, since expansions can come','line_number':491,'multiline':False]['text':' from a character.','line_number':492,'multiline':False]['text':' down to the last index','line_number':497,'multiline':False]['text':' number of ces from right of array to the count','line_number':499,'multiline':False]['text':' for ignorables we just shift by one. see test examples.','line_number':504,'multiline':False]['text':' the original value count does not seem to work','line_number':511,'multiline':False]['text':'*
* Building of the pattern collation element list and the boyer moore strsrch
* table.
* The canonical match will only be performed after the default match fails.
* For both cases we need to remember the size of the composed and decomposed
* versions of the string. Since the Boyer-Moore shift calculations shifts by
* a number of characters in the text and tries to match the pattern from that
* offset, the shift value can not be too large in case we miss some
* characters. To choose a right shift size, we estimate the NFC form of the
* and use its size as a shift guide. The NFC form should be the small
* possible representation of the pattern. Anyways, we'll err on the smaller
* shift size. Hence the calculation for minlength.
* Canonical match will be performed slightly differently. We'll split the
* pattern into 3 parts, the prefix accents (PA), the middle string bounded by
* the first and last base character (MS), the ending accents (EA). Matches
* will be done on MS first, and only when we match MS then some processing
* will be required for the prefix and end accents in order to determine if
* they match PA and EA. Hence the default shift values
* for the canonical match will take the size of either end's accent into
* consideration. Forwards search will take the end accents into consideration
* for the default shift values and the backwards search will take the prefix
* accents into consideration.
* If pattern has no non-ignorable ce, we return a illegal argument error.
* Internal method, status assumed to be success.
* @param strsrch UStringSearch data storage
* @param status  for output errors if it occurs, status is assumed to be a
*                success when it is passed in.
','line_number':519,'multiline':True]['text':'*
* Check to make sure that the match length is at the end of the character by
* using the breakiterator.
* @param strsrch string search data
* @param start target text start offset
* @param end target text end offset
','line_number':566,'multiline':True]['text':'start','line_number':574,'multiline':True]['text':'int32_t matchstart = *start;','line_number':581,'multiline':False]['text':' Check the start of the matched text to make sure it doesn't have any accents
         * before it.  This code may not be necessary and so it is commented out ','line_number':587,'multiline':True]['text':'if (!ubrk_isBoundary(breakiterator, matchstart) && !ubrk_isBoundary(breakiterator, matchstart-1)) {
            *start = ubrk_preceding(breakiterator, matchstart);
        }','line_number':589,'multiline':True]['text':'*
* Determine whether the target text in UStringSearch bounded by the offset
* start and end is one or more whole units of text as
* determined by the breakiterator in UStringSearch.
* @param strsrch string search data
* @param start target text start offset
* @param end target text end offset
','line_number':596,'multiline':True]['text':'TODO: Add here.','line_number':610,'multiline':False]['text':' out-of-range indexes are never boundary positions','line_number':615,'multiline':False]['text':' otherwise, we can use following() on the position before the','line_number':620,'multiline':False]['text':' specified one and return true of the position we get back is the','line_number':621,'multiline':False]['text':' one the user specified','line_number':622,'multiline':False]['text':' iterates the individual ces','line_number':628,'multiline':False]['text':' extra collation elements at the end of the match','line_number':652,'multiline':False]['text':'*
* Getting the next base character offset if current offset is an accent,
* or the current offset if the current character contains a base character.
* accents the following base character will be returned
* @param text string
* @param textoffset current offset
* @param textlength length of text string
* @return the next base character or the current offset
*         if the current character is contains a base character.
','line_number':662,'multiline':True]['text':'*
* Gets the next base character offset depending on the string search pattern
* data
* @param strsrch string search data
* @param textoffset current offset, one offset away from the last character
*                   to search for.
* @return start index of the next base character or the current offset
*         if the current character is contains a base character.
','line_number':693,'multiline':True]['text':'*
* Shifting the collation element iterator position forward to prepare for
* a following match. If the last character is a unsafe character, we'll only
* shift by 1 to capture contractions, normalization etc.
* Internal method, status assumed to be success.
* @param text strsrch string search data
* @param textoffset start text position to do search
* @param ce the text ce which failed the match.
* @param patternceindex index of the ce within the pattern ce buffer which
*        failed the match
* @return final offset
','line_number':719,'multiline':True]['text':' this is to adjust for characters in the middle of the','line_number':740,'multiline':False]['text':' substring for matching that failed.','line_number':741,'multiline':False]['text':' check for unsafe characters','line_number':753,'multiline':False]['text':' * if it is the start or middle of a contraction: to be done after','line_number':754,'multiline':False]['text':'   a initial match is found','line_number':755,'multiline':False]['text':' * thai or lao base consonant character: similar to contraction','line_number':756,'multiline':False]['text':' * high surrogate character: similar to contraction','line_number':757,'multiline':False]['text':' * next character is a accent: shift to the next base character','line_number':758,'multiline':False]['text':' #if BOYER_MOORE','line_number':761,'multiline':False]['text':'*
* sets match not found
* @param strsrch string search data
','line_number':763,'multiline':True]['text':' this method resets the match result regardless of the error status.','line_number':770,'multiline':False]['text':'*
* Gets the offset to the next safe point in text.
* ie. not the middle of a contraction, swappable characters or supplementary
* characters.
* @param collator collation sata
* @param text string to work with
* @param textoffset offset in string
* @param textlength length of text string
* @return offset to the next safe character
','line_number':782,'multiline':True]['text':' first contraction character','line_number':798,'multiline':False]['text':'*
* This checks for accents in the potential match started with a .
* composite character.
* This is really painful... we have to check that composite character do not
* have any extra accents. We have to normalize the potential match and find
* the immediate decomposed character before the match.
* The first composite character would have been taken care of by the fcd
* checks in checkForwardExactMatch.
* This is the slow path after the fcd of the first character and
* the last character has been checked by checkForwardExactMatch and we
* determine that the potential match has extra non-ignorable preceding
* ces.
* E.g. looking for \u0301 acute in \u01FA A ring above and acute,
* checkExtraMatchAccent should fail since there is a middle ring in \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* Internal method, status assumed to be a success, caller should check status
* before calling this method
* @param strsrch string search data
* @param start index of the potential unfriendly composite character
* @param end index of the potential unfriendly composite character
* @param status output error status if any.
* @return TRUE if there is non-ignorable accents before at the beginning
*              of the match, FALSE otherwise.
','line_number':805,'multiline':True]['text':' we are only concerned with the first composite character','line_number':842,'multiline':False]['text':' if allocation failed, status will be set to','line_number':860,'multiline':False]['text':' U_MEMORY_ALLOCATION_ERROR and unorm_normalize internally','line_number':861,'multiline':False]['text':' checks for it.','line_number':862,'multiline':False]['text':'*
* Used by exact matches, checks if there are accents before the match.
* This is really painful... we have to check that composite characters at
* the start of the matches have to not have any extra accents.
* We check the FCD of the character first, if it starts with an accent and
* the first pattern ce does not match the first ce of the character, we bail.
* Otherwise we try normalizing the first composite
* character and find the immediate decomposed character before the match to
* see if it is an non-ignorable accent.
* Now normalizing the first composite character is enough because we ensure
* that when the match is passed in here with extra beginning ces, the
* first or last ce that match has to occur within the first character.
* E.g. looking for \u0301 acute in \u01FA A ring above and acute,
* checkExtraMatchAccent should fail since there is a middle ring in \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* @param strsrch string search data
* @param start offset
* @param end offset
* @return TRUE if there are accents on either side of the match,
*         FALSE otherwise
','line_number':899,'multiline':True]['text':' we have been iterating forwards previously','line_number':927,'multiline':False]['text':' within normalization buffer, discontiguous handled here','line_number':946,'multiline':False]['text':' within text','line_number':950,'multiline':False]['text':' original code','line_number':952,'multiline':False]['text':' accent = (getFCD(strsrch->search->text, &temp,','line_number':953,'multiline':False]['text':'                  strsrch->search->textLength)','line_number':954,'multiline':False]['text':'            >> SECOND_LAST_BYTE_SHIFT_);','line_number':955,'multiline':False]['text':' however this code does not work well with VC7 .net in release mode.','line_number':956,'multiline':False]['text':' maybe the inlines for getFCD combined with shifting has bugs in','line_number':957,'multiline':False]['text':' VC7. anyways this is a work around.','line_number':958,'multiline':False]['text':'*
* Used by exact matches, checks if there are accents bounding the match.
* Note this is the initial boundary check. If the potential match
* starts or ends with composite characters, the accents in those
* characters will be determined later.
* Not doing backwards iteration here, since discontiguos contraction for
* backwards collation element iterator, use up too many characters.
* E.g. looking for \u030A ring in \u01FA A ring above and acute,
* should fail since there is a acute at the end of \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* @param strsrch string search data
* @param start offset of match
* @param end end offset of the match
* @return TRUE if there are accents on either side of the match,
*         FALSE otherwise
','line_number':985,'multiline':True]['text':' Thai can give an ignorable here.','line_number':1025,'multiline':False]['text':' #if BOYER_MOORE','line_number':1053,'multiline':False]['text':'*
* Checks if the offset runs out of the text string
* @param offset
* @param textlength of the text string
* @return TRUE if offset is out of bounds, FALSE otherwise
','line_number':1055,'multiline':True]['text':'*
* Checks for identical match
* @param strsrch string search data
* @param start offset of possible match
* @param end offset of possible match
* @return TRUE if identical match is found
','line_number':1067,'multiline':True]['text':' Note: We could use Normalizer::compare() or similar, but for short strings','line_number':1082,'multiline':False]['text':' which may not be in FCD it might be faster to just NFD them.','line_number':1083,'multiline':False]['text':' return FALSE if NFD failed','line_number':1090,'multiline':False]['text':'*
* Checks to see if the match is repeated
* @param strsrch string search data
* @param start new match start index
* @param end new match end index
* @return TRUE if the the match is repeated, FALSE otherwise
','line_number':1095,'multiline':True]['text':'*
* Gets the collation element iterator's current offset.
* @param coleiter collation element iterator
* @param forwards flag TRUE if we are moving in th forwards direction
* @return current offset
','line_number':1129,'multiline':True]['text':' intricacies of the the backwards collation element iterator','line_number':1140,'multiline':False]['text':'*
* Checks match for contraction.
* If the match ends with a partial contraction we fail.
* If the match starts too far off (because of backwards iteration) we try to
* chip off the extra characters depending on whether a breakiterator has
* been used.
* Internal method, error assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1147,'multiline':True]['text':' This part checks if either ends of the match contains potential','line_number':1172,'multiline':False]['text':' contraction. If so we'll have to iterate through them','line_number':1173,'multiline':False]['text':' The start contraction needs to be checked since ucol_previous dumps','line_number':1174,'multiline':False]['text':' all characters till the first safe character into the buffer.','line_number':1175,'multiline':False]['text':' *start + 1 is used to test for the unsafe characters instead of *start','line_number':1176,'multiline':False]['text':' because ucol_prev takes all unsafe characters till the first safe','line_number':1177,'multiline':False]['text':' character ie *start. so by testing *start + 1, we can estimate if','line_number':1178,'multiline':False]['text':' excess prefix characters has been included in the potential search','line_number':1179,'multiline':False]['text':' results.','line_number':1180,'multiline':False]['text':' getting rid of the redundant ce, caused by setOffset.','line_number':1188,'multiline':False]['text':' since backward contraction/expansion may have extra ces if we','line_number':1189,'multiline':False]['text':' are in the normalization buffer, hasAccentsBeforeMatch would','line_number':1190,'multiline':False]['text':' have taken care of it.','line_number':1191,'multiline':False]['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':1192,'multiline':False]['text':' we are only looking for acute and ring \u030A and \u0301, we'll','line_number':1193,'multiline':False]['text':' have to skip the first ce in the expansion buffer.','line_number':1194,'multiline':False]['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> exact matches has no extra accents
* <li> identical matchesb
* <li> potential match does not end in the middle of a contraction
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated end offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1229,'multiline':True]['text':' this totally matches, however we need to check if it is repeating','line_number':1260,'multiline':False]['text':'Add breakiterator boundary check for primary strength search.','line_number':1272,'multiline':False]['text':' totally match, we will get rid of the ending ignorables.','line_number':1277,'multiline':False]['text':'*
* Getting the previous base character offset, or the current offset if the
* current character is a base character
* @param text string
* @param textoffset one offset after the current character
* @return the offset of the next character after the base character or the first
*         composed character with accents
','line_number':1283,'multiline':True]['text':'*
* Getting the indexes of the accents that are not blocked in the argument
* accent array
* @param accents array of accents in nfd terminated by a 0.
* @param accentsindex array of indexes of the accents that are not blocked
','line_number':1315,'multiline':True]['text':'*
* Appends 3 UChar arrays to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param destinationlength target array size, returning the appended length
* @param source1 null-terminated first array
* @param source2 second array
* @param source2length length of second array
* @param source3 null-terminated third array
* @param status error status if any
* @return new destination array, destination if there was no new allocation
','line_number':1343,'multiline':True]['text':' if error allocating memory, status will be','line_number':1376,'multiline':False]['text':' U_MEMORY_ALLOCATION_ERROR','line_number':1377,'multiline':False]['text':'*
* Running through a collation element iterator to see if the contents matches
* pattern in string search data
* @param strsrch string search data
* @param coleiter collation element iterator
* @return TRUE if a match if found, FALSE otherwise
','line_number':1398,'multiline':True]['text':'*
* Rearranges the front accents to try matching.
* Prefix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status is assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search match
* @param start first offset of the accents to start searching
* @param end start of the last accent set
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the starting
*         offset of the match. Note this start includes all preceding accents.
','line_number':1426,'multiline':True]['text':' die... failed at a base character','line_number':1456,'multiline':False]['text':' normalizing the offensive string','line_number':1464,'multiline':False]['text':' copy the base characters','line_number':1479,'multiline':False]['text':' forming all possible canonical rearrangement by dropping','line_number':1483,'multiline':False]['text':' sets of accents','line_number':1484,'multiline':False]['text':' if status is a failure, ucol_setText does nothing.','line_number':1502,'multiline':False]['text':' run the collator iterator through this match','line_number':1503,'multiline':False]['text':'*
* Gets the offset to the safe point in text before textoffset.
* ie. not the middle of a contraction, swappable characters or supplementary
* characters.
* @param collator collation sata
* @param text string to work with
* @param textoffset offset in string
* @param textlength length of text string
* @return offset to the previous safe character
','line_number':1518,'multiline':True]['text':' first contraction character','line_number':1533,'multiline':False]['text':' the first contraction character is consider unsafe here','line_number':1538,'multiline':False]['text':'*
* Cleaning up after we passed the safe zone
* @param strsrch string search data
* @param safetext safe text array
* @param safebuffer safe text buffer
* @param coleiter collation element iterator for safe text
','line_number':1544,'multiline':True]['text':'*
* Take the rearranged end accents and tries matching. If match failed at
* a separate preceding set of accents (separated from the rearranged on by
* at least a base character) then we rearrange the preceding accents and
* tries matching again.
* We allow skipping of the ends of the accent set if the ces do not match.
* However if the failure is found before the accent set, it fails.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset of the start of the rearranged accent
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the starting
*         offset of the match. Note this start includes all preceding accents.
','line_number':1561,'multiline':True]['text':' if status is a failure, ucol_setText does nothing','line_number':1605,'multiline':False]['text':' status checked in loop below','line_number':1607,'multiline':False]['text':' indication flag for position in safe zone','line_number':1612,'multiline':False]['text':' check if we have passed the safe buffer','line_number':1623,'multiline':False]['text':' status checked at the start of the loop','line_number':1632,'multiline':False]['text':' do the beginning stuff','line_number':1638,'multiline':False]['text':' alas... no hope. failed at rearranged accent set','line_number':1641,'multiline':False]['text':' try rearranging the front accents','line_number':1651,'multiline':False]['text':' if status is a failure, ucol_setOffset does nothing','line_number':1655,'multiline':False]['text':' set offset here','line_number':1668,'multiline':False]['text':' sets the text iterator here with the correct expansion and offset','line_number':1671,'multiline':False]['text':'*
* Trying out the substring and sees if it can be a canonical match.
* This will try normalizing the end accents and arranging them into canonical
* equivalents and check their corresponding ces with the pattern ce.
* Suffix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset end offset in the collation element text that ends with
*                   the accents to be rearranged
* @param status error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1689,'multiline':True]['text':' offset to the last base character in substring to search','line_number':1736,'multiline':False]['text':' normalizing the offensive string','line_number':1738,'multiline':False]['text':' status checked in loop below','line_number':1741,'multiline':False]['text':' 2 power n - 1 plus the full set of accents','line_number':1746,'multiline':False]['text':' copy the base characters','line_number':1750,'multiline':False]['text':' forming all possible canonical rearrangement by dropping','line_number':1754,'multiline':False]['text':' sets of accents','line_number':1755,'multiline':False]['text':' match found','line_number':1768,'multiline':False]['text':'*
* Gets the previous base character offset depending on the string search
* pattern data
* @param strsrch string search data
* @param textoffset current offset, current character
* @return the offset of the next character after this base character or itself
*         if it is a composed character with accents
','line_number':1775,'multiline':True]['text':'*
* Checks match for contraction.
* If the match ends with a partial contraction we fail.
* If the match starts too far off (because of backwards iteration) we try to
* chip off the extra characters
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1798,'multiline':True]['text':' This part checks if either ends of the match contains potential','line_number':1822,'multiline':False]['text':' contraction. If so we'll have to iterate through them','line_number':1823,'multiline':False]['text':' getting rid of the redundant ce, caused by setOffset.','line_number':1831,'multiline':False]['text':' since backward contraction/expansion may have extra ces if we','line_number':1832,'multiline':False]['text':' are in the normalization buffer, hasAccentsBeforeMatch would','line_number':1833,'multiline':False]['text':' have taken care of it.','line_number':1834,'multiline':False]['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':1835,'multiline':False]['text':' we are only looking for acute and ring \u030A and \u0301, we'll','line_number':1836,'multiline':False]['text':' have to skip the first ce in the expansion buffer.','line_number':1837,'multiline':False]['text':' status checked below, note that if status is a failure','line_number':1855,'multiline':False]['text':' ucol_next returns UCOL_NULLORDER','line_number':1856,'multiline':False]['text':' accents may have extra starting ces, this occurs when a','line_number':1866,'multiline':False]['text':' pure accent pattern is matched without rearrangement','line_number':1867,'multiline':False]['text':' text \u0325\u0300 and looking for \u0300','line_number':1868,'multiline':False]['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> potential match does not end in the middle of a contraction
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check the
* status before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated end offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1890,'multiline':True]['text':' to ensure that the start and ends are not composite characters','line_number':1914,'multiline':False]['text':' if we have a canonical accent match','line_number':1916,'multiline':False]['text':' this totally matches, however we need to check if it is repeating','line_number':1936,'multiline':False]['text':'*
* Shifting the collation element iterator position forward to prepare for
* a preceding match. If the first character is a unsafe character, we'll only
* shift by 1 to capture contractions, normalization etc.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param text strsrch string search data
* @param textoffset start text position to do search
* @param ce the text ce which failed the match.
* @param patternceindex index of the ce within the pattern ce buffer which
*        failed the match
* @return final offset
','line_number':1951,'multiline':True]['text':' this is to adjust for characters in the middle of the substring','line_number':1982,'multiline':False]['text':' for matching that failed.','line_number':1983,'multiline':False]['text':'*
* Checks match for contraction.
* If the match starts with a partial contraction we fail.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1998,'multiline':True]['text':' This part checks if either if the start of the match contains potential','line_number':2019,'multiline':False]['text':' contraction. If so we'll have to iterate through them','line_number':2020,'multiline':False]['text':' Since we used ucol_next while previously looking for the potential','line_number':2021,'multiline':False]['text':' match, this guarantees that our end will not be a partial contraction,','line_number':2022,'multiline':False]['text':' or a partial supplementary character.','line_number':2023,'multiline':False]['text':' getting rid of the redundant ce','line_number':2029,'multiline':False]['text':' since forward contraction/expansion may have extra ces','line_number':2030,'multiline':False]['text':' if we are in the normalization buffer, hasAccentsBeforeMatch','line_number':2031,'multiline':False]['text':' would have taken care of it.','line_number':2032,'multiline':False]['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':2033,'multiline':False]['text':' we are only looking for A ring A\u030A, we'll have to skip the','line_number':2034,'multiline':False]['text':' last ce in the expansion buffer','line_number':2035,'multiline':False]['text':' status checked below, note that if status is a failure','line_number':2052,'multiline':False]['text':' ucol_previous returns UCOL_NULLORDER','line_number':2053,'multiline':False]['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the current match does not repeat the last match
* <li> boundaries are correct
* <li> exact matches has no extra accents
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the preceding character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param collator
* @param coleiter collation element iterator
* @param text string
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated start offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2073,'multiline':True]['text':' to ensure that the start and ends are not composite characters','line_number':2100,'multiline':False]['text':' this totally matches, however we need to check if it is repeating','line_number':2107,'multiline':False]['text':' the old match','line_number':2108,'multiline':False]['text':'Add breakiterator boundary check for primary strength search.','line_number':2120,'multiline':False]['text':'*
* Rearranges the end accents to try matching.
* Suffix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, user has to check status
* before calling this method.
* @param strsrch string search match
* @param start offset of the first base character
* @param end start of the last accent set
* @param status only error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the ending
*         offset of the match. Note this start includes all following accents.
','line_number':2130,'multiline':True]['text':' die... failed at a base character','line_number':2161,'multiline':False]['text':' normalizing the offensive string','line_number':2169,'multiline':False]['text':' copy the base characters','line_number':2181,'multiline':False]['text':' forming all possible canonical rearrangement by dropping','line_number':2185,'multiline':False]['text':' sets of accents','line_number':2186,'multiline':False]['text':' run the collator iterator through this match','line_number':2204,'multiline':False]['text':' if status is a failure ucol_setText does nothing','line_number':2205,'multiline':False]['text':'*
* Take the rearranged start accents and tries matching. If match failed at
* a separate following set of accents (separated from the rearranged on by
* at least a base character) then we rearrange the preceding accents and
* tries matching again.
* We allow skipping of the ends of the accent set if the ces do not match.
* However if the failure is found before the accent set, it fails.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset of the ends of the rearranged accent
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the ending
*         offset of the match. Note this start includes all following accents.
','line_number':2221,'multiline':True]['text':' if status is a failure, ucol_setText does nothing','line_number':2268,'multiline':False]['text':' status checked in loop below','line_number':2270,'multiline':False]['text':' safe zone indication flag for position','line_number':2275,'multiline':False]['text':' check if we have passed the safe buffer','line_number':2287,'multiline':False]['text':' status checked at the start of the loop','line_number':2296,'multiline':False]['text':' do the beginning stuff','line_number':2302,'multiline':False]['text':' alas... no hope. failed at rearranged accent set','line_number':2305,'multiline':False]['text':' try rearranging the end accents','line_number':2315,'multiline':False]['text':' if status is a failure, ucol_setOffset does nothing','line_number':2319,'multiline':False]['text':' set offset here','line_number':2332,'multiline':False]['text':' sets the text iterator here with the correct expansion and offset','line_number':2335,'multiline':False]['text':'*
* Trying out the substring and sees if it can be a canonical match.
* This will try normalizing the starting accents and arranging them into
* canonical equivalents and check their corresponding ces with the pattern ce.
* Prefix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset start offset in the collation element text that starts
*                   with the accents to be rearranged
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2352,'multiline':True]['text':' offset to the last base character in substring to search','line_number':2399,'multiline':False]['text':' normalizing the offensive string','line_number':2401,'multiline':False]['text':' status checked in loop','line_number':2404,'multiline':False]['text':' 2 power n - 1 plus the full set of accents','line_number':2409,'multiline':False]['text':' copy the base characters','line_number':2413,'multiline':False]['text':' forming all possible canonical rearrangement by dropping','line_number':2417,'multiline':False]['text':' sets of accents','line_number':2418,'multiline':False]['text':' match found','line_number':2431,'multiline':False]['text':'*
* Checks match for contraction.
* If the match starts with a partial contraction we fail.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status only error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':2438,'multiline':True]['text':' This part checks if either if the start of the match contains potential','line_number':2459,'multiline':False]['text':' contraction. If so we'll have to iterate through them','line_number':2460,'multiline':False]['text':' Since we used ucol_next while previously looking for the potential','line_number':2461,'multiline':False]['text':' match, this guarantees that our end will not be a partial contraction,','line_number':2462,'multiline':False]['text':' or a partial supplementary character.','line_number':2463,'multiline':False]['text':' getting rid of the redundant ce','line_number':2469,'multiline':False]['text':' since forward contraction/expansion may have extra ces','line_number':2470,'multiline':False]['text':' if we are in the normalization buffer, hasAccentsBeforeMatch','line_number':2471,'multiline':False]['text':' would have taken care of it.','line_number':2472,'multiline':False]['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':2473,'multiline':False]['text':' we are only looking for A ring A\u030A, we'll have to skip the','line_number':2474,'multiline':False]['text':' last ce in the expansion buffer','line_number':2475,'multiline':False]['text':' status checked below, note that if status is a failure','line_number':2492,'multiline':False]['text':' ucol_previous returns UCOL_NULLORDER','line_number':2493,'multiline':False]['text':' accents may have extra starting ces, this occurs when a','line_number':2504,'multiline':False]['text':' pure accent pattern is matched without rearrangement','line_number':2505,'multiline':False]['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> potential match does not end in the middle of a contraction
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated start offset of the match or the new start
*        search offset.
* @param status only error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2528,'multiline':True]['text':' to ensure that the start and ends are not composite characters','line_number':2552,'multiline':False]['text':' if we have a canonical accent match','line_number':2554,'multiline':False]['text':' this totally matches, however we need to check if it is repeating','line_number':2575,'multiline':False]['text':' #if BOYER_MOORE','line_number':2589,'multiline':False]['text':' constructors and destructor -------------------------------------------','line_number':2591,'multiline':False]['text':' ucol_open internally checks for status','line_number':2611,'multiline':False]['text':' pattern, text checks are done in usearch_openFromCollator','line_number':2613,'multiline':False]['text':' string search does not really work when numeric collation is turned on','line_number':2656,'multiline':False]['text':' set and get methods --------------------------------------------------','line_number':2804,'multiline':False]['text':' if status is a failure, ucol_getAttribute returns UCOL_DEFAULT','line_number':3041,'multiline':False]['text':' if status is a failure, ucol_getVariableTop returns 0','line_number':3045,'multiline':False]['text':' initialize() _after_ setting the iterators for the new collator.','line_number':3053,'multiline':False]['text':' **** are these calls needed?','line_number':3057,'multiline':False]['text':' **** we call uprv_init_pce in initializePatternPCETable','line_number':3058,'multiline':False]['text':' **** and the CEIBuffer constructor...','line_number':3059,'multiline':False]['text':' miscellanous methods --------------------------------------------------','line_number':3110,'multiline':False]['text':' position checked in usearch_setOffset','line_number':3131,'multiline':False]['text':' position checked in usearch_setOffset','line_number':3159,'multiline':False]['text':'*
* If a direction switch is required, we'll count the number of ces till the
* beginning of the collation element iterator and iterate forwards that
* number of times. This is so that we get to the correct point within the
* string to continue the search in. Imagine when we are in the middle of the
* normalization buffer when the change in direction is request. arrrgghh....
* After searching the offset within the collation element iterator will be
* shifted to the start of the match. If a match is not found, the offset would
* have been set to the end of the text string in the collation element
* iterator.
* Okay, here's my take on normalization buffer. The only time when there can
* be 2 matches within the same normalization is when the pattern is consists
* of all accents. But since the offset returned is from the text string, we
* should not confuse the caller by returning the second match within the
* same normalization buffer. If we do, the 2 results will have the same match
* offsets, and that'll be confusing. I'll return the next match that doesn't
* fall within the same normalization buffer. Note this does not affect the
* results of matches spanning the text and the normalization buffer.
* The position to start searching is taken from the collation element
* iterator. Callers of this API would have to set the offset in the collation
* element iterator before using this method.
','line_number':3168,'multiline':True]['text':' note offset is either equivalent to the start of the previous match','line_number':3194,'multiline':False]['text':' or is set by the user','line_number':3195,'multiline':False]['text':' not enough characters to match','line_number':3207,'multiline':False]['text':' not enough characters to match','line_number':3216,'multiline':False]['text':' switching direction.','line_number':3223,'multiline':False]['text':' if matchedIndex == USEARCH_DONE, it means that either a','line_number':3224,'multiline':False]['text':' setOffset has been called or that previous ran off the text','line_number':3225,'multiline':False]['text':' string. the iterator would have been set to offset 0 if a','line_number':3226,'multiline':False]['text':' match is not found.','line_number':3227,'multiline':False]['text':' there's no need to set the collation element iterator','line_number':3230,'multiline':False]['text':' the next call to next will set the offset.','line_number':3231,'multiline':False]['text':' moves by codepoints','line_number':3241,'multiline':False]['text':' status checked below','line_number':3247,'multiline':False]['text':' if matchlength is 0 we are at the start of the iteration','line_number':3254,'multiline':False]['text':' for boundary check purposes. this will ensure that the','line_number':3264,'multiline':False]['text':' next match will not preceed the current offset','line_number':3265,'multiline':False]['text':' note search->matchedIndex will always be set to something','line_number':3266,'multiline':False]['text':' in the code','line_number':3267,'multiline':False]['text':' can't use exact here since extra accents are allowed.','line_number':3272,'multiline':False]['text':' switching direction.','line_number':3316,'multiline':False]['text':' if matchedIndex == USEARCH_DONE, it means that either a','line_number':3317,'multiline':False]['text':' setOffset has been called or that next ran off the text','line_number':3318,'multiline':False]['text':' string. the iterator would have been set to offset textLength if','line_number':3319,'multiline':False]['text':' a match is not found.','line_number':3320,'multiline':False]['text':' not enough characters to match','line_number':3333,'multiline':False]['text':' Could check pattern length, but the','line_number':3338,'multiline':False]['text':' linear search will do the right thing','line_number':3339,'multiline':False]['text':' status checked below','line_number':3353,'multiline':False]['text':' move by codepoints','line_number':3355,'multiline':False]['text':' status checked below','line_number':3358,'multiline':False]['text':' can't use exact here since extra accents are allowed.','line_number':3364,'multiline':False]['text':' status checked below','line_number':3366,'multiline':False]['text':' status checked below','line_number':3370,'multiline':False]['text':'
    reset is setting the attributes that are already in
    string search, hence all attributes in the collator should
    be retrieved without any problems
    ','line_number':3388,'multiline':True]['text':' **** hack to deal w/ how processed CEs encode quaternary ****','line_number':3400,'multiline':False]['text':' if status is a failure, ucol_getAttribute returns UCOL_DEFAULT','line_number':3414,'multiline':False]['text':' if status is a failure, ucol_getVariableTop returns 0','line_number':3422,'multiline':False]['text':'','line_number':3444,'multiline':False]['text':'  CEI  Collation Element + source text index.','line_number':3445,'multiline':False]['text':'       These structs are kept in the circular buffer.','line_number':3446,'multiline':False]['text':'','line_number':3447,'multiline':False]['text':'','line_number':3457,'multiline':False]['text':'  CEIBuffer   A circular buffer of CEs-with-index from the text being searched.','line_number':3458,'multiline':False]['text':'','line_number':3459,'multiline':False]['text':' Some typical max values to make buffer size more reasonable for asymmetric search.','line_number':3462,'multiline':False]['text':' #8694 is for a better long-term solution to allocation of this buffer.','line_number':3463,'multiline':False]['text':' No check for surrogates, we might allocate slightly more buffer than necessary.','line_number':3498,'multiline':False]['text':' TODO: add a reset or init function so that allocated','line_number':3518,'multiline':False]['text':'       buffers can be retained & reused.','line_number':3519,'multiline':False]['text':' Get the CE with the specified index.','line_number':3528,'multiline':False]['text':'   Index must be in the range','line_number':3529,'multiline':False]['text':'          n-history_size < index < n+1','line_number':3530,'multiline':False]['text':'   where n is the largest index to have been fetched by some previous call to this function.','line_number':3531,'multiline':False]['text':'   The CE value will be UCOL__PROCESSED_NULLORDER at end of input.','line_number':3532,'multiline':False]['text':'','line_number':3533,'multiline':False]['text':' The request was for an entry already in our buffer.','line_number':3538,'multiline':False]['text':'  Just return it.','line_number':3539,'multiline':False]['text':' Caller is requesting a new, never accessed before, CE.','line_number':3543,'multiline':False]['text':'   Verify that it is the next one in sequence, which is all','line_number':3544,'multiline':False]['text':'   that is allowed.','line_number':3545,'multiline':False]['text':' TODO: In ICU 64 the above assert was changed to use UPRV_UNREACHABLE instead','line_number':3548,'multiline':False]['text':' which unconditionally calls abort(). However, there were cases where this was','line_number':3549,'multiline':False]['text':' being hit. This change is reverted for now, restoring the existing behavior.','line_number':3550,'multiline':False]['text':' ICU-20792 tracks the follow-up work/further investigation on this.','line_number':3551,'multiline':False]['text':' Manage the circular CE buffer indexing','line_number':3555,'multiline':False]['text':' The buffer is full, knock out the lowest-indexed entry.','line_number':3559,'multiline':False]['text':' Get the CE with the specified index.','line_number':3570,'multiline':False]['text':'   Index must be in the range','line_number':3571,'multiline':False]['text':'          n-history_size < index < n+1','line_number':3572,'multiline':False]['text':'   where n is the largest index to have been fetched by some previous call to this function.','line_number':3573,'multiline':False]['text':'   The CE value will be UCOL__PROCESSED_NULLORDER at end of input.','line_number':3574,'multiline':False]['text':'','line_number':3575,'multiline':False]['text':' The request was for an entry already in our buffer.','line_number':3580,'multiline':False]['text':'  Just return it.','line_number':3581,'multiline':False]['text':' Caller is requesting a new, never accessed before, CE.','line_number':3585,'multiline':False]['text':'   Verify that it is the next one in sequence, which is all','line_number':3586,'multiline':False]['text':'   that is allowed.','line_number':3587,'multiline':False]['text':' TODO: In ICU 64 the above assert was changed to use UPRV_UNREACHABLE instead','line_number':3590,'multiline':False]['text':' which unconditionally calls abort(). However, there were cases where this was','line_number':3591,'multiline':False]['text':' being hit. This change is reverted for now, restoring the existing behavior.','line_number':3592,'multiline':False]['text':' ICU-20792 tracks the follow-up work/further investigation on this.','line_number':3593,'multiline':False]['text':' Manage the circular CE buffer indexing','line_number':3597,'multiline':False]['text':' The buffer is full, knock out the lowest-indexed entry.','line_number':3601,'multiline':False]['text':' #define USEARCH_DEBUG','line_number':3617,'multiline':False]['text':'
 * Find the next break boundary after startIndex. If the UStringSearch object
 * has an external break iterator, use that. Otherwise use the internal character
 * break iterator.
 ','line_number':3624,'multiline':True]['text':' If we are on a control character, stop without looking for combining marks.','line_number':3645,'multiline':False]['text':'    Control characters do not combine.','line_number':3646,'multiline':False]['text':' The initial character was not a control, and can thus accept trailing','line_number':3652,'multiline':False]['text':'   combining characters.  Advance over however many of them there are.','line_number':3653,'multiline':False]['text':' **** or should we use the original code? ****','line_number':3680,'multiline':False]['text':'
 * Returns TRUE if index is on a break boundary. If the UStringSearch
 * has an external break iterator, test using that, otherwise test
 * using the internal character break iterator.
 ','line_number':3686,'multiline':True]['text':' If the character at the current index is not a GRAPHEME_EXTEND','line_number':3703,'multiline':False]['text':'    then we can not be within a combining sequence.','line_number':3704,'multiline':False]['text':' We are at a combining mark.  If the preceding character is anything','line_number':3712,'multiline':False]['text':'   except a CONTROL, CR or LF, we are in a combining sequence.','line_number':3713,'multiline':False]['text':' **** or use the original code? ****','line_number':3727,'multiline':False]['text':' out-of-range indexes are never boundary positions','line_number':3742,'multiline':False]['text':' TODO: #if BOYER_MOORE, need 32-bit version of compareCE64s','line_number':3817,'multiline':False]['text':' namespace','line_number':3840,'multiline':False]['text':' TODO:  reject search patterns beginning with a combining char.','line_number':3852,'multiline':False]['text':' Input parameter sanity check.','line_number':3864,'multiline':False]['text':'  TODO:  should input indices clip to the text length','line_number':3865,'multiline':False]['text':'         in the same way that UText does.','line_number':3866,'multiline':False]['text':' Outer loop moves over match starting positions in the','line_number':3895,'multiline':False]['text':'      target CE space.','line_number':3896,'multiline':False]['text':' Here we see the target as a sequence of collation elements, resulting from the following:','line_number':3897,'multiline':False]['text':' 1. Target characters were decomposed, and (if appropriate) other compressions and expansions are applied','line_number':3898,'multiline':False]['text':'    (for example, digraphs such as IJ may be broken into two characters).','line_number':3899,'multiline':False]['text':' 2. An int64_t CE weight is determined for each resulting unit (high 16 bits are primary strength, next','line_number':3900,'multiline':False]['text':'    16 bits are secondary, next 16 (the high 16 bits of the low 32-bit half) are tertiary. Any of these','line_number':3901,'multiline':False]['text':'    fields that are for strengths below that of the collator are set to 0. If this makes the int64_t','line_number':3902,'multiline':False]['text':'    CE weight 0 (as for a combining diacritic with secondary weight when the collator strentgh is primary),','line_number':3903,'multiline':False]['text':'    then the CE is deleted, so the following code sees only CEs that are relevant.','line_number':3904,'multiline':False]['text':' For each CE, the lowIndex and highIndex correspond to where this CE begins and ends in the original text.','line_number':3905,'multiline':False]['text':' If lowIndex==highIndex, either the CE resulted from an expansion/decomposition of one of the original text','line_number':3906,'multiline':False]['text':' characters, or the CE marks the limit of the target text (in which case the CE weight is UCOL_PROCESSED_NULLORDER).','line_number':3907,'multiline':False]['text':'','line_number':3908,'multiline':False]['text':'  Inner loop checks for a match beginning at each','line_number':3912,'multiline':False]['text':'  position from the outer loop.','line_number':3913,'multiline':False]['text':' For targetIx > 0, this ceb.get gets a CE that is as far back in the ring buffer','line_number':3916,'multiline':False]['text':' (compared to the last CE fetched for the previous targetIx value) as we need to go','line_number':3917,'multiline':False]['text':' for this targetIx value, so if it is non-NULL then other ceb.get calls should be OK.','line_number':3918,'multiline':False]['text':'  Compare CE from target string with CE from the pattern.','line_number':3929,'multiline':False]['text':'    Note that the target CE will be UCOL_PROCESSED_NULLORDER if we reach the end of input,','line_number':3930,'multiline':False]['text':'    which will fail the compare, below.','line_number':3931,'multiline':False]['text':' redo with same patCE, next targCE','line_number':3938,'multiline':False]['text':' ceMatch == U_CE_SKIP_PATN','line_number':3941,'multiline':False]['text':' redo with same targCE, next patCE','line_number':3942,'multiline':False]['text':' this is now the offset in target CE space to end of the match so far','line_number':3947,'multiline':False]['text':' No match at this targetIx.  Try again at the next.','line_number':3950,'multiline':False]['text':' No match at all, we have run off the end of the target text.','line_number':3955,'multiline':False]['text':' We have found a match in CE space.','line_number':3960,'multiline':False]['text':' Now determine the bounds in string index space.','line_number':3961,'multiline':False]['text':'  There still is a chance of match failure if the CE range not correspond to','line_number':3962,'multiline':False]['text':'     an acceptable character range.','line_number':3963,'multiline':False]['text':'','line_number':3964,'multiline':False]['text':' Look at the CE following the match.  If it is UCOL_NULLORDER the match','line_number':3970,'multiline':False]['text':'   extended to the end of input, and the match is good.','line_number':3971,'multiline':False]['text':' Look at the high and low indices of the CE following the match. If','line_number':3973,'multiline':False]['text':' they are the same it means one of two things:','line_number':3974,'multiline':False]['text':'    1. The match extended to the last CE from the target text, which is OK, or','line_number':3975,'multiline':False]['text':'    2. The last CE that was part of the match is in an expansion that extends','line_number':3976,'multiline':False]['text':'       to the first CE after the match. In this case, we reject the match.','line_number':3977,'multiline':False]['text':' If we are at the end of the target too, match succeeds','line_number':3989,'multiline':False]['text':' As long as the next CE has primary weight of 0,','line_number':3993,'multiline':False]['text':' it is part of the last target element matched by the pattern;','line_number':3994,'multiline':False]['text':' make sure it can be part of a match with the last patCE','line_number':3995,'multiline':False]['text':' If lowIndex == highIndex, this target CE is part of an expansion of the last matched','line_number':4002,'multiline':False]['text':' target element, but it has non-zero primary weight => match fails','line_number':4003,'multiline':False]['text':' Else the target CE is not part of an expansion of the last matched element, match succeeds','line_number':4007,'multiline':False]['text':' Check for the start of the match being within a combining sequence.','line_number':4015,'multiline':False]['text':'   This can happen if the pattern itself begins with a combining char, and','line_number':4016,'multiline':False]['text':'   the match found combining marks in the target text that were attached','line_number':4017,'multiline':False]['text':'    to something else.','line_number':4018,'multiline':False]['text':'   This type of match should be rejected for not completely consuming a','line_number':4019,'multiline':False]['text':'   combining sequence.','line_number':4020,'multiline':False]['text':' Check for the start of the match being within an Collation Element Expansion,','line_number':4025,'multiline':False]['text':'   meaning that the first char of the match is only partially matched.','line_number':4026,'multiline':False]['text':'   With expansions, the first CE will report the index of the source','line_number':4027,'multiline':False]['text':'   character, and all subsequent (expansions) CEs will report the source index of the','line_number':4028,'multiline':False]['text':'    _following_ character.','line_number':4029,'multiline':False]['text':' Allow matches to end in the middle of a grapheme cluster if the following','line_number':4035,'multiline':False]['text':' conditions are met; this is needed to make prefix search work properly in','line_number':4036,'multiline':False]['text':' Indic, see #11750','line_number':4037,'multiline':False]['text':' * the default breakIter is being used','line_number':4038,'multiline':False]['text':' * the next collation element after this combining sequence','line_number':4039,'multiline':False]['text':'   - has non-zero primary weight','line_number':4040,'multiline':False]['text':'   - corresponds to a separate character following the one at end of the current match','line_number':4041,'multiline':False]['text':'   (the second of these conditions, and perhaps both, may be redundant given the','line_number':4042,'multiline':False]['text':'   subsequent check for normalization boundary; however they are likely much faster','line_number':4043,'multiline':False]['text':'   tests in any case)','line_number':4044,'multiline':False]['text':' * the match limit is a normalization boundary','line_number':4045,'multiline':False]['text':' If those conditions are met, then:','line_number':4055,'multiline':False]['text':' * do NOT advance the candidate match limit (mLimit) to a break boundary; however','line_number':4056,'multiline':False]['text':'   the match limit may be backed off to a previous break boundary. This handles','line_number':4057,'multiline':False]['text':'   cases in which mLimit includes target characters that are ignorable with current','line_number':4058,'multiline':False]['text':'   settings (such as space) and which extend beyond the pattern match.','line_number':4059,'multiline':False]['text':' * do NOT require that end of the combining sequence not extend beyond the match in CE space','line_number':4060,'multiline':False]['text':' * do NOT require that match limit be on a breakIter boundary','line_number':4061,'multiline':False]['text':'  Advance the match end position to the first acceptable match boundary.','line_number':4063,'multiline':False]['text':'    This advances the index over any combining characters.','line_number':4064,'multiline':False]['text':' When the last CE's low index is same with its high index, the CE is likely','line_number':4067,'multiline':False]['text':' a part of expansion. In this case, the index is located just after the','line_number':4068,'multiline':False]['text':' character corresponding to the CEs compared above. If the index is right','line_number':4069,'multiline':False]['text':' at the break boundary, move the position to the next boundary will result','line_number':4070,'multiline':False]['text':' incorrect match length when there are ignorable characters exist between','line_number':4071,'multiline':False]['text':' the position and the next character produces CE(s). See ticket#8482.','line_number':4072,'multiline':False]['text':' Note that we can have nba < maxLimit && nba >= minLImit, in which','line_number':4077,'multiline':False]['text':' case we want to set mLimit to nba regardless of allowMidclusterMatch','line_number':4078,'multiline':False]['text':' (i.e. we back off mLimit to the previous breakIterator boundary).','line_number':4079,'multiline':False]['text':' If advancing to the end of a combining sequence in character indexing space','line_number':4093,'multiline':False]['text':'   advanced us beyond the end of the match in CE space, reject this match.','line_number':4094,'multiline':False]['text':' All Done.  Store back the match bounds to the caller.','line_number':4124,'multiline':False]['text':'','line_number':4125,'multiline':False]['text':' TODO:  reject search patterns beginning with a combining char.','line_number':4152,'multiline':False]['text':' Input parameter sanity check.','line_number':4164,'multiline':False]['text':'  TODO:  should input indicies clip to the text length','line_number':4165,'multiline':False]['text':'         in the same way that UText does.','line_number':4166,'multiline':False]['text':'
     * Pre-load the buffer with the CE's for the grapheme
     * after our starting position so that we're sure that
     * we can look at the CE following the match when we
     * check the match boundaries.
     *
     * This will also pre-fetch the first CE that we'll
     * consider for the match.
     ','line_number':4182,'multiline':True]['text':' Outer loop moves over match starting positions in the','line_number':4219,'multiline':False]['text':'      target CE space.','line_number':4220,'multiline':False]['text':' Here, targetIx values increase toward the beginning of the base text (i.e. we get the text CEs in reverse order).','line_number':4221,'multiline':False]['text':' But  patIx is 0 at the beginning of the pattern and increases toward the end.','line_number':4222,'multiline':False]['text':' So this loop performs a comparison starting with the end of pattern, and prcessd toward the beginning of the pattern','line_number':4223,'multiline':False]['text':' and the beginning of the base text.','line_number':4224,'multiline':False]['text':' For targetIx > limitIx, this ceb.getPrevious gets a CE that is as far back in the ring buffer','line_number':4228,'multiline':False]['text':' (compared to the last CE fetched for the previous targetIx value) as we need to go','line_number':4229,'multiline':False]['text':' for this targetIx value, so if it is non-NULL then other ceb.getPrevious calls should be OK.','line_number':4230,'multiline':False]['text':'  Inner loop checks for a match beginning at each','line_number':4237,'multiline':False]['text':'  position from the outer loop.','line_number':4238,'multiline':False]['text':'  Compare CE from target string with CE from the pattern.','line_number':4244,'multiline':False]['text':'    Note that the target CE will be UCOL_NULLORDER if we reach the end of input,','line_number':4245,'multiline':False]['text':'    which will fail the compare, below.','line_number':4246,'multiline':False]['text':' redo with same patCE, next targCE','line_number':4253,'multiline':False]['text':' ceMatch == U_CE_SKIP_PATN','line_number':4256,'multiline':False]['text':' redo with same targCE, next patCE','line_number':4257,'multiline':False]['text':' No match at this targetIx.  Try again at the next.','line_number':4264,'multiline':False]['text':' No match at all, we have run off the end of the target text.','line_number':4269,'multiline':False]['text':' We have found a match in CE space.','line_number':4274,'multiline':False]['text':' Now determine the bounds in string index space.','line_number':4275,'multiline':False]['text':'  There still is a chance of match failure if the CE range not correspond to','line_number':4276,'multiline':False]['text':'     an acceptable character range.','line_number':4277,'multiline':False]['text':'','line_number':4278,'multiline':False]['text':' Check for the start of the match being within a combining sequence.','line_number':4282,'multiline':False]['text':'   This can happen if the pattern itself begins with a combining char, and','line_number':4283,'multiline':False]['text':'   the match found combining marks in the target text that were attached','line_number':4284,'multiline':False]['text':'    to something else.','line_number':4285,'multiline':False]['text':'   This type of match should be rejected for not completely consuming a','line_number':4286,'multiline':False]['text':'   combining sequence.','line_number':4287,'multiline':False]['text':' Look at the high index of the first CE in the match. If it's the same as the','line_number':4292,'multiline':False]['text':' low index, the first CE in the match is in the middle of an expansion.','line_number':4293,'multiline':False]['text':' Look at the CE following the match.  If it is UCOL_NULLORDER the match','line_number':4302,'multiline':False]['text':'   extended to the end of input, and the match is good.','line_number':4303,'multiline':False]['text':' Look at the high and low indices of the CE following the match. If','line_number':4305,'multiline':False]['text':' they are the same it means one of two things:','line_number':4306,'multiline':False]['text':'    1. The match extended to the last CE from the target text, which is OK, or','line_number':4307,'multiline':False]['text':'    2. The last CE that was part of the match is in an expansion that extends','line_number':4308,'multiline':False]['text':'       to the first CE after the match. In this case, we reject the match.','line_number':4309,'multiline':False]['text':' Allow matches to end in the middle of a grapheme cluster if the following','line_number':4318,'multiline':False]['text':' conditions are met; this is needed to make prefix search work properly in','line_number':4319,'multiline':False]['text':' Indic, see #11750','line_number':4320,'multiline':False]['text':' * the default breakIter is being used','line_number':4321,'multiline':False]['text':' * the next collation element after this combining sequence','line_number':4322,'multiline':False]['text':'   - has non-zero primary weight','line_number':4323,'multiline':False]['text':'   - corresponds to a separate character following the one at end of the current match','line_number':4324,'multiline':False]['text':'   (the second of these conditions, and perhaps both, may be redundant given the','line_number':4325,'multiline':False]['text':'   subsequent check for normalization boundary; however they are likely much faster','line_number':4326,'multiline':False]['text':'   tests in any case)','line_number':4327,'multiline':False]['text':' * the match limit is a normalization boundary','line_number':4328,'multiline':False]['text':' If those conditions are met, then:','line_number':4338,'multiline':False]['text':' * do NOT advance the candidate match limit (mLimit) to a break boundary; however','line_number':4339,'multiline':False]['text':'   the match limit may be backed off to a previous break boundary. This handles','line_number':4340,'multiline':False]['text':'   cases in which mLimit includes target characters that are ignorable with current','line_number':4341,'multiline':False]['text':'   settings (such as space) and which extend beyond the pattern match.','line_number':4342,'multiline':False]['text':' * do NOT require that end of the combining sequence not extend beyond the match in CE space','line_number':4343,'multiline':False]['text':' * do NOT require that match limit be on a breakIter boundary','line_number':4344,'multiline':False]['text':'  Advance the match end position to the first acceptable match boundary.','line_number':4346,'multiline':False]['text':'    This advances the index over any combining characters.','line_number':4347,'multiline':False]['text':' Note that we can have nba < maxLimit && nba >= minLImit, in which','line_number':4350,'multiline':False]['text':' case we want to set mLimit to nba regardless of allowMidclusterMatch','line_number':4351,'multiline':False]['text':' (i.e. we back off mLimit to the previous breakIterator boundary).','line_number':4352,'multiline':False]['text':' If advancing to the end of a combining sequence in character indexing space','line_number':4359,'multiline':False]['text':'   advanced us beyond the end of the match in CE space, reject this match.','line_number':4360,'multiline':False]['text':' Make sure the end of the match is on a break boundary','line_number':4365,'multiline':False]['text':' No non-ignorable CEs after this point.','line_number':4372,'multiline':False]['text':' The maximum position is detected by boundary after','line_number':4373,'multiline':False]['text':' the last non-ignorable CE. Combining sequence','line_number':4374,'multiline':False]['text':' across the start index will be truncated.','line_number':4375,'multiline':False]['text':' All Done.  Store back the match bounds to the caller.','line_number':4407,'multiline':False]['text':'','line_number':4408,'multiline':False]['text':' internal use methods declared in usrchimp.h -----------------------------','line_number':4425,'multiline':False]['text':' status used in setting coleiter offset, since offset is checked in','line_number':4441,'multiline':False]['text':' shiftForward before setting the coleiter offset, status never','line_number':4442,'multiline':False]['text':' a failure','line_number':4443,'multiline':False]['text':' finding the last pattern ce match, imagine composite characters','line_number':4456,'multiline':False]['text':' for example: search for pattern A in text \u00C0','line_number':4457,'multiline':False]['text':' we'll have to skip \u0300 the grave first before we get to A','line_number':4458,'multiline':False]['text':' this is for the text \u0315\u0300 that requires','line_number':4466,'multiline':False]['text':' normalization and pattern \u0300, where \u0315 is ignorable','line_number':4467,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4473,'multiline':False]['text':' the first ce can be a contraction','line_number':4475,'multiline':False]['text':'targetce = lastce;','line_number':4485,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4500,'multiline':False]['text':' status checked at loop.','line_number':4512,'multiline':False]['text':' status checked in ucol_setOffset','line_number':4518,'multiline':False]['text':' finding the last pattern ce match, imagine composite characters','line_number':4572,'multiline':False]['text':' for example: search for pattern A in text \u00C0','line_number':4573,'multiline':False]['text':' we'll have to skip \u0300 the grave first before we get to A','line_number':4574,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4584,'multiline':False]['text':' the first ce can be a contraction','line_number':4586,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4608,'multiline':False]['text':' initializing the rearranged accent array','line_number':4612,'multiline':False]['text':' status checked at loop','line_number':4628,'multiline':False]['text':' shifting it check for setting offset','line_number':4669,'multiline':False]['text':' if setOffset is called previously or there was no previous match, we','line_number':4670,'multiline':False]['text':' leave the offset as it is.','line_number':4671,'multiline':False]['text':' if status is a failure, ucol_setOffset does nothing','line_number':4686,'multiline':False]['text':' finding the first pattern ce match, imagine composite','line_number':4690,'multiline':False]['text':' characters. for example: search for pattern \u0300 in text','line_number':4691,'multiline':False]['text':' \u00C0, we'll have to skip A first before we get to','line_number':4692,'multiline':False]['text':' \u0300 the grave accent','line_number':4693,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4706,'multiline':False]['text':' checking for accents in composite character','line_number':4712,'multiline':False]['text':'targetce = firstce;','line_number':4718,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4732,'multiline':False]['text':' move the start position at the end of possible match','line_number':4764,'multiline':False]['text':' at the end of the text','line_number':4773,'multiline':False]['text':' shifting it check for setting offset','line_number':4817,'multiline':False]['text':' if setOffset is called previously or there was no previous match, we','line_number':4818,'multiline':False]['text':' leave the offset as it is.','line_number':4819,'multiline':False]['text':' finding the first pattern ce match, imagine composite','line_number':4838,'multiline':False]['text':' characters. for example: search for pattern \u0300 in text','line_number':4839,'multiline':False]['text':' \u00C0, we'll have to skip A first before we get to','line_number':4840,'multiline':False]['text':' \u0300 the grave accent','line_number':4841,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4852,'multiline':False]['text':' the first ce can be a contraction','line_number':4854,'multiline':False]['text':' checking for accents in composite character','line_number':4859,'multiline':False]['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4878,'multiline':False]['text':' initializing the rearranged accent array','line_number':4883,'multiline':False]['text':' move the start position at the end of possible match','line_number':4917,'multiline':False]['text':' at the end of the text','line_number':4926,'multiline':False]['text':' #if !UCONFIG_NO_COLLATION ','line_number':4954,'multiline':True]