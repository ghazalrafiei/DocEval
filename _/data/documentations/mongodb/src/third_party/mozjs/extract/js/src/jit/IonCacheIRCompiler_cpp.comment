['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JS::ExpandoAndGeneration','line_number':23,'multiline':False]['text':' IonCacheIRCompiler compiles CacheIR to IonIC native code.','line_number':45,'multiline':False]['text':' AutoSaveLiveRegisters must be used when we make a call that can GC. The','line_number':82,'multiline':False]['text':' constructor ensures all live registers are stored on the stack (where the GC','line_number':83,'multiline':False]['text':' expects them) and the destructor restores these registers.','line_number':84,'multiline':False]['text':' namespace jit','line_number':102,'multiline':False]['text':' namespace js','line_number':103,'multiline':False]['text':' We have to push all registers in liveRegs on the stack. It's possible we','line_number':109,'multiline':False]['text':' stored other values in our live registers and stored operands on the','line_number':110,'multiline':False]['text':' stack (where our live registers should go), so this requires some careful','line_number':111,'multiline':False]['text':' work. Try to keep it simple by taking one small step at a time.','line_number':112,'multiline':False]['text':' Step 1. Discard any dead operands so we can reuse their registers.','line_number':114,'multiline':False]['text':' Step 2. Figure out the size of our live regs.  This is consistent with','line_number':117,'multiline':False]['text':' the fact that we're using storeRegsInMask to generate the save code and','line_number':118,'multiline':False]['text':' PopRegsInMask to generate the restore code.','line_number':119,'multiline':False]['text':' Step 3. Ensure all non-input operands are on the stack.','line_number':124,'multiline':False]['text':' Step 4. Restore the register state, but don't discard the stack as','line_number':133,'multiline':False]['text':' non-input operands are stored there.','line_number':134,'multiline':False]['text':' shouldDiscardStack = ','line_number':135,'multiline':True]['text':' We just restored the input state, so no input operands should be stored','line_number':137,'multiline':False]['text':' on the stack.','line_number':138,'multiline':False]['text':' Step 5. At this point our register state is correct. Stack values,','line_number':146,'multiline':False]['text':' however, may cover the space where we have to store the live registers.','line_number':147,'multiline':False]['text':' Move them out of the way.','line_number':148,'multiline':False]['text':' If this operand doesn't cover the live register space, there's','line_number':165,'multiline':False]['text':' nothing to do.','line_number':166,'multiline':False]['text':' Reserve stack space for the live registers if needed.','line_number':172,'multiline':False]['text':' Push the operand below the live register space.','line_number':180,'multiline':False]['text':' Step 6. If we have any operands on the stack, adjust their stackPushed','line_number':195,'multiline':False]['text':' values to not include sizeOfLiveRegsInBytes (this simplifies code down','line_number':196,'multiline':False]['text':' the line). Then push/store the live registers.','line_number':197,'multiline':False]['text':' If no operands are on the stack, discard the unused stack space.','line_number':214,'multiline':False]['text':' Step 7. All live registers and non-input operands are stored on the stack','line_number':227,'multiline':False]['text':' now, so at this point all registers except for the input registers are','line_number':228,'multiline':False]['text':' available.','line_number':229,'multiline':False]['text':' Step 8. We restored our input state, so we have to fix up aliased input','line_number':233,'multiline':False]['text':' registers again.','line_number':234,'multiline':False]['text':' The AutoSaveLiveRegisters parameter is used to ensure registers were saved','line_number':260,'multiline':False]['text':' Done emitting the main IC code. Now emit the failure paths.','line_number':562,'multiline':False]['text':' FloatReg0 is available per LIRGenerator::visitSetPropertyCache.','line_number':616,'multiline':False]['text':' FloatReg0 and FloatReg1 are available per','line_number':621,'multiline':False]['text':' LIRGenerator::visitBinaryCache.','line_number':622,'multiline':False]['text':' Verify that the global wrapper is still valid, as','line_number':698,'multiline':False]['text':' it is pre-requisite for doing the compartment check.','line_number':699,'multiline':False]['text':' Construct IonICCallFrameLayout.','line_number':860,'multiline':False]['text':' The JitFrameLayout pushed below will be aligned to JitStackAlignment,','line_number':867,'multiline':False]['text':' so we just have to make sure the stack is aligned after we push the','line_number':868,'multiline':False]['text':' |this| + argument Values.','line_number':869,'multiline':False]['text':' argc','line_number':890,'multiline':False]['text':' Check stack alignment. Add sizeof(uintptr_t) for the return address.','line_number':894,'multiline':False]['text':' Native functions have the signature:','line_number':938,'multiline':False]['text':'  bool (*)(JSContext*, unsigned, Value* vp)','line_number':939,'multiline':False]['text':' Where vp[0] is space for an outparam, vp[1] is |this|, and vp[2] onward','line_number':940,'multiline':False]['text':' are the function arguments.','line_number':941,'multiline':False]['text':' Construct vp array:','line_number':943,'multiline':False]['text':' Push receiver value for |this|','line_number':944,'multiline':False]['text':' Push callee/outparam.','line_number':946,'multiline':False]['text':' Preload arguments into registers.','line_number':949,'multiline':False]['text':' Push marking data for later use.','line_number':954,'multiline':False]['text':' Construct and execute call.','line_number':967,'multiline':False]['text':' Test for failure.','line_number':975,'multiline':False]['text':' Load the outparam vp[0] into output register(s).','line_number':982,'multiline':False]['text':' ProxyGetProperty(JSContext* cx, HandleObject proxy, HandleId id,','line_number':1051,'multiline':False]['text':'                  MutableHandleValue vp)','line_number':1052,'multiline':False]['text':' Push stubCode for marking.','line_number':1061,'multiline':False]['text':' Push args on stack first so we can take pointers to make handles.','line_number':1064,'multiline':False]['text':' Push the proxy. Also used as receiver.','line_number':1071,'multiline':False]['text':' Make the call.','line_number':1082,'multiline':False]['text':' Test for failure.','line_number':1093,'multiline':False]['text':' Load the outparam vp[0] into output register(s).','line_number':1096,'multiline':False]['text':' Spectre mitigation in case of speculative execution within C++ code.','line_number':1101,'multiline':False]['text':' masm.leaveExitFrame & pop locals','line_number':1106,'multiline':False]['text':' Check for uninitialized lexicals.','line_number':1127,'multiline':False]['text':' Load the value.','line_number':1131,'multiline':False]['text':' Check for uninitialized lexicals.','line_number':1151,'multiline':False]['text':' Load the value.','line_number':1155,'multiline':False]['text':' Push the operands in reverse order for JSOp::Le and JSOp::Gt:','line_number':1185,'multiline':False]['text':' - |left <= right| is implemented as |right >= left|.','line_number':1186,'multiline':False]['text':' - |left > right| is implemented as |right < left|.','line_number':1187,'multiline':False]['text':' We have to (re)allocate dynamic slots. Do this first, as it's the','line_number':1264,'multiline':False]['text':' only fallible operation here. Note that growSlotsPure is','line_number':1265,'multiline':False]['text':' fallible but does not GC.','line_number':1266,'multiline':False]['text':' Update the object's shape.','line_number':1297,'multiline':False]['text':' Perform the store. No pre-barrier required since this is a new','line_number':1303,'multiline':False]['text':' initialization.','line_number':1304,'multiline':False]['text':' Bounds check, load string char.','line_number':1366,'multiline':False]['text':' Load StaticString for this char. For larger code units perform a VM call.','line_number':1371,'multiline':False]['text':' FailurePath and AutoSaveLiveRegisters don't get along very well. Both are','line_number':1384,'multiline':False]['text':' modifying the stack and expect that no other stack manipulations are','line_number':1385,'multiline':False]['text':' made. Therefore we need to use an ABI call instead of a VM call here.','line_number':1386,'multiline':False]['text':' Set up the call:','line_number':1433,'multiline':False]['text':'  bool (*)(JSContext*, unsigned, Value* vp)','line_number':1434,'multiline':False]['text':' vp[0] is callee/outparam','line_number':1435,'multiline':False]['text':' vp[1] is |this|','line_number':1436,'multiline':False]['text':' vp[2] is the value','line_number':1437,'multiline':False]['text':' Build vp and move the base into argVpReg.','line_number':1439,'multiline':False]['text':' Preload other regs.','line_number':1445,'multiline':False]['text':' Push marking data for later use.','line_number':1449,'multiline':False]['text':' Make the call.','line_number':1462,'multiline':False]['text':' Test for failure.','line_number':1470,'multiline':False]['text':' Construct IonICCallFrameLayout.','line_number':1501,'multiline':False]['text':' The JitFrameLayout pushed below will be aligned to JitStackAlignment,','line_number':1508,'multiline':False]['text':' so we just have to make sure the stack is aligned after we push the','line_number':1509,'multiline':False]['text':' |this| + argument Values.','line_number':1510,'multiline':False]['text':' argc','line_number':1533,'multiline':False]['text':' Check stack alignment. Add sizeof(uintptr_t) for the return address.','line_number':1537,'multiline':False]['text':' Load our PropertyIteratorObject* and its NativeIterator.','line_number':1709,'multiline':False]['text':' Ensure the iterator is reusable: see NativeIterator::isReusable.','line_number':1714,'multiline':False]['text':' Pre-write barrier for store to 'objectBeingIterated_'.','line_number':1717,'multiline':False]['text':' Mark iterator as active.','line_number':1721,'multiline':False]['text':' Post-write barrier for stores to 'objectBeingIterated_'.','line_number':1726,'multiline':False]['text':' Chain onto the active iterator stack.','line_number':1731,'multiline':False]['text':' The expando object is not used in this case, so we don't need Spectre','line_number':1756,'multiline':False]['text':' mitigations.','line_number':1757,'multiline':False]['text':' We shouldn't GC or report OOM (or any other exception) here.','line_number':1789,'multiline':False]['text':' Do nothing if the IR generator failed or triggered a GC that invalidated','line_number':1795,'multiline':False]['text':' the script.','line_number':1796,'multiline':False]['text':' Try to reuse a previously-allocated CacheIRStubInfo.','line_number':1807,'multiline':False]['text':' Allocate the shared CacheIRStubInfo. Note that the','line_number':1812,'multiline':False]['text':' putIonCacheIRStubInfo call below will transfer ownership to','line_number':1813,'multiline':False]['text':' the stub info HashSet, so we don't have to worry about freeing','line_number':1814,'multiline':False]['text':' it below.','line_number':1815,'multiline':False]['text':' For Ion ICs, we don't track/use the makesGCCalls flag, so just pass true.','line_number':1817,'multiline':False]['text':' Ensure we don't attach duplicate stubs. This can happen if a stub failed','line_number':1833,'multiline':False]['text':' for some reason and the IR generator doesn't check for exactly the same','line_number':1834,'multiline':False]['text':' conditions.','line_number':1835,'multiline':False]['text':' Allocate the IonICStub in the optimized stub space. Ion stubs and','line_number':1848,'multiline':False]['text':' CacheIRStubInfo instances for Ion stubs can be purged on GC. That's okay','line_number':1849,'multiline':False]['text':' because the stub code is rooted separately when we make a VM call, and','line_number':1850,'multiline':False]['text':' stub code should never access the IonICStub after making a VM call. The','line_number':1851,'multiline':False]['text':' IonICStub::poison method poisons the stub to catch bugs in this area.','line_number':1852,'multiline':False]