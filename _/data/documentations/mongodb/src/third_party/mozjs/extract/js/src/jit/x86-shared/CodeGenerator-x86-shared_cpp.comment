['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':18,'multiline':False]['text':' vucomisd flags:','line_number':96,'multiline':False]['text':'             Z  P  C','line_number':97,'multiline':False]['text':'            ---------','line_number':98,'multiline':False]['text':'      NaN    1  1  1','line_number':99,'multiline':False]['text':'        >    0  0  0','line_number':100,'multiline':False]['text':'        <    0  0  1','line_number':101,'multiline':False]['text':'        =    1  0  0','line_number':102,'multiline':False]['text':'','line_number':103,'multiline':False]['text':' NaN is falsey, so comparing against 0 and then using the Z flag is','line_number':104,'multiline':False]['text':' enough to determine which branch to take.','line_number':105,'multiline':False]['text':' vucomiss flags are the same as doubles; see comment above','line_number':114,'multiline':False]['text':' Not returns true if the input is a NaN. We don't have to worry about','line_number':209,'multiline':False]['text':' it if we know the input is never NaN though.','line_number':210,'multiline':False]['text':' Not returns true if the input is a NaN. We don't have to worry about','line_number':225,'multiline':False]['text':' it if we know the input is never NaN though.','line_number':226,'multiline':False]['text':' All non-table-based bailouts will go here.','line_number':535,'multiline':False]['text':' Push the frame size, so the handler can recover the IonScript.','line_number':538,'multiline':False]['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':582,'multiline':False]['text':' the known value makes sense. We can't use bailout tables if the stack','line_number':583,'multiline':False]['text':' isn't properly aligned to the static frame size.','line_number':584,'multiline':False]['text':' On x64, bailout tables are pointless, because 16 extra bytes are','line_number':589,'multiline':False]['text':' reserved per external jump, whereas it takes only 10 bytes to encode a','line_number':590,'multiline':False]['text':' a non-table based bailout.','line_number':591,'multiline':False]['text':' We could not use a jump table, either because all bailout IDs were','line_number':599,'multiline':False]['text':' reserved, or a jump table is not optimal for this frame size or','line_number':600,'multiline':False]['text':' platform. Whatever, we will generate a lazy bailout.','line_number':601,'multiline':False]['text':'','line_number':602,'multiline':False]['text':' All bailout code is associated with the bytecodeSite of the block we are','line_number':603,'multiline':False]['text':' bailing out from.','line_number':604,'multiline':False]['text':' Branch if not -Infinity.','line_number':709,'multiline':False]['text':' Math.pow(-Infinity, 0.5) == Infinity.','line_number':718,'multiline':False]['text':' Math.pow(-0, 0.5) == 0 == Math.pow(0, 0.5).','line_number':727,'multiline':False]['text':' Adding 0 converts any -0 to 0.','line_number':728,'multiline':False]['text':' Undo the effect of the ALU operation, which was performed on the output','line_number':829,'multiline':False]['text':' register and overflowed. Writing to the output register clobbered an','line_number':830,'multiline':False]['text':' input reg, and the original value of the input needs to be recovered','line_number':831,'multiline':False]['text':' to satisfy the constraint imposed by any RECOVERED_INPUT operands to','line_number':832,'multiline':False]['text':' the bailout snapshot.','line_number':833,'multiline':False]['text':' Bailout on -0.0','line_number':873,'multiline':False]['text':' escape overflow check;','line_number':888,'multiline':False]['text':' nop','line_number':890,'multiline':False]['text':' escape overflow check;','line_number':891,'multiline':False]['text':' Use shift if cannot overflow and constant is power of 2','line_number':897,'multiline':False]['text':' Bailout on overflow','line_number':907,'multiline':False]['text':' Bailout on overflow','line_number':914,'multiline':False]['text':' Jump to an OOL path if the result is 0.','line_number':920,'multiline':False]['text':' nop','line_number':947,'multiline':False]['text':' Use shift if constant is power of 2.','line_number':954,'multiline':False]['text':' Put the lhs in eax.','line_number':998,'multiline':False]['text':' Prevent divide by zero.','line_number':1003,'multiline':False]['text':' Zero extend the lhs into edx to make (edx:eax), since udiv is 64-bit.','line_number':1021,'multiline':False]['text':' If the remainder is > 0, bailout since this must be a double.','line_number':1025,'multiline':False]['text':' Unsigned div or mod can return a value that's not a signed int32.','line_number':1032,'multiline':False]['text':' If our users aren't expecting that, bail.','line_number':1033,'multiline':False]['text':' This emits the division answer into edx or the modulus answer into eax.','line_number':1050,'multiline':False]['text':' The denominator isn't a power of 2 (see LDivPowTwoI and LModPowTwoI).','line_number':1068,'multiline':False]['text':' maxLog = ','line_number':1071,'multiline':True]['text':' We first compute (M * n) >> 32, where M = rmc.multiplier.','line_number':1073,'multiline':False]['text':' M >= 2^32 and shift == 0 is impossible, as d >= 2 implies that','line_number':1077,'multiline':False]['text':' ((M * n) >> (32 + shift)) >= n > floor(n/d) whenever n >= d,','line_number':1078,'multiline':False]['text':' contradicting the proof of correctness in computeDivisionConstants.','line_number':1079,'multiline':False]['text':' We actually computed edx = ((uint32_t(M) * n) >> 32) instead. Since','line_number':1083,'multiline':False]['text':' (M * n) >> (32 + shift) is the same as (edx + n) >> shift, we can','line_number':1084,'multiline':False]['text':' correct for the overflow. This case is a bit trickier than the signed','line_number':1085,'multiline':False]['text':' case, though, as the (edx + n) addition itself can overflow; however,','line_number':1086,'multiline':False]['text':' note that (edx + n) >> shift == (((n - edx) >> 1) + edx) >> (shift - 1),','line_number':1087,'multiline':False]['text':' which is overflow-free. See Hacker's Delight, section 10-8 for details.','line_number':1088,'multiline':False]['text':' Compute (n - edx) >> 1 into eax.','line_number':1090,'multiline':False]['text':' Finish the computation.','line_number':1095,'multiline':False]['text':' We now have the truncated division value in edx. If we're','line_number':1102,'multiline':False]['text':' computing a modulus or checking whether the division resulted','line_number':1103,'multiline':False]['text':' in an integer, we need to multiply the obtained value by d and','line_number':1104,'multiline':False]['text':' finish the computation/check.','line_number':1105,'multiline':False]['text':' The final result of the modulus op, just computed above by the','line_number':1111,'multiline':False]['text':' sub instruction, can be a number in the range [2^31, 2^32). If','line_number':1112,'multiline':False]['text':' this is the case and the modulus is not truncated, we must bail','line_number':1113,'multiline':False]['text':' out.','line_number':1114,'multiline':False]['text':' Result is -0 if lhs or rhs is negative.','line_number':1133,'multiline':False]['text':' We use defineReuseInput so these should always be the same, which is','line_number':1150,'multiline':False]['text':' convenient since all of our instructions here are two-address.','line_number':1151,'multiline':False]['text':' 0 divided by a negative number must return a double.','line_number':1155,'multiline':False]['text':' If the remainder is != 0, bailout since this must be a double.','line_number':1162,'multiline':False]['text':' Adjust the value so that shifting produces a correctly','line_number':1170,'multiline':False]['text':' rounded result when the numerator is negative. See 10-1','line_number':1171,'multiline':False]['text':' "Signed Division by a Known Power of 2" in Henry','line_number':1172,'multiline':False]['text':' S. Warren, Jr.'s Hacker's Delight.','line_number':1173,'multiline':False]['text':' Note: There is no need to execute this code, which handles how to','line_number':1175,'multiline':False]['text':' round the signed integer division towards 0, if we previously bailed','line_number':1176,'multiline':False]['text':' due to a non-zero remainder.','line_number':1177,'multiline':False]['text':' Copy the sign bit of the numerator. (= (2^32 - 1) or 0)','line_number':1181,'multiline':False]['text':' Divide by 2^(32 - shift)','line_number':1184,'multiline':False]['text':' i.e. (= (2^32 - 1) / 2^(32 - shift) or 0)','line_number':1185,'multiline':False]['text':' i.e. (= (2^shift - 1) or 0)','line_number':1186,'multiline':False]['text':' If signed, make any 1 bit below the shifted bits to bubble up, such','line_number':1188,'multiline':False]['text':' that once shifted the value would be rounded towards 0.','line_number':1189,'multiline':False]['text':' INT32_MIN / -1 overflows.','line_number':1202,'multiline':False]['text':' Unsigned division by 1 can overflow if output is not','line_number':1213,'multiline':False]['text':' truncated.','line_number':1214,'multiline':False]['text':' This emits the division answer into edx or the modulus answer into eax.','line_number':1225,'multiline':False]['text':' The absolute value of the denominator isn't a power of 2 (see LDivPowTwoI','line_number':1230,'multiline':False]['text':' and LModPowTwoI).','line_number':1231,'multiline':False]['text':' We will first divide by Abs(d), and negate the answer if d is negative.','line_number':1234,'multiline':False]['text':' If desired, this can be avoided by generalizing computeDivisionConstants.','line_number':1235,'multiline':False]['text':' maxLog = ','line_number':1237,'multiline':True]['text':' We first compute (M * n) >> 32, where M = rmc.multiplier.','line_number':1239,'multiline':False]['text':' We actually computed edx = ((int32_t(M) * n) >> 32) instead. Since','line_number':1245,'multiline':False]['text':' (M * n) >> 32 is the same as (edx + n), we can correct for the overflow.','line_number':1246,'multiline':False]['text':' (edx + n) can't overflow, as n and edx have opposite signs because','line_number':1247,'multiline':False]['text':' int32_t(M) is negative.','line_number':1248,'multiline':False]['text':' (M * n) >> (32 + shift) is the truncated division answer if n is','line_number':1251,'multiline':False]['text':' non-negative, as proved in the comments of computeDivisionConstants. We','line_number':1252,'multiline':False]['text':' must add 1 later if n is negative to get the right answer in all cases.','line_number':1253,'multiline':False]['text':' We'll subtract -1 instead of adding 1, because (n < 0 ? -1 : 0) can be','line_number':1256,'multiline':False]['text':' computed with just a sign-extending shift of 31 bits.','line_number':1257,'multiline':False]['text':' After this, edx contains the correct truncated division result.','line_number':1264,'multiline':False]['text':' This is a division op. Multiply the obtained value by d to check if','line_number':1276,'multiline':False]['text':' the correct answer is an integer. This cannot overflow, since |d| > 1.','line_number':1277,'multiline':False]['text':' If lhs is zero and the divisor is negative, the answer should have','line_number':1282,'multiline':False]['text':' been -0.','line_number':1283,'multiline':False]['text':' This is a mod op. If the computed value is zero and lhs','line_number':1289,'multiline':False]['text':' is negative, the answer should have been -0.','line_number':1290,'multiline':False]['text':' Put the lhs in eax, for either the negative overflow case or the regular','line_number':1320,'multiline':False]['text':' divide case.','line_number':1321,'multiline':False]['text':' Handle divide by zero.','line_number':1326,'multiline':False]['text':' Truncated division by zero is zero (Infinity|0 == 0)','line_number':1335,'multiline':False]['text':' Handle an integer overflow exception from -2147483648 / -1.','line_number':1346,'multiline':False]['text':' (-INT32_MIN)|0 == INT32_MIN and INT32_MIN is already in the','line_number':1356,'multiline':False]['text':' output register (lhs == eax).','line_number':1357,'multiline':False]['text':' Handle negative 0.','line_number':1366,'multiline':False]['text':' Sign extend the lhs into edx to make (edx:eax), since idiv is 64-bit.','line_number':1376,'multiline':False]['text':' If the remainder is > 0, bailout since this must be a double.','line_number':1384,'multiline':False]['text':' Switch based on sign of the lhs.','line_number':1404,'multiline':False]['text':' Positive numbers are just a bitmask','line_number':1405,'multiline':False]['text':' Negative numbers need a negate, bitmask, negate','line_number':1415,'multiline':False]['text':' Unlike in the visitModI case, we are not computing the mod by means of a','line_number':1418,'multiline':False]['text':' division. Therefore, the divisor = -1 case isn't problematic (the andl','line_number':1419,'multiline':False]['text':' always returns 0, which is what we expect).','line_number':1420,'multiline':False]['text':'','line_number':1421,'multiline':False]['text':' The negl instruction overflows if lhs == INT32_MIN, but this is also not','line_number':1422,'multiline':False]['text':' a problem: shift is at most 31, and so the andl also always returns 0.','line_number':1423,'multiline':False]['text':' Since a%b has the same sign as b, and a is negative in this branch,','line_number':1428,'multiline':False]['text':' an answer of 0 means the correct result is actually -0. Bail out.','line_number':1429,'multiline':False]['text':' Required to use idiv.','line_number':1470,'multiline':False]['text':' Set up eax in preparation for doing a div.','line_number':1480,'multiline':False]['text':' Prevent divide by zero.','line_number':1487,'multiline':False]['text':' Switch based on sign of the lhs.','line_number':1509,'multiline':False]['text':' If lhs >= 0 then remainder = lhs % rhs. The remainder must be positive.','line_number':1514,'multiline':False]['text':' Check if rhs is a power-of-two.','line_number':1516,'multiline':False]['text':' Rhs y is a power-of-two if (y & (y-1)) == 0. Note that if','line_number':1520,'multiline':False]['text':' y is any negative number other than INT32_MIN, both y and','line_number':1521,'multiline':False]['text':' y-1 will have the sign bit set so these are never optimized','line_number':1522,'multiline':False]['text':' as powers-of-two. If y is INT32_MIN, y-1 will be INT32_MAX','line_number':1523,'multiline':False]['text':' and because lhs >= 0 at this point, lhs & INT32_MAX returns','line_number':1524,'multiline':False]['text':' the correct value.','line_number':1525,'multiline':False]['text':' Since lhs >= 0, the sign-extension will be 0','line_number':1537,'multiline':False]['text':' Otherwise, we have to beware of two special cases:','line_number':1542,'multiline':False]['text':' Prevent an integer overflow exception from -2147483648 % -1','line_number':1548,'multiline':False]['text':' A remainder of 0 means that the rval must be -0, which is a double.','line_number':1558,'multiline':False]['text':' x >>> 0 can overflow.','line_number':1669,'multiline':False]['text':' x >>> 0 can overflow.','line_number':1689,'multiline':False]['text':' The entries of the jump table need to be absolute addresses and thus','line_number':1828,'multiline':False]['text':' must be patched after codegen is finished.','line_number':1829,'multiline':False]['text':' Lower value with low value','line_number':1842,'multiline':False]['text':' Jump to default case if input is out of range','line_number':1847,'multiline':False]['text':' To fill in the CodeLabels for the case entries, we need to first','line_number':1852,'multiline':False]['text':' generate the case entries (we don't yet know their offsets in the','line_number':1853,'multiline':False]['text':' instruction stream).','line_number':1854,'multiline':False]['text':' Compute the position where a pointer to the right case stands.','line_number':1858,'multiline':False]['text':' Jump to the right case','line_number':1862,'multiline':False]['text':' Ensure that there is enough space in the buffer for the OsiPoint','line_number':1937,'multiline':False]['text':' patching to occur. Otherwise, we could overwrite the invalidation','line_number':1938,'multiline':False]['text':' epilogue.','line_number':1939,'multiline':False]['text':' Push the Ion script onto the stack (when we determine what that pointer','line_number':1946,'multiline':False]['text':' is).','line_number':1947,'multiline':False]['text':' Jump to the invalidator which will replace the current frame.','line_number':1950,'multiline':False]['text':' Other types don't need canonicalization.','line_number':2161,'multiline':False]['text':' DEBUG','line_number':2165,'multiline':False]['text':' x86/x64 specific: The CPU provides ~A & B.  The operands were swapped','line_number':2297,'multiline':False]['text':' during lowering, and we'll compute A & ~B here as desired.','line_number':2298,'multiline':False]['text':' `lhsDest` is actually rhsDest, and `rhs` is actually lhs','line_number':2588,'multiline':False]['text':' `lhsDest` is actually rhsDest, and `rhs` is actually lhs','line_number':2592,'multiline':False]['text':' `lhsDest` is actually rhsDest, and `rhs` is actually lhs','line_number':2596,'multiline':False]['text':' `lhsDest` is actually rhsDest, and `rhs` is actually lhs','line_number':2600,'multiline':False]['text':' Swap qwords first','line_number':3102,'multiline':False]['text':' Permute low qword by control_[0..3]','line_number':3103,'multiline':False]['text':' Permute high qword by control_[4..7]','line_number':3104,'multiline':False]['text':' Skip lanes that equal v starting at i, returning the index just beyond the','line_number':3107,'multiline':False]['text':' last of those.  There is no requirement that the initial lanes[i] == v.','line_number':3108,'multiline':False]['text':' Apply a transformation to each lane value.','line_number':3119,'multiline':False]['text':' Recognize part of an identity permutation starting at start, with','line_number':3128,'multiline':False]['text':' the first value of the permutation expected to be bias.','line_number':3129,'multiline':False]['text':' We can permute by words if the mask is reducible to a word mask, but the x64','line_number':3143,'multiline':False]['text':' lowering is only efficient if we can permute the high and low quadwords','line_number':3144,'multiline':False]['text':' separately, possibly after swapping quadwords.','line_number':3145,'multiline':False]['text':' Now compute the operation bits.  `mapped` holds the adjusted lane mask.','line_number':3158,'multiline':False]['text':' For broadcast, would MOVDDUP be better than PSHUFD for the last step?','line_number':3186,'multiline':False]['text':' Set the zero flag if all of the lanes are zero, and branch on that.','line_number':3667,'multiline':False]['text':' Compare all lanes to zero, set the zero flag if none of the lanes are','line_number':3675,'multiline':False]['text':' zero, and branch on that.','line_number':3676,'multiline':False]['text':' namespace jit','line_number':3821,'multiline':False]['text':' namespace js','line_number':3822,'multiline':False]