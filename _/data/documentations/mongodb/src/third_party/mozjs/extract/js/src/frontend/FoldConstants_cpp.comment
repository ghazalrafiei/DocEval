['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' mozilla::Maybe','line_number':10,'multiline':False]['text':' ParserAtomsTable, TaggedParserAtomIndex','line_number':20,'multiline':False]['text':' js::AutoCheckRecursionLimit','line_number':22,'multiline':False]['text':' StringBuffer','line_number':24,'multiline':False]['text':' Don't use ReplaceNode directly, because we want the constant folder to keep','line_number':44,'multiline':False]['text':' the attributes isInParens and isDirectRHSAnonFunction of the old node being','line_number':45,'multiline':False]['text':' replaced.','line_number':46,'multiline':False]['text':' convenience check: can call TryReplaceNode(pnp, alloc_parsenode())','line_number':48,'multiline':False]['text':' directly, without having to worry about alloc returning null.','line_number':49,'multiline':False]['text':' Determines whether the given ParseNode contains any declarations whose','line_number':77,'multiline':False]['text':' visibility will extend outside the node itself -- that is, whether the','line_number':78,'multiline':False]['text':' ParseNode contains any var statements.','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' THIS IS NOT A GENERAL-PURPOSE FUNCTION.  It is only written to work in the','line_number':81,'multiline':False]['text':' specific context of deciding that |node|, as one arm of a ParseNodeKind::If','line_number':82,'multiline':False]['text':' controlled by a constant condition, contains a declaration that forbids','line_number':83,'multiline':False]['text':' |node| being completely eliminated as dead.','line_number':84,'multiline':False]['text':' With a better-typed AST, we would have distinct parse node classes for','line_number':94,'multiline':False]['text':' expressions and for statements and would characterize expressions with','line_number':95,'multiline':False]['text':' ExpressionKind and statements with StatementKind.  Perhaps someday.  In','line_number':96,'multiline':False]['text':' the meantime we must characterize every ParseNodeKind, even the','line_number':97,'multiline':False]['text':' expression/sub-expression ones that, if we handle all statement kinds','line_number':98,'multiline':False]['text':' correctly, we'll never see.','line_number':99,'multiline':False]['text':' Base case.','line_number':101,'multiline':False]['text':' Non-global lexical declarations are block-scoped (ergo not hoistable).','line_number':106,'multiline':False]['text':' Similarly to the lexical declarations above, classes cannot add hoisted','line_number':113,'multiline':False]['text':' declarations','line_number':114,'multiline':False]['text':' Function declarations *can* be hoisted declarations.  But in the','line_number':120,'multiline':False]['text':' magical world of the rewritten frontend, the declaration necessitated','line_number':121,'multiline':False]['text':' by a nested function statement, not at body level, doesn't require','line_number':122,'multiline':False]['text':' that we preserve an unreachable function declaration node against','line_number':123,'multiline':False]['text':' dead-code removal.','line_number':124,'multiline':False]['text':' Statements with no sub-components at all.','line_number':133,'multiline':False]['text':' Statements containing only an expression have no declarations.','line_number':144,'multiline':False]['text':' These two aren't statements in the spec, but we sometimes insert them','line_number':152,'multiline':False]['text':' in statement lists anyway.','line_number':153,'multiline':False]['text':' Other statements with no sub-statement components.','line_number':161,'multiline':False]['text':' Statements possibly containing hoistable declarations only in the left','line_number':179,'multiline':False]['text':' half, in ParseNode terms -- the loop body in AST terms.','line_number':180,'multiline':False]['text':' Statements possibly containing hoistable declarations only in the','line_number':185,'multiline':False]['text':' right half, in ParseNode terms -- the loop body or nested statement','line_number':186,'multiline':False]['text':' (usually a block statement), in AST terms.','line_number':187,'multiline':False]['text':' Statements with more complicated structures.','line_number':197,'multiline':False]['text':' if-statement nodes may have hoisted declarations in their consequent','line_number':199,'multiline':False]['text':' and alternative components.','line_number':200,'multiline':False]['text':' try-statements have statements to execute, and one or both of a','line_number':219,'multiline':False]['text':' catch-list and a finally-block.','line_number':220,'multiline':False]['text':' A switch node's left half is an expression; only its right half (a','line_number':257,'multiline':False]['text':' list of cases/defaults, or a block node) could contain hoisted','line_number':258,'multiline':False]['text':' declarations.','line_number':259,'multiline':False]['text':' for (init?; cond?; update?), with only init possibly containing','line_number':280,'multiline':False]['text':' a hoisted declaration.  (Note: a lexical-declaration |init| is','line_number':281,'multiline':False]['text':' (at present) hoisted in SpiderMonkey parlance -- but such','line_number':282,'multiline':False]['text':' hoisting doesn't extend outside of this statement, so it is not','line_number':283,'multiline':False]['text':' hoisting in the sense meant by ContainsHoistedDeclaration.)','line_number':284,'multiline':False]['text':' for each? (target in ...), where only target may introduce','line_number':294,'multiline':False]['text':' hoisted declarations.','line_number':295,'multiline':False]['text':'','line_number':296,'multiline':False]['text':'   -- or --','line_number':297,'multiline':False]['text':'','line_number':298,'multiline':False]['text':' for (target of ...), where only target may introduce hoisted','line_number':299,'multiline':False]['text':' declarations.','line_number':300,'multiline':False]['text':'','line_number':301,'multiline':False]['text':' Either way, if |target| contains a declaration, it's |loopHead|'s','line_number':302,'multiline':False]['text':' first kid.','line_number':303,'multiline':False]['text':' List nodes with all non-null children.','line_number':328,'multiline':False]['text':' Grammar sub-components that should never be reached directly by this','line_number':332,'multiline':False]['text':' method, because some parent component should have asserted itself.','line_number':333,'multiline':False]['text':'
 * Fold from one constant type to another.
 * XXX handles only strings and numbers for now
 ','line_number':463,'multiline':True]['text':' |void <foo>| evaluates to |undefined| which isn't truthy.  But the','line_number':548,'multiline':False]['text':' sense of this method requires that the expression be literally','line_number':549,'multiline':False]['text':' replaceable with true/false: not the case if the nested expression','line_number':550,'multiline':False]['text':' is effectful, might throw, &c.  Walk past the |void| (and nested','line_number':551,'multiline':False]['text':' |void| expressions, for good measure) and check that the nested','line_number':552,'multiline':False]['text':' expression doesn't break this requirement before indicating falsity.','line_number':553,'multiline':False]['text':' Conditions fold like any other expression, but then they sometimes can be','line_number':567,'multiline':False]['text':' further folded to constants. *nodePtr should already have been','line_number':568,'multiline':False]['text':' constant-folded.','line_number':569,'multiline':False]['text':' We can turn function nodes into constant nodes here, but mutating','line_number':573,'multiline':False]['text':' function nodes is tricky --- in particular, mutating a function node','line_number':574,'multiline':False]['text':' that appears on a method list corrupts the method list. However,','line_number':575,'multiline':False]['text':' methods are M's in statements of the form 'this.foo = M;', which we','line_number':576,'multiline':False]['text':' never fold, so we're okay.','line_number':577,'multiline':False]['text':' Constant-fold the entire |typeof| if given a constant with known type.','line_number':592,'multiline':False]['text':' Expression deletion evaluates the expression, then evaluates to true.','line_number':626,'multiline':False]['text':' For effectless expressions, eliminate the expression evaluation.','line_number':627,'multiline':False]['text':' If we're deleting an element, but constant-folding converted our','line_number':643,'multiline':False]['text':' element reference into a dotted property access, we must *also*','line_number':644,'multiline':False]['text':' morph the node's kind.','line_number':645,'multiline':False]['text':'','line_number':646,'multiline':False]['text':' In principle this also applies to |super["foo"] -> super.foo|,','line_number':647,'multiline':False]['text':' but we don't constant-fold |super["foo"]| yet.','line_number':648,'multiline':False]['text':' newDelete will detect and use DeletePropExpr','line_number':652,'multiline':False]['text':' nothing to do','line_number':707,'multiline':False]['text':' If we don't know the constant-folded node's truthiness, we can't','line_number':733,'multiline':False]['text':' reduce this node with its surroundings.  Continue folding any','line_number':734,'multiline':False]['text':' remaining nodes.','line_number':735,'multiline':False]['text':' If the constant-folded node's truthiness will terminate the','line_number':748,'multiline':False]['text':' condition -- `a || true || expr` or `b && false && expr` or','line_number':749,'multiline':False]['text':' `false ?? c ?? expr` -- then trailing nodes will never be','line_number':750,'multiline':False]['text':' evaluated.  Truncate the list after the known-truthiness node,','line_number':751,'multiline':False]['text':' as it's the overall result.','line_number':752,'multiline':False]['text':' Terminate the original and/or list at the known-truthiness','line_number':758,'multiline':False]['text':' node.','line_number':759,'multiline':False]['text':' We've encountered a vacuous node that'll never short-circuit','line_number':765,'multiline':False]['text':' evaluation.','line_number':766,'multiline':False]['text':' This node is never the overall result when there are','line_number':768,'multiline':False]['text':' subsequent nodes.  Remove it.','line_number':769,'multiline':False]['text':' Otherwise this node is the result of the overall expression,','line_number':774,'multiline':False]['text':' so leave it alone.  And we're done.','line_number':775,'multiline':False]['text':' If we removed nodes, we may have to replace a one-element list with','line_number':783,'multiline':False]['text':' its element.','line_number':784,'multiline':False]['text':' |nextNode| on entry points to the C?T:F expression to be folded.','line_number':802,'multiline':False]['text':' Reset it to exit the loop in the common case where F isn't another','line_number':803,'multiline':False]['text':' ?: expression.','line_number':804,'multiline':False]['text':' If our C?T:F node has F as another ?: node, *iteratively* constant-','line_number':826,'multiline':False]['text':' fold F *after* folding C and T (and possibly eliminating C and one','line_number':827,'multiline':False]['text':' of T/F entirely); otherwise fold F normally.  Making |nextNode| non-','line_number':828,'multiline':False]['text':' null causes this loop to run again to fold F.','line_number':829,'multiline':False]['text':'','line_number':830,'multiline':False]['text':' Conceivably we could instead/also iteratively constant-fold T, if T','line_number':831,'multiline':False]['text':' were more complex than F.  Such an optimization is unimplemented.','line_number':832,'multiline':False]['text':' Try to constant-fold based on the condition expression.','line_number':842,'multiline':False]['text':' Otherwise reduce 'C ? T : F' to T or F as directed by C.','line_number':848,'multiline':False]['text':' Otherwise perform a replacement.  This invalidates |nextNode|, so','line_number':851,'multiline':False]['text':' reset it (if the replacement requires folding) or clear it (if','line_number':852,'multiline':False]['text':' |ifFalsy| is dead code) as needed.','line_number':853,'multiline':False]['text':' |nextNode| on entry points to the initial |if| to be folded.  Reset','line_number':867,'multiline':False]['text':' it to exit the loop when the |else| arm isn't another |if|.','line_number':868,'multiline':False]['text':' If in |if (C) T; else F;| we have |F| as another |if|,','line_number':890,'multiline':False]['text':' *iteratively* constant-fold |F| *after* folding |C| and |T| (and','line_number':891,'multiline':False]['text':' possibly completely replacing the whole thing with |T| or |F|);','line_number':892,'multiline':False]['text':' otherwise fold F normally.  Making |nextNode| non-null causes','line_number':893,'multiline':False]['text':' this loop to run again to fold F.','line_number':894,'multiline':False]['text':' Eliminate the consequent or alternative if the condition has','line_number':905,'multiline':False]['text':' constant truthiness.','line_number':906,'multiline':False]['text':' Careful!  Either of these can be null: |replacement| in |if (0) T;|,','line_number':912,'multiline':False]['text':' and |discarded| in |if (true) T;|.','line_number':913,'multiline':False]['text':' A declaration that hoists outside the discarded arm prevents the','line_number':926,'multiline':False]['text':' |if| from being folded away.','line_number':927,'multiline':False]['text':' If there's no replacement node, we have a constantly-false |if|','line_number':942,'multiline':False]['text':' with no |else|.  Replace the entire thing with an empty','line_number':943,'multiline':False]['text':' statement list.','line_number':944,'multiline':False]['text':' Replacement invalidates |nextNode|, so reset it (if the','line_number':950,'multiline':False]['text':' replacement requires folding) or clear it (if |alternative|','line_number':951,'multiline':False]['text':' is dead code) as needed.','line_number':952,'multiline':False]['text':' Fold each operand to a number if possible.','line_number':1006,'multiline':False]['text':' Now fold all leading numeric terms together into a single number.','line_number':1015,'multiline':False]['text':' (Trailing terms for the non-shift operations can't be folded together','line_number':1016,'multiline':False]['text':' due to floating point imprecision.  For example, if |x === -2**53|,','line_number':1017,'multiline':False]['text':' |x - 1 - 1 === -2**53| but |x - 2 === -2**53 - 2|.  Shifts could be','line_number':1018,'multiline':False]['text':' folded, but it doesn't seem worth the effort.)','line_number':1019,'multiline':False]['text':' Fold each operand, ideally into a number.','line_number':1060,'multiline':False]['text':' Unlike all other binary arithmetic operators, ** is right-associative:','line_number':1070,'multiline':False]['text':' 2**3**5 is 2**(3**5), not (2**3)**5.  As list nodes singly-link their','line_number':1071,'multiline':False]['text':' children, full constant-folding requires either linear space or dodgy','line_number':1072,'multiline':False]['text':' in-place linked list reversal.  So we only fold one exponentiation: it's','line_number':1073,'multiline':False]['text':' easy and addresses common cases like |2**32|.','line_number':1074,'multiline':False]['text':' Optimization 1: We have something like expr["100"]. This is','line_number':1103,'multiline':False]['text':' equivalent to expr[100] which is faster.','line_number':1104,'multiline':False]['text':' Optimization 2: We have something like expr[3.14]. The number','line_number':1118,'multiline':False]['text':' isn't an array index, so it converts to a string ("3.14"),','line_number':1119,'multiline':False]['text':' enabling optimization 3 below.','line_number':1120,'multiline':False]['text':' If we don't have a name, we can't optimize to getprop.','line_number':1128,'multiline':False]['text':' Optimization 3: We have expr["foo"] where foo is not an index.  Convert','line_number':1133,'multiline':False]['text':' to a property access (like expr.foo) that optimizes better downstream.','line_number':1134,'multiline':False]['text':' Fold leading numeric operands together:','line_number':1154,'multiline':False]['text':'','line_number':1155,'multiline':False]['text':'   (1 + 2 + x)  becomes  (3 + x)','line_number':1156,'multiline':False]['text':'','line_number':1157,'multiline':False]['text':' Don't go past the leading operands: additions after a string are','line_number':1158,'multiline':False]['text':' string concatenations, not additions: ("1" + 2 + 3 === "123").','line_number':1159,'multiline':False]['text':' If any operands remain, attempt string concatenation folding.','line_number':1184,'multiline':False]['text':' If no operands remain, we're done.','line_number':1186,'multiline':False]['text':' (number + string) is string concatenation *only* at the start of','line_number':1191,'multiline':False]['text':' the list: (x + 1 + "2" !== x + "12") when x is a number.','line_number':1192,'multiline':False]['text':' The first string forces all subsequent additions to be','line_number':1201,'multiline':False]['text':' string concatenations.','line_number':1202,'multiline':False]['text':' If there's nothing left to fold, we're done.','line_number':1212,'multiline':False]['text':' Concat all strings.','line_number':1218,'multiline':False]['text':' To avoid unnecessarily copy when there's no strings after the','line_number':1221,'multiline':False]['text':' first item, lazily construct StringBuffer and append the first item.','line_number':1222,'multiline':False]['text':' Try folding the next operand to a string.','line_number':1228,'multiline':False]['text':' Stop glomming once folding doesn't produce a string.','line_number':1233,'multiline':False]['text':' Append this string and remove the node.','line_number':1244,'multiline':False]['text':' Replace with concatenation if we multiple nodes.','line_number':1255,'multiline':False]['text':' Replace |current|'s string with the entire combination.','line_number':1262,'multiline':False]['text':' If we're out of nodes, we're done.','line_number':1267,'multiline':False]['text':' If we're out of nodes *after* the non-foldable-to-string','line_number':1275,'multiline':False]['text':' node, we're done.','line_number':1276,'multiline':False]['text':' Otherwise find the next node foldable to a string, and loop.','line_number':1281,'multiline':False]['text':' We reduced the list to a constant.  Replace the ParseNodeKind::Add node','line_number':1299,'multiline':False]['text':' with that constant.','line_number':1300,'multiline':False]['text':' Note that this does result in the unfortunate fact that dead arms of this','line_number':1393,'multiline':False]['text':' node get constant folded. The same goes for visitOr and visitCoalesce.','line_number':1394,'multiline':False]['text':' Don't call base-class visitConditional because FoldConditional processes','line_number':1407,'multiline':False]['text':' pn's child nodes specially to save stack space.','line_number':1408,'multiline':False]['text':' Don't fold a parenthesized callable component in an invocation, as this','line_number':1420,'multiline':False]['text':' might cause a different |this| value to be used, changing semantics:','line_number':1421,'multiline':False]['text':'','line_number':1422,'multiline':False]['text':'   var prop = "global";','line_number':1423,'multiline':False]['text':'   var obj = { prop: "obj", f: function() { return this.prop; } };','line_number':1424,'multiline':False]['text':'   assertEq((true ? obj.f : null)(), "global");','line_number':1425,'multiline':False]['text':'   assertEq(obj.f(), "obj");','line_number':1426,'multiline':False]['text':'   assertEq((true ? obj.f : null)``, "global");','line_number':1427,'multiline':False]['text':'   assertEq(obj.f``, "obj");','line_number':1428,'multiline':False]['text':'','line_number':1429,'multiline':False]['text':' As an exception to this, we do allow folding the function in','line_number':1430,'multiline':False]['text':' `(function() { ... })()` (the module pattern), because that lets us','line_number':1431,'multiline':False]['text':' constant fold code inside that function.','line_number':1432,'multiline':False]['text':'','line_number':1433,'multiline':False]['text':' See bug 537673 and bug 1182373.','line_number':1434,'multiline':False]['text':' Don't call base-class visitIf because FoldIf processes pn's child nodes','line_number':1472,'multiline':False]['text':' specially to save stack space.','line_number':1473,'multiline':False]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':1514,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':1515,'multiline':False]['text':' Empty arrays are non-constant, since we cannot easily determine their','line_number':1529,'multiline':False]['text':' type.','line_number':1530,'multiline':False]