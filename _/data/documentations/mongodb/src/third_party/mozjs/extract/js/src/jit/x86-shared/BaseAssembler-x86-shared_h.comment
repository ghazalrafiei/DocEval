['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (C) 2008 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** ','line_number':1,'multiline':True]['text':' Note: the offset is relative to the address of the instruction after','line_number':70,'multiline':False]['text':' the call which is five bytes.','line_number':71,'multiline':False]['text':' The nop can be already patched as call, overriding the call.','line_number':73,'multiline':False]['text':' See also nop_five.','line_number':74,'multiline':False]['text':' See also patchFiveByteNopToCall and nop_five.','line_number':84,'multiline':False]['text':' The call can be already patched as nop.','line_number':86,'multiline':False]['text':'
   * The nop multibytes sequences are directly taken from the Intel's
   * architecture software developer manual.
   * They are defined for sequences of sizes from 1 to 9 included.
   ','line_number':100,'multiline':True]['text':' Stack operations:','line_number':220,'multiline':False]['text':' Arithmetic operations:','line_number':274,'multiline':False]['text':' 32-bit immediate always, for patching.','line_number':327,'multiline':False]['text':' Note that CMPXCHG performs comparison against REG = %al/%ax/%eax/%rax.','line_number':1699,'multiline':False]['text':' If %REG == [%base+offset], then %src -> [%base+offset].','line_number':1700,'multiline':False]['text':' Otherwise, [%base+offset] -> %REG.','line_number':1701,'multiline':False]['text':' For the 8-bit operations src must also be an 8-bit register.','line_number':1702,'multiline':False]['text':' Comparisons:','line_number':1754,'multiline':False]['text':' If the mask fits in an 8-bit immediate, we can use testb with an','line_number':1959,'multiline':False]['text':' 8-bit subreg.','line_number':1960,'multiline':False]['text':' If the mask is a subset of 0xff00, we can use testb with an h reg, if','line_number':1965,'multiline':False]['text':' one happens to be available.','line_number':1966,'multiline':False]['text':' Like testb_ir, but never emits a REX prefix. This may be used to','line_number':2032,'multiline':False]['text':' reference ah..bh.','line_number':2033,'multiline':False]['text':' Various move ops:','line_number':2053,'multiline':False]['text':' vmovq_rm can be encoded either as a true vmovq or as a vmovd with a','line_number':2315,'multiline':False]['text':' REX prefix modifying it to be 64-bit. We choose the vmovq encoding','line_number':2316,'multiline':False]['text':' because it's smaller (when it doesn't need a REX prefix for other','line_number':2317,'multiline':False]['text':' reasons) and because it works on 32-bit x86 too.','line_number':2318,'multiline':False]['text':' vmovq_mr can be encoded either as a true vmovq or as a vmovd with a','line_number':2339,'multiline':False]['text':' REX prefix modifying it to be 64-bit. We choose the vmovq encoding','line_number':2340,'multiline':False]['text':' because it's smaller (when it doesn't need a REX prefix for other','line_number':2341,'multiline':False]['text':' reasons) and because it works on 32-bit x86 too.','line_number':2342,'multiline':False]['text':' Flow control:','line_number':2540,'multiline':False]['text':' Comparison of EAX against a 32-bit immediate. The immediate is patched','line_number':2559,'multiline':False]['text':' in as if it were a jump target. The intention is to toggle the first','line_number':2560,'multiline':False]['text':' byte of the instruction between a CMP and a JMP to produce a pseudo-NOP.','line_number':2561,'multiline':False]['text':' The jump immediate is an offset from the end of the jump instruction.','line_number':2573,'multiline':False]['text':' A jump instruction is either 1 byte opcode and 1 byte offset, or 1','line_number':2574,'multiline':False]['text':' byte opcode and 4 bytes offset.','line_number':2575,'multiline':False]['text':' The jump immediate is an offset from the end of the jump instruction.','line_number':2611,'multiline':False]['text':' A conditional jump instruction is either 1 byte opcode and 1 byte','line_number':2612,'multiline':False]['text':' offset, or 2 bytes opcode and 4 bytes offset.','line_number':2613,'multiline':False]['text':' SSE operations:','line_number':2630,'multiline':False]['text':' Note that the register-to-register form of vmovsd does not write to the','line_number':3298,'multiline':False]['text':' entire output register. For general-purpose register-to-register moves,','line_number':3299,'multiline':False]['text':' use vmovapd instead.','line_number':3300,'multiline':False]['text':' The register-to-register form of vmovss has the same problem as vmovsd','line_number':3305,'multiline':False]['text':' above. Prefer vmovaps for register-to-register moves.','line_number':3306,'multiline':False]['text':' There are two opcodes that can encode this instruction. If we have','line_number':3363,'multiline':False]['text':' one register in [xmm8,xmm15] and one in [xmm0,xmm7], use the','line_number':3364,'multiline':False]['text':' opcode which swaps the operands, as that way we can get a two-byte','line_number':3365,'multiline':False]['text':' VEX in that case.','line_number':3366,'multiline':False]['text':' There are two opcodes that can encode this instruction. If we have','line_number':3423,'multiline':False]['text':' one register in [xmm8,xmm15] and one in [xmm0,xmm7], use the','line_number':3424,'multiline':False]['text':' opcode which swaps the operands, as that way we can get a two-byte','line_number':3425,'multiline':False]['text':' VEX in that case.','line_number':3426,'multiline':False]['text':' There are two opcodes that can encode this instruction. If we have','line_number':3470,'multiline':False]['text':' one register in [xmm8,xmm15] and one in [xmm0,xmm7], use the','line_number':3471,'multiline':False]['text':' opcode which swaps the operands, as that way we can get a two-byte','line_number':3472,'multiline':False]['text':' VEX in that case.','line_number':3473,'multiline':False]['text':' Despite being a "ps" instruction, vblendps is encoded with the "pd"','line_number':3841,'multiline':False]['text':' prefix.','line_number':3842,'multiline':False]['text':' Despite being a "ps" instruction, vblendps is encoded with the "pd"','line_number':3850,'multiline':False]['text':' prefix.','line_number':3851,'multiline':False]['text':' BMI instructions:','line_number':4214,'multiline':False]['text':' = F3 ','line_number':4223,'multiline':True]['text':' = 66 ','line_number':4234,'multiline':True]['text':' = F2 ','line_number':4245,'multiline':True]['text':' Misc instructions:','line_number':4249,'multiline':False]['text':' Assembler admin methods:','line_number':4281,'multiline':False]['text':' Linking & patching:','line_number':4345,'multiline':False]['text':' The target offset is stored at offset - 4.','line_number':4348,'multiline':False]['text':' Sanity check - if the assembler has OOM'd, it will start overwriting','line_number':4354,'multiline':False]['text':' its internal buffer and thus our links could be garbage.','line_number':4355,'multiline':False]['text':' Stash some data on the stack so we can retrieve it from minidumps,','line_number':4371,'multiline':False]['text':' see bug 1124397.','line_number':4372,'multiline':False]['text':' Sanity check - if the assembler has OOM'd, it will start overwriting','line_number':4401,'multiline':False]['text':' its internal buffer and thus our links could be garbage.','line_number':4402,'multiline':False]['text':' Sanity check - if the assembler has OOM'd, it will start overwriting','line_number':4419,'multiline':False]['text':' its internal buffer and thus our links could be garbage.','line_number':4420,'multiline':False]['text':' `offset` is the instruction offset at the end of the instruction.','line_number':4441,'multiline':False]['text':' Methods for encoding SIMD instructions via either legacy SSE encoding or','line_number':4465,'multiline':False]['text':' VEX encoding.','line_number':4466,'multiline':False]['text':' If we don't have AVX or it's disabled, use the legacy SSE encoding.','line_number':4469,'multiline':False]['text':' If src0 is the same as the output register, we might as well use','line_number':4478,'multiline':False]['text':' the legacy SSE encoding, since it is smaller. However, this is only','line_number':4479,'multiline':False]['text':' beneficial as long as we're not using ymm registers anywhere.','line_number':4480,'multiline':False]['text':' Similar to useLegacySSEEncoding, but for vblendv the Legacy SSE','line_number':4486,'multiline':False]['text':' encoding also requires the mask to be in xmm0.','line_number':4487,'multiline':False]['text':' Blendv is a three-byte op, but the VEX encoding has a different opcode','line_number':5130,'multiline':False]['text':' than the SSE encoding, so we handle it specially.','line_number':5131,'multiline':False]['text':' Even though a "ps" instruction, vblendv is encoded with the "pd"','line_number':5136,'multiline':False]['text':' prefix.','line_number':5137,'multiline':False]['text':' Even though a "ps" instruction, vblendv is encoded with the "pd" prefix.','line_number':5146,'multiline':False]['text':' Even though a "ps" instruction, vblendv is encoded with the "pd"','line_number':5155,'multiline':False]['text':' prefix.','line_number':5156,'multiline':False]['text':' Even though a "ps" instruction, vblendv is encoded with the "pd" prefix.','line_number':5165,'multiline':False]['text':' Legacy prefix bytes:','line_number':5191,'multiline':False]['text':'','line_number':5192,'multiline':False]['text':' These are emmitted prior to the instruction.','line_number':5193,'multiline':False]['text':' clang-format off ','line_number':5213,'multiline':True]['text':'','line_number':5214,'multiline':False]['text':' Word-sized operands / no operand instruction formatters.','line_number':5215,'multiline':False]['text':'','line_number':5216,'multiline':False]['text':' In addition to the opcode, the following operand permutations are supported:','line_number':5217,'multiline':False]['text':'   * None - instruction takes no operands.','line_number':5218,'multiline':False]['text':'   * One register - the low three bits of the RegisterID are added into the opcode.','line_number':5219,'multiline':False]['text':'   * Two registers - encode a register form ModRm (for all ModRm formats, the reg field is passed first, and a GroupOpcodeID may be passed in its place).','line_number':5220,'multiline':False]['text':'   * Three argument ModRM - a register, and a register and an offset describing a memory operand.','line_number':5221,'multiline':False]['text':'   * Five argument ModRM - a register, and a base register, an index, scale, and offset describing a memory operand.','line_number':5222,'multiline':False]['text':'','line_number':5223,'multiline':False]['text':' For 32-bit x86 targets, the address operand may also be provided as a','line_number':5224,'multiline':False]['text':' void*.  On 64-bit targets REX prefixes will be planted as necessary,','line_number':5225,'multiline':False]['text':' where high numbered registers are used.','line_number':5226,'multiline':False]['text':'','line_number':5227,'multiline':False]['text':' The twoByteOp methods plant two-byte Intel instructions sequences','line_number':5228,'multiline':False]['text':' (first opcode byte 0x0F).','line_number':5229,'multiline':False]['text':'','line_number':5230,'multiline':False]['text':' clang-format on ','line_number':5231,'multiline':True]['text':' 0x0F','line_number':5326,'multiline':False]['text':' 0x0F','line_number':5358,'multiline':False]['text':' 0x0F','line_number':5376,'multiline':False]['text':' 0x0F','line_number':5395,'multiline':False]['text':' 0x0F','line_number':5414,'multiline':False]['text':' 0x0F','line_number':5431,'multiline':False]['text':' Quad-word-sized operands:','line_number':5608,'multiline':False]['text':'','line_number':5609,'multiline':False]['text':' Used to format 64-bit operantions, planting a REX.w prefix.  When','line_number':5610,'multiline':False]['text':' planting d64 or f64 instructions, not requiring a REX.w prefix, the','line_number':5611,'multiline':False]['text':' normal (non-'64'-postfixed) formatters should be used.','line_number':5612,'multiline':False]['text':' 0x0F','line_number':5708,'multiline':False]['text':' Byte-operands:','line_number':5744,'multiline':False]['text':'','line_number':5745,'multiline':False]['text':' These methods format byte operations.  Byte operations differ from','line_number':5746,'multiline':False]['text':' the normal formatters in the circumstances under which they will','line_number':5747,'multiline':False]['text':' decide to emit REX prefixes.  These should be used where any register','line_number':5748,'multiline':False]['text':' operand signifies a byte register.','line_number':5749,'multiline':False]['text':'','line_number':5750,'multiline':False]['text':' The disctinction is due to the handling of register numbers in the','line_number':5751,'multiline':False]['text':' range 4..7 on x86-64.  These register numbers may either represent','line_number':5752,'multiline':False]['text':' the second byte of the first four registers (ah..bh) or the first','line_number':5753,'multiline':False]['text':' byte of the second four registers (spl..dil).','line_number':5754,'multiline':False]['text':'','line_number':5755,'multiline':False]['text':' Address operands should still be checked using regRequiresRex(),','line_number':5756,'multiline':False]['text':' while byteRegRequiresRex() is provided to check byte register','line_number':5757,'multiline':False]['text':' operands.','line_number':5758,'multiline':False]['text':' Like oneByteOp8, but never emits a REX prefix.','line_number':5779,'multiline':False]['text':' Like twoByteOp8 but doesn't add a REX prefix if the destination reg','line_number':5848,'multiline':False]['text':' is in esp..edi. This may be used when the destination is not an 8-bit','line_number':5849,'multiline':False]['text':' register (as in a movzbl instruction), so it doesn't need a REX','line_number':5850,'multiline':False]['text':' prefix to disambiguate it from ah..bh.','line_number':5851,'multiline':False]['text':' Immediates:','line_number':5870,'multiline':False]['text':'','line_number':5871,'multiline':False]['text':' An immedaite should be appended where appropriate after an op has','line_number':5872,'multiline':False]['text':' been emitted.  The writes are unchecked since the opcode formatters','line_number':5873,'multiline':False]['text':' above will have ensured space.','line_number':5874,'multiline':False]['text':' A signed 8-bit immediate.','line_number':5876,'multiline':False]['text':' An unsigned 8-bit immediate.','line_number':5882,'multiline':False]['text':' An 8-bit immediate with is either signed or unsigned, for use in','line_number':5888,'multiline':False]['text':' instructions which actually only operate on 8 bits.','line_number':5889,'multiline':False]['text':' A signed 16-bit immediate.','line_number':5894,'multiline':False]['text':' An unsigned 16-bit immediate.','line_number':5900,'multiline':False]['text':' A 16-bit immediate with is either signed or unsigned, for use in','line_number':5906,'multiline':False]['text':' instructions which actually only operate on 16 bits.','line_number':5907,'multiline':False]['text':' Data:','line_number':5925,'multiline':False]['text':' Administrative methods:','line_number':5964,'multiline':False]['text':' Internals; ModRm and REX formatters.','line_number':5981,'multiline':False]['text':' Byte operand register spl & above requir a REX prefix, which precludes','line_number':5983,'multiline':False]['text':' use of the h registers in the same instruction.','line_number':5984,'multiline':False]['text':' For non-byte sizes, registers r8 & above always require a REX prefix.','line_number':5993,'multiline':False]['text':' Format a REX prefix byte.','line_number':6003,'multiline':False]['text':' Used to plant a REX byte with REX.w set (for 64-bit operations).','line_number':6009,'multiline':False]['text':' Used for operations with byte operands - use byteRegRequiresRex() to','line_number':6012,'multiline':False]['text':' check register operands, regRequiresRex() to check other registers','line_number':6013,'multiline':False]['text':' (i.e. address base & index).','line_number':6014,'multiline':False]['text':'','line_number':6015,'multiline':False]['text':' NB: WebKit's use of emitRexIf() is limited such that the','line_number':6016,'multiline':False]['text':' reqRequiresRex() checks are not needed. SpiderMonkey extends','line_number':6017,'multiline':False]['text':' oneByteOp8 and twoByteOp8 functionality such that r, x, and b','line_number':6018,'multiline':False]['text':' can all be used.','line_number':6019,'multiline':False]['text':' Used for word sized operations, will plant a REX prefix if necessary','line_number':6027,'multiline':False]['text':' (if any register is r8 or above).','line_number':6028,'multiline':False]['text':' No REX prefix bytes on 32-bit x86.','line_number':6031,'multiline':False]['text':' A base of esp or r12 would be interpreted as a sib, so force a','line_number':6055,'multiline':False]['text':' sib with no index & put the base in there.','line_number':6056,'multiline':False]['text':' No need to check if the base is noBase, since we know','line_number':6062,'multiline':False]['text':' it is hasSib!','line_number':6063,'multiline':False]['text':' A base of esp or r12 would be interpreted as a sib, so force a','line_number':6090,'multiline':False]['text':' sib with no index & put the base in there.','line_number':6091,'multiline':False]['text':' NB: the base-less memoryModRM overloads generate different code','line_number':6128,'multiline':False]['text':' then the base-full memoryModRM overloads in the base == noBase','line_number':6129,'multiline':False]['text':' case. The base-less overloads assume that the desired effective','line_number':6130,'multiline':False]['text':' address is:','line_number':6131,'multiline':False]['text':'','line_number':6132,'multiline':False]['text':'   reg := [scaled index] + disp32','line_number':6133,'multiline':False]['text':'','line_number':6134,'multiline':False]['text':' which means the mod needs to be ModRmMemoryNoDisp. The base-full','line_number':6135,'multiline':False]['text':' overloads pass ModRmMemoryDisp32 in all cases and thus, when','line_number':6136,'multiline':False]['text':' base == noBase (== ebp), the effective address is:','line_number':6137,'multiline':False]['text':'','line_number':6138,'multiline':False]['text':'   reg := [scaled index] + disp32 + [ebp]','line_number':6139,'multiline':False]['text':'','line_number':6140,'multiline':False]['text':' See Intel developer manual, Vol 2, 2.1.5, Table 2-3.','line_number':6141,'multiline':False]['text':' On x64-64, non-RIP-relative absolute mode requires a SIB.','line_number':6150,'multiline':False]['text':' noBase + ModRmMemoryNoDisp means noBase + ModRmMemoryDisp32!','line_number':6153,'multiline':False]['text':' Two byte VEX.','line_number':6172,'multiline':False]['text':' Three byte VEX.','line_number':6176,'multiline':False]['text':' namespace X86Encoding','line_number':6191,'multiline':False]['text':' namespace jit','line_number':6193,'multiline':False]['text':' namespace js','line_number':6194,'multiline':False]['text':' jit_x86_shared_BaseAssembler_x86_shared_h ','line_number':6196,'multiline':True]