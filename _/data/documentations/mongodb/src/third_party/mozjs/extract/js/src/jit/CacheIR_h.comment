['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JS::XrayJitInfo','line_number':21,'multiline':False]['text':' js::Scalar::Type','line_number':22,'multiline':False]['text':' [SMDOC] CacheIR','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':' CacheIR is an (extremely simple) linear IR language for inline caches.','line_number':50,'multiline':False]['text':' From this IR, we can generate machine code for Baseline or Ion IC stubs.','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' IRWriter','line_number':53,'multiline':False]['text':' --------','line_number':54,'multiline':False]['text':' CacheIR bytecode is written using IRWriter. This class also records some','line_number':55,'multiline':False]['text':' metadata that's used by the Baseline and Ion code generators to generate','line_number':56,'multiline':False]['text':' (efficient) machine code.','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':' Sharing Baseline stub code','line_number':59,'multiline':False]['text':' --------------------------','line_number':60,'multiline':False]['text':' Baseline stores data (like Shape* and fixed slot offsets) inside the ICStub','line_number':61,'multiline':False]['text':' structure, instead of embedding them directly in the JitCode. This makes','line_number':62,'multiline':False]['text':' Baseline IC code slightly slower, but allows us to share IC code between','line_number':63,'multiline':False]['text':' caches. CacheIR makes it easy to share code between stubs: stubs that have','line_number':64,'multiline':False]['text':' the same CacheIR (and CacheKind), will have the same Baseline stub code.','line_number':65,'multiline':False]['text':'','line_number':66,'multiline':False]['text':' Baseline stubs that share JitCode also share a CacheIRStubInfo structure.','line_number':67,'multiline':False]['text':' This class stores the CacheIR and the location of GC things stored in the','line_number':68,'multiline':False]['text':' stub, for the GC.','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' JitZone has a CacheIRStubInfo* -> JitCode* weak map that's used to share both','line_number':71,'multiline':False]['text':' the IR and JitCode between Baseline CacheIR stubs. This HashMap owns the','line_number':72,'multiline':False]['text':' stubInfo (it uses UniquePtr), so once there are no references left to the','line_number':73,'multiline':False]['text':' shared stub code, we can also free the CacheIRStubInfo.','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' Ion stubs','line_number':76,'multiline':False]['text':' ---------','line_number':77,'multiline':False]['text':' Unlike Baseline stubs, Ion stubs do not share stub code, and data stored in','line_number':78,'multiline':False]['text':' the IonICStub is baked into JIT code. This is one of the reasons Ion stubs','line_number':79,'multiline':False]['text':' are faster than Baseline stubs. Also note that Ion ICs contain more state','line_number':80,'multiline':False]['text':' (see IonGetPropertyIC for example) and use dynamic input/output registers,','line_number':81,'multiline':False]['text':' so sharing stub code for Ion would be much more difficult.','line_number':82,'multiline':False]['text':' An OperandId represents either a cache input or a value returned by a','line_number':84,'multiline':False]['text':' CacheIR instruction. Most code should use the ValOperandId and ObjOperandId','line_number':85,'multiline':False]['text':' classes below. The ObjOperandId class represents an operand that's known to','line_number':86,'multiline':False]['text':' be an object, just as StringOperandId represents a known string, etc.','line_number':87,'multiline':False]['text':' CacheIR opcode info that's read in performance-sensitive code. Stored as a','line_number':236,'multiline':False]['text':' single byte per op for better cache locality.','line_number':237,'multiline':False]['text':' These fields take up a single word.','line_number':251,'multiline':False]['text':' These fields take up 64 bits on all platforms.','line_number':263,'multiline':False]['text':' This class is used to wrap up information about a call to make it','line_number':315,'multiline':False]['text':' easier to convey from one function to another. (In particular,','line_number':316,'multiline':False]['text':' CacheIRWriter encodes the CallFlags in CacheIR, and CacheIRReader','line_number':317,'multiline':False]['text':' decodes them and uses them for compilation.)','line_number':318,'multiline':False]['text':' See CacheIRReader::callFlags()','line_number':353,'multiline':False]['text':' Used for encoding/decoding','line_number':374,'multiline':False]['text':' We cannot attach a stub.','line_number':387,'multiline':False]['text':' We can attach a stub.','line_number':390,'multiline':False]['text':' We cannot currently attach a stub, but we expect to be able to do so in the','line_number':393,'multiline':False]['text':' future. In this case, we do not call trackNotAttached().','line_number':394,'multiline':False]['text':' We want to attach a stub, but the result of the operation is','line_number':397,'multiline':False]['text':' needed to generate that stub. For example, AddSlot needs to know','line_number':398,'multiline':False]['text':' the resulting shape. Note: the attached stub will inspect the','line_number':399,'multiline':False]['text':' inputs to the operation, so most input checks should be done','line_number':400,'multiline':False]['text':' before the actual operation, with only minimal checks remaining','line_number':401,'multiline':False]['text':' for the deferred portion. This prevents arbitrary scripted code','line_number':402,'multiline':False]['text':' run by the operation from interfering with the conditions being','line_number':403,'multiline':False]['text':' checked.','line_number':404,'multiline':False]['text':' If the input expression evaluates to an AttachDecision other than NoAction,','line_number':408,'multiline':False]['text':' return that AttachDecision. If it is NoAction, do nothing.','line_number':409,'multiline':False]['text':' Set of arguments supported by GetIndexOfArgument.','line_number':418,'multiline':False]['text':' Support for higher argument indices can be added easily, but is currently','line_number':419,'multiline':False]['text':' unneeded.','line_number':420,'multiline':False]['text':' This function calculates the index of an argument based on the call flags.','line_number':444,'multiline':False]['text':' addArgc is an out-parameter, indicating whether the value of argc should','line_number':445,'multiline':False]['text':' be added to the return value to find the actual index.','line_number':446,'multiline':False]['text':' *** STACK LAYOUT (bottom to top) ***        ******** INDEX ********','line_number':449,'multiline':False]['text':'   Callee                                <-- argc+1 + isConstructing','line_number':450,'multiline':False]['text':'   ThisValue                             <-- argc   + isConstructing','line_number':451,'multiline':False]['text':'   Args: | Arg0 |        |  ArgArray  |  <-- argc-1 + isConstructing','line_number':452,'multiline':False]['text':'         | Arg1 | --or-- |            |  <-- argc-2 + isConstructing','line_number':453,'multiline':False]['text':'         | ...  |        | (if spread |  <-- ...','line_number':454,'multiline':False]['text':'         | ArgN |        |  call)     |  <-- 0      + isConstructing','line_number':455,'multiline':False]['text':'   NewTarget (only if constructing)      <-- 0 (if it exists)','line_number':456,'multiline':False]['text':'','line_number':457,'multiline':False]['text':' If this is a spread call, then argc is always 1, and we can calculate the','line_number':458,'multiline':False]['text':' index directly. If this is not a spread call, then the index of any','line_number':459,'multiline':False]['text':' argument other than NewTarget depends on argc.','line_number':460,'multiline':False]['text':' First we determine whether the caller needs to add argc.','line_number':462,'multiline':False]['text':' Spread calls do not have Arg1 or higher.','line_number':468,'multiline':False]['text':' Second, we determine the offset relative to argc.','line_number':480,'multiline':False]['text':' We use this enum as GuardClass operand, instead of storing Class* pointers','line_number':512,'multiline':False]['text':' in the IR, to keep the IR compact and the same size on all platforms.','line_number':513,'multiline':False]['text':' Some ops refer to shapes that might be in other zones. Instead of putting','line_number':525,'multiline':False]['text':' cross-zone pointers in the caches themselves (which would complicate tracing','line_number':526,'multiline':False]['text':' enormously), these ops instead contain wrappers for objects in the target','line_number':527,'multiline':False]['text':' zone, which refer to the actual shape via a reserved slot.','line_number':528,'multiline':False]['text':' Class to record CacheIR + some additional metadata for code generation.','line_number':538,'multiline':False]['text':' The data (shapes, slot offsets, etc.) that will be stored in the ICStub.','line_number':551,'multiline':False]['text':' For each operand id, record which instruction accessed it last. This','line_number':555,'multiline':False]['text':' information greatly improves register allocation.','line_number':556,'multiline':False]['text':' OperandId and stub offsets are stored in a single byte, so make sure','line_number':559,'multiline':False]['text':' this doesn't overflow. We use a very conservative limit for now.','line_number':560,'multiline':False]['text':' Assume this stub can't be trial inlined until we see a scripted call/inline','line_number':565,'multiline':False]['text':' instruction.','line_number':566,'multiline':False]['text':' Basic caching to avoid quadatic lookup behaviour in readStubFieldForIon.','line_number':569,'multiline':False]['text':' Information for assertLengthMatches.','line_number':574,'multiline':False]['text':' After writing arguments, assert the length matches CacheIROpArgLengths.','line_number':599,'multiline':False]['text':' On 32-bit platforms there are two stub field sizes (4 bytes and 8 bytes).','line_number':631,'multiline':False]['text':' Ensure 8-byte fields are properly aligned.','line_number':632,'multiline':False]['text':' Add a RawInt32 stub field for padding if necessary, because when we','line_number':642,'multiline':False]['text':' iterate over the stub fields we assume there are no 'holes'.','line_number':643,'multiline':False]['text':' For now, assert we only GC before we append stub fields.','line_number':802,'multiline':False]['text':' This should not be used when compiling Baseline code, as Baseline code','line_number':832,'multiline':False]['text':' shouldn't bake in stub values.','line_number':833,'multiline':False]['text':' Guard shape to ensure that object class is unchanged. This is true','line_number':876,'multiline':False]['text':' for all shapes.','line_number':877,'multiline':False]['text':' Guard shape to detect changes to (non-dense) own properties. This','line_number':882,'multiline':False]['text':' also implies |guardShapeForClass|.','line_number':883,'multiline':False]['text':' Guard object is a specific function. This implies immutable fields on','line_number':896,'multiline':False]['text':' the JSFunction struct itself are unchanged.','line_number':897,'multiline':False]['text':' Bake in the nargs and FunctionFlags so Warp can use them off-main thread,','line_number':898,'multiline':False]['text':' instead of directly using the JSFunction fields.','line_number':899,'multiline':False]['text':' Guard function has a specific BaseScript. This implies immutable fields','line_number':905,'multiline':False]['text':' on the JSFunction struct itself are unchanged and are equivalent for','line_number':906,'multiline':False]['text':' lambda clones.','line_number':907,'multiline':False]['text':' Bake in the nargs and FunctionFlags so Warp can use them off-main thread,','line_number':908,'multiline':False]['text':' instead of directly using the JSFunction fields.','line_number':909,'multiline':False]['text':' Some native functions can be implemented faster if we know that','line_number':967,'multiline':False]['text':' the return value is ignored.','line_number':968,'multiline':False]['text':' The simulator requires VM calls to be redirected to a special','line_number':974,'multiline':False]['text':' swi instruction to handle them, so we store the redirected','line_number':975,'multiline':False]['text':' pointer in the stub and use that instead of the original one.','line_number':976,'multiline':False]['text':' If we are calling the ignoresReturnValue version of a native','line_number':977,'multiline':False]['text':' function, we bake it into the redirected pointer.','line_number':978,'multiline':False]['text':' (See BaselineCacheIRCompiler::emitCallNativeFunction.)','line_number':979,'multiline':False]['text':' If we are not running in the simulator, we generate different jitcode','line_number':987,'multiline':False]['text':' to find the ignoresReturnValue version of a native function.','line_number':988,'multiline':False]['text':' The simulator requires native calls to be redirected to a','line_number':1009,'multiline':False]['text':' special swi instruction. If we are calling an arbitrary native','line_number':1010,'multiline':False]['text':' function, we can't wrap the real target ahead of time, so we','line_number':1011,'multiline':False]['text':' call a wrapper function (CallAnyNative) that calls the target','line_number':1012,'multiline':False]['text':' itself, and redirect that wrapper.','line_number':1013,'multiline':False]['text':' ignoresReturnValue = ','line_number':1020,'multiline':True]['text':' The simulator requires VM calls to be redirected to a special','line_number':1029,'multiline':False]['text':' swi instruction to handle them, so we store the redirected','line_number':1030,'multiline':False]['text':' pointer in the stub and use that instead of the original one.','line_number':1031,'multiline':False]['text':' Helper class for reading CacheIR bytecode.','line_number':1096,'multiline':False]['text':' Skip data not currently used.','line_number':1114,'multiline':False]['text':' See CacheIRWriter::writeCallFlagsImm()','line_number':1176,'multiline':False]['text':'isSpread =','line_number':1188,'multiline':True]['text':'isSpread =','line_number':1191,'multiline':True]['text':' The existing non-standard argument formats (FunCall and FunApply)','line_number':1194,'multiline':False]['text':' can't be constructors.','line_number':1195,'multiline':False]['text':' GetPropIRGenerator generates CacheIR for a GetProp IC.','line_number':1282,'multiline':False]['text':' If this is a GetElem cache, emit instructions to guard the incoming Value','line_number':1380,'multiline':False]['text':' matches |id|.','line_number':1381,'multiline':False]['text':' GetNameIRGenerator generates CacheIR for a GetName IC.','line_number':1394,'multiline':False]['text':' BindNameIRGenerator generates CacheIR for a BindName IC.','line_number':1412,'multiline':False]['text':' SetPropIRGenerator generates CacheIR for a SetProp IC.','line_number':1429,'multiline':False]['text':' If this is a SetElem cache, emit instructions to guard the incoming Value','line_number':1454,'multiline':False]['text':' matches |id|.','line_number':1455,'multiline':False]['text':' HasPropIRGenerator generates CacheIR for a HasProp IC. Used for','line_number':1522,'multiline':False]['text':' CacheKind::In / CacheKind::HasOwn.','line_number':1523,'multiline':False]['text':' NOTE: Argument order is PROPERTY, OBJECT','line_number':1553,'multiline':False]['text':' Retrieve Xray JIT info set by the embedder.','line_number':1962,'multiline':False]['text':' namespace jit','line_number':1965,'multiline':False]['text':' namespace js','line_number':1966,'multiline':False]['text':' jit_CacheIR_h ','line_number':1968,'multiline':True]