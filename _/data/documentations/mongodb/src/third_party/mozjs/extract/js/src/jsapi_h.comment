['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JavaScript API. ','line_number':7,'multiline':True]['text':'**********************************************************************','line_number':63,'multiline':True]['text':'*
 * Tell JS engine whether to use fdlibm for Math.sin, Math.cos, and Math.tan.
 * Using fdlibm ensures that we don't expose a math fingerprint.
 ','line_number':66,'multiline':True]['text':' namespace JS','line_number':71,'multiline':False]['text':'**********************************************************************','line_number':73,'multiline':True]['text':' namespace JS ','line_number':90,'multiline':True]['text':' Callbacks and their arguments. ','line_number':92,'multiline':True]['text':'**********************************************************************','line_number':94,'multiline':True]['text':' Callback for the embedding to map from a ScriptSourceObject private-value to','line_number':96,'multiline':False]['text':' an object that is exposed as the source "element" in debugger API.  This hook','line_number':97,'multiline':False]['text':' must be infallible, but can return nullptr if no such element exists.','line_number':98,'multiline':False]['text':'*
 * Callback used to ask the embedding for the cross compartment wrapper handler
 * that implements the desired prolicy for this kind of object in the
 * destination compartment. |obj| is the object to be wrapped. If |existing| is
 * non-nullptr, it will point to an existing wrapper object that should be
 * re-used if possible. |existing| is guaranteed to be a cross-compartment
 * wrapper with a lazily-defined prototype and the correct global. It is
 * guaranteed not to wrap a function.
 ','line_number':103,'multiline':True]['text':'*
 * Callback used by the wrap hook to ask the embedding to prepare an object
 * for wrapping in a context. This might include unwrapping other wrappers
 * or even finding a more suitable object for the new compartment. If |origObj|
 * is non-null, then it is the original object we are going to swap into during
 * a transplant.
 ','line_number':115,'multiline':True]['text':'*
 * Callback used to intercept JavaScript errors.
 ','line_number':131,'multiline':True]['text':'*
   * This method is called whenever an error has been raised from JS code.
   *
   * This method MUST be infallible.
   ','line_number':135,'multiline':True]['text':'**********************************************************************','line_number':143,'multiline':True]['text':'**********************************************************************','line_number':154,'multiline':True]['text':'**********************************************************************','line_number':158,'multiline':True]['text':'* Microseconds since the epoch, midnight, January 1, 1970 UTC. ','line_number':160,'multiline':True]['text':'* Timing information for telemetry purposes *','line_number':184,'multiline':True]['text':' Total time spent executing','line_number':186,'multiline':False]['text':' Total time spent delazifying','line_number':187,'multiline':False]['text':' Total time spent XDR encoding','line_number':188,'multiline':False]['text':' Total time spent in GC','line_number':189,'multiline':False]['text':' Total time spent protecting JIT executable memory','line_number':191,'multiline':False]['text':' Total time spent in baseline compiler','line_number':193,'multiline':False]['text':' namespace JS ','line_number':198,'multiline':True]['text':'* True iff fun is the global eval function. ','line_number':200,'multiline':True]['text':'* True iff fun is the Function constructor. ','line_number':203,'multiline':True]['text':' Set a callback that will be called whenever an error','line_number':211,'multiline':False]['text':' is thrown in this runtime. This is designed as a mechanism','line_number':212,'multiline':False]['text':' for logging errors. Note that the VM makes no attempt to sanitize','line_number':213,'multiline':False]['text':' the contents of the error (so it may contain private data)','line_number':214,'multiline':False]['text':' or to sort out among errors (so it may not be the error you','line_number':215,'multiline':False]['text':' are interested in or for the component in which you are','line_number':216,'multiline':False]['text':' interested).','line_number':217,'multiline':False]['text':'','line_number':218,'multiline':False]['text':' If the callback sets a new error, this new error','line_number':219,'multiline':False]['text':' will replace the original error.','line_number':220,'multiline':False]['text':'','line_number':221,'multiline':False]['text':' May be `nullptr`.','line_number':222,'multiline':False]['text':' This is a no-op if built without NIGHTLY_BUILD.','line_number':223,'multiline':False]['text':' This returns nullptr if built without NIGHTLY_BUILD.','line_number':227,'multiline':False]['text':' Examine a value to determine if it is one of the built-in Error types.','line_number':231,'multiline':False]['text':' If so, return the error type.','line_number':232,'multiline':False]['text':'*
 * Resolve id, which must contain either a string or an int, to a standard
 * class name in obj if possible, defining the class's constructor and/or
 * prototype and storing true in *resolved.  If id does not name a standard
 * class or a top-level property induced by initializing a standard class,
 * store false in *resolved and just return true.  Return false on error,
 * as usual for bool result-typed API entry points.
 *
 * This API can be called directly from a global object class's resolve op,
 * to define standard classes lazily. The class should either have an enumerate
 * hook that calls JS_EnumerateStandardClasses, or a newEnumerate hook that
 * calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's
 * faster (does not define all standard classes).
 ','line_number':246,'multiline':True]['text':'*
 * Fill "properties" with a list of standard class names that have not yet been
 * resolved on "obj".  This can be used as (part of) a newEnumerate class hook
 * on a global.  Already-resolved things are excluded because they might have
 * been deleted by script after being resolved and enumeration considers
 * already-defined properties anyway.
 ','line_number':272,'multiline':True]['text':'*
 * Fill "properties" with a list of standard class names.  This can be used for
 * proxies that want to define behavior that looks like enumerating a global
 * without touching the global itself.
 ','line_number':283,'multiline':True]['text':'
 * Determine if the given object is an instance/prototype/constructor for a
 * standard class. If so, return the associated JSProtoKey. If not, return
 * JSProto_Null.
 ','line_number':300,'multiline':True]['text':' namespace JS ','line_number':318,'multiline':True]['text':'*
 * Get the current realm's global. Returns nullptr if no realm has been
 * entered.
 ','line_number':332,'multiline':True]['text':'*
 * Get the global object associated with an object's realm. The object must not
 * be a cross-compartment wrapper (because CCWs are shared by all realms in the
 * compartment).
 ','line_number':338,'multiline':True]['text':' namespace JS','line_number':345,'multiline':False]['text':'*
 * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
 * given global.
 ','line_number':347,'multiline':True]['text':'*
 * Add various profiling-related functions as properties of the given object.
 * Defined in builtin/Profilers.cpp.
 ','line_number':354,'multiline':True]['text':' Defined in vm/Debugger.cpp. ','line_number':361,'multiline':True]['text':'*
 * Tell JS engine whether Profile Timeline Recording is enabled or not.
 * If Profile Timeline Recording is enabled, data shown there like stack won't
 * be optimized out.
 * This is global state and not associated with specific runtime or context.
 ','line_number':367,'multiline':True]['text':' namespace JS','line_number':377,'multiline':False]['text':'*
 * Set the size of the native stack that should not be exceed. To disable
 * stack size checking pass 0.
 *
 * SpiderMonkey allows for a distinction between system code (such as GCs, which
 * may incidentally be triggered by script but are not strictly performed on
 * behalf of such script), trusted script (as determined by
 * JS_SetTrustedPrincipals), and untrusted script. Each kind of code may have a
 * different stack quota, allowing embedders to keep higher-priority machinery
 * running in the face of scripted stack exhaustion by something else.
 *
 * The stack quotas for each kind of code should be monotonically descending,
 * and may be specified with this function. If 0 is passed for a given kind
 * of code, it defaults to the value of the next-highest-priority kind.
 *
 * This function may only be called immediately after the runtime is initialized
 * and before any code is executed and/or interrupts requested.
 ','line_number':379,'multiline':True]['text':'**********************************************************************','line_number':401,'multiline':True]['text':'*
 * Convert obj to a primitive value. On success, store the result in vp and
 * return true.
 *
 * The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or
 * JSTYPE_UNDEFINED (no hint).
 *
 * Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType]).
 ','line_number':414,'multiline':True]['text':'*
 * If args.get(0) is one of the strings "string", "number", or "default", set
 * result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and
 * return true. Otherwise, return false with a TypeError pending.
 *
 * This can be useful in implementing a @@toPrimitive method.
 ','line_number':426,'multiline':True]['text':' namespace JS ','line_number':437,'multiline':True]['text':'*
 * Set up ctor.prototype = proto and proto.constructor = ctor with the
 * right property flags.
 ','line_number':445,'multiline':True]['text':' Implementation of','line_number':463,'multiline':False]['text':' http://www.ecma-international.org/ecma-262/6.0/#sec-ordinaryhasinstance.  If','line_number':464,'multiline':False]['text':' you're looking for the equivalent of "instanceof", you want JS_HasInstance,','line_number':465,'multiline':False]['text':' not this function.','line_number':466,'multiline':False]['text':' Implementation of','line_number':471,'multiline':False]['text':' https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator','line_number':472,'multiline':False]['text':' This is almost identical to JS_HasInstance, except the latter may call a','line_number':473,'multiline':False]['text':' custom hasInstance class op instead of InstanceofOperator.','line_number':474,'multiline':False]['text':' namespace JS','line_number':478,'multiline':False]['text':'*
 * During global creation, we fire notifications to callbacks registered
 * via the Debugger API. These callbacks are arbitrary script, and can touch
 * the global in arbitrary ways. When that happens, the global should not be
 * in a half-baked state. But this creates a problem for consumers that need
 * to set slots on the global to put it in a consistent state.
 *
 * This API provides a way for consumers to set slots atomically (immediately
 * after the global is created), before any debugger hooks are fired. It's
 * unfortunately on the clunky side, but that's the way the cookie crumbles.
 *
 * If callers have no additional state on the global to set up, they may pass
 * |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to
 * fire the hook as its final act before returning. Otherwise, callers should
 * pass |DontFireOnNewGlobalHook|, which means that they are responsible for
 * invoking JS_FireOnNewGlobalObject upon successfully creating the global. If
 * an error occurs and the operation aborts, callers should skip firing the
 * hook. But otherwise, callers must take care to fire the hook exactly once
 * before compiling any script in the global's scope (we have assertions in
 * place to enforce this). This lets us be sure that debugger clients never miss
 * breakpoints.
 ','line_number':493,'multiline':True]['text':' namespace JS ','line_number':517,'multiline':True]['text':'*
 * Spidermonkey does not have a good way of keeping track of what compartments
 * should be marked on their own. We can mark the roots unconditionally, but
 * marking GC things only relevant in live compartments is hard. To mitigate
 * this, we create a static trace hook, installed on each global object, from
 * which we can be sure the compartment is relevant, and mark it.
 *
 * It is still possible to specify custom trace hooks for global object classes.
 * They can be provided via the RealmOptions passed to JS_NewGlobalObject.
 ','line_number':522,'multiline':True]['text':'*
 * This allows easily constructing a global object without having to deal with
 * JSClassOps, forgetting to add JS_GlobalObjectTraceHook, or forgetting to call
 * JS::InitRealmStandardClasses(). Example:
 *
 *     const JSClass globalClass = { "MyGlobal", JSCLASS_GLOBAL_FLAGS,
 *         &JS::DefaultGlobalClassOps };
 *     JS_NewGlobalObject(cx, &globalClass, ...);
 ','line_number':537,'multiline':True]['text':' namespace JS','line_number':548,'multiline':False]['text':'*
 * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
 * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
 ','line_number':558,'multiline':True]['text':'*
 * Creates a new plain object, like `new Object()`, with Object.prototype as
 * [[Prototype]].
 ','line_number':565,'multiline':True]['text':'*
 * Freeze obj, and all objects it refers to, recursively. This will not recurse
 * through non-extensible objects, on the assumption that those are already
 * deep-frozen.
 ','line_number':571,'multiline':True]['text':'*
 * Freezes an object; see ES5's Object.freeze(obj) method.
 ','line_number':579,'multiline':True]['text':'** Standard internal methods **********************************************
 *
 * The functions below are the fundamental operations on objects.
 *
 * ES6 specifies 14 internal methods that define how objects behave.  The
 * standard is actually quite good on this topic, though you may have to read
 * it a few times. See ES6 sections 6.1.7.2 and 6.1.7.3.
 *
 * When 'obj' is an ordinary object, these functions have boring standard
 * behavior as specified by ES6 section 9.1; see the section about internal
 * methods in js/src/vm/NativeObject.h.
 *
 * Proxies override the behavior of internal methods. So when 'obj' is a proxy,
 * any one of the functions below could do just about anything. See
 * js/public/Proxy.h.
 ','line_number':585,'multiline':True]['text':'*
 * Get the prototype of |obj|, storing it in |proto|.
 *
 * Implements: ES6 [[GetPrototypeOf]] internal method.
 ','line_number':602,'multiline':True]['text':'*
 * If |obj| (underneath any functionally-transparent wrapper proxies) has as
 * its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined
 * for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype
 * in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
 * outparams have unspecified value.
 ','line_number':610,'multiline':True]['text':'*
 * Change the prototype of obj.
 *
 * Implements: ES6 [[SetPrototypeOf]] internal method.
 *
 * In cases where ES6 [[SetPrototypeOf]] returns false without an exception,
 * JS_SetPrototype throws a TypeError and returns false.
 *
 * Performance warning: JS_SetPrototype is very bad for performance. It may
 * cause compiled jit-code to be invalidated. It also causes not only obj but
 * all other objects in the same "group" as obj to be permanently deoptimized.
 * It's better to create the object with the right prototype from the start.
 ','line_number':621,'multiline':True]['text':'*
 * Determine whether obj is extensible. Extensible objects can have new
 * properties defined on them. Inextensible objects can't, and their
 * [[Prototype]] slot is fixed as well.
 *
 * Implements: ES6 [[IsExtensible]] internal method.
 ','line_number':637,'multiline':True]['text':'*
 * Attempt to make |obj| non-extensible.
 *
 * Not all failures are treated as errors. See the comment on
 * JS::ObjectOpResult in js/public/Class.h.
 *
 * Implements: ES6 [[PreventExtensions]] internal method.
 ','line_number':647,'multiline':True]['text':'*
 * Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt
 * to modify it will fail.  If an error occurs during the attempt, return false
 * (with a pending exception set, depending upon the nature of the error).  If
 * no error occurs, return true with |*succeeded| set to indicate whether the
 * attempt successfully made the [[Prototype]] immutable.
 *
 * This is a nonstandard internal method.
 ','line_number':659,'multiline':True]['text':'*
 * Get a description of one of obj's own properties. If no such property exists
 * on obj, return true with desc.object() set to null.
 *
 * Implements: ES6 [[GetOwnProperty]] internal method.
 ','line_number':672,'multiline':True]['text':'*
 * DEPRECATED
 *
 * Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain
 * if no own property is found directly on obj. The object on which the
 * property is found is returned in holder. If the property is not found
 * on the prototype chain, then desc is Nothing.
 ','line_number':690,'multiline':True]['text':'*
 * Define a property on obj.
 *
 * This function uses JS::ObjectOpResult to indicate conditions that ES6
 * specifies as non-error failures. This is inconvenient at best, so use this
 * function only if you are implementing a proxy handler's defineProperty()
 * method. For all other purposes, use one of the many DefineProperty functions
 * below that throw an exception in all failure cases.
 *
 * Implements: ES6 [[DefineOwnProperty]] internal method.
 ','line_number':713,'multiline':True]['text':'*
 * Define a property on obj, throwing a TypeError if the attempt fails.
 * This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`.
 ','line_number':728,'multiline':True]['text':'*
 * Compute the expression `id in obj`.
 *
 * If obj has an own or inherited property obj[id], set *foundp = true and
 * return true. If not, set *foundp = false and return true. On error, return
 * false with an exception pending.
 *
 * Implements: ES6 [[Has]] internal method.
 ','line_number':889,'multiline':True]['text':'*
 * Determine whether obj has an own property with the key `id`.
 *
 * Implements: ES6 7.3.11 HasOwnProperty(O, P).
 ','line_number':912,'multiline':True]['text':'*
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.
 *
 * Most callers don't need the `receiver` argument. Consider using
 * JS_GetProperty instead. (But if you're implementing a proxy handler's set()
 * method, it's often correct to call this function and pass the receiver
 * through.)
 *
 * Implements: ES6 [[Get]] internal method.
 ','line_number':924,'multiline':True]['text':'*
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. The result is stored in vp.
 *
 * Implements: ES6 7.3.1 Get(O, P).
 ','line_number':947,'multiline':True]['text':'*
 * Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.
 *
 * This function has a `receiver` argument that most callers don't need.
 * Consider using JS_SetProperty instead.
 *
 * Implements: ES6 [[Set]] internal method.
 ','line_number':970,'multiline':True]['text':'*
 * Perform the assignment `obj[id] = v`.
 *
 * This function performs non-strict assignment, so if the property is
 * read-only, nothing happens and no error is thrown.
 ','line_number':982,'multiline':True]['text':'*
 * Delete a property. This is the C++ equivalent of
 * `result = Reflect.deleteProperty(obj, id)`.
 *
 * This function has a `result` out parameter that most callers don't need.
 * Unless you can pass through an ObjectOpResult provided by your caller, it's
 * probably best to use the JS_DeletePropertyById signature with just 3
 * arguments.
 *
 * Implements: ES6 [[Delete]] internal method.
 ','line_number':1018,'multiline':True]['text':'*
 * Delete a property, ignoring strict failures. This is the C++ equivalent of
 * the JS `delete obj[id]` in non-strict mode code.
 ','line_number':1048,'multiline':True]['text':'*
 * Get an array of the non-symbol enumerable properties of obj.
 * This function is roughly equivalent to:
 *
 *     var result = [];
 *     for (key in obj) {
 *         result.push(key);
 *     }
 *     return result;
 *
 * This is the closest thing we currently have to the ES6 [[Enumerate]]
 * internal method.
 *
 * The array of ids returned by JS_Enumerate must be rooted to protect its
 * contents from garbage collection. Use JS::Rooted<JS::IdVector>.
 ','line_number':1061,'multiline':True]['text':'*
 * Equivalent to `Object.assign(target, src)`: Copies the properties from the
 * `src` object (which must not be null) to `target` (which also must not be
 * null).
 ','line_number':1080,'multiline':True]['text':'
 * API for determining callability and constructability. [[Call]] and
 * [[Construct]] are internal methods that aren't present on all objects, so it
 * is useful to ask if they are there or not. The standard itself asks these
 * questions routinely.
 ','line_number':1089,'multiline':True]['text':'*
 * Return true if the given object is callable. In ES6 terms, an object is
 * callable if it has a [[Call]] internal method.
 *
 * Implements: ES6 7.2.3 IsCallable(argument).
 *
 * Functions are callable. A scripted proxy or wrapper is callable if its
 * target is callable. Most other objects aren't callable.
 ','line_number':1097,'multiline':True]['text':'*
 * Return true if the given object is a constructor. In ES6 terms, an object is
 * a constructor if it has a [[Construct]] internal method. The expression
 * `new obj()` throws a TypeError if obj is not a constructor.
 *
 * Implements: ES6 7.2.4 IsConstructor(argument).
 *
 * JS functions and classes are constructors. Arrow functions and most builtin
 * functions are not. A scripted proxy or wrapper is a constructor if its
 * target is a constructor.
 ','line_number':1108,'multiline':True]['text':' namespace JS ','line_number':1121,'multiline':True]['text':'*
 * Call a function, passing a this-value and arguments. This is the C++
 * equivalent of `rval = Reflect.apply(fun, obj, args)`.
 *
 * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
 * Use this function to invoke the [[Call]] internal method.
 ','line_number':1123,'multiline':True]['text':'*
 * Perform the method call `rval = obj[name](args)`.
 ','line_number':1141,'multiline':True]['text':'*
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = Reflect.construct(fun, args, newTarget)`.
 *
 * JS::Construct() takes a `newTarget` argument that most callers don't need.
 * Consider using the four-argument Construct signature instead. (But if you're
 * implementing a subclass or a proxy handler's construct() method, this is the
 * right function to call.)
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).
 * Use this function to invoke the [[Construct]] internal method.
 ','line_number':1185,'multiline':True]['text':'*
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = new fun(...args)`.
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when
 * newTarget is omitted.
 ','line_number':1202,'multiline':True]['text':' namespace JS ','line_number':1213,'multiline':True]['text':'** Other property-defining functions *************************************','line_number':1215,'multiline':True]['text':' * ','line_number':1227,'multiline':True]['text':'*
 * On success, returns true, setting |*isMap| to true if |obj| is a Map object
 * or a wrapper around one, or to false if not.  Returns false on failure.
 *
 * This method returns true with |*isMap == false| when passed an ES6 proxy
 * whose target is a Map, or when passed a revoked proxy.
 ','line_number':1251,'multiline':True]['text':'*
 * On success, returns true, setting |*isSet| to true if |obj| is a Set object
 * or a wrapper around one, or to false if not.  Returns false on failure.
 *
 * This method returns true with |*isSet == false| when passed an ES6 proxy
 * whose target is a Set, or when passed a revoked proxy.
 ','line_number':1261,'multiline':True]['text':' namespace JS ','line_number':1271,'multiline':True]['text':'*
 * Assign 'undefined' to all of the object's non-reserved slots. Note: this is
 * done for all slots, regardless of the associated property descriptor.
 ','line_number':1273,'multiline':True]['text':'**********************************************************************','line_number':1295,'multiline':True]['text':' native that can be called as a ctor ','line_number':1297,'multiline':True]['text':' | of all the JSFUN_* flags ','line_number':1300,'multiline':True]['text':'
 * Functions and scripts.
 ','line_number':1307,'multiline':True]['text':'*
 * Create a new function based on the given JSFunctionSpec, *fs.
 * id is the result of a successful call to
 * `PropertySpecNameToId(cx, fs->name, &id)` or
   `PropertySpecNameToPermanentId(cx, fs->name, &id)`.
 *
 * Unlike JS_DefineFunctions, this does not treat fs as an array.
 * *fs must not be JS_FS_END.
 ','line_number':1319,'multiline':True]['text':'*
 * Same as above, but without an id arg, for callers who don't have
 * the id already.
 ','line_number':1332,'multiline':True]['text':' namespace JS ','line_number':1339,'multiline':True]['text':'*
 * Return the function's identifier as a JSString, or null if fun is unnamed.
 * The returned string lives as long as fun, so you don't need to root a saved
 * reference to it if fun is well-connected or rooted, and provided you bound
 * the use of the saved reference by fun's lifetime.
 ','line_number':1343,'multiline':True]['text':'*
 * Return a function's display name. This is the defined name if one was given
 * where the function was defined, or it could be an inferred name by the JS
 * engine in the case that the function was defined to be anonymous. This can
 * still return nullptr if a useful display name could not be inferred. The
 * same restrictions on rooting as those in JS_GetFunctionId apply.
 ','line_number':1351,'multiline':True]['text':'
 * Return the arity of fun, which includes default parameters and rest
 * parameter.  This can be used as `nargs` parameter for other functions.
 ','line_number':1360,'multiline':True]['text':'
 * Return the length of fun, which is the original value of .length property.
 ','line_number':1366,'multiline':True]['text':'*
 * Infallible predicate to test whether obj is a function object (faster than
 * comparing obj's class name to "Function", but equivalent unless someone has
 * overwritten the "Function" identifier with a different constructor and then
 * created instances using that constructor that might be passed in as obj).
 ','line_number':1372,'multiline':True]['text':'* Return whether the given function is a valid constructor. ','line_number':1382,'multiline':True]['text':'*
 * Set a private value associated with a script. Note that this value is shared
 * by all nested scripts compiled from a single source file.
 ','line_number':1423,'multiline':True]['text':'*
 * Get the private value associated with a script. Note that this value is
 * shared by all nested scripts compiled from a single source file.
 ','line_number':1430,'multiline':True]['text':'
 * Return the private value associated with currently executing script or
 * module, or undefined if there is no such script.
 ','line_number':1436,'multiline':True]['text':'*
 * Hooks called when references to a script private value are created or
 * destroyed. This allows use of a reference counted object as the
 * script private.
 ','line_number':1442,'multiline':True]['text':'*
 * Set the script private finalize hook for the runtime to the given function.
 ','line_number':1449,'multiline':True]['text':' namespace JS ','line_number':1456,'multiline':True]['text':'
 * These functions allow setting an interrupt callback that will be called
 * from the JS thread some time after any thread triggered the callback using
 * JS_RequestInterruptCallback(cx).
 *
 * To schedule the GC and for other activities the engine internally triggers
 * interrupt callbacks. The embedding should thus not rely on callbacks being
 * triggered through the external API only.
 *
 * Important note: Additional callbacks can occur inside the callback handler
 * if it re-enters the JS engine. The embedding must ensure that the callback
 * is disconnected before attempting such re-entry.
 ','line_number':1460,'multiline':True]['text':'*
 * The ConsumeStreamCallback is called from an active JSContext, passing a
 * StreamConsumer that wishes to consume the given host object as a stream of
 * bytes with the given MIME type. On failure, the embedding must report the
 * appropriate error on 'cx'. On success, the embedding must call
 * consumer->consumeChunk() repeatedly on any thread until exactly one of:
 *  - consumeChunk() returns false
 *  - the embedding calls consumer->streamEnd()
 *  - the embedding calls consumer->streamError()
 * before JS_DestroyContext(cx) or JS::ShutdownAsyncTasks(cx) is called.
 *
 * Note: consumeChunk(), streamEnd() and streamError() may be called
 * synchronously by ConsumeStreamCallback.
 *
 * When streamEnd() is called, the embedding may optionally pass an
 * OptimizedEncodingListener*, indicating that there is a cache entry associated
 * with this stream that can store an optimized encoding of the bytes that were
 * just streamed at some point in the future by having SpiderMonkey call
 * storeOptimizedEncoding(). Until the optimized encoding is ready, SpiderMonkey
 * will hold an outstanding refcount to keep the listener alive.
 *
 * After storeOptimizedEncoding() is called, on cache hit, the embedding
 * may call consumeOptimizedEncoding() instead of consumeChunk()/streamEnd().
 * The embedding must ensure that the GetOptimizedEncodingBuildId() (see
 * js/BuildId.h) at the time when an optimized encoding is created is the same
 * as when it is later consumed.
 ','line_number':1486,'multiline':True]['text':' SpiderMonkey will hold an outstanding reference count as long as it holds','line_number':1522,'multiline':False]['text':' a pointer to OptimizedEncodingListener.','line_number':1523,'multiline':False]['text':' SpiderMonkey may optionally call storeOptimizedEncoding() after it has','line_number':1527,'multiline':False]['text':' finished processing a streamed resource.','line_number':1528,'multiline':False]['text':' AsyncStreamConsumers are created and destroyed by SpiderMonkey.','line_number':1534,'multiline':False]['text':' Called by the embedding as each chunk of bytes becomes available.','line_number':1539,'multiline':False]['text':' If this function returns 'false', the stream must drop all pointers to','line_number':1540,'multiline':False]['text':' this StreamConsumer.','line_number':1541,'multiline':False]['text':' Called by the embedding when the stream reaches end-of-file, passing the','line_number':1544,'multiline':False]['text':' listener described above.','line_number':1545,'multiline':False]['text':' Called by the embedding when there is an error during streaming. The','line_number':1548,'multiline':False]['text':' given error code should be passed to the ReportStreamErrorCallback on the','line_number':1549,'multiline':False]['text':' main thread to produce the semantically-correct rejection value.','line_number':1550,'multiline':False]['text':' Called by the embedding *instead of* consumeChunk()/streamEnd() if an','line_number':1553,'multiline':False]['text':' optimized encoding is available from a previous streaming of the same','line_number':1554,'multiline':False]['text':' contents with the same optimized build id.','line_number':1555,'multiline':False]['text':' Provides optional stream attributes such as base or source mapping URLs.','line_number':1559,'multiline':False]['text':' Necessarily called before consumeChunk(), streamEnd(), streamError() or','line_number':1560,'multiline':False]['text':' consumeOptimizedEncoding(). The caller retains ownership of the strings.','line_number':1561,'multiline':False]['text':'*
 * Supply an alternative stack to incorporate into captured SavedFrame
 * backtraces as the imputed caller of asynchronous JavaScript calls, like async
 * function resumptions and DOM callbacks.
 *
 * When one async function awaits the result of another, it's natural to think
 * of that as a sort of function call: just as execution resumes from an
 * ordinary call expression when the callee returns, with the return value
 * providing the value of the call expression, execution resumes from an 'await'
 * expression after the awaited asynchronous function call returns, passing the
 * return value along.
 *
 * Call the two async functions in such a situation the 'awaiter' and the
 * 'awaitee'.
 *
 * As an async function, the awaitee contains 'await' expressions of its own.
 * Whenever it executes after its first 'await', there are never any actual
 * frames on the JavaScript stack under it; its awaiter is certainly not there.
 * An await expression's continuation is invoked as a promise callback, and
 * those are always called directly from the event loop in their own microtick.
 * (Ignore unusual cases like nested event loops.)
 *
 * But because await expressions bear such a strong resemblance to calls (and
 * deliberately so!), it would be unhelpful for stacks captured within the
 * awaitee to be empty; instead, they should present the awaiter as the caller.
 *
 * The AutoSetAsyncStackForNewCalls RAII class supplies a SavedFrame stack to
 * treat as the caller of any JavaScript invocations that occur within its
 * lifetime. Any SavedFrame stack captured during such an invocation uses the
 * SavedFrame passed to the constructor's 'stack' parameter as the 'asyncParent'
 * property of the SavedFrame for the invocation's oldest frame. Its 'parent'
 * property will be null, so stack-walking code can distinguish this
 * awaiter/awaitee transition from an ordinary caller/callee transition.
 *
 * The constructor's 'asyncCause' parameter supplies a string explaining what
 * sort of asynchronous call caused 'stack' to be spliced into the backtrace;
 * for example, async function resumptions use the string "async". This appears
 * as the 'asyncCause' property of the 'asyncParent' SavedFrame.
 *
 * Async callers are distinguished in the string form of a SavedFrame chain by
 * including the 'asyncCause' string in the frame. It appears before the
 * function name, with the two separated by a '*'.
 *
 * Note that, as each compartment has its own set of SavedFrames, the
 * 'asyncParent' may actually point to a copy of 'stack', rather than the exact
 * SavedFrame object passed.
 *
 * The youngest frame of 'stack' is not mutated to take the asyncCause string as
 * its 'asyncCause' property; SavedFrame objects are immutable. Rather, a fresh
 * clone of the frame is created with the needed 'asyncCause' property.
 *
 * The 'kind' argument specifies how aggressively 'stack' supplants any
 * JavaScript frames older than this AutoSetAsyncStackForNewCalls object. If
 * 'kind' is 'EXPLICIT', then all captured SavedFrame chains take on 'stack' as
 * their 'asyncParent' where the chain crosses this object's scope. If 'kind' is
 * 'IMPLICIT', then 'stack' is only included in captured chains if there are no
 * other JavaScript frames on the stack --- that is, only if the stack would
 * otherwise end at that point.
 *
 * AutoSetAsyncStackForNewCalls affects only SavedFrame chains; it does not
 * affect Debugger.Frame or js::FrameIter. SavedFrame chains are used for
 * Error.stack, allocation profiling, Promise debugging, and so on.
 *
 * See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
 * stack frames.
 ','line_number':1577,'multiline':True]['text':' The ordinary kind of call, where we may apply an async','line_number':1651,'multiline':False]['text':' parent if there is no ordinary parent.','line_number':1652,'multiline':False]['text':' An explicit async parent, e.g., callFunctionWithAsyncStack,','line_number':1654,'multiline':False]['text':' where we always want to override any ordinary parent.','line_number':1655,'multiline':False]['text':' The stack parameter cannot be null by design, because it would be','line_number':1659,'multiline':False]['text':' ambiguous whether that would clear any scheduled async stack and make the','line_number':1660,'multiline':False]['text':' normal stack reappear in the new call, or just keep the async stack','line_number':1661,'multiline':False]['text':' already scheduled for the new call, if any.','line_number':1662,'multiline':False]['text':'','line_number':1663,'multiline':False]['text':' asyncCause is owned by the caller and its lifetime must outlive the','line_number':1664,'multiline':False]['text':' lifetime of the AutoSetAsyncStackForNewCalls object. It is strongly','line_number':1665,'multiline':False]['text':' encouraged that asyncCause be a string constant or similar statically','line_number':1666,'multiline':False]['text':' allocated string.','line_number':1667,'multiline':False]['text':' namespace JS','line_number':1674,'multiline':False]['text':'**********************************************************************','line_number':1676,'multiline':True]['text':'*
 * Create a jsid that does not need to be marked for GC.
 *
 * 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The
 * resulting jsid, on success, is either an interned string or a well-known
 * symbol; either way it is immune to GC so there is no need to visit *idp
 * during GC marking.
 ','line_number':1683,'multiline':True]['text':' namespace JS ','line_number':1695,'multiline':True]['text':'**********************************************************************','line_number':1697,'multiline':True]['text':'*
 * A JS context always has an "owner thread". The owner thread is set when the
 * context is created (to the current thread) and practically all entry points
 * into the JS engine check that a context (or anything contained in the
 * context: runtime, compartment, object, etc) is only touched by its owner
 * thread. Embeddings may check this invariant outside the JS engine by calling
 * JS_AbortIfWrongThread (which will abort if not on the owner thread, even for
 * non-debug builds).
 ','line_number':1699,'multiline':True]['text':'**********************************************************************','line_number':1711,'multiline':True]['text':'*
 * A constructor can request that the JS engine create a default new 'this'
 * object of the given class, using the callee to determine parentage and
 * [[Prototype]].
 ','line_number':1713,'multiline':True]['text':'**********************************************************************','line_number':1721,'multiline':True]['text':' clang-format off','line_number':1729,'multiline':False]['text':' clang-format on','line_number':1758,'multiline':False]['text':'*
 * Convert a uint32_t index into a jsid.
 ','line_number':1776,'multiline':True]['text':'*
 * Convert chars into a jsid.
 *
 * |chars| may not be an index.
 ','line_number':1782,'multiline':True]['text':'*
 *  Test if the given string is a valid ECMAScript identifier
 ','line_number':1790,'multiline':True]['text':'*
 * Test whether the given chars + length are a valid ECMAScript identifier.
 * This version is infallible, so just returns whether the chars are an
 * identifier.
 ','line_number':1796,'multiline':True]['text':' namespace js','line_number':1805,'multiline':False]['text':'*
 * Return the current filename, line number and column number of the most
 * currently running frame. Returns true if a scripted frame was found, false
 * otherwise.
 *
 * If a the embedding has hidden the scripted caller for the topmost activation
 * record, this will also return false.
 ','line_number':1832,'multiline':True]['text':'*
 * Informs the JS engine that the scripted caller should be hidden. This can be
 * used by the embedding to maintain an override of the scripted caller in its
 * calculations, by hiding the scripted caller in the JS engine and pushing data
 * onto a separate stack, which it inspects when DescribeScriptedCaller returns
 * null.
 *
 * We maintain a counter on each activation record. Add() increments the counter
 * of the topmost activation, and Remove() decrements it. The count may never
 * drop below zero, and must always be exactly zero when the activation is
 * popped from the stack.
 ','line_number':1846,'multiline':True]['text':' namespace JS ','line_number':1873,'multiline':True]['text':'
 * Sets the format used for stringifying Error stacks.
 *
 * The default format is StackFormat::SpiderMonkey.  Use StackFormat::V8
 * in order to emulate V8's stack formatting.  StackFormat::Default can't be
 * used here.
 ','line_number':1879,'multiline':True]['text':' namespace js','line_number':1890,'multiline':False]['text':'*
 * Attempt to disable Wasm's usage of reserving a large virtual memory
 * allocation to avoid bounds checking overhead. This must be called before any
 * Wasm module or memory is created in this process, or else this function will
 * fail.
 ','line_number':1894,'multiline':True]['text':'*
 * If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS
 * engine may call the large-allocation-failure callback, if set, to allow the
 * embedding to flush caches, possibly perform shrinking GCs, etc. to make some
 * room. The allocation will then be retried (and may still fail.) This callback
 * can be called on any thread and must be set at most once in a process.
 ','line_number':1902,'multiline':True]['text':'*
 * Unlike the error reporter, which is only called if the exception for an OOM
 * bubbles up and is not caught, the OutOfMemoryCallback is called immediately
 * at the OOM site to allow the embedding to capture the current state of heap
 * allocation before anything is freed. If the large-allocation-failure callback
 * is called at all (not all allocation sites call the large-allocation-failure
 * callback on failure), it is called before the out-of-memory callback; the
 * out-of-memory callback is only called if the allocation still fails after the
 * large-allocation-failure callback has returned.
 ','line_number':1915,'multiline':True]['text':'*
 * When the JSRuntime is about to block in an Atomics.wait() JS call or in a
 * `wait` instruction in WebAssembly, it can notify the host by means of a call
 * to BeforeWaitCallback.  After the wait, it can notify the host by means of a
 * call to AfterWaitCallback.  Both callbacks must be null, or neither.
 *
 * (If you change the callbacks from null to not-null or vice versa while some
 * thread on the runtime is in a wait, you will be sorry.)
 *
 * The argument to the BeforeWaitCallback is a pointer to uninitialized
 * stack-allocated working memory of size WAIT_CALLBACK_CLIENT_MAXMEM bytes.
 * The caller of SetWaitCallback() must pass the amount of memory it will need,
 * and this amount will be checked against that limit and the process will crash
 * reliably if the check fails.
 *
 * The value returned by the BeforeWaitCallback will be passed to the
 * AfterWaitCallback.
 *
 * The AfterWaitCallback will be called even if the wakeup is spurious and the
 * thread goes right back to waiting again.  Of course the thread will call the
 * BeforeWaitCallback once more before it goes to sleep in this situation.
 ','line_number':1932,'multiline':True]['text':'*
 * Capture all frames.
 ','line_number':1965,'multiline':True]['text':'*
 * Capture at most this many frames.
 ','line_number':1970,'multiline':True]['text':'*
 * Capture the first frame with the given principals. By default, do not
 * consider self-hosted frames with the given principals as satisfying the stack
 * capture.
 ','line_number':1979,'multiline':True]['text':'*
   * Use the cx's current compartment's principals.
   ','line_number':1989,'multiline':True]['text':' No copying because we want to avoid holding and dropping principals','line_number':2003,'multiline':False]['text':' unnecessarily.','line_number':2004,'multiline':False]['text':'*
 * Capture the current call stack as a chain of SavedFrame JSObjects, and set
 * |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there
 * are no JS frames on the stack.
 *
 * The |capture| parameter describes the portion of the JS stack to capture:
 *
 *   * |JS::AllFrames|: Capture all frames on the stack.
 *
 *   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the
 *      stack.
 *
 *   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are
 *     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not
 *     consider self-hosted frames; this can be controlled via the
 *     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async
 *     stack.
 ','line_number':2028,'multiline':True]['text':'*
 * Returns true if capturing stack trace data to associate with an asynchronous
 * operation is currently enabled for the current context realm.
 *
 * Users should check this state before capturing a stack that will be passed
 * back to AutoSetAsyncStackForNewCalls later, in order to avoid capturing a
 * stack for async use when we don't actually want to capture it.
 ','line_number':2050,'multiline':True]['text':'
 * This is a utility function for preparing an async stack to be used
 * by some other object.  This may be used when you need to treat a
 * given stack trace as an async parent.  If you just need to capture
 * the current stack, async parents and all, use CaptureCurrentStack
 * instead.
 *
 * Here |asyncStack| is the async stack to prepare.  It is copied into
 * |cx|'s current compartment, and the newest frame is given
 * |asyncCause| as its asynchronous cause.  If |maxFrameCount| is
 * |Some(n)|, capture at most the youngest |n| frames.  The
 * new stack object is written to |stackp|.  Returns true on success,
 * or sets an exception and returns |false| on error.
 ','line_number':2060,'multiline':True]['text':'*
 * Given a SavedFrame JSObject stack, stringify it in the same format as
 * Error.prototype.stack. The stringified stack out parameter is placed in the
 * cx's compartment. Defaults to the empty string.
 *
 * The same notes above about SavedFrame accessors applies here as well: cx
 * doesn't need to be in stack's compartment, and stack can be null, a
 * SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.
 * SavedFrames not subsumed by |principals| are skipped.
 *
 * Optional indent parameter specifies the number of white spaces to indent
 * each line.
 ','line_number':2078,'multiline':True]['text':'*
 * Return true iff the given object is either a SavedFrame object or wrapper
 * around a SavedFrame object, and it is not the SavedFrame.prototype object.
 ','line_number':2096,'multiline':True]['text':'*
 * Return true iff the given object is a SavedFrame object and not the
 * SavedFrame.prototype object.
 ','line_number':2102,'multiline':True]['text':' namespace JS ','line_number':2108,'multiline':True]['text':'*
 * Hint that we expect a crash. Currently, the only thing that cares is the
 * breakpad injector, which (if loaded) will suppress minidump generation.
 ','line_number':2112,'multiline':True]['text':' namespace js ','line_number':2118,'multiline':True]['text':' namespace js ','line_number':2124,'multiline':True]['text':' DEBUG ','line_number':2132,'multiline':True]['text':' jsapi_h ','line_number':2134,'multiline':True]