['text':' Copyright 2019 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]['text':' Use of this source code is governed by a BSD-style license that can be','line_number':2,'multiline':False]['text':' found in the LICENSE file.','line_number':3,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':10,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':16,'multiline':False]['text':' NOLINT(build/namespaces)','line_number':21,'multiline':False]['text':' -------------------------------------------------------------------','line_number':23,'multiline':False]['text':' Tree to graph conversion','line_number':24,'multiline':False]['text':' Remove final marker.','line_number':43,'multiline':False]['text':' Remove final marker.','line_number':72,'multiline':False]['text':' TODO(lrn): Remove need for this function, by not throwing away information','line_number':88,'multiline':False]['text':' along the way.','line_number':89,'multiline':False]['text':' The unicode range splitter categorizes given character ranges into:','line_number':126,'multiline':False]['text':' - Code points from the BMP representable by one code unit.','line_number':127,'multiline':False]['text':' - Code points outside the BMP that need to be split into surrogate pairs.','line_number':128,'multiline':False]['text':' - Lone lead surrogates.','line_number':129,'multiline':False]['text':' - Lone trail surrogates.','line_number':130,'multiline':False]['text':' Lone surrogates are valid code points, even though no actual characters.','line_number':131,'multiline':False]['text':' They require special matching to make sure we do not split surrogate pairs.','line_number':132,'multiline':False]['text':' Ends are all inclusive.','line_number':143,'multiline':False]['text':' Translates between new and old V8-isms (SmallVector, ZoneList).','line_number':183,'multiline':False]['text':' Match surrogate pair.','line_number':219,'multiline':False]['text':' E.g. [\u10005-\u11005] becomes','line_number':220,'multiline':False]['text':'      \ud800[\udc05-\udfff]|','line_number':221,'multiline':False]['text':'      [\ud801-\ud803][\udc00-\udfff]|','line_number':222,'multiline':False]['text':'      \ud804[\udc00-\udc05]','line_number':223,'multiline':False]['text':' The lead surrogate is the same.','line_number':231,'multiline':False]['text':' Add [from_l][from_t-\udfff]','line_number':239,'multiline':False]['text':' Add [to_l][\udc00-to_t]','line_number':248,'multiline':False]['text':' Add [from_l-to_l][\udc00-\udfff]','line_number':257,'multiline':False]['text':' E.g. \ud801 becomes \ud801(?![\udc00-\udfff]).','line_number':307,'multiline':False]['text':' Reading backward. Assert that reading forward, there is no trail','line_number':313,'multiline':False]['text':' surrogate, and then backward match the lead surrogate.','line_number':314,'multiline':False]['text':' Reading forward. Forward match the lead surrogate and assert that','line_number':318,'multiline':False]['text':' no trail surrogate follows.','line_number':319,'multiline':False]['text':' E.g. \udc01 becomes (?<![\ud800-\udbff])\udc01','line_number':334,'multiline':False]['text':' Reading backward. Backward match the trail surrogate and assert that no','line_number':340,'multiline':False]['text':' lead surrogate precedes it.','line_number':341,'multiline':False]['text':' Reading forward. Assert that reading backward, there is no lead','line_number':345,'multiline':False]['text':' surrogate, and then forward match the trail surrogate.','line_number':346,'multiline':False]['text':' This implements ES2015 21.2.5.2.3, AdvanceStringIndex.','line_number':355,'multiline':False]['text':' Advance any character. If the character happens to be a lead surrogate and','line_number':358,'multiline':False]['text':' we advanced into the middle of a surrogate pair, it will work out, as','line_number':359,'multiline':False]['text':' nothing will match from there. We will have to advance again, consuming','line_number':360,'multiline':False]['text':' the associated trail surrogate.','line_number':361,'multiline':False]['text':' Micro-optimization to avoid passing large ranges to UnicodeSet::closeOver.','line_number':373,'multiline':False]['text':' See also https://crbug.com/v8/6727.','line_number':374,'multiline':False]['text':' TODO(jgruber): This only covers the special case of the {0,0x10FFFF} range,','line_number':375,'multiline':False]['text':' which we use frequently internally. But large ranges can also easily be','line_number':376,'multiline':False]['text':' created by the user. We might want to have a more general caching mechanism','line_number':377,'multiline':False]['text':' for such ranges.','line_number':378,'multiline':False]['text':' Use ICU to compute the case fold closure over the ranges.','line_number':381,'multiline':False]['text':' Clear the ranges list without freeing the backing store.','line_number':386,'multiline':False]['text':' Full case mapping map single characters to multiple characters.','line_number':389,'multiline':False]['text':' Those are represented as strings in the set. Remove them so that','line_number':390,'multiline':False]['text':' we end up with only simple and common case mappings.','line_number':391,'multiline':False]['text':' No errors and everything we collected have been ranges.','line_number':397,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':399,'multiline':False]['text':' namespace','line_number':402,'multiline':False]['text':' Arbitrary.','line_number':435,'multiline':False]['text':' Case Insensitve comparesion','line_number':456,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':491,'multiline':False]['text':' We can stable sort runs of atoms, since the order does not matter if they','line_number':493,'multiline':False]['text':' start with different characters.','line_number':494,'multiline':False]['text':' Returns true if any consecutive atoms were found.','line_number':495,'multiline':False]['text':' i is length or it is the index of an atom.','line_number':506,'multiline':False]['text':' Sort atoms to get ones with common prefixes together.','line_number':517,'multiline':False]['text':' This step is more tricky if we are in a case-independent regexp,','line_number':518,'multiline':False]['text':' because it would change /is|I/ to /I|is/, and order matters when','line_number':519,'multiline':False]['text':' the regexp parts don't match only disjoint starting points. To fix','line_number':520,'multiline':False]['text':' this we have a version of CompareFirstChar that uses case-','line_number':521,'multiline':False]['text':' independent character classes for comparison.','line_number':522,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':538,'multiline':False]['text':' Optimizes ab|ac|az to a(?:b|c|d).','line_number':547,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':568,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':594,'multiline':False]['text':' Found worthwhile run of alternatives with common prefix of at least one','line_number':599,'multiline':False]['text':' character.  The sorting function above did not sort on more than one','line_number':600,'multiline':False]['text':' character for reasons of correctness, but there may still be a longer','line_number':601,'multiline':False]['text':' common prefix if the terms were similar or presorted in the input.','line_number':602,'multiline':False]['text':' Find out how long the common prefix is.','line_number':603,'multiline':False]['text':' Just copy any non-worthwhile alternatives.','line_number':638,'multiline':False]['text':' Trim end of array.','line_number':644,'multiline':False]['text':' Optimizes b|c|z to [bcz].','line_number':647,'multiline':False]['text':' Find a run of single-character atom alternatives that have identical','line_number':676,'multiline':False]['text':' flags (case independence and unicode-ness).','line_number':677,'multiline':False]['text':' Found non-trivial run of single-character alternatives.','line_number':691,'multiline':False]['text':' Just copy any trivial alternatives.','line_number':707,'multiline':False]['text':' Trim end of array.','line_number':713,'multiline':False]['text':' Desugar \b to (?<=\w)(?=\W)|(?<=\W)(?=\w) and','line_number':747,'multiline':False]['text':'         \B to (?<=\w)(?=\w)|(?<=\W)(?=\W)','line_number':748,'multiline':False]['text':' Add two choices. The (non-)boundary could start with a word or','line_number':761,'multiline':False]['text':' a non-word-character.','line_number':762,'multiline':False]['text':' Look to the left.','line_number':767,'multiline':False]['text':' Look to the right.','line_number':772,'multiline':False]['text':' anonymous namespace','line_number':782,'multiline':False]['text':' Compile $ in multiline regexps as an alternation with a positive','line_number':807,'multiline':False]['text':' lookahead in one side and an end-of-input on the other side.','line_number':808,'multiline':False]['text':' We need two registers for the lookahead.','line_number':809,'multiline':False]['text':' The ChoiceNode to distinguish between a newline and end-of-input.','line_number':812,'multiline':False]['text':' Create a newline atom.','line_number':814,'multiline':False]['text':' No captures inside.','line_number':825,'multiline':False]['text':' Ignored if no captures.','line_number':826,'multiline':False]['text':' Create an end-of-input matcher.','line_number':828,'multiline':False]['text':' Add the two alternatives to the ChoiceNode.','line_number':831,'multiline':False]['text':' We use a ChoiceNode to represent the negative lookaround. The first','line_number':884,'multiline':False]['text':' alternative is the negative match. On success, the end node backtracks.','line_number':885,'multiline':False]['text':' On failure, the second alternative is tried and leads to success.','line_number':886,'multiline':False]['text':' NegativeLookaheadChoiceNode is a special ChoiceNode that ignores the','line_number':887,'multiline':False]['text':' first exit when calculating quick checks.','line_number':888,'multiline':False]['text':' TODO(jgruber): Consider moving this to a separate AST tree rewriter pass','line_number':939,'multiline':False]['text':' instead of sprinkling rewrites into the AST->Node conversion process.','line_number':940,'multiline':False]['text':' Start a sequence.','line_number':950,'multiline':False]['text':' Terminate and process the sequence.','line_number':952,'multiline':False]['text':' All assertions are zero width. A consecutive sequence of assertions is','line_number':963,'multiline':False]['text':' order-independent. There's two ways we can optimize here:','line_number':964,'multiline':False]['text':' 1. fold all identical assertions.','line_number':965,'multiline':False]['text':' 2. if any assertion combinations are known to fail (e.g. \b\B), the entire','line_number':966,'multiline':False]['text':'    sequence fails.','line_number':967,'multiline':False]['text':' Bitfield of all seen assertions.','line_number':971,'multiline':False]['text':' Flags must match for folding.','line_number':975,'multiline':False]['text':' Fold duplicates.','line_number':985,'multiline':False]['text':' Collapse failures.','line_number':992,'multiline':False]['text':' Replace the entire sequence with a single node that always fails.','line_number':1001,'multiline':False]['text':' TODO(jgruber): Consider adding an explicit Fail kind. Until then, the','line_number':1002,'multiline':False]['text':' negated '*' (everything) range serves the purpose.','line_number':1003,'multiline':False]['text':' Zero out the rest.','line_number':1010,'multiline':False]['text':' namespace','line_number':1023,'multiline':False]['text':' See #sec-runtime-semantics-wordcharacters-abstract-operation','line_number':1074,'multiline':False]['text':' In case of unicode and ignore_case, we need to create the closure over','line_number':1075,'multiline':False]['text':' case equivalent characters before negating.','line_number':1076,'multiline':False]['text':' This is not a character range as defined by the spec but a','line_number':1118,'multiline':False]['text':' convenient shorthand for a character class that matches any','line_number':1119,'multiline':False]['text':' character.','line_number':1120,'multiline':False]['text':' This is the set of characters matched by the $ and ^ symbols','line_number':1124,'multiline':False]['text':' in multiline mode.','line_number':1125,'multiline':False]['text':' static','line_number':1138,'multiline':False]['text':' Nothing to be done for surrogates.','line_number':1151,'multiline':False]['text':' Compute the set of additional characters that should be added,','line_number':1160,'multiline':False]['text':' using UnicodeSet::closeOver. ECMA 262 defines slightly different','line_number':1161,'multiline':False]['text':' case-folding rules than Unicode, so some characters that are','line_number':1162,'multiline':False]['text':' added by closeOver do not match anything other than themselves in','line_number':1163,'multiline':False]['text':' JS. For example, 'ſ' (U+017F LATIN SMALL LETTER LONG S) is the','line_number':1164,'multiline':False]['text':' same case-insensitive character as 's' or 'S' according to','line_number':1165,'multiline':False]['text':' Unicode, but does not match any other character in JS. To handle','line_number':1166,'multiline':False]['text':' this case, we add such characters to the IgnoreSet and filter','line_number':1167,'multiline':False]['text':' them out. We filter twice: once before calling closeOver (to','line_number':1168,'multiline':False]['text':' prevent 'ſ' from adding 's'), and once after calling closeOver','line_number':1169,'multiline':False]['text':' (to prevent 's' from adding 'ſ'). See regexp/special-case.h for','line_number':1170,'multiline':False]['text':' more information.','line_number':1171,'multiline':False]['text':' Add others to the ranges','line_number':1178,'multiline':False]['text':' Nothing to be done for surrogates.','line_number':1194,'multiline':False]['text':' If this is a singleton we just expand the one character.','line_number':1202,'multiline':False]['text':' If this is a range we expand the characters block by block, expanding','line_number':1211,'multiline':False]['text':' contiguous subranges (blocks) one at a time.  The approach is as','line_number':1212,'multiline':False]['text':' follows.  For a given start character we look up the remainder of the','line_number':1213,'multiline':False]['text':' block that contains it (represented by the end point), for instance we','line_number':1214,'multiline':False]['text':' find 'z' if the character is 'c'.  A block is characterized by the','line_number':1215,'multiline':False]['text':' property that all characters uncanonicalize in the same way, except','line_number':1216,'multiline':False]['text':' that each entry in the result is incremented by the distance from the','line_number':1217,'multiline':False]['text':' first element.  So a-z is a block because 'a' uncanonicalizes to ['a',','line_number':1218,'multiline':False]['text':' 'A'] and the k'th letter uncanonicalizes to ['a' + k, 'A' + k].  Once','line_number':1219,'multiline':False]['text':' we've found the end point we look up its uncanonicalization and','line_number':1220,'multiline':False]['text':' produce a range for each element.  For instance for [c-f] we look up','line_number':1221,'multiline':False]['text':' ['z', 'Z'] and produce [c-f] and [C-F].  We then only add a range if','line_number':1222,'multiline':False]['text':' it is not already contained in the input, so [c-f] will be skipped but','line_number':1223,'multiline':False]['text':' [C-F] will be added.  If this range is not completely contained in a','line_number':1224,'multiline':False]['text':' block we do this for all the blocks covered by the range (handling','line_number':1225,'multiline':False]['text':' characters that is not in a block as a "singleton block").','line_number':1226,'multiline':False]['text':' V8_INTL_SUPPORT','line_number':1254,'multiline':False]['text':' Move a number of elements in a zonelist to another position','line_number':1278,'multiline':False]['text':' in the same list. Handles overlapping source and target areas.','line_number':1279,'multiline':False]['text':' Ranges are potentially overlapping.','line_number':1282,'multiline':False]['text':' Inserts a range into list[0..count[, which must be sorted','line_number':1296,'multiline':False]['text':' by from value and non-overlapping and non-adjacent, using at most','line_number':1297,'multiline':False]['text':' list[0..count] for the result. Returns the number of resulting','line_number':1298,'multiline':False]['text':' canonicalized ranges. Inserting a range may collapse existing ranges into','line_number':1299,'multiline':False]['text':' fewer ranges, so the return value can be anything in the range 1..count+1.','line_number':1300,'multiline':False]['text':' Inserted range overlaps, or is adjacent to, ranges at positions','line_number':1315,'multiline':False]['text':' [start_pos..end_pos[. Ranges before start_pos or at or after end_pos are','line_number':1316,'multiline':False]['text':' not affected by the insertion.','line_number':1317,'multiline':False]['text':' If start_pos == end_pos, the range must be inserted before start_pos.','line_number':1318,'multiline':False]['text':' if start_pos < end_pos, the entire range from start_pos to end_pos','line_number':1319,'multiline':False]['text':' must be merged with the insert range.','line_number':1320,'multiline':False]['text':' Insert between existing ranges at position start_pos.','line_number':1323,'multiline':False]['text':' Replace single existing range at position start_pos.','line_number':1331,'multiline':False]['text':' Replace a number of existing ranges from start_pos to end_pos - 1.','line_number':1338,'multiline':False]['text':' Move the remaining ranges down.','line_number':1339,'multiline':False]['text':' Special/default classes are always considered canonical. The result','line_number':1351,'multiline':False]['text':' of calling ranges() will be sorted.','line_number':1352,'multiline':False]['text':' Check whether ranges are already canonical (increasing, non-overlapping,','line_number':1359,'multiline':False]['text':' non-adjacent).','line_number':1360,'multiline':False]['text':' Canonical until the i'th range. If that's all of them, we are done.','line_number':1372,'multiline':False]['text':' The ranges at index i and forward are not canonicalized. Make them so by','line_number':1375,'multiline':False]['text':' doing the equivalent of insertion sort (inserting each into the previous','line_number':1376,'multiline':False]['text':' list, in order).','line_number':1377,'multiline':False]['text':' Notice that inserting a range can reduce the number of ranges in the','line_number':1378,'multiline':False]['text':' result due to combining of adjacent and overlapping ranges.','line_number':1379,'multiline':False]['text':' Range to insert.','line_number':1380,'multiline':False]['text':' Length of canonicalized part of list.','line_number':1381,'multiline':False]['text':' Scoped object to keep track of how much we unroll quantifier loops in the','line_number':1416,'multiline':False]['text':' regexp graph generator.','line_number':1417,'multiline':False]['text':' Avoid integer overflow of the current expansion factor.','line_number':1428,'multiline':False]['text':' x{f, t} becomes this:','line_number':1457,'multiline':False]['text':'','line_number':1458,'multiline':False]['text':'             (r++)<-.','line_number':1459,'multiline':False]['text':'               |     `','line_number':1460,'multiline':False]['text':'               |     (x)','line_number':1461,'multiline':False]['text':'               v     ^','line_number':1462,'multiline':False]['text':'      (r=0)-->(?)---/ [if r < t]','line_number':1463,'multiline':False]['text':'               |','line_number':1464,'multiline':False]['text':'   [if r >= f] \----> ...','line_number':1465,'multiline':False]['text':'','line_number':1466,'multiline':False]['text':' 15.10.2.5 RepeatMatcher algorithm.','line_number':1468,'multiline':False]['text':' The parser has already eliminated the case where max is 0.  In the case','line_number':1469,'multiline':False]['text':' where max_match is zero the parser has removed the quantifier if min was','line_number':1470,'multiline':False]['text':' > 0 and removed the atom if min was 0.  See AddQuantifierToAtom.','line_number':1471,'multiline':False]['text':' If we know that we cannot match zero length then things are a little','line_number':1473,'multiline':False]['text':' simpler since we don't need to make the special zero length match check','line_number':1474,'multiline':False]['text':' from step 2.1.  If the min and max are small we can unroll a little in','line_number':1475,'multiline':False]['text':' this case.','line_number':1476,'multiline':False]['text':' Unroll (foo)+ and (foo){3,}','line_number':1477,'multiline':False]['text':' Unroll (foo)? and (foo){x,3}','line_number':1478,'multiline':False]['text':' This can happen due to recursion.','line_number':1479,'multiline':False]['text':' Only unroll if there are no captures and the body can't be','line_number':1489,'multiline':False]['text':' empty.','line_number':1490,'multiline':False]['text':' Recurse once to get the loop or optional matches after the fixed','line_number':1495,'multiline':False]['text':' ones.','line_number':1496,'multiline':False]['text':' Unroll the forced matches from 0 to min.  This can cause chains of','line_number':1499,'multiline':False]['text':' TextNodes (which the parser does not generate).  These should be','line_number':1500,'multiline':False]['text':' combined if it turns out they hinder good code generation.','line_number':1501,'multiline':False]['text':' Due to the 'if' above.','line_number':1509,'multiline':False]['text':' Unroll the optional matches up to max.','line_number':1512,'multiline':False]['text':' If the body can be empty we need to check if it was and then','line_number':1547,'multiline':False]['text':' backtrack.','line_number':1548,'multiline':False]['text':' If the body can be empty we need to store the start position','line_number':1554,'multiline':False]['text':' so we can bail out if it was empty.','line_number':1555,'multiline':False]['text':' Before entering the body of this loop we need to clear captures.','line_number':1559,'multiline':False]['text':' namespace internal','line_number':1586,'multiline':False]['text':' namespace v8','line_number':1587,'multiline':False]