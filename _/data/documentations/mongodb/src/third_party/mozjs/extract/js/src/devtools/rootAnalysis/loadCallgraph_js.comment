['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' -*- indent-tabs-mode: nil; js-indent-level: 4 -*- ','line_number':5,'multiline':True]['text':' Functions come out of sixgill in the form "mangled$readable". The mangled','line_number':11,'multiline':False]['text':' name is Truth. One mangled name might correspond to multiple readable names,','line_number':12,'multiline':False]['text':' for multiple reasons, including (1) sixgill/gcc doesn't always qualify types','line_number':13,'multiline':False]['text':' the same way or de-typedef the same amount; (2) sixgill's output treats','line_number':14,'multiline':False]['text':' references and pointers the same, and so doesn't distinguish them, but C++','line_number':15,'multiline':False]['text':' treats them as separate for overloading and linking; (3) (identical)','line_number':16,'multiline':False]['text':' destructors sometimes have an int32 parameter, sometimes not.','line_number':17,'multiline':False]['text':'','line_number':18,'multiline':False]['text':' The readable names are useful because they're far more meaningful to the','line_number':19,'multiline':False]['text':' user, and are what should show up in reports and questions to mrgiggles. At','line_number':20,'multiline':False]['text':' least in most cases, it's fine to have the extra mangled name tacked onto','line_number':21,'multiline':False]['text':' the beginning for these.','line_number':22,'multiline':False]['text':'','line_number':23,'multiline':False]['text':' The strategy used is to separate out the pieces whenever they are read in,','line_number':24,'multiline':False]['text':' create a table mapping mangled names to all readable names, and use the','line_number':25,'multiline':False]['text':' mangled names in all computation -- except for limited circumstances when','line_number':26,'multiline':False]['text':' the readable name is used in annotations.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' Note that callgraph.txt uses a compressed representation -- each name is','line_number':29,'multiline':False]['text':' mapped to an integer, and those integers are what is recorded in the edges.','line_number':30,'multiline':False]['text':' But the integers depend on the full name, whereas the true edge should only','line_number':31,'multiline':False]['text':' consider the mangled name. And some of the names encoded in callgraph.txt','line_number':32,'multiline':False]['text':' are FieldCalls, not just function names.','line_number':33,'multiline':False]['text':' map from mangled name => list of readable names','line_number':35,'multiline':False]['text':' map from mangled => list of tuples of {'callee':mangled, 'limits':intset}','line_number':36,'multiline':False]['text':' map from mangled => list of tuples of {'caller':mangled, 'limits':intset}','line_number':37,'multiline':False]['text':' map from mangled callee => reason','line_number':38,'multiline':False]['text':' set of mangled names (map from mangled name => limit intset)','line_number':39,'multiline':False]['text':' "Map" from identifier to mangled name, or sometimes to a Class.Field name.','line_number':42,'multiline':False]['text':' Returns whether the function was added. (It will be refused if it was','line_number':47,'multiline':False]['text':' already there, or if limits or annotations say it shouldn't be added.)','line_number':48,'multiline':False]['text':' Every caller->callee callsite is associated with a limit saying what is','line_number':65,'multiline':False]['text':' allowed at that callsite (eg if it's in a GC suppression zone, it would have','line_number':66,'multiline':False]['text':' LIMIT_CANNOT_GC set.) A given caller might call the same callee multiple','line_number':67,'multiline':False]['text':' times, with different limits, so we want to associate the <caller,callee>','line_number':68,'multiline':False]['text':' edge with the intersection ('AND') of all of the callsites' limits.','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' Scan through all call edges and intersect the limits for all matching','line_number':71,'multiline':False]['text':' <caller,callee> edges (so that the result is the least limiting of all','line_number':72,'multiline':False]['text':' matching edges.) Preserve the original order.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' During the same scan, build callersOf from calleesOf.','line_number':75,'multiline':False]['text':' callee_limits is a list of {callee,limit} objects.','line_number':82,'multiline':False]['text':' Update the contents of callee_limits to contain a single entry for','line_number':94,'multiline':False]['text':' each callee, with its limits set to the AND of the limits observed','line_number':95,'multiline':False]['text':' at all callsites within this caller function.','line_number':96,'multiline':False]['text':' map from full field name id => csu name','line_number':113,'multiline':False]['text':' set of mangled names (map from mangled name => limit intset)','line_number':116,'multiline':False]['text':' Example line: D /17 6 7','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' This means a direct call from 6 -> 7, but within a scope that','line_number':145,'multiline':False]['text':' applies limits 0x1 and 0x10 to the callee.','line_number':146,'multiline':False]['text':'','line_number':147,'multiline':False]['text':' Look for a limit and remove it from the line if found.','line_number':148,'multiline':False]['text':' Resolved virtual functions create a dummy node for the field','line_number':180,'multiline':False]['text':' call, and callers call it. It will then call all possible','line_number':181,'multiline':False]['text':' instantiations. No additional limits are placed on the callees;','line_number':182,'multiline':False]['text':' it's as if there were a function named BaseClass.foo:','line_number':183,'multiline':False]['text':'','line_number':184,'multiline':False]['text':'     void BaseClass.foo() {','line_number':185,'multiline':False]['text':'         Subclass1::foo();','line_number':186,'multiline':False]['text':'         Subclass2::foo();','line_number':187,'multiline':False]['text':'     }','line_number':188,'multiline':False]['text':'','line_number':189,'multiline':False]['text':' Mark that we resolved this virtual method, so that it isn't','line_number':191,'multiline':False]['text':' assumed to call some random function that might do anything.','line_number':192,'multiline':False]['text':' Callers have a list of callees, with duplicates (if the same function is','line_number':206,'multiline':False]['text':' called more than once.) Merge the repeated calls, only keeping limits','line_number':207,'multiline':False]['text':' that are in force for *every* callsite of that callee. Also, generate','line_number':208,'multiline':False]['text':' the callersOf table at the same time.','line_number':209,'multiline':False]['text':' Add in any extra functions at the end. (If we did this early, it would','line_number':212,'multiline':False]['text':' mess up the id <-> name correspondence. Also, we need to know if the','line_number':213,'multiline':False]['text':' functions even exist in the first place.)','line_number':214,'multiline':False]['text':' Compute functionLimits: it should contain the set of functions that','line_number':219,'multiline':False]['text':' are *always* called within some sort of limited context (eg GC','line_number':220,'multiline':False]['text':' suppression).','line_number':221,'multiline':False]['text':' Initialize to limited field calls.','line_number':223,'multiline':False]['text':' Initialize functionLimits to the set of all functions, where each one is','line_number':229,'multiline':False]['text':' maximally limited, and return a worklist containing all simple roots','line_number':230,'multiline':False]['text':' (nodes with no callers).','line_number':231,'multiline':False]['text':' Traverse the graph, spreading the limits down from the roots.','line_number':234,'multiline':False]['text':' There are a surprising number of "recursive roots", where there is a','line_number':237,'multiline':False]['text':' cycle of functions calling each other but not called by anything else,','line_number':238,'multiline':False]['text':' and these roots may also have descendants. Now that the above traversal','line_number':239,'multiline':False]['text':' has eliminated everything reachable from simple roots, traverse the','line_number':240,'multiline':False]['text':' remaining graph to gather up a representative function from each root','line_number':241,'multiline':False]['text':' cycle.','line_number':242,'multiline':False]['text':' And do a final traversal starting with the recursive roots.','line_number':245,'multiline':False]['text':' Eliminate GC-limited functions from the set of functions known to GC.','line_number':248,'multiline':False]['text':' functionLimits should now contain all functions that are always called','line_number':254,'multiline':False]['text':' in a limited context.','line_number':255,'multiline':False]['text':' Sanity check to make sure the callgraph has some functions annotated as','line_number':257,'multiline':False]['text':' GC Calls. This is mostly a check to be sure the earlier processing','line_number':258,'multiline':False]['text':' succeeded (as opposed to, say, running on empty xdb files because you','line_number':259,'multiline':False]['text':' didn't actually compile anything interesting.)','line_number':260,'multiline':False]['text':' Initialize the worklist to all known gcFunctions.','line_number':263,'multiline':False]['text':' Include all field calls and unresolved virtual method calls.','line_number':268,'multiline':False]['text':' Skip resolved virtual functions.','line_number':271,'multiline':False]['text':' Recursively find all callers not always called in a GC suppression','line_number':279,'multiline':False]['text':' context, and add them to the set of gcFunctions.','line_number':280,'multiline':False]['text':' Convert functionLimits to limitedFunctions (using mangled names instead','line_number':294,'multiline':False]['text':' of ids.)','line_number':295,'multiline':False]['text':' The above code uses integer ids for efficiency. External code uses','line_number':300,'multiline':False]['text':' mangled names. Rewrite the various data structures to convert ids to','line_number':301,'multiline':False]['text':' mangled names.','line_number':302,'multiline':False]['text':' Return a worklist of functions with no callers, and also initialize','line_number':306,'multiline':False]['text':' functionLimits to the set of all functions, each mapped to LIMIT_UNVISTED.','line_number':307,'multiline':False]['text':' Recursively traverse the callgraph from the roots. Recurse through every','line_number':322,'multiline':False]['text':' edge that weakens the limits. (Limits that entirely disappear, aka go to a','line_number':323,'multiline':False]['text':' zero intset, will be removed from functionLimits.)','line_number':324,'multiline':False]['text':' Consider caller where (graph) -> caller -> (0 or more callees)','line_number':328,'multiline':False]['text':' 'callercaller' is for debugging.','line_number':329,'multiline':False]['text':' Turning off a limit (or unvisited marker). Must recurse to the','line_number':333,'multiline':False]['text':' children. But first, update this caller's limits: we just found','line_number':334,'multiline':False]['text':' out it is reachable by an unlimited path, so it must be treated','line_number':335,'multiline':False]['text':' as unlimited (with respect to that bit).','line_number':336,'multiline':False]['text':' Mutually-recursive roots and their descendants will not have been visited,','line_number':348,'multiline':False]['text':' and will still be set to LIMIT_UNVISITED. Scan through and gather them.','line_number':349,'multiline':False]['text':' 'seen' maps functions to the most recent starting function that each was','line_number':353,'multiline':False]['text':' first reachable from, to distinguish between the current pass and passes','line_number':354,'multiline':False]['text':' for preceding functions.','line_number':355,'multiline':False]['text':'','line_number':356,'multiline':False]['text':' Consider:','line_number':357,'multiline':False]['text':'','line_number':358,'multiline':False]['text':'   A <--> B --> C <-- D <--> E','line_number':359,'multiline':False]['text':'                C --> F','line_number':360,'multiline':False]['text':'                C --> G','line_number':361,'multiline':False]['text':'','line_number':362,'multiline':False]['text':' So there are two root cycles AB and DE, both calling C that in turn','line_number':363,'multiline':False]['text':' calls F and G. If we start at F and scan up through callers, we will','line_number':364,'multiline':False]['text':' keep going until A loops back to B and E loops back to D, and will add B','line_number':365,'multiline':False]['text':' and D as roots. Then if we scan from G, we encounter C and see that it','line_number':366,'multiline':False]['text':' was already been seen on an earlier pass. So C and everything reachable','line_number':367,'multiline':False]['text':' from it is already reachable by some root. (We need to label nodes with','line_number':368,'multiline':False]['text':' their pass because otherwise we couldn't distinguish "already seen C,','line_number':369,'multiline':False]['text':' done" from "already seen B, must be a root".)','line_number':370,'multiline':False]['text':'','line_number':371,'multiline':False]['text':' We should only be looking at nodes with callers, since otherwise','line_number':377,'multiline':False]['text':' they would have been handled in the previous pass!','line_number':378,'multiline':False]['text':' We have traversed a cycle and reached an already-seen','line_number':386,'multiline':False]['text':' node. Treat it as a root.','line_number':387,'multiline':False]['text':' Otherwise we hit the portion of the graph that is','line_number':391,'multiline':False]['text':' reachable from a past root.','line_number':392,'multiline':False]