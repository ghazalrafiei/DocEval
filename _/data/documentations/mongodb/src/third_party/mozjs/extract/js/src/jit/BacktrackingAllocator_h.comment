['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' Gives better traces in Nightly/debug builds (could be EARLY_BETA_OR_EARLIER)','line_number':18,'multiline':False]['text':' Backtracking priority queue based register allocator based on that described','line_number':25,'multiline':False]['text':' in the following blog post:','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':' http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html','line_number':28,'multiline':False]['text':' FIXED has a dedicated constructor.','line_number':40,'multiline':False]['text':' Merge newRequirement with any existing requirement, returning false','line_number':56,'multiline':False]['text':' if the new and old requirements conflict.','line_number':57,'multiline':False]['text':' A UsePosition is an LUse* with a CodePosition.  UsePosition also has an','line_number':84,'multiline':False]['text':' optimization that allows access to the associated LUse::Policy without','line_number':85,'multiline':False]['text':' dereferencing memory: the policy is encoded in the low bits of the LUse*.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' Note however that because LUse* is uintptr_t-aligned, on 32-bit systems','line_number':88,'multiline':False]['text':' there are only 4 encodable values, for more than 4 use policies; in that','line_number':89,'multiline':False]['text':' case we allocate the common LUse::ANY, LUse::REGISTER, and LUse::FIXED use','line_number':90,'multiline':False]['text':' policies to tags, and use tag 0x3 to indicate that dereferencing the LUse','line_number':91,'multiline':False]['text':' is necessary to get the policy (KEEPALIVE or STACK, in that case).','line_number':92,'multiline':False]['text':' RECOVERED_INPUT is used by snapshots and ignored when building the','line_number':105,'multiline':False]['text':' liveness information. Thus we can safely assume that no such value','line_number':106,'multiline':False]['text':' would be seen.','line_number':107,'multiline':False]['text':' On a 32-bit machine, LUse::KEEPALIVE and LUse::STACK are accessed by','line_number':112,'multiline':False]['text':' dereferencing the use pointer.','line_number':113,'multiline':False]['text':' On 32-bit machines, reach out to memory if it's LUse::KEEPALIVE or','line_number':130,'multiline':False]['text':' LUse::STACK.','line_number':131,'multiline':False]['text':' Verify that the usedAtStart() flag is consistent with the','line_number':142,'multiline':False]['text':' subposition. For now ignore fixed registers, because they','line_number':143,'multiline':False]['text':' are handled specially around calls.','line_number':144,'multiline':False]['text':' Backtracking allocator data structures overview.','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':' LiveRange: A continuous range of positions where a virtual register is live.','line_number':156,'multiline':False]['text':' LiveBundle: A set of LiveRanges which do not overlap.','line_number':157,'multiline':False]['text':' VirtualRegister: A set of all LiveRanges used for some LDefinition.','line_number':158,'multiline':False]['text':'','line_number':159,'multiline':False]['text':' The allocator first performs a liveness ananlysis on the LIR graph which','line_number':160,'multiline':False]['text':' constructs LiveRanges for each VirtualRegister, determining where the','line_number':161,'multiline':False]['text':' registers are live.','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':' The ranges are then bundled together according to heuristics, and placed on','line_number':164,'multiline':False]['text':' the allocation queue.','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':' As bundles are removed from the allocation queue, we attempt to find a','line_number':167,'multiline':False]['text':' physical register or stack slot allocation for all ranges in the removed','line_number':168,'multiline':False]['text':' bundle, possibly evicting already-allocated bundles. See processBundle()','line_number':169,'multiline':False]['text':' for details.','line_number':170,'multiline':False]['text':'','line_number':171,'multiline':False]['text':' If we are not able to allocate a bundle, it is split according to heuristics','line_number':172,'multiline':False]['text':' into two or more smaller bundles which cover all the ranges of the original.','line_number':173,'multiline':False]['text':' These smaller bundles are then allocated independently.','line_number':174,'multiline':False]['text':' Linked lists are used to keep track of the ranges in each LiveBundle and','line_number':180,'multiline':False]['text':' VirtualRegister. Since a LiveRange may be in two lists simultaneously, use','line_number':181,'multiline':False]['text':' these auxiliary classes to keep things straight.','line_number':182,'multiline':False]['text':' Links in the lists in LiveBundle and VirtualRegister.','line_number':189,'multiline':False]['text':' The beginning of this range, inclusive.','line_number':203,'multiline':False]['text':' The end of this range, exclusive.','line_number':206,'multiline':False]['text':' The virtual register this range is for, or zero if this does not have a','line_number':222,'multiline':False]['text':' virtual register (for example, it is in the callRanges bundle).','line_number':223,'multiline':False]['text':' The bundle containing this range, null if liveness information is being','line_number':226,'multiline':False]['text':' constructed and we haven't started allocating bundles yet.','line_number':227,'multiline':False]['text':' The code positions in this range.','line_number':230,'multiline':False]['text':' All uses of the virtual register in this range, ordered by location.','line_number':233,'multiline':False]['text':' Total spill weight that calculate from all the uses' policy. Because the','line_number':236,'multiline':False]['text':' use's policy can't be changed after initialization, we can update the','line_number':237,'multiline':False]['text':' weight whenever a use is added to or remove from this range. This way, we','line_number':238,'multiline':False]['text':' don't need to iterate all the uses every time computeSpillWeight() is','line_number':239,'multiline':False]['text':' called.','line_number':240,'multiline':False]['text':' Number of uses that have policy LUse::FIXED.','line_number':243,'multiline':False]['text':' Whether this range contains the virtual register's definition.','line_number':246,'multiline':False]['text':' Whether this range wholly contains other.','line_number':282,'multiline':False]['text':' Intersect this range with other, returning the subranges of this','line_number':285,'multiline':False]['text':' that are before, inside, or after other.','line_number':286,'multiline':False]['text':' Whether this range has any intersection with other.','line_number':290,'multiline':False]['text':' Return a string describing this range.','line_number':323,'multiline':False]['text':' Comparator for use in range splay trees.','line_number':327,'multiline':False]['text':' LiveRange includes 'from' but excludes 'to'.','line_number':329,'multiline':False]['text':' Tracks information about bundles that should all be spilled to the same','line_number':340,'multiline':False]['text':' physical location. At the beginning of allocation, each bundle has its own','line_number':341,'multiline':False]['text':' spill set. As bundles are split, the new smaller bundles continue to use the','line_number':342,'multiline':False]['text':' same spill set.','line_number':343,'multiline':False]['text':' All bundles with this spill set which have been spilled. All bundles in','line_number':345,'multiline':False]['text':' this list will be given the same physical slot.','line_number':346,'multiline':False]['text':' A set of live ranges which are all pairwise disjoint. The register allocator','line_number':365,'multiline':False]['text':' attempts to find allocations for an entire bundle, and if it fails the','line_number':366,'multiline':False]['text':' bundle will be broken into smaller ones which are allocated independently.','line_number':367,'multiline':False]['text':' Set to use if this bundle or one it is split into is spilled.','line_number':369,'multiline':False]['text':' All the ranges in this set, ordered by location.','line_number':372,'multiline':False]['text':' Allocation to use for ranges in this set, bogus if unallocated or spilled','line_number':375,'multiline':False]['text':' and not yet given a physical stack slot.','line_number':376,'multiline':False]['text':' Bundle which entirely contains this one and has no register uses. This','line_number':379,'multiline':False]['text':' may or may not be spilled by the allocator, but it can be spilled and','line_number':380,'multiline':False]['text':' will not be split.','line_number':381,'multiline':False]['text':' Return a string describing this bundle.','line_number':423,'multiline':False]['text':' Information about the allocation for a virtual register.','line_number':428,'multiline':False]['text':' Instruction which defines this register.','line_number':430,'multiline':False]['text':' Definition in the instruction for this register.','line_number':433,'multiline':False]['text':' All live ranges for this register. These may overlap each other, and are','line_number':436,'multiline':False]['text':' ordered by their start position.','line_number':437,'multiline':False]['text':' Whether def_ is a temp or an output.','line_number':440,'multiline':False]['text':' Whether this vreg is an input for some phi. This use is not reflected in','line_number':443,'multiline':False]['text':' any range on the vreg.','line_number':444,'multiline':False]['text':' If this register's definition is MUST_REUSE_INPUT, whether a copy must','line_number':447,'multiline':False]['text':' be introduced before the definition that relaxes the policy.','line_number':448,'multiline':False]['text':' A sequence of code positions, for tellings BacktrackingAllocator::splitAt','line_number':507,'multiline':False]['text':' where to split.','line_number':508,'multiline':False]['text':' This flag is set when testing new allocator modifications.','line_number':514,'multiline':False]['text':' Allocation state.','line_number':520,'multiline':False]['text':' Priority queue element: a bundle and the associated priority.','line_number':523,'multiline':False]['text':' Each physical register is associated with the set of ranges over which','line_number':540,'multiline':False]['text':' that register is currently allocated.','line_number':541,'multiline':False]['text':' Ranges of code which are considered to be hot, for which good allocation','line_number':551,'multiline':False]['text':' should be prioritized.','line_number':552,'multiline':False]['text':' Comparator for use in splay tree.','line_number':560,'multiline':False]['text':' Ranges where all registers must be spilled due to call instructions.','line_number':572,'multiline':False]['text':' Information about an allocated stack slot.','line_number':577,'multiline':False]['text':' All allocated slots of each width.','line_number':588,'multiline':False]['text':' Liveness methods.','line_number':621,'multiline':False]['text':' Allocation methods.','line_number':636,'multiline':False]['text':' Reification methods.','line_number':672,'multiline':False]['text':' Debugging methods.','line_number':731,'multiline':False]['text':' Heuristic methods.','line_number':740,'multiline':False]['text':' namespace jit','line_number':766,'multiline':False]['text':' namespace js','line_number':767,'multiline':False]['text':' jit_BacktrackingAllocator_h ','line_number':769,'multiline':True]