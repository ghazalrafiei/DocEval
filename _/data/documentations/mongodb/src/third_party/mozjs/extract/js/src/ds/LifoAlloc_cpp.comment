['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' static ','line_number':28,'multiline':True]['text':' We assume that the alignment of LIFO_ALLOC_ALIGN is less than that of the','line_number':38,'multiline':False]['text':' underlying memory allocator -- creating a new BumpChunk should always','line_number':39,'multiline':False]['text':' satisfy the LIFO_ALLOC_ALIGN alignment constraint.','line_number':40,'multiline':False]['text':' The allocated chunks might not be aligned on page boundaries. This code','line_number':65,'multiline':False]['text':' is used to ensure that we are changing the memory protection of pointers','line_number':66,'multiline':False]['text':' which are within the range of the BumpChunk, or that the range formed by','line_number':67,'multiline':False]['text':' [b .. e] is empty.','line_number':68,'multiline':False]['text':' The allocated chunks might not be aligned on page boundaries. This code','line_number':82,'multiline':False]['text':' is used to ensure that we are changing the memory protection of pointers','line_number':83,'multiline':False]['text':' which are within the range of the BumpChunk, or that the range formed by','line_number':84,'multiline':False]['text':' [b .. e] is empty.','line_number':85,'multiline':False]['text':' namespace detail','line_number':99,'multiline':False]['text':' namespace js','line_number':100,'multiline':False]['text':' When free-ing all chunks, we can no longer determine which chunks were','line_number':122,'multiline':False]['text':' transferred and which were not, so simply clear the heuristic to zero','line_number':123,'multiline':False]['text':' right away.','line_number':124,'multiline':False]['text':' Nb: maintaining curSize_ correctly isn't easy.  Fortunately, this is an','line_number':140,'multiline':False]['text':' excellent sanity check.','line_number':141,'multiline':False]['text':' Round at the same page granularity used by malloc.','line_number':145,'multiline':False]['text':' Heuristic to choose the size of the next BumpChunk for small allocations.','line_number':154,'multiline':False]['text':' `start` is the size of the first chunk. `used` is the total size of all','line_number':155,'multiline':False]['text':' BumpChunks in this LifoAlloc so far.','line_number':156,'multiline':False]['text':' Double the size, up to 1 MB.','line_number':158,'multiline':False]['text':' After 1 MB, grow more gradually, to waste less memory.','line_number':164,'multiline':False]['text':' The sequence (in megabytes) begins:','line_number':165,'multiline':False]['text':' 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, ...','line_number':166,'multiline':False]['text':' Compute the size which should be requested in order to be able to fit |n|','line_number':175,'multiline':False]['text':' bytes in a newly allocated chunk, or default to |defaultChunkSize_|.','line_number':176,'multiline':False]['text':' Note: When computing chunkSize growth, we only are interested in chunks','line_number':184,'multiline':False]['text':' used for small allocations. This excludes unused chunks, oversized chunks,','line_number':185,'multiline':False]['text':' and chunks transferred in from another LifoAlloc.','line_number':186,'multiline':False]['text':' Create a new BumpChunk, and allocate space for it.','line_number':192,'multiline':False]['text':' Look for existing unused BumpChunks to satisfy the request, and pick the','line_number':202,'multiline':False]['text':' first one which is large enough, and move it into the list of used','line_number':203,'multiline':False]['text':' chunks.','line_number':204,'multiline':False]['text':' Allocate a new BumpChunk with enough space for the next allocation.','line_number':224,'multiline':False]['text':' This new chunk is about to be used for small allocations.','line_number':240,'multiline':False]['text':' Since we just created a large enough chunk, this can't fail.','line_number':243,'multiline':False]['text':' Since we just created a large enough chunk, this can't fail.','line_number':258,'multiline':False]['text':' Move the blocks which are after the mark to the set released chunks.','line_number':317,'multiline':False]['text':' Release everything which follows the mark in the last chunk.','line_number':324,'multiline':False]['text':' Release the content of all the blocks which are after the marks, and keep','line_number':330,'multiline':False]['text':' blocks as unused.','line_number':331,'multiline':False]['text':' Chunks moved from (after a mark) in chunks_ to unused_ are no longer','line_number':336,'multiline':False]['text':' considered small allocations.','line_number':337,'multiline':False]['text':' Free the content of all the blocks which are after the marks.','line_number':342,'multiline':False]['text':' Copy everything from |other| to |this| except for |peakSize_|, which','line_number':356,'multiline':False]['text':' requires some care.','line_number':357,'multiline':False]['text':' Transferred chunks are not counted as part of |smallAllocsSize| as this','line_number':378,'multiline':False]['text':' could introduce bias in the |NextSize| heuristics, leading to','line_number':379,'multiline':False]['text':' over-allocations in *this* LifoAlloc. As well, to avoid interference with','line_number':380,'multiline':False]['text':' small allocations made with |this|, the last chunk of the |chunks_| list','line_number':381,'multiline':False]['text':' should remain the last chunk. Therefore, the transferred chunks are','line_number':382,'multiline':False]['text':' prepended to the |chunks_| list.','line_number':383,'multiline':False]