['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' MOZ_ASSERT','line_number':10,'multiline':False]['text':' size_t','line_number':12,'multiline':False]['text':' uint8_t, uint32_t','line_number':13,'multiline':False]['text':' js::jit::Bailout{Id,Kind}, js::jit::SnapshotOffset','line_number':17,'multiline':False]['text':' js::jit::MachineState','line_number':18,'multiline':False]['text':' jsbytecode','line_number':19,'multiline':False]['text':' [SMDOC] IonMonkey Bailouts','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' A "bailout" is the process of recovering a baseline interpreter frame from an','line_number':29,'multiline':False]['text':' IonFrame.  Bailouts are implemented in js::jit::BailoutIonToBaseline, which','line_number':30,'multiline':False]['text':' has the following callers:','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' *   js::jit::Bailout - This is used when a guard fails in the Ion code','line_number':33,'multiline':False]['text':'     itself; for example, an LGuardShape fails or an LAddI overflows. See','line_number':34,'multiline':False]['text':'     callers of CodeGenerator::bailoutFrom() for more examples.','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':' * js::jit::ExceptionHandlerBailout - Ion doesn't implement `catch` or','line_number':37,'multiline':False]['text':'     `finally`. If an exception is thrown and would be caught by an Ion frame,','line_number':38,'multiline':False]['text':'     we bail out instead.','line_number':39,'multiline':False]['text':'','line_number':40,'multiline':False]['text':' *   js::jit::InvalidationBailout - We returned to Ion code that was','line_number':41,'multiline':False]['text':'     invalidated while it was on the stack. See "OSI" below. Ion code can be','line_number':42,'multiline':False]['text':'     invalidated for several reasons: when GC evicts Ion code to save memory,','line_number':43,'multiline':False]['text':'     for example, or when assumptions baked into the jitted code are','line_number':44,'multiline':False]['text':'     invalidated by the VM.','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' (Some stack inspection can be done without bailing out, including GC stack','line_number':47,'multiline':False]['text':' marking, Error object construction, and Gecko profiler sampling.)','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':' Consider the first case. When an Ion guard fails, we can't continue in','line_number':50,'multiline':False]['text':' Ion. There's no IC fallback case coming to save us; we've got a broken','line_number':51,'multiline':False]['text':' assumption baked into the code we're running. So we jump to an out-of-line','line_number':52,'multiline':False]['text':' code path that's responsible for abandoning Ion execution and resuming in','line_number':53,'multiline':False]['text':' the baseline interpreter: the bailout path.','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' We were in the midst of optimized Ion code, so bits of program state may be','line_number':56,'multiline':False]['text':' in registers or spilled to the native stack; values may be unboxed; some','line_number':57,'multiline':False]['text':' objects may have been optimized away; thanks to inlining, whole call frames','line_number':58,'multiline':False]['text':' may be missing. The bailout path must put all these pieces back together','line_number':59,'multiline':False]['text':' into the structure the baseline interpreter expects.','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' The data structure that makes this possible is called a *snapshot*.','line_number':62,'multiline':False]['text':' Snapshots are created during Ion codegen and associated with the IonScript;','line_number':63,'multiline':False]['text':' they tell how to recover each value in a BaselineFrame from the current','line_number':64,'multiline':False]['text':' machine state at a given point in the Ion JIT code. This is potentially','line_number':65,'multiline':False]['text':' different at every place in an Ion script where we might bail out. (See','line_number':66,'multiline':False]['text':' Snapshots.h.)','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':' The bailout path performs roughly the following steps:','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' 1.  Push a snapshot index and the frame size to the native stack.','line_number':71,'multiline':False]['text':' 2.  Spill all registers.','line_number':72,'multiline':False]['text':' 3.  Call js::jit::Bailout to reconstruct the baseline frame(s).','line_number':73,'multiline':False]['text':' 4.  memmove() those to the right place on the native stack.','line_number':74,'multiline':False]['text':' 5.  Jump into the baseline interpreter.','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' When C++ code invalidates Ion code, we do on-stack invalidation, or OSI, to','line_number':77,'multiline':False]['text':' arrange for every affected Ion frame on the stack to bail out as soon as','line_number':78,'multiline':False]['text':' control returns to it. OSI patches every instruction in the JIT code that's','line_number':79,'multiline':False]['text':' at a return address currently on the stack. See InvalidateActivation.','line_number':80,'multiline':False]['text':'','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':' ## Bailout path implementation details','line_number':83,'multiline':False]['text':'','line_number':84,'multiline':False]['text':' Ion code has a lot of guards, so each bailout path must be small. Steps 2','line_number':85,'multiline':False]['text':' and 3 above are therefore implemented by a shared per-Runtime trampoline,','line_number':86,'multiline':False]['text':' rt->jitRuntime()->getGenericBailoutHandler().','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' Naively, we could implement step 1 like:','line_number':89,'multiline':False]['text':'','line_number':90,'multiline':False]['text':'     _bailout_ID_1:','line_number':91,'multiline':False]['text':'       push 1','line_number':92,'multiline':False]['text':'       jmp _deopt','line_number':93,'multiline':False]['text':'     _bailout_ID_2:','line_number':94,'multiline':False]['text':'       push 2','line_number':95,'multiline':False]['text':'       jmp _deopt','line_number':96,'multiline':False]['text':'     ...','line_number':97,'multiline':False]['text':'     _deopt:','line_number':98,'multiline':False]['text':'       push imm(FrameSize)','line_number':99,'multiline':False]['text':'       call _global_bailout_handler','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':' This takes about 10 extra bytes per guard. On some platforms, we can reduce','line_number':102,'multiline':False]['text':' this overhead to 4 bytes by creating a global jump table, shared again in','line_number':103,'multiline':False]['text':' the compartment:','line_number':104,'multiline':False]['text':'','line_number':105,'multiline':False]['text':'       call _global_bailout_handler','line_number':106,'multiline':False]['text':'       call _global_bailout_handler','line_number':107,'multiline':False]['text':'       call _global_bailout_handler','line_number':108,'multiline':False]['text':'       call _global_bailout_handler','line_number':109,'multiline':False]['text':'       ...','line_number':110,'multiline':False]['text':'     _global_bailout_handler:','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':' In the bailout handler, we can recompute which entry in the table was','line_number':113,'multiline':False]['text':' selected by subtracting the return addressed pushed by the call, from the','line_number':114,'multiline':False]['text':' start of the table, and then dividing by the size of a (call X) entry in the','line_number':115,'multiline':False]['text':' table. This gives us a number in [0, TableSize), which we call a','line_number':116,'multiline':False]['text':' "BailoutId".','line_number':117,'multiline':False]['text':'','line_number':118,'multiline':False]['text':' Then, we can provide a per-script mapping from BailoutIds to snapshots,','line_number':119,'multiline':False]['text':' which takes only four bytes per entry.','line_number':120,'multiline':False]['text':'','line_number':121,'multiline':False]['text':' This strategy does not work as given, because the bailout handler has no way','line_number':122,'multiline':False]['text':' to compute the location of an IonScript. Currently, we do not use frame','line_number':123,'multiline':False]['text':' pointers. To account for this we segregate frames into a limited set of','line_number':124,'multiline':False]['text':' "frame sizes", and create a table for each frame size. We also have the','line_number':125,'multiline':False]['text':' option of not using bailout tables, for platforms or situations where the','line_number':126,'multiline':False]['text':' 10 byte cost is more optimal than a bailout table. See JitFrames.h for more','line_number':127,'multiline':False]['text':' detail.','line_number':128,'multiline':False]['text':' Keep this arbitrarily small for now, for testing.','line_number':132,'multiline':False]['text':' BailoutStack is an architecture specific pointer to the stack, given by the','line_number':135,'multiline':False]['text':' bailout handler.','line_number':136,'multiline':False]['text':' Must be implemented by each architecture.','line_number':147,'multiline':False]['text':' This structure is constructed before recovering the baseline frames for a','line_number':149,'multiline':False]['text':' bailout. It records all information extracted from the stack, and which are','line_number':150,'multiline':False]['text':' needed for the JSJitFrameIter.','line_number':151,'multiline':False]['text':' Called from a bailout thunk.','line_number':183,'multiline':False]['text':' Called from the invalidation thunk.','line_number':186,'multiline':False]['text':' Called from the exception handler to enter a catch or finally block.','line_number':220,'multiline':False]['text':' namespace jit','line_number':228,'multiline':False]['text':' namespace js','line_number':229,'multiline':False]['text':' jit_Bailouts_h ','line_number':231,'multiline':True]