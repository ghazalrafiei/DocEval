['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':25,'multiline':False]['text':' [SMDOC] IonMonkey Range Analysis','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' This algorithm is based on the paper "Eliminating Range Checks Using','line_number':51,'multiline':False]['text':' Static Single Assignment Form" by Gough and Klaren.','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':' We associate a range object with each SSA name, and the ranges are consulted','line_number':54,'multiline':False]['text':' in order to determine whether overflow is possible for arithmetic','line_number':55,'multiline':False]['text':' computations.','line_number':56,'multiline':False]['text':'','line_number':57,'multiline':False]['text':' An important source of range information that requires care to take','line_number':58,'multiline':False]['text':' advantage of is conditional control flow. Consider the code below:','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':' if (x < 0) {','line_number':61,'multiline':False]['text':'   y = x + 2000000000;','line_number':62,'multiline':False]['text':' } else {','line_number':63,'multiline':False]['text':'   if (x < 1000000000) {','line_number':64,'multiline':False]['text':'     y = x * 2;','line_number':65,'multiline':False]['text':'   } else {','line_number':66,'multiline':False]['text':'     y = x - 3000000000;','line_number':67,'multiline':False]['text':'   }','line_number':68,'multiline':False]['text':' }','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' The arithmetic operations in this code cannot overflow, but it is not','line_number':71,'multiline':False]['text':' sufficient to simply associate each name with a range, since the information','line_number':72,'multiline':False]['text':' differs between basic blocks. The traditional dataflow approach would be','line_number':73,'multiline':False]['text':' associate ranges with (name, basic block) pairs. This solution is not','line_number':74,'multiline':False]['text':' satisfying, since we lose the benefit of SSA form: in SSA form, each','line_number':75,'multiline':False]['text':' definition has a unique name, so there is no need to track information about','line_number':76,'multiline':False]['text':' the control flow of the program.','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':' The approach used here is to add a new form of pseudo operation called a','line_number':79,'multiline':False]['text':' beta node, which associates range information with a value. These beta','line_number':80,'multiline':False]['text':' instructions take one argument and additionally have an auxiliary constant','line_number':81,'multiline':False]['text':' range associated with them. Operationally, beta nodes are just copies, but','line_number':82,'multiline':False]['text':' the invariant expressed by beta node copies is that the output will fall','line_number':83,'multiline':False]['text':' inside the range given by the beta node.  Gough and Klaeren refer to SSA','line_number':84,'multiline':False]['text':' extended with these beta nodes as XSA form. The following shows the example','line_number':85,'multiline':False]['text':' code transformed into XSA form:','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' if (x < 0) {','line_number':88,'multiline':False]['text':'   x1 = Beta(x, [INT_MIN, -1]);','line_number':89,'multiline':False]['text':'   y1 = x1 + 2000000000;','line_number':90,'multiline':False]['text':' } else {','line_number':91,'multiline':False]['text':'   x2 = Beta(x, [0, INT_MAX]);','line_number':92,'multiline':False]['text':'   if (x2 < 1000000000) {','line_number':93,'multiline':False]['text':'     x3 = Beta(x2, [INT_MIN, 999999999]);','line_number':94,'multiline':False]['text':'     y2 = x3*2;','line_number':95,'multiline':False]['text':'   } else {','line_number':96,'multiline':False]['text':'     x4 = Beta(x2, [1000000000, INT_MAX]);','line_number':97,'multiline':False]['text':'     y3 = x4 - 3000000000;','line_number':98,'multiline':False]['text':'   }','line_number':99,'multiline':False]['text':'   y4 = Phi(y2, y3);','line_number':100,'multiline':False]['text':' }','line_number':101,'multiline':False]['text':' y = Phi(y1, y4);','line_number':102,'multiline':False]['text':'','line_number':103,'multiline':False]['text':' We insert beta nodes for the purposes of range analysis (they might also be','line_number':104,'multiline':False]['text':' usefully used for other forms of bounds check elimination) and remove them','line_number':105,'multiline':False]['text':' after range analysis is performed. The remaining compiler phases do not ever','line_number':106,'multiline':False]['text':' encounter beta nodes.','line_number':107,'multiline':False]['text':' TODO: support unsigned comparisons','line_number':202,'multiline':False]['text':' isNumericComparison should return false for UIntPtr.','line_number':207,'multiline':False]['text':' At this point, one of the operands if the compare is a constant, and','line_number':271,'multiline':False]['text':' val is the other operand.','line_number':272,'multiline':False]['text':' For integers, if x < c, the upper bound of x is c-1.','line_number':281,'multiline':False]['text':' Negative zero is not less than zero.','line_number':291,'multiline':False]['text':' For integers, if x > c, the lower bound of x is c+1.','line_number':300,'multiline':False]['text':' Negative zero is not greater than zero.','line_number':310,'multiline':False]['text':' A strict comparison can test for things other than numeric value.','line_number':316,'multiline':False]['text':' Otherwise fall through to handle JSOp::StrictEq the same as JSOp::Eq.','line_number':320,'multiline':False]['text':' A strict comparison can test for things other than numeric value.','line_number':326,'multiline':False]['text':' Otherwise fall through to handle JSOp::StrictNe the same as JSOp::Ne.','line_number':330,'multiline':False]['text':' Negative zero is not not-equal to zero.','line_number':333,'multiline':False]['text':' well, we could have','line_number':338,'multiline':False]['text':' [-\inf, bound-1] U [bound+1, \inf] but we only use','line_number':339,'multiline':False]['text':' contiguous ranges.','line_number':340,'multiline':False]['text':' We only place Beta nodes at the beginning of basic','line_number':379,'multiline':False]['text':' blocks, so if we see something else, we can move on','line_number':380,'multiline':False]['text':' to the next block.','line_number':381,'multiline':False]['text':' Test whether the given range's exponent tells us anything that its lower','line_number':403,'multiline':False]['text':' and upper bound values don't.','line_number':404,'multiline':False]['text':' If it lacks either a lower or upper bound, the exponent is interesting.','line_number':406,'multiline':False]['text':' Otherwise if there's no fractional part, the lower and upper bounds,','line_number':411,'multiline':False]['text':' which are integers, are perfectly precise.','line_number':412,'multiline':False]['text':' Otherwise, if the bounds are conservatively rounded across a power-of-two','line_number':417,'multiline':False]['text':' boundary, the exponent may imply a tighter range.','line_number':418,'multiline':False]['text':' Floating-point or Integer subset.','line_number':425,'multiline':False]['text':' If upper < lower, then we have conflicting constraints. Consider:','line_number':535,'multiline':False]['text':'','line_number':536,'multiline':False]['text':' if (x < 0) {','line_number':537,'multiline':False]['text':'   if (x > 0) {','line_number':538,'multiline':False]['text':'     [Some code.]','line_number':539,'multiline':False]['text':'   }','line_number':540,'multiline':False]['text':' }','line_number':541,'multiline':False]['text':'','line_number':542,'multiline':False]['text':' In this case, the block is unreachable.','line_number':543,'multiline':False]['text':' If both ranges can be NaN, the result can still be NaN.','line_number':545,'multiline':False]['text':' NaN is a special value which is neither greater than infinity or less than','line_number':564,'multiline':False]['text':' negative infinity. When we intersect two ranges like [?, 0] and [0, ?], we','line_number':565,'multiline':False]['text':' can end up thinking we have both a lower and upper bound, even though NaN','line_number':566,'multiline':False]['text':' is still possible. In this case, just be conservative, since any case where','line_number':567,'multiline':False]['text':' we can have NaN is not especially interesting.','line_number':568,'multiline':False]['text':' If one of the ranges has a fractional part and the other doesn't, it's','line_number':574,'multiline':False]['text':' possible that we will have computed a newExponent that's more precise','line_number':575,'multiline':False]['text':' than our newLower and newUpper. This is unusual, so we handle it here','line_number':576,'multiline':False]['text':' instead of in optimize().','line_number':577,'multiline':False]['text':'','line_number':578,'multiline':False]['text':' For example, consider the range F[0,1.5]. Range analysis represents the','line_number':579,'multiline':False]['text':' lower and upper bound as integers, so we'd actually have','line_number':580,'multiline':False]['text':' F[0,2] (< pow(2, 0+1)). In this case, the exponent gives us a slightly','line_number':581,'multiline':False]['text':' more precise upper bound than the integer upper bound.','line_number':582,'multiline':False]['text':'','line_number':583,'multiline':False]['text':' When intersecting such a range with an integer range, the fractional part','line_number':584,'multiline':False]['text':' of the range is dropped. The max exponent of 0 remains valid, so the','line_number':585,'multiline':False]['text':' upper bound needs to be adjusted to 1.','line_number':586,'multiline':False]['text':'','line_number':587,'multiline':False]['text':' When intersecting F[0,2] (< pow(2, 0+1)) with a range like F[2,4],','line_number':588,'multiline':False]['text':' the naive intersection is I[2,2], but since the max exponent tells us','line_number':589,'multiline':False]['text':' that the value is always less than 2, the intersection is actually empty.','line_number':590,'multiline':False]['text':' If we're intersecting two ranges that don't overlap, this could also','line_number':597,'multiline':False]['text':' push the bounds past each other, since the actual intersection is','line_number':598,'multiline':False]['text':' the empty set.','line_number':599,'multiline':False]['text':' The instruction has range information; use it.','line_number':635,'multiline':False]['text':' Simulate the effect of converting the value to its type.','line_number':638,'multiline':False]['text':' Note: we cannot clamp here, since ranges aren't allowed to shrink','line_number':639,'multiline':False]['text':' and truncation can increase range again. So doing wrapAround to','line_number':640,'multiline':False]['text':' mimick a possible truncation.','line_number':641,'multiline':False]['text':' MToNumberInt32 cannot truncate. So we can safely clamp.','line_number':644,'multiline':False]['text':' Otherwise just use type information. We can trust the type here','line_number':660,'multiline':False]['text':' because we don't care what value the instruction actually produces,','line_number':661,'multiline':False]['text':' but what value we might get after we get past the bailouts.','line_number':662,'multiline':False]['text':' As a special case, MUrsh is permitted to claim a result type of','line_number':678,'multiline':False]['text':' MIRType::Int32 while actually returning values in [0,UINT32_MAX] without','line_number':679,'multiline':False]['text':' bailouts. If range analysis hasn't ruled out values in','line_number':680,'multiline':False]['text':' (INT32_MAX,UINT32_MAX], set the range to be conservatively correct for','line_number':681,'multiline':False]['text':' use as either a uint32 or an int32.','line_number':682,'multiline':False]['text':' Handle the special values.','line_number':692,'multiline':False]['text':' Otherwise take the exponent part and clamp it at zero, since the Range','line_number':700,'multiline':False]['text':' class doesn't track fractional ranges.','line_number':701,'multiline':False]['text':' Infer lower_, upper_, hasInt32LowerBound_, and hasInt32UpperBound_.','line_number':708,'multiline':False]['text':' Infer max_exponent_.','line_number':730,'multiline':False]['text':' Infer the canHaveFractionalPart_ setting. We can have a','line_number':738,'multiline':False]['text':' fractional part if the range crosses through the neighborhood of zero. We','line_number':739,'multiline':False]['text':' won't have a fractional value if the value is always beyond the point at','line_number':740,'multiline':False]['text':' which double precision can't represent fractional values.','line_number':741,'multiline':False]['text':' Infer the canBeNegativeZero_ setting. We can have a negative zero if','line_number':750,'multiline':False]['text':' either bound is zero.','line_number':751,'multiline':False]['text':' The above setDouble call is for comparisons, and treats negative zero','line_number':762,'multiline':False]['text':' as equal to zero. We're aiming for a minimum range, so we can clear the','line_number':763,'multiline':False]['text':' negative zero flag if the value isn't actually negative zero.','line_number':764,'multiline':False]['text':' The exponent is at most one greater than the greater of the operands'','line_number':787,'multiline':False]['text':' exponents, except for NaN and infinity cases.','line_number':788,'multiline':False]['text':' Infinity + -Infinity is NaN.','line_number':794,'multiline':False]['text':' The exponent is at most one greater than the greater of the operands'','line_number':818,'multiline':False]['text':' exponents, except for NaN and infinity cases.','line_number':819,'multiline':False]['text':' Infinity - Infinity is NaN.','line_number':825,'multiline':False]['text':' If both numbers can be negative, result can be negative in the whole range','line_number':841,'multiline':False]['text':' Only one of both numbers can be negative.','line_number':847,'multiline':False]['text':' - result can't be negative','line_number':848,'multiline':False]['text':' - Upper bound is minimum of both upper range,','line_number':849,'multiline':False]['text':' EXCEPT when upper bound of non negative number is max value,','line_number':853,'multiline':False]['text':' because negative value can return the whole max value.','line_number':854,'multiline':False]['text':' -1 & 5 = 5','line_number':855,'multiline':False]['text':' When one operand is always 0 or always -1, it's a special case where we','line_number':869,'multiline':False]['text':' can compute a fully precise result. Handling these up front also','line_number':870,'multiline':False]['text':' protects the code below from calling CountLeadingZeroes32 with a zero','line_number':871,'multiline':False]['text':' operand or from shifting an int32_t by 32.','line_number':872,'multiline':False]['text':' The code below uses CountLeadingZeroes32, which has undefined behavior','line_number':890,'multiline':False]['text':' if its operand is 0. We rely on the code above to protect it.','line_number':891,'multiline':False]['text':' Both operands are non-negative, so the result won't be less than either.','line_number':901,'multiline':False]['text':' The result will have leading zeros where both operands have leading','line_number':903,'multiline':False]['text':' zeros. CountLeadingZeroes32 of a non-negative int32 will at least be 1 to','line_number':904,'multiline':False]['text':' account for the bit of sign.','line_number':905,'multiline':False]['text':' The result will have leading ones where either operand has leading ones.','line_number':909,'multiline':False]['text':' If either operand is negative, bitwise-negate it, and arrange to negate','line_number':934,'multiline':False]['text':' the result; ~((~x)^y) == x^y. If both are negative the negations on the','line_number':935,'multiline':False]['text':' result cancel each other out; effectively this is (~x)^(~y) == x^y.','line_number':936,'multiline':False]['text':' These transformations reduce the number of cases we have to handle below.','line_number':937,'multiline':False]['text':' Handle cases where lhs or rhs is always zero specially, because they're','line_number':951,'multiline':False]['text':' easy cases where we can be perfectly precise, and because it protects the','line_number':952,'multiline':False]['text':' CountLeadingZeroes32 calls below from seeing 0 operands, which would be','line_number':953,'multiline':False]['text':' undefined behavior.','line_number':954,'multiline':False]['text':' Both operands are non-negative. The result will be non-negative.','line_number':964,'multiline':False]['text':' To compute the upper value, take each operand's upper value and','line_number':966,'multiline':False]['text':' set all bits that don't correspond to leading zero bits in the','line_number':967,'multiline':False]['text':' other to one. For each one, this gives an upper bound for the','line_number':968,'multiline':False]['text':' result, so we can take the minimum between the two.','line_number':969,'multiline':False]['text':' If we bitwise-negated one (but not both) of the operands above, apply the','line_number':976,'multiline':False]['text':' bitwise-negate to the result, completing ~((~x)^y) == x^y.','line_number':977,'multiline':False]['text':' Two finite values.','line_number':1002,'multiline':False]['text':' Two values that multiplied together won't produce a NaN.','line_number':1010,'multiline':False]['text':' Could be anything.','line_number':1013,'multiline':False]['text':' If the shift doesn't loose bits or shift bits into the sign bit, we','line_number':1036,'multiline':False]['text':' can simply compute the correct range by shifting.','line_number':1037,'multiline':False]['text':' ursh's left operand is uint32, not int32, but for range analysis we','line_number':1057,'multiline':False]['text':' currently approximate it as int32. We assume here that the range has','line_number':1058,'multiline':False]['text':' already been adjusted accordingly by our callers.','line_number':1059,'multiline':False]['text':' If the value is always non-negative or always negative, we can simply','line_number':1064,'multiline':False]['text':' compute the correct range by shifting.','line_number':1065,'multiline':False]['text':' Otherwise return the most general range after the shift.','line_number':1071,'multiline':False]['text':' Canonicalize the shift range to 0 to 31.','line_number':1085,'multiline':False]['text':' The lhs bounds are signed, thus the minimum is either the lower bound','line_number':1101,'multiline':False]['text':' shift by the smallest shift if negative or the lower bound shifted by the','line_number':1102,'multiline':False]['text':' biggest shift otherwise.  And the opposite for the maximum.','line_number':1103,'multiline':False]['text':' ursh's left operand is uint32, not int32, but for range analysis we','line_number':1113,'multiline':False]['text':' currently approximate it as int32. We assume here that the range has','line_number':1114,'multiline':False]['text':' already been adjusted accordingly by our callers.','line_number':1115,'multiline':False]['text':' Abs never produces a negative zero.','line_number':1127,'multiline':False]['text':' If either operand is NaN, the result is NaN.','line_number':1138,'multiline':False]['text':' If either operand is NaN, the result is NaN.','line_number':1157,'multiline':False]['text':' Decrement lower bound of copy range if op have a factional part and lower','line_number':1177,'multiline':False]['text':' bound is Int32 defined. Also we avoid to decrement when op have a','line_number':1178,'multiline':False]['text':' fractional part but lower_ >= JSVAL_INT_MAX.','line_number':1179,'multiline':False]['text':' Also refine max_exponent_ because floor may have decremented int value','line_number':1184,'multiline':False]['text':' If we've got int32 defined bounds, just deduce it using defined bounds.','line_number':1185,'multiline':False]['text':' But, if we don't have those, value's max_exponent_ may have changed.','line_number':1186,'multiline':False]['text':' Because we're looking to maintain an over estimation, if we can,','line_number':1187,'multiline':False]['text':' we increment it.','line_number':1188,'multiline':False]['text':' We need to refine max_exponent_ because ceil may have incremented the int','line_number':1202,'multiline':False]['text':' value. If we have got int32 bounds defined, just deduce it using the','line_number':1203,'multiline':False]['text':' defined bounds. Else we can just increment its value, as we are looking to','line_number':1204,'multiline':False]['text':' maintain an over estimation.','line_number':1205,'multiline':False]['text':' If the range is definitely above 0 or below -1, we don't need to include','line_number':1212,'multiline':False]['text':' -0; otherwise we do.','line_number':1213,'multiline':False]['text':' The result can only be negative zero if both sides are finite and they','line_number':1254,'multiline':False]['text':' have differing signs.','line_number':1255,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1282,'multiline':False]['text':' Range Computation for MIR Nodes','line_number':1283,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1284,'multiline':False]['text':' Peek at the pre-bailout range so we can take a short-cut; if any of','line_number':1299,'multiline':False]['text':' the operands has an unknown range, this phi has an unknown range.','line_number':1300,'multiline':False]['text':' ECMA 262 says that the integer will be non-negative and at most 65535.','line_number':1341,'multiline':False]['text':' ursh can be thought of as converting its left operand to uint32, or it','line_number':1445,'multiline':False]['text':' can be thought of as converting its left operand to int32, and then','line_number':1446,'multiline':False]['text':' reinterpreting the int32 bits as a uint32 value. Both approaches yield','line_number':1447,'multiline':False]['text':' the same result. Since we lack support for full uint32 ranges, we use','line_number':1448,'multiline':False]['text':' the second interpretation, though it does cause us to be conservative.','line_number':1449,'multiline':False]['text':' Truncated multiplications could overflow in both directions','line_number':1558,'multiline':False]['text':' If either operand is a NaN, the result is NaN. This also conservatively','line_number':1572,'multiline':False]['text':' handles Infinity cases.','line_number':1573,'multiline':False]['text':' If RHS can be zero, the result can be NaN.','line_number':1578,'multiline':False]['text':' If both operands are non-negative integers, we can optimize this to an','line_number':1583,'multiline':False]['text':' unsigned mod.','line_number':1584,'multiline':False]['text':' It is not possible to check that lhs.lower() >= 0, since the range','line_number':1588,'multiline':False]['text':' of a ursh with rhs a 0 constant is wrapped around the int32 range in','line_number':1589,'multiline':False]['text':' Range::Range(). However, IsUint32Type() will only return true for','line_number':1590,'multiline':False]['text':' nodes that lie in the range [0, UINT32_MAX].','line_number':1591,'multiline':False]['text':' For unsigned mod, we have to convert both operands to unsigned.','line_number':1601,'multiline':False]['text':' Note that we handled the case of a zero rhs above.','line_number':1602,'multiline':False]['text':' The result of an unsigned mod will never be unsigned-greater than','line_number':1604,'multiline':False]['text':' either operand.','line_number':1605,'multiline':False]['text':' If either range crosses through -1 as a signed value, it could be','line_number':1609,'multiline':False]['text':' the maximum unsigned value when interpreted as unsigned. If the range','line_number':1610,'multiline':False]['text':' doesn't include -1, then the simple max value we computed above is','line_number':1611,'multiline':False]['text':' correct.','line_number':1612,'multiline':False]['text':' The result will never be equal to the rhs, and we shouldn't have','line_number':1620,'multiline':False]['text':' any rounding to worry about.','line_number':1621,'multiline':False]['text':' This gives us two upper bounds, so we can take the best one.','line_number':1625,'multiline':False]['text':' Math.abs(lhs % rhs) == Math.abs(lhs) % Math.abs(rhs).','line_number':1630,'multiline':False]['text':' First, the absolute value of the result will always be less than the','line_number':1631,'multiline':False]['text':' absolute value of rhs. (And if rhs is zero, the result is NaN).','line_number':1632,'multiline':False]['text':' If the value is known to be integer, less-than abs(rhs) is equivalent','line_number':1640,'multiline':False]['text':' to less-than-or-equal abs(rhs)-1. This is important for being able to','line_number':1641,'multiline':False]['text':' say that the result of x%256 is an 8-bit unsigned number.','line_number':1642,'multiline':False]['text':' Next, the absolute value of the result will never be greater than the','line_number':1647,'multiline':False]['text':' absolute value of lhs.','line_number':1648,'multiline':False]['text':' This gives us two upper bounds, so we can take the best one.','line_number':1652,'multiline':False]['text':' Now consider the sign of the result.','line_number':1655,'multiline':False]['text':' If lhs is non-negative, the result will be non-negative.','line_number':1656,'multiline':False]['text':' If lhs is non-positive, the result will be non-positive.','line_number':1657,'multiline':False]['text':' If the lhs can have the sign bit set and we can return a zero, it'll be a','line_number':1665,'multiline':False]['text':' negative zero.','line_number':1666,'multiline':False]['text':' If either operand is a NaN, the result is NaN. This also conservatively','line_number':1682,'multiline':False]['text':' handles Infinity cases.','line_number':1683,'multiline':False]['text':' Something simple for now: When dividing by a positive rhs, the result','line_number':1688,'multiline':False]['text':' won't be further from zero than lhs.','line_number':1689,'multiline':False]['text':' We shouldn't set the unsigned flag if the inputs can have','line_number':1694,'multiline':False]['text':' fractional parts.','line_number':1695,'multiline':False]['text':' We shouldn't set the unsigned flag if the inputs can be','line_number':1697,'multiline':False]['text':' negative zero.','line_number':1698,'multiline':False]['text':' Unsigned division by a non-zero rhs will return a uint32 value.','line_number':1700,'multiline':False]['text':' If either operand is a NaN, the result is NaN. This also conservatively','line_number':1708,'multiline':False]['text':' handles Infinity cases.','line_number':1709,'multiline':False]['text':' Sqrt of a negative non-zero value is NaN.','line_number':1714,'multiline':False]['text':' Something simple for now: When taking the sqrt of a positive value, the','line_number':1719,'multiline':False]['text':' result won't be further from zero than the input.','line_number':1720,'multiline':False]['text':' And, sqrt of an integer may have a fractional part.','line_number':1721,'multiline':False]['text':' No clamping since this computes the range *before* bailouts.','line_number':1739,'multiline':False]['text':' We have an Int32 type and if this is a UInt32 load it may produce a value','line_number':1783,'multiline':False]['text':' outside of our range, but we have a bailout to handle those cases.','line_number':1784,'multiline':False]['text':' We have an Int32 type and if this is a UInt32 load it may produce a value','line_number':1789,'multiline':False]['text':' outside of our range, but we have a bailout to handle those cases.','line_number':1790,'multiline':False]['text':' Array lengths can go up to UINT32_MAX. We will bail out if the array','line_number':1795,'multiline':False]['text':' length > INT32_MAX.','line_number':1796,'multiline':False]['text':' This is is a conservative upper bound on what |TooManyActualArguments|','line_number':1837,'multiline':False]['text':' checks.  If exceeded, Ion will not be entered in the first place.','line_number':1838,'multiline':False]['text':' Just transfer the incoming index range to the output. The length() is','line_number':1845,'multiline':False]['text':' also interesting, but it is handled as a bailout check, and we're','line_number':1846,'multiline':False]['text':' computing a pre-bailout range here.','line_number':1847,'multiline':False]['text':' Just transfer the incoming index range to the output for now.','line_number':1852,'multiline':False]['text':' We will bail out if the IntPtr value > INT32_MAX.','line_number':1861,'multiline':False]['text':' MArrayPush returns the new array length. It bails out if the new length','line_number':1866,'multiline':False]['text':' doesn't fit in an Int32.','line_number':1867,'multiline':False]['text':' Random never returns negative zero.','line_number':1894,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1905,'multiline':False]['text':' Range Analysis','line_number':1906,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1907,'multiline':False]['text':' Try to compute an upper bound on the number of times the loop backedge','line_number':1912,'multiline':False]['text':' will be taken. Look for tests that dominate the backedge and which have','line_number':1913,'multiline':False]['text':' an edge leaving the loop body.','line_number':1914,'multiline':False]['text':' Ignore trivial infinite loops.','line_number':1917,'multiline':False]['text':' Ignore broken loops.','line_number':1925,'multiline':False]['text':' Try to compute symbolic bounds for the phi nodes at the head of this','line_number':1979,'multiline':False]['text':' loop, expressed in terms of the iteration bound just computed.','line_number':1980,'multiline':False]['text':' Try to hoist any bounds checks from the loop using symbolic bounds.','line_number':1988,'multiline':False]['text':' Note: replace all uses of the original bounds check with the','line_number':2014,'multiline':False]['text':' actual index. This is usually done during bounds check elimination,','line_number':2015,'multiline':False]['text':' but in this case it's safe to do it here since the load/store is','line_number':2016,'multiline':False]['text':' definitely not loop-invariant, so we will never move it before','line_number':2017,'multiline':False]['text':' one of the bounds checks we just added.','line_number':2018,'multiline':False]['text':' Unbox beta nodes in order to hoist instruction properly, and not be limited','line_number':2030,'multiline':False]['text':' by the beta nodes which are added after each branch.','line_number':2031,'multiline':False]['text':' Ensure the rhs is a loop invariant term.','line_number':2048,'multiline':False]['text':' Ensure the lhs is a phi node from the start of the loop body.','line_number':2064,'multiline':False]['text':' Check that the value of the lhs changes by a constant amount with each','line_number':2069,'multiline':False]['text':' loop iteration. This requires that the lhs be written in every loop','line_number':2070,'multiline':False]['text':' iteration with a value that is a constant difference from its value at','line_number':2071,'multiline':False]['text':' the start of the iteration.','line_number':2072,'multiline':False]['text':' The first operand of the phi should be the lhs' value at the start of','line_number':2078,'multiline':False]['text':' the first executed iteration, and not a value written which could','line_number':2079,'multiline':False]['text':' replace the second operand below during the middle of execution.','line_number':2080,'multiline':False]['text':' The second operand of the phi should be a value written by an add/sub','line_number':2086,'multiline':False]['text':' in every loop iteration, i.e. in a block which dominates the backedge.','line_number':2087,'multiline':False]['text':' Check that the value of the lhs at the backedge is of the form','line_number':2106,'multiline':False]['text':' 'old(lhs) + N'. We can be sure that old(lhs) is the value at the start','line_number':2107,'multiline':False]['text':' of the iteration, and not that written to lhs in a previous iteration,','line_number':2108,'multiline':False]['text':' as such a previous value could not appear directly in the addition:','line_number':2109,'multiline':False]['text':' it could not be stored in lhs as the lhs add/sub executes in every','line_number':2110,'multiline':False]['text':' iteration, and if it were stored in another variable its use here would','line_number':2111,'multiline':False]['text':' be as an operand to a phi node for that variable.','line_number':2112,'multiline':False]['text':' The value of lhs is 'initial(lhs) + iterCount' and this will end','line_number':2121,'multiline':False]['text':' execution of the loop if 'lhs + lhsN >= rhs'. Thus, an upper bound','line_number':2122,'multiline':False]['text':' on the number of backedges executed is:','line_number':2123,'multiline':False]['text':'','line_number':2124,'multiline':False]['text':' initial(lhs) + iterCount + lhsN == rhs','line_number':2125,'multiline':False]['text':' iterCount == rhsN - initial(lhs) - lhsN','line_number':2126,'multiline':False]['text':' The value of lhs is 'initial(lhs) - iterCount'. Similar to the above','line_number':2152,'multiline':False]['text':' case, an upper bound on the number of backedges executed is:','line_number':2153,'multiline':False]['text':'','line_number':2154,'multiline':False]['text':' initial(lhs) - iterCount + lhsN == rhs','line_number':2155,'multiline':False]['text':' iterCount == initial(lhs) - rhs + lhsN','line_number':2156,'multiline':False]['text':' Given a bound on the number of backedges taken, compute an upper and','line_number':2185,'multiline':False]['text':' lower bound for a phi node that may change by a constant amount each','line_number':2186,'multiline':False]['text':' iteration. Unlike for the case when computing the iteration bound','line_number':2187,'multiline':False]['text':' itself, the phi does not need to change the same amount every iteration,','line_number':2188,'multiline':False]['text':' but is required to change at most N and be either nondecreasing or','line_number':2189,'multiline':False]['text':' nonincreasing.','line_number':2190,'multiline':False]['text':' The phi may change by N each iteration, and is either nondecreasing or','line_number':2215,'multiline':False]['text':' nonincreasing. initial(phi) is either a lower or upper bound for the','line_number':2216,'multiline':False]['text':' phi, and initial(phi) + loopBound * N is either an upper or lower bound,','line_number':2217,'multiline':False]['text':' at all points within the loop, provided that loopBound >= 0.','line_number':2218,'multiline':False]['text':'','line_number':2219,'multiline':False]['text':' We are more interested, however, in the bound for phi at points','line_number':2220,'multiline':False]['text':' dominated by the loop bound's test; if the test dominates e.g. a bounds','line_number':2221,'multiline':False]['text':' check we want to hoist from the loop, using the value of the phi at the','line_number':2222,'multiline':False]['text':' head of the loop for this will usually be too imprecise to hoist the','line_number':2223,'multiline':False]['text':' check. These points will execute only if the backedge executes at least','line_number':2224,'multiline':False]['text':' one more time (as the test passed and the test dominates the backedge),','line_number':2225,'multiline':False]['text':' so we know both that loopBound >= 1 and that the phi's value has changed','line_number':2226,'multiline':False]['text':' at most loopBound - 1 times. Thus, another upper or lower bound for the','line_number':2227,'multiline':False]['text':' phi is initial(phi) + (loopBound - 1) * N, without requiring us to','line_number':2228,'multiline':False]['text':' ensure that loopBound >= 0.','line_number':2229,'multiline':False]['text':' Whether bound is valid at the specified bounds check instruction in a loop,','line_number':2265,'multiline':False]['text':' and may be used to hoist ins.','line_number':2266,'multiline':False]['text':' The bounds check's length must be loop invariant or a constant.','line_number':2284,'multiline':False]['text':' The bounds check's index should not be loop invariant (else we would','line_number':2290,'multiline':False]['text':' already have hoisted it during LICM).','line_number':2291,'multiline':False]['text':' Check for a symbolic lower and upper bound on the index. If either','line_number':2297,'multiline':False]['text':' condition depends on an iteration bound for the loop, only hoist if','line_number':2298,'multiline':False]['text':' the bounds check is dominated by the iteration bound's test.','line_number':2299,'multiline':False]['text':' We are checking that index + indexConstant >= 0, and know that','line_number':2327,'multiline':False]['text':' index >= lowerTerm + lowerConstant. Thus, check that:','line_number':2328,'multiline':False]['text':'','line_number':2329,'multiline':False]['text':' lowerTerm + lowerConstant + indexConstant >= 0','line_number':2330,'multiline':False]['text':' lowerTerm >= -lowerConstant - indexConstant','line_number':2331,'multiline':False]['text':' We are checking that index < boundsLength, and know that','line_number':2341,'multiline':False]['text':' index <= upperTerm + upperConstant. Thus, check that:','line_number':2342,'multiline':False]['text':'','line_number':2343,'multiline':False]['text':' upperTerm + upperConstant < boundsLength','line_number':2344,'multiline':False]['text':' Hoist the loop invariant lower bounds checks.','line_number':2351,'multiline':False]['text':' A common pattern for iterating over typed arrays is this:','line_number':2359,'multiline':False]['text':'','line_number':2360,'multiline':False]['text':'   for (var i = 0; i < ta.length; i++) {','line_number':2361,'multiline':False]['text':'     use ta[i];','line_number':2362,'multiline':False]['text':'   }','line_number':2363,'multiline':False]['text':'','line_number':2364,'multiline':False]['text':' Here |upperTerm| (= ta.length) is a NonNegativeIntPtrToInt32 instruction.','line_number':2365,'multiline':False]['text':' Unwrap this if |length| is also an IntPtr so that we don't add an','line_number':2366,'multiline':False]['text':' unnecessary bounds check and Int32ToIntPtr below.','line_number':2367,'multiline':False]['text':' Hoist the loop invariant upper bounds checks.','line_number':2373,'multiline':False]['text':' Hoist the bound check's length if it isn't already loop invariant.','line_number':2375,'multiline':False]['text':' If the length is IntPtr, convert the upperTerm to that as well for the','line_number':2382,'multiline':False]['text':' bounds check.','line_number':2383,'multiline':False]['text':' No blocks are supposed to be unreachable, except when we have an OSR','line_number':2410,'multiline':False]['text':' block, in which case the Value Numbering phase add fixup blocks which','line_number':2411,'multiline':False]['text':' are unreachable.','line_number':2412,'multiline':False]['text':' If the block's immediate dominator is unreachable, the block is','line_number':2415,'multiline':False]['text':' unreachable. Iterating in RPO, we'll always see the immediate','line_number':2416,'multiline':False]['text':' dominator before the block.','line_number':2417,'multiline':False]['text':' Beta node range analysis may have marked this block unreachable. If','line_number':2434,'multiline':False]['text':' so, it's no longer interesting to continue processing it.','line_number':2435,'multiline':False]['text':' First pass at collecting range info - while the beta nodes are still','line_number':2446,'multiline':False]['text':' around and before truncation.','line_number':2447,'multiline':False]['text':' Check the computed range for this instruction, if the option is set. Note','line_number':2462,'multiline':False]['text':' that this code is quite invasive; it adds numerous additional','line_number':2463,'multiline':False]['text':' instructions for each MInstruction with a computed range, and it uses','line_number':2464,'multiline':False]['text':' registers, so it also affects register allocation.','line_number':2465,'multiline':False]['text':' Do not add assertions in unreachable blocks.','line_number':2470,'multiline':False]['text':' Perform range checking for all numeric and numeric-like types.','line_number':2478,'multiline':False]['text':' MIsNoIter is fused with the MTest that follows it and emitted as','line_number':2484,'multiline':False]['text':' LIsNoIterAndBranch. Skip it to avoid complicating MIsNoIter','line_number':2485,'multiline':False]['text':' lowering.','line_number':2486,'multiline':False]['text':' Don't insert assertions if there's nothing interesting to assert.','line_number':2495,'multiline':False]['text':' Don't add a use to an instruction that is recovered on bailout.','line_number':2501,'multiline':False]['text':' Beta nodes and interrupt checks are required to be located at the','line_number':2512,'multiline':False]['text':' beginnings of basic blocks, so we must insert range assertions','line_number':2513,'multiline':False]['text':' after any such instructions.','line_number':2514,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':2533,'multiline':False]['text':' Range based Truncation','line_number':2534,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':2535,'multiline':False]['text':' Clearing the fractional field may provide an opportunity to refine','line_number':2550,'multiline':False]['text':' lower_ or upper_.','line_number':2551,'multiline':False]['text':' If nothing else, we can clear the negative zero flag.','line_number':2559,'multiline':False]['text':' No procedure defined for truncating this instruction.','line_number':2581,'multiline':False]['text':' Truncate the double to int, since all uses truncates it.','line_number':2596,'multiline':False]['text':' Remember analysis, needed for fallible checks.','line_number':2623,'multiline':False]['text':' Remember analysis, needed for fallible checks.','line_number':2638,'multiline':False]['text':' Remember analysis, needed for fallible checks.','line_number':2653,'multiline':False]['text':' Remember analysis, needed for fallible checks.','line_number':2671,'multiline':False]['text':' Divisions where the lhs and rhs are unsigned and the result is','line_number':2681,'multiline':False]['text':' truncated can be lowered more efficiently.','line_number':2682,'multiline':False]['text':' Remember analysis, needed for fallible checks.','line_number':2690,'multiline':False]['text':' As for division, handle unsigned modulus with a truncated result.','line_number':2697,'multiline':False]['text':' We use the return type to flag that this MToDouble should be replaced by','line_number':2717,'multiline':False]['text':' a MTruncateToInt32 when modifying the graph.','line_number':2718,'multiline':False]['text':' If we're compiling wasm, don't try to optimize the comparison type, as','line_number':2737,'multiline':False]['text':' the code presumably is already using the type it wants. Also, wasm','line_number':2738,'multiline':False]['text':' doesn't support bailouts, so we woudn't be able to rely on','line_number':2739,'multiline':False]['text':' TruncateAfterBailouts to convert our inputs.','line_number':2740,'multiline':False]['text':' If both operands are naturally in the int32 range, we can convert from','line_number':2749,'multiline':False]['text':' a double comparison to being an int32 comparison.','line_number':2750,'multiline':False]['text':' Truncating the operands won't change their value because we don't force a','line_number':2761,'multiline':False]['text':' truncation, but it will change their type, which we need because we','line_number':2762,'multiline':False]['text':' now expect integer inputs.','line_number':2763,'multiline':False]['text':' Generic routine: We don't know anything.','line_number':2768,'multiline':False]['text':' The truncation applied to a phi is effectively applied to the phi's','line_number':2773,'multiline':False]['text':' operands.','line_number':2774,'multiline':False]['text':' This operator is an explicit truncate to int32.','line_number':2779,'multiline':False]['text':' The bitwise operators truncate to int32.','line_number':2785,'multiline':False]['text':' This operator is doing some arithmetic. If its result is truncated,','line_number':2794,'multiline':False]['text':' it's an indirect truncate for its operands.','line_number':2795,'multiline':False]['text':' See the comment in MAdd::operandTruncateKind.','line_number':2800,'multiline':False]['text':' See the comment in MAdd::operandTruncateKind.','line_number':2805,'multiline':False]['text':' MToDouble propagates its truncate kind to its operand.','line_number':2810,'multiline':False]['text':' An integer store truncates the stored value.','line_number':2815,'multiline':False]['text':' An integer store truncates the stored value.','line_number':2821,'multiline':False]['text':' An integer store truncates the stored value.','line_number':2828,'multiline':False]['text':' If we're doing an int32 comparison on operands which were previously','line_number':2842,'multiline':False]['text':' floating-point, convert them!','line_number':2843,'multiline':False]['text':' If all possible inputs to the test are either int32 or boolean,','line_number':2850,'multiline':False]['text':' convert those inputs to int32 so that an int32 test can be performed.','line_number':2851,'multiline':False]['text':' Truncating instruction result is an optimization which implies','line_number':2892,'multiline':False]['text':' knowing all uses of an instruction.  This implies that if one of','line_number':2893,'multiline':False]['text':' the uses got removed, then Range Analysis is not be allowed to do','line_number':2894,'multiline':False]['text':' any modification which can change the result, especially if the','line_number':2895,'multiline':False]['text':' result can be observed.','line_number':2896,'multiline':False]['text':'','line_number':2897,'multiline':False]['text':' This corner can easily be understood with UCE examples, but it','line_number':2898,'multiline':False]['text':' might also happen with type inference assumptions.  Note: Type','line_number':2899,'multiline':False]['text':' inference is implicitly branches where other types might be','line_number':2900,'multiline':False]['text':' flowing into.','line_number':2901,'multiline':False]['text':' Compare returns a boolean so it doesn't have to be recovered on bailout','line_number':2904,'multiline':False]['text':' because the output would remain correct.','line_number':2905,'multiline':False]['text':' Set ImplicitlyUsed flag on the cloned instruction in order to chain recover','line_number':2930,'multiline':False]['text':' instruction for the bailout path.','line_number':2931,'multiline':False]['text':' Replace the candidate by its recovered on bailout clone within recovered','line_number':2941,'multiline':False]['text':' instructions and resume points operands.','line_number':2942,'multiline':False]['text':' Examine all the users of |candidate| and determine the most aggressive','line_number':2956,'multiline':False]['text':' truncate kind that satisfies all of them.','line_number':2957,'multiline':False]['text':' Check if used by a recovered instruction or a resume point.','line_number':2961,'multiline':False]['text':' Check if it can be read from another frame.','line_number':2963,'multiline':False]['text':' Check if it can safely be reconstructed.','line_number':2964,'multiline':False]['text':' Truncation is a destructive optimization, as such, we need to pay','line_number':2971,'multiline':False]['text':' attention to removed branches and prevent optimization','line_number':2972,'multiline':False]['text':' destructive optimizations if we have no alternative. (see','line_number':2973,'multiline':False]['text':' ImplicitlyUsed flag)','line_number':2974,'multiline':False]['text':' We cannot do full trunction on guarded instructions.','line_number':3000,'multiline':False]['text':' If the value naturally produces an int32 value (before bailout checks)','line_number':3005,'multiline':False]['text':' that needs no conversion, we don't have to worry about resume points','line_number':3006,'multiline':False]['text':' seeing truncated values.','line_number':3007,'multiline':False]['text':' If the instruction is explicitly truncated (not indirectly) by all its','line_number':3010,'multiline':False]['text':' uses and if it is not implicitly used, then we can safely encode its','line_number':3011,'multiline':False]['text':' truncated result as part of the resume point operands.  This is safe,','line_number':3012,'multiline':False]['text':' because even if we resume with a truncated double, the next baseline','line_number':3013,'multiline':False]['text':' instruction operating on this instruction is going to be a no-op.','line_number':3014,'multiline':False]['text':'','line_number':3015,'multiline':False]['text':' Note, that if the result can be observed from another frame, then this','line_number':3016,'multiline':False]['text':' optimization is not safe.','line_number':3017,'multiline':False]['text':' If the candidate instruction appears as operand of a resume point or a','line_number':3021,'multiline':False]['text':' recover instruction, and we have to truncate its result, then we might','line_number':3022,'multiline':False]['text':' have to either recover the result during the bailout, or avoid the','line_number':3023,'multiline':False]['text':' truncation.','line_number':3024,'multiline':False]['text':' If the result can be recovered from all the resume points (not needed','line_number':3026,'multiline':False]['text':' for iterating over the inlined frames), and this instruction can be','line_number':3027,'multiline':False]['text':' recovered on bailout, then we can clone it and use the cloned','line_number':3028,'multiline':False]['text':' instruction to encode the recover instruction.  Otherwise, we should','line_number':3029,'multiline':False]['text':' keep the original result and bailout if the value is not in the int32','line_number':3030,'multiline':False]['text':' range.','line_number':3031,'multiline':False]['text':' Compare operations might coerce its inputs to int32 if the ranges are','line_number':3045,'multiline':False]['text':' correct.  So we do not need to check if all uses are coerced.','line_number':3046,'multiline':False]['text':' Set truncated flag if range analysis ensure that it has no','line_number':3051,'multiline':False]['text':' rounding errors and no fractional part. Note that we can't use','line_number':3052,'multiline':False]['text':' the MDefinition Range constructor, because we need to know if','line_number':3053,'multiline':False]['text':' the value will have rounding errors before any bailout checks.','line_number':3054,'multiline':False]['text':' Special case integer division and modulo: a/b can be infinite, and a%b','line_number':3058,'multiline':False]['text':' can be NaN but cannot actually have rounding errors induced by truncation.','line_number':3059,'multiline':False]['text':' Ensure all observable uses are truncated.','line_number':3069,'multiline':False]['text':' Compare returns a boolean so it doen't have any output truncates.','line_number':3074,'multiline':False]['text':' Range Analysis is sometimes eager to do optimizations, even if we','line_number':3138,'multiline':False]['text':' are not able to truncate an instruction. In such case, we','line_number':3139,'multiline':False]['text':' speculatively compile the instruction to an int32 instruction','line_number':3140,'multiline':False]['text':' while adding a guard. This is what is implied by','line_number':3141,'multiline':False]['text':' TruncateAfterBailout.','line_number':3142,'multiline':False]['text':'','line_number':3143,'multiline':False]['text':' If a previous compilation was invalidated because a speculative','line_number':3144,'multiline':False]['text':' truncation bailed out, we no longer attempt to make this kind of','line_number':3145,'multiline':False]['text':' eager optimization.','line_number':3146,'multiline':False]['text':' MDiv and MMod always require TruncateAfterBailout for their operands.','line_number':3151,'multiline':False]['text':' See MDiv::operandTruncateKind and MMod::operandTruncateKind.','line_number':3152,'multiline':False]['text':' Iterate backward on all instruction and attempt to truncate operations for','line_number':3161,'multiline':False]['text':' each instruction which respect the following list of predicates: Has been','line_number':3162,'multiline':False]['text':' analyzed by range analysis, the range has no rounding errors, all uses cases','line_number':3163,'multiline':False]['text':' are truncating the result.','line_number':3164,'multiline':False]['text':'','line_number':3165,'multiline':False]['text':' If the truncation of the operation is successful, then the instruction is','line_number':3166,'multiline':False]['text':' queue for later updating the graph to restore the type correctness by','line_number':3167,'multiline':False]['text':' converting the operands that need to be truncated.','line_number':3168,'multiline':False]['text':'','line_number':3169,'multiline':False]['text':' We iterate backward because it is likely that a truncated operation truncates','line_number':3170,'multiline':False]['text':' some of its operands.','line_number':3171,'multiline':False]['text':' Automatic truncation is disabled for wasm because the truncation logic','line_number':3175,'multiline':False]['text':' is based on IonMonkey which assumes that we can bailout if the truncation','line_number':3176,'multiline':False]['text':' logic fails. As wasm code has no bailout mechanism, it is safer to avoid','line_number':3177,'multiline':False]['text':' any automatic truncations.','line_number':3178,'multiline':False]['text':' Remember all bitop instructions for folding after range analysis.','line_number':3200,'multiline':False]['text':' Truncate this instruction if possible.','line_number':3218,'multiline':False]['text':' If needed, clone the current instruction for keeping it for the','line_number':3225,'multiline':False]['text':' bailout path.  This give us the ability to truncate instructions','line_number':3226,'multiline':False]['text':' even after the removal of branches.','line_number':3227,'multiline':False]['text':' TruncateAfterBailouts keeps the bailout code as-is and','line_number':3232,'multiline':False]['text':' continues with truncated operations, with the expectation','line_number':3233,'multiline':False]['text':' that we are unlikely to bail out. If we do bail out, then we','line_number':3234,'multiline':False]['text':' will set a flag in FinishBailoutToBaseline to prevent eager','line_number':3235,'multiline':False]['text':' truncation when we recompile, to avoid bailout loops.','line_number':3236,'multiline':False]['text':' Delay updates of inputs/outputs to avoid creating node which','line_number':3243,'multiline':False]['text':' would be removed by the truncation of the next operations.','line_number':3244,'multiline':False]['text':' Truncate this phi if possible.','line_number':3255,'multiline':False]['text':' Delay updates of inputs/outputs to avoid creating node which','line_number':3265,'multiline':False]['text':' would be removed by the truncation of the next operations.','line_number':3266,'multiline':False]['text':' Update inputs/outputs of truncated instructions.','line_number':3274,'multiline':False]['text':' Note: This operation change the semantic of the program in a way which','line_number':3291,'multiline':False]['text':' uniquely works with Int32, Recover Instructions added by the Sink phase','line_number':3292,'multiline':False]['text':' expects the MIR Graph to still have a valid flow as-if they were double','line_number':3293,'multiline':False]['text':' operations instead of Int32 operations. Thus, this phase should be','line_number':3294,'multiline':False]['text':' executed after the Sink phase, and before DCE.','line_number':3295,'multiline':False]['text':' Fold any unnecessary bitops in the graph, such as (x | 0) on an integer','line_number':3297,'multiline':False]['text':' input. This is done after range analysis rather than during GVN as the','line_number':3298,'multiline':False]['text':' presence of the bitop can change which instructions are truncated.','line_number':3299,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':3317,'multiline':False]['text':' Collect Range information of operands','line_number':3318,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':3319,'multiline':False]['text':' Test if Dividend is non-negative.','line_number':3362,'multiline':False]['text':' Try removing divide by zero check.','line_number':3367,'multiline':False]['text':' If lhsRange does not contain INT32_MIN in its range,','line_number':3372,'multiline':False]['text':' negative overflow check can be skipped.','line_number':3373,'multiline':False]['text':' If rhsRange does not contain -1 likewise.','line_number':3378,'multiline':False]['text':' If lhsRange does not contain a zero,','line_number':3383,'multiline':False]['text':' negative zero check can be skipped.','line_number':3384,'multiline':False]['text':' If rhsRange >= 0 negative zero check can be skipped.','line_number':3389,'multiline':False]['text':' If lhsRange contains only positive then we can skip negative zero check.','line_number':3399,'multiline':False]['text':' Likewise rhsRange.','line_number':3404,'multiline':False]['text':' If rhsRange and lhsRange contain Non-negative integers only,','line_number':3409,'multiline':False]['text':' We skip negative zero check.','line_number':3410,'multiline':False]['text':' If rhsRange and lhsRange < 0. Then we skip negative zero check.','line_number':3415,'multiline':False]['text':' As in MUrsh::computeRange(), convert the inputs.','line_number':3499,'multiline':False]['text':' If the most significant bit of our result is always going to be zero,','line_number':3503,'multiline':False]['text':' we can optimize by disabling bailout checks for enforcing an int32 range.','line_number':3504,'multiline':False]['text':' Check if range is positive, because the bitand operator in `(-3) & 0xff`','line_number':3511,'multiline':False]['text':' can't be eliminated.','line_number':3512,'multiline':False]['text':' Check that the mask value has all bits set given the range upper bound.','line_number':3515,'multiline':False]['text':' Note that the upper bound does not have to be exactly the mask value. For','line_number':3516,'multiline':False]['text':' example, consider `x & 0xfff` where `x` is a uint8. That expression can','line_number':3517,'multiline':False]['text':' still be optimized to `x`.','line_number':3518,'multiline':False]['text':' Filter out unreachable fake entries.','line_number':3566,'multiline':False]['text':' Ignore fixup blocks added by the Value Numbering phase, in order','line_number':3568,'multiline':False]['text':' to keep the dominator tree as-is when we have OSR Block which are','line_number':3569,'multiline':False]['text':' no longer reachable from the main entry point of the graph.','line_number':3570,'multiline':False]['text':' Replace the condition of the test control instruction by a constant','line_number':3580,'multiline':False]['text':' chosen based which of the successors has the unreachable flag which is','line_number':3581,'multiline':False]['text':' added by MBeta::computeRange on its own block.','line_number':3582,'multiline':False]['text':' If the false-branch is unreachable, then the test condition must be true.','line_number':3586,'multiline':False]['text':' If the true-branch is unreachable, then the test condition must be false.','line_number':3587,'multiline':False]['text':' Flag all fallible instructions which were indirectly used in the','line_number':3628,'multiline':False]['text':' computation of the condition, such that we do not ignore','line_number':3629,'multiline':False]['text':' bailout-paths which are used to shrink the input range of the','line_number':3630,'multiline':False]['text':' operands of the condition.','line_number':3631,'multiline':False]['text':' If this ins is a guard even without guardRangeBailouts,','line_number':3635,'multiline':False]['text':' there is no reason in trying to hoist the guardRangeBailouts check.','line_number':3636,'multiline':False]['text':' Filter the range of the instruction based on its MIRType.','line_number':3649,'multiline':False]['text':' If the output range is updated by adding the inner range,','line_number':3652,'multiline':False]['text':' then the MIRType act as an effectful filter. As we do not know if','line_number':3653,'multiline':False]['text':' this filtered Range might change or not the result of the','line_number':3654,'multiline':False]['text':' previous comparison, we have to keep this instruction as a guard','line_number':3655,'multiline':False]['text':' because it has to bailout in order to restrict the Range to its','line_number':3656,'multiline':False]['text':' MIRType.','line_number':3657,'multiline':False]['text':' Propagate the guard to its operands.','line_number':3665,'multiline':False]['text':' Already marked.','line_number':3669,'multiline':False]