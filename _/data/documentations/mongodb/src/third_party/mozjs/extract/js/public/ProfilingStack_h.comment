['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' This file defines the classes ProfilingStack and ProfilingStackFrame.','line_number':22,'multiline':False]['text':' The ProfilingStack manages an array of ProfilingStackFrames.','line_number':23,'multiline':False]['text':' It keeps track of the "label stack" and the JS interpreter stack.','line_number':24,'multiline':False]['text':' The two stack types are interleaved.','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' Usage:','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':'  ProfilingStack* profilingStack = ...;','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':'  // For label frames:','line_number':31,'multiline':False]['text':'  profilingStack->pushLabelFrame(...);','line_number':32,'multiline':False]['text':'  // Execute some code. When finished, pop the frame:','line_number':33,'multiline':False]['text':'  profilingStack->pop();','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':'  // For JS stack frames:','line_number':36,'multiline':False]['text':'  profilingStack->pushJSFrame(...);','line_number':37,'multiline':False]['text':'  // Execute some code. When finished, pop the frame:','line_number':38,'multiline':False]['text':'  profilingStack->pop();','line_number':39,'multiline':False]['text':'','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' Concurrency considerations','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' A thread's profiling stack (and the frames inside it) is only modified by','line_number':44,'multiline':False]['text':' that thread. However, the profiling stack can be *read* by a different','line_number':45,'multiline':False]['text':' thread, the sampler thread: Whenever the profiler wants to sample a given','line_number':46,'multiline':False]['text':' thread A, the following happens:','line_number':47,'multiline':False]['text':'  (1) Thread A is suspended.','line_number':48,'multiline':False]['text':'  (2) The sampler thread (thread S) reads the ProfilingStack of thread A,','line_number':49,'multiline':False]['text':'      including all ProfilingStackFrames that are currently in that stack','line_number':50,'multiline':False]['text':'      (profilingStack->frames[0..profilingStack->stackSize()]).','line_number':51,'multiline':False]['text':'  (3) Thread A is resumed.','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':' Thread suspension is achieved using platform-specific APIs; refer to each','line_number':54,'multiline':False]['text':' platform's Sampler::SuspendAndSampleAndResumeThread implementation in','line_number':55,'multiline':False]['text':' platform-*.cpp for details.','line_number':56,'multiline':False]['text':'','line_number':57,'multiline':False]['text':' When the thread is suspended, the values in profilingStack->stackPointer and','line_number':58,'multiline':False]['text':' in the stack frame range','line_number':59,'multiline':False]['text':' profilingStack->frames[0..profilingStack->stackPointer] need to be in a','line_number':60,'multiline':False]['text':' consistent state, so that thread S does not read partially- constructed stack','line_number':61,'multiline':False]['text':' frames. More specifically, we have two requirements:','line_number':62,'multiline':False]['text':'  (1) When adding a new frame at the top of the stack, its ProfilingStackFrame','line_number':63,'multiline':False]['text':'      data needs to be put in place *before* the stackPointer is incremented,','line_number':64,'multiline':False]['text':'      and the compiler + CPU need to know that this order matters.','line_number':65,'multiline':False]['text':'  (2) When popping an frame from the stack and then preparing the','line_number':66,'multiline':False]['text':'      ProfilingStackFrame data for the next frame that is about to be pushed,','line_number':67,'multiline':False]['text':'      the decrement of the stackPointer in pop() needs to happen *before* the','line_number':68,'multiline':False]['text':'      ProfilingStackFrame for the new frame is being popuplated, and the','line_number':69,'multiline':False]['text':'      compiler + CPU need to know that this order matters.','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':' We can express the relevance of these orderings in multiple ways.','line_number':72,'multiline':False]['text':' Option A is to make stackPointer an atomic with SequentiallyConsistent','line_number':73,'multiline':False]['text':' memory ordering. This would ensure that no writes in thread A would be','line_number':74,'multiline':False]['text':' reordered across any writes to stackPointer, which satisfies requirements','line_number':75,'multiline':False]['text':' (1) and (2) at the same time. Option A is the simplest.','line_number':76,'multiline':False]['text':' Option B is to use ReleaseAcquire memory ordering both for writes to','line_number':77,'multiline':False]['text':' stackPointer *and* for writes to ProfilingStackFrame fields. Release-stores','line_number':78,'multiline':False]['text':' ensure that all writes that happened *before this write in program order* are','line_number':79,'multiline':False]['text':' not reordered to happen after this write. ReleaseAcquire ordering places no','line_number':80,'multiline':False]['text':' requirements on the ordering of writes that happen *after* this write in','line_number':81,'multiline':False]['text':' program order.','line_number':82,'multiline':False]['text':' Using release-stores for writes to stackPointer expresses requirement (1),','line_number':83,'multiline':False]['text':' and using release-stores for writes to the ProfilingStackFrame fields','line_number':84,'multiline':False]['text':' expresses requirement (2).','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' Option B is more complicated than option A, but has much better performance','line_number':87,'multiline':False]['text':' on x86/64: In a microbenchmark run on a Macbook Pro from 2017, switching','line_number':88,'multiline':False]['text':' from option A to option B reduced the overhead of pushing+popping a','line_number':89,'multiline':False]['text':' ProfilingStackFrame by 10 nanoseconds.','line_number':90,'multiline':False]['text':' On x86/64, release-stores require no explicit hardware barriers or lock','line_number':91,'multiline':False]['text':' instructions.','line_number':92,'multiline':False]['text':' On ARM/64, option B may be slower than option A, because the compiler will','line_number':93,'multiline':False]['text':' generate hardware barriers for every single release-store instead of just','line_number':94,'multiline':False]['text':' for the writes to stackPointer. However, the actual performance impact of','line_number':95,'multiline':False]['text':' this has not yet been measured on ARM, so we're currently using option B','line_number':96,'multiline':False]['text':' everywhere. This is something that we may want to change in the future once','line_number':97,'multiline':False]['text':' we've done measurements.','line_number':98,'multiline':False]['text':' A call stack can be specified to the JS engine such that all JS entry/exits','line_number':102,'multiline':False]['text':' to functions push/pop a stack frame to/from the specified stack.','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':' For more detailed information, see vm/GeckoProfiler.h.','line_number':105,'multiline':False]['text':'','line_number':106,'multiline':False]['text':' A ProfilingStackFrame represents either a label frame or a JS frame.','line_number':108,'multiline':False]['text':' WARNING WARNING WARNING','line_number':110,'multiline':False]['text':'','line_number':111,'multiline':False]['text':' All the fields below are Atomic<...,ReleaseAcquire>. This is needed so','line_number':112,'multiline':False]['text':' that writes to these fields are release-writes, which ensures that','line_number':113,'multiline':False]['text':' earlier writes in this thread don't get reordered after the writes to','line_number':114,'multiline':False]['text':' these fields. In particular, the decrement of the stack pointer in','line_number':115,'multiline':False]['text':' ProfilingStack::pop() is a write that *must* happen before the values in','line_number':116,'multiline':False]['text':' this ProfilingStackFrame are changed. Otherwise, the sampler thread might','line_number':117,'multiline':False]['text':' see an inconsistent state where the stack pointer still points to a','line_number':118,'multiline':False]['text':' ProfilingStackFrame which has already been popped off the stack and whose','line_number':119,'multiline':False]['text':' fields have now been partially repopulated with new values.','line_number':120,'multiline':False]['text':' See the "Concurrency considerations" paragraph at the top of this file','line_number':121,'multiline':False]['text':' for more details.','line_number':122,'multiline':False]['text':' Descriptive label for this stack frame. Must be a static string! Can be','line_number':124,'multiline':False]['text':' an empty string, but not a null pointer.','line_number':125,'multiline':False]['text':' An additional descriptive string of this frame which is combined with','line_number':128,'multiline':False]['text':' |label_| in profiler output. Need not be (and usually isn't) static. Can','line_number':129,'multiline':False]['text':' be null.','line_number':130,'multiline':False]['text':' Stack pointer for non-JS stack frames, the script pointer otherwise.','line_number':133,'multiline':False]['text':' ID of the JS Realm for JS stack frames.','line_number':136,'multiline':False]['text':' Must not be used on non-JS frames; it'll contain either the default 0,','line_number':137,'multiline':False]['text':' or a leftover value from a previous JS stack frame that was using this','line_number':138,'multiline':False]['text':' ProfilingStackFrame object.','line_number':139,'multiline':False]['text':' The bytecode offset for JS stack frames.','line_number':142,'multiline':False]['text':' Must not be used on non-JS frames; it'll contain either the default 0,','line_number':143,'multiline':False]['text':' or a leftover value from a previous JS stack frame that was using this','line_number':144,'multiline':False]['text':' ProfilingStackFrame object.','line_number':145,'multiline':False]['text':' Bits 0...8 hold the Flags. Bits 9...31 hold the category pair.','line_number':148,'multiline':False]['text':' Reserve up to 16 bits for flags, and 16 for category pair.','line_number':169,'multiline':False]['text':' The first three flags describe the kind of the frame and are','line_number':171,'multiline':False]['text':' mutually exclusive. (We still give them individual bits for','line_number':172,'multiline':False]['text':' simplicity.)','line_number':173,'multiline':False]['text':' A regular label frame. These usually come from AutoProfilerLabel.','line_number':175,'multiline':False]['text':' A special frame indicating the start of a run of JS profiling stack','line_number':178,'multiline':False]['text':' frames. IS_SP_MARKER_FRAME frames are ignored, except for the sp','line_number':179,'multiline':False]['text':' field. These frames are needed to get correct ordering between JS','line_number':180,'multiline':False]['text':' and LABEL frames because JS frames don't carry sp information.','line_number':181,'multiline':False]['text':' SP is short for "stack pointer".','line_number':182,'multiline':False]['text':' A JS frame.','line_number':185,'multiline':False]['text':' An interpreter JS frame that has OSR-ed into baseline. IS_JS_FRAME','line_number':188,'multiline':False]['text':' frames can have this flag set and unset during their lifetime.','line_number':189,'multiline':False]['text':' JS_OSR frames are ignored.','line_number':190,'multiline':False]['text':' The next three are mutually exclusive.','line_number':193,'multiline':False]['text':' By default, for profiling stack frames that have both a label and a','line_number':194,'multiline':False]['text':' dynamic string, the two strings are combined into one string of the','line_number':195,'multiline':False]['text':' form "<label> <dynamicString>" during JSON serialization. The','line_number':196,'multiline':False]['text':' following flags can be used to change this preset.','line_number':197,'multiline':False]['text':' "<label>.<dynamicString>"','line_number':198,'multiline':False]['text':' "get <label>.<dynamicString>"','line_number':199,'multiline':False]['text':' "set <label>.<dynamicString>"','line_number':200,'multiline':False]['text':' If set, causes this stack frame to be marked as "relevantForJS" in','line_number':202,'multiline':False]['text':' the profile JSON, which will make it show up in the "JS only" call','line_number':203,'multiline':False]['text':' tree view.','line_number':204,'multiline':False]['text':' If set, causes the label on this ProfilingStackFrame to be ignored','line_number':207,'multiline':False]['text':' and to be replaced by the subcategory's label.','line_number':208,'multiline':False]['text':' Frame dynamic string does not contain user data.','line_number':211,'multiline':False]['text':' A JS Baseline Interpreter frame.','line_number':214,'multiline':False]['text':' pcOffsetIfJS_ is not set and must not be used on label frames.','line_number':281,'multiline':False]['text':' pcOffsetIfJS_ is not set and must not be used on sp marker frames.','line_number':292,'multiline':False]['text':' Note that the pointer returned might be invalid.','line_number':333,'multiline':False]['text':' We can't know the layout of JSScript, so look in vm/GeckoProfiler.cpp.','line_number':340,'multiline':False]['text':' The offset of a pc into a script's code can actually be 0, so to','line_number':346,'multiline':False]['text':' signify a nullptr pc, use a -1 index. This is checked against in','line_number':347,'multiline':False]['text':' pc() and setPC() to set/get the right pc.','line_number':348,'multiline':False]['text':' GetContextProfilingStack also exists, but it's defined in RootingAPI.h.','line_number':355,'multiline':False]['text':' namespace js','line_number':363,'multiline':False]['text':' regiserThread and unregisterThread callbacks are functions which are called','line_number':372,'multiline':False]['text':' by other threads without any locking mechanism.','line_number':373,'multiline':False]['text':' namespace JS','line_number':378,'multiline':False]['text':' Each thread has its own ProfilingStack. That thread modifies the','line_number':380,'multiline':False]['text':' ProfilingStack, pushing and popping elements as necessary.','line_number':381,'multiline':False]['text':'','line_number':382,'multiline':False]['text':' The ProfilingStack is also read periodically by the profiler's sampler','line_number':383,'multiline':False]['text':' thread. This happens only when the thread that owns the ProfilingStack is','line_number':384,'multiline':False]['text':' suspended. So there are no genuine parallel accesses.','line_number':385,'multiline':False]['text':'','line_number':386,'multiline':False]['text':' However, it is possible for pushing/popping to be interrupted by a periodic','line_number':387,'multiline':False]['text':' sample. Because of this, we need pushing/popping to be effectively atomic.','line_number':388,'multiline':False]['text':'','line_number':389,'multiline':False]['text':' - When pushing a new frame, we increment the stack pointer -- making the new','line_number':390,'multiline':False]['text':'   frame visible to the sampler thread -- only after the new frame has been','line_number':391,'multiline':False]['text':'   fully written. The stack pointer is Atomic<uint32_t,ReleaseAcquire>, so','line_number':392,'multiline':False]['text':'   the increment is a release-store, which ensures that this store is not','line_number':393,'multiline':False]['text':'   reordered before the writes of the frame.','line_number':394,'multiline':False]['text':'','line_number':395,'multiline':False]['text':' - When popping an old frame, the only operation is the decrementing of the','line_number':396,'multiline':False]['text':'   stack pointer, which is obviously atomic.','line_number':397,'multiline':False]['text':'','line_number':398,'multiline':False]['text':' This thread is the only one that ever changes the value of','line_number':408,'multiline':False]['text':' stackPointer.','line_number':409,'multiline':False]['text':' Store the value of the atomic in a non-atomic local variable so that','line_number':410,'multiline':False]['text':' the compiler won't generate two separate loads from the atomic for','line_number':411,'multiline':False]['text':' the size check and the frames[] array indexing operation.','line_number':412,'multiline':False]['text':' This must happen at the end! The compiler will not reorder this','line_number':421,'multiline':False]['text':' update because stackPointer is Atomic<..., ReleaseAcquire>, so any','line_number':422,'multiline':False]['text':' the writes above will not be reordered below the stackPointer store.','line_number':423,'multiline':False]['text':' Do the read and the write as two separate statements, in order to','line_number':424,'multiline':False]['text':' make it clear that we don't need an atomic increment, which would be','line_number':425,'multiline':False]['text':' more expensive on x86 than the separate operations done here.','line_number':426,'multiline':False]['text':' However, don't use stackPointerVal here; instead, allow the compiler','line_number':427,'multiline':False]['text':' to turn this store into a non-atomic increment instruction which','line_number':428,'multiline':False]['text':' takes up less code size.','line_number':429,'multiline':False]['text':' This must happen at the end, see the comment in pushLabelFrame.','line_number':441,'multiline':False]['text':' This thread is the only one that ever changes the value of','line_number':447,'multiline':False]['text':' stackPointer. Only load the atomic once.','line_number':448,'multiline':False]['text':' This must happen at the end, see the comment in pushLabelFrame.','line_number':458,'multiline':False]['text':' Do the read and the write as two separate statements, in order to','line_number':464,'multiline':False]['text':' make it clear that we don't need an atomic decrement, which would be','line_number':465,'multiline':False]['text':' more expensive on x86 than the separate operations done here.','line_number':466,'multiline':False]['text':' This thread is the only one that ever changes the value of','line_number':467,'multiline':False]['text':' stackPointer.','line_number':468,'multiline':False]['text':' Out of line path for expanding the buffer, since otherwise this would get','line_number':477,'multiline':False]['text':' inlined in every DOM WebIDL call.','line_number':478,'multiline':False]['text':' No copying.','line_number':481,'multiline':False]['text':' No moving either.','line_number':485,'multiline':False]['text':' The pointer to the stack frames, this is read from the profiler thread and','line_number':492,'multiline':False]['text':' written from the current thread.','line_number':493,'multiline':False]['text':'','line_number':494,'multiline':False]['text':' This is effectively a unique pointer.','line_number':495,'multiline':False]['text':' This may exceed the capacity, so instead use the stackSize() method to','line_number':499,'multiline':False]['text':' determine the number of valid frames in stackFrames. When this is less','line_number':500,'multiline':False]['text':' than stackCapacity(), it refers to the first free stackframe past the top','line_number':501,'multiline':False]['text':' of the in-use stack (i.e. frames[stackPointer - 1] is the top stack','line_number':502,'multiline':False]['text':' frame).','line_number':503,'multiline':False]['text':'','line_number':504,'multiline':False]['text':' WARNING WARNING WARNING','line_number':505,'multiline':False]['text':'','line_number':506,'multiline':False]['text':' This is an atomic variable that uses ReleaseAcquire memory ordering.','line_number':507,'multiline':False]['text':' See the "Concurrency considerations" paragraph at the top of this file','line_number':508,'multiline':False]['text':' for more details.','line_number':509,'multiline':False]['text':' Same as profilingStack_ if the profiler is currently active, otherwise','line_number':526,'multiline':False]['text':' null.','line_number':527,'multiline':False]['text':'
   * True if the profiler infrastructure is setup.  Should be true in builds
   * that include profiler support except during early startup or late
   * shutdown.  Unrelated to the presence of the Gecko Profiler addon.
   ','line_number':543,'multiline':True]['text':'
   * Functions which are the actual instrumentation to track run information
   *
   *   - enter: a function has started to execute
   *   - updatePC: updates the pc information about where a function
   *               is currently executing
   *   - exit: this function has ceased execution, and no further
   *           entries/exits will be made
   ','line_number':556,'multiline':True]['text':' namespace js','line_number':570,'multiline':False]['text':' js_ProfilingStack_h ','line_number':572,'multiline':True]