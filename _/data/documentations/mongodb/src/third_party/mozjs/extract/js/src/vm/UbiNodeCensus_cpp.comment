['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::GetErrorMessage, JSMSG_*','line_number':11,'multiline':False]['text':' js::PlainObject','line_number':14,'multiline':False]['text':' Downcast to our true type and destruct, as guided by our CountType','line_number':31,'multiline':False]['text':' pointer.','line_number':32,'multiline':False]['text':'** Count Types ***********************************************************','line_number':37,'multiline':True]['text':' The simplest type: just count everything.','line_number':39,'multiline':False]['text':' A count type that collects all matching nodes in a bucket.','line_number':122,'multiline':False]['text':' A type that categorizes nodes by their JavaScript type -- 'objects',','line_number':173,'multiline':False]['text':' 'strings', 'scripts', 'domNode', and 'other' -- and then passes the nodes to','line_number':174,'multiline':False]['text':' child types.','line_number':175,'multiline':False]['text':'','line_number':176,'multiline':False]['text':' Implementation details of scripts like jitted code are counted under','line_number':177,'multiline':False]['text':' 'scripts'.','line_number':178,'multiline':False]['text':' Comparison function for sorting hash table entries by the smallest node ID','line_number':310,'multiline':False]['text':' they counted. Node IDs are stable and unique, which ensures ordering of','line_number':311,'multiline':False]['text':' results never depends on hash table placement or sort algorithm vagaries. The','line_number':312,'multiline':False]['text':' arguments are doubly indirect: they're pointers to elements in an array of','line_number':313,'multiline':False]['text':' pointers to table entries.','line_number':314,'multiline':False]['text':' We don't want to just subtract the values, as they're unsigned.','line_number':324,'multiline':False]['text':' A hash map mapping from C strings to counts.','line_number':334,'multiline':False]['text':' Convert a HashMap into an object with each key one of the entries from the','line_number':338,'multiline':False]['text':' map and each value the associated count's report. For use during census','line_number':339,'multiline':False]['text':' reporting.','line_number':340,'multiline':False]['text':'','line_number':341,'multiline':False]['text':' `Map` must be a `HashMap` from some key type to a `CountBasePtr`.','line_number':342,'multiline':False]['text':'','line_number':343,'multiline':False]['text':' `GetName` must be a callable type which takes `const Map::Key&` and returns','line_number':344,'multiline':False]['text':' `const char*`.','line_number':345,'multiline':False]['text':' Build a vector of pointers to entries; sort by total; and then use','line_number':348,'multiline':False]['text':' that to build the result object. This makes the ordering of entries','line_number':349,'multiline':False]['text':' more interesting, and a little less non-deterministic.','line_number':350,'multiline':False]['text':' Build a vector of pointers to entries; sort by total; and then use','line_number':398,'multiline':False]['text':' that to build the result object. This makes the ordering of entries','line_number':399,'multiline':False]['text':' more interesting, and a little less non-deterministic.','line_number':400,'multiline':False]['text':' A type that categorizes nodes that are JSObjects by their class name,','line_number':445,'multiline':False]['text':' and places all other nodes in an 'other' category.','line_number':446,'multiline':False]['text':' A table mapping class names to their counts. Note that we treat js::Class','line_number':448,'multiline':False]['text':' instances with the same name as equal keys. If you have several','line_number':449,'multiline':False]['text':' js::Classes with equal names (and we do; as of this writing there were','line_number':450,'multiline':False]['text':' six named "Object"), you will get several different js::Classes being','line_number':451,'multiline':False]['text':' counted in the same table entry.','line_number':452,'multiline':False]['text':' A table mapping descriptive names to their counts.','line_number':549,'multiline':False]['text':' A count type that categorizes nodes by their ubi::Node::typeName.','line_number':652,'multiline':False]['text':' Note that, because ubi::Node::typeName promises to return a specific','line_number':654,'multiline':False]['text':' pointer, not just any string whose contents are correct, we can use their','line_number':655,'multiline':False]['text':' addresses as hash table keys.','line_number':656,'multiline':False]['text':' Build a vector of pointers to entries; sort by total; and then use','line_number':723,'multiline':False]['text':' that to build the result object. This makes the ordering of entries','line_number':724,'multiline':False]['text':' more interesting, and a little less non-deterministic.','line_number':725,'multiline':False]['text':' Now build the result by iterating over the sorted vector.','line_number':738,'multiline':False]['text':' A count type that categorizes nodes by the JS stack under which they were','line_number':769,'multiline':False]['text':' allocated.','line_number':770,'multiline':False]['text':' NOTE: You may look up entries in this table by JS::ubi::StackFrame','line_number':777,'multiline':False]['text':' key only during traversal, NOT ONCE TRAVERSAL IS COMPLETE. Once','line_number':778,'multiline':False]['text':' traversal is complete, you may only iterate over it.','line_number':779,'multiline':False]['text':'','line_number':780,'multiline':False]['text':' In this hash table, keys are JSObjects (with some indirection), and','line_number':781,'multiline':False]['text':' we use JSObject identity (that is, address identity) as key','line_number':782,'multiline':False]['text':' identity. The normal way to support such a table is to make the trace','line_number':783,'multiline':False]['text':' function notice keys that have moved and re-key them in the','line_number':784,'multiline':False]['text':' table. However, our trace function does *not* rehash; the first GC','line_number':785,'multiline':False]['text':' may render the hash table unsearchable.','line_number':786,'multiline':False]['text':'','line_number':787,'multiline':False]['text':' This is as it should be:','line_number':788,'multiline':False]['text':'','line_number':789,'multiline':False]['text':' First, the heap traversal phase needs lookups by key to work. But no','line_number':790,'multiline':False]['text':' GC may ever occur during a traversal; this is enforced by the','line_number':791,'multiline':False]['text':' JS::ubi::BreadthFirst template. So the traceCount function doesn't','line_number':792,'multiline':False]['text':' need to do anything to help traversal; it never even runs then.','line_number':793,'multiline':False]['text':'','line_number':794,'multiline':False]['text':' Second, the report phase needs iteration over the table to work, but','line_number':795,'multiline':False]['text':' never looks up entries by key. GC may well occur during this phase:','line_number':796,'multiline':False]['text':' we allocate a Map object, and probably cross-compartment wrappers for','line_number':797,'multiline':False]['text':' SavedFrame instances as well. If a GC were to occur, it would call','line_number':798,'multiline':False]['text':' our traceCount function; if traceCount were to re-key, that would','line_number':799,'multiline':False]['text':' ruin the traversal in progress.','line_number':800,'multiline':False]['text':'','line_number':801,'multiline':False]['text':' So depending on the phase, we either don't need re-keying, or','line_number':802,'multiline':False]['text':' can't abide it.','line_number':803,'multiline':False]['text':' Trace our child Counts.','line_number':849,'multiline':False]['text':' Trace the StackFrame that is this entry's key. Do not re-key if','line_number':852,'multiline':False]['text':' it has moved; see comments for ByAllocationStack::Count::table.','line_number':853,'multiline':False]['text':' If we do have an allocation stack for this node, include it in the','line_number':866,'multiline':False]['text':' count for that stack.','line_number':867,'multiline':False]['text':' Otherwise, count it in the "no stack" category.','line_number':882,'multiline':False]['text':' Check that nothing rehashes our table while we hold pointers into it.','line_number':891,'multiline':False]['text':' Build a vector of pointers to entries; sort by total; and then use','line_number':895,'multiline':False]['text':' that to build the result object. This makes the ordering of entries','line_number':896,'multiline':False]['text':' more interesting, and a little less non-deterministic.','line_number':897,'multiline':False]['text':' Now build the result by iterating over the sorted vector.','line_number':910,'multiline':False]['text':' A count type that categorizes nodes by their script's filename.','line_number':955,'multiline':False]['text':' A table mapping filenames to their counts. Note that we treat scripts','line_number':971,'multiline':False]['text':' with the same filename as equivalent. If you have several sources with','line_number':972,'multiline':False]['text':' the same filename, then all their scripts will get bucketed together.','line_number':973,'multiline':False]['text':'** Census Handler ********************************************************','line_number':1085,'multiline':True]['text':' We're only interested in the first time we reach edge.referent, not','line_number':1090,'multiline':False]['text':' in every edge arriving at that node.','line_number':1091,'multiline':False]['text':' Don't count nodes outside the debuggee zones. Do count things in the','line_number':1096,'multiline':False]['text':' special atoms zone, but don't traverse their outgoing edges, on the','line_number':1097,'multiline':False]['text':' assumption that they are shared resources that debuggee is using.','line_number':1098,'multiline':False]['text':' Symbols are always allocated in the atoms zone, even if they were','line_number':1099,'multiline':False]['text':' created for exactly one compartment and never shared; this rule will','line_number':1100,'multiline':False]['text':' include such nodes in the count.','line_number':1101,'multiline':False]['text':'** Parsing Breakdowns ****************************************************','line_number':1118,'multiline':True]['text':' Construct the default type, { by: 'count' }','line_number':1132,'multiline':False]['text':' Both 'count' and 'bytes' default to true if omitted, but ToBoolean','line_number':1162,'multiline':False]['text':' naturally treats 'undefined' as false; fix this up.','line_number':1163,'multiline':False]['text':' Undocumented feature, for testing: { by: 'count' } breakdowns can have','line_number':1167,'multiline':False]['text':' a 'label' property whose value is converted to a string and included as','line_number':1168,'multiline':False]['text':' a 'label' property on the report object.','line_number':1169,'multiline':False]['text':' We didn't recognize the breakdown type; complain.','line_number':1290,'multiline':False]['text':' Get the default census breakdown:','line_number':1301,'multiline':False]['text':'','line_number':1302,'multiline':False]['text':' { by: "coarseType",','line_number':1303,'multiline':False]['text':'   objects: { by: "objectClass" },','line_number':1304,'multiline':False]['text':'   other:   { by: "internalType" },','line_number':1305,'multiline':False]['text':'   domNode: { by: "descriptiveType" }','line_number':1306,'multiline':False]['text':' }','line_number':1307,'multiline':False]['text':' namespace ubi','line_number':1370,'multiline':False]['text':' namespace JS','line_number':1371,'multiline':False]