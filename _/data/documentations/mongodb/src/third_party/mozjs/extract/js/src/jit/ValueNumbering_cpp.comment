['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'
 * [SMDOC] IonMonkey Value Numbering
 *
 * Some notes on the main algorithm here:
 *  - The SSA identifier id() is the value number. We do replaceAllUsesWith as
 *    we go, so there's always at most one visible value with a given number.
 *
 *  - Consequently, the GVN algorithm is effectively pessimistic. This means it
 *    is not as powerful as an optimistic GVN would be, but it is simpler and
 *    faster.
 *
 *  - We iterate in RPO, so that when visiting a block, we've already optimized
 *    and hashed all values in dominating blocks. With occasional exceptions,
 *    this allows us to do everything in a single pass.
 *
 *  - When we do use multiple passes, we just re-run the algorithm on the whole
 *    graph instead of doing sparse propagation. This is a tradeoff to keep the
 *    algorithm simpler and lighter on inputs that don't have a lot of
 *    interesting unreachable blocks or degenerate loop induction variables, at
 *    the expense of being slower on inputs that do. The loop for this always
 *    terminates, because it only iterates when code is or will be removed, so
 *    eventually it must stop iterating.
 *
 *  - Values are not immediately removed from the hash set when they go out of
 *    scope. Instead, we check for dominance after a lookup. If the dominance
 *    check fails, the value is removed.
 ','line_number':17,'multiline':True]['text':' Test whether two MDefinitions are congruent.','line_number':49,'multiline':False]['text':' If one of the instructions depends on a store, and the other instruction','line_number':51,'multiline':False]['text':' does not depend on the same store, the instructions are not congruent.','line_number':52,'multiline':False]['text':' Ask the values themselves what they think.','line_number':58,'multiline':False]['text':' Look up the first entry for |def|.','line_number':77,'multiline':False]['text':' Look up the first entry for |def|.','line_number':83,'multiline':False]['text':' Insert a value into the set.','line_number':89,'multiline':False]['text':' Insert a value onto the set overwriting any existing entry.','line_number':94,'multiline':False]['text':' |def| will be discarded, so remove it from any sets.','line_number':99,'multiline':False]['text':' Clear all state.','line_number':107,'multiline':False]['text':' Test whether |def| is in the set.','line_number':111,'multiline':False]['text':' Call MDefinition::justReplaceAllUsesWith, and add some GVN-specific asserts.','line_number':118,'multiline':False]['text':' We don't need the extra setting of ImplicitlyUsed flags that the regular','line_number':125,'multiline':False]['text':' replaceAllUsesWith does because we do it ourselves.','line_number':126,'multiline':False]['text':' Test whether |succ| is a successor of |block|.','line_number':130,'multiline':False]['text':' Given a block which has had predecessors removed but is still reachable, test','line_number':141,'multiline':False]['text':' whether the block's new dominator will be closer than its old one and whether','line_number':142,'multiline':False]['text':' it will expose potential optimization opportunities.','line_number':143,'multiline':False]['text':' Note that dominators haven't been recomputed yet, so we have to check','line_number':148,'multiline':False]['text':' whether now dominates pred, not block.','line_number':149,'multiline':False]['text':' Test for any defs which look potentially interesting to GVN.','line_number':168,'multiline':False]['text':' Walk up the dominator tree from |block| to the root and test for any defs','line_number':173,'multiline':False]['text':' which look potentially interesting to GVN.','line_number':174,'multiline':False]['text':' Walk up the dominator tree from |now| to |old| and test for any defs which','line_number':190,'multiline':False]['text':' look potentially interesting to GVN.','line_number':191,'multiline':False]['text':' Given a block which has had predecessors removed but is still reachable, test','line_number':204,'multiline':False]['text':' whether the block's new dominator will be closer than its old one and whether','line_number':205,'multiline':False]['text':' it will expose potential optimization opportunities.','line_number':206,'multiline':False]['text':' If this block is just a goto and it doesn't dominate its destination,','line_number':211,'multiline':False]['text':' removing its predecessors won't refine the dominators of anything','line_number':212,'multiline':False]['text':' interesting.','line_number':213,'multiline':False]['text':' We've computed block's new dominator. Test whether there are any','line_number':220,'multiline':False]['text':' newly-dominating definitions which look interesting.','line_number':221,'multiline':False]['text':' |def| has just had one of its users release it. If it's now dead, enqueue it','line_number':229,'multiline':False]['text':' for discarding, otherwise just make note of it.','line_number':230,'multiline':False]['text':' Discard |def| and anything in its use-def subtree which is no longer needed.','line_number':246,'multiline':False]['text':' Assuming |resume| is unreachable, release its operands.','line_number':253,'multiline':False]['text':' It might be nice to integrate this code with prepareForDiscard, however GVN','line_number':254,'multiline':False]['text':' needs it to call handleUseReleased so that it can observe when a definition','line_number':255,'multiline':False]['text':' becomes unused, so it isn't trivial to do.','line_number':256,'multiline':False]['text':' We set the ImplicitlyUsed flag when removing resume point operands,','line_number':265,'multiline':False]['text':' because even though we may think we're certain that a particular','line_number':266,'multiline':False]['text':' branch might not be taken, the type information might be incomplete.','line_number':267,'multiline':False]['text':' Assuming |phi| is dead, release and remove its operands. If an operand','line_number':275,'multiline':False]['text':' becomes dead, push it to the discard worklist.','line_number':276,'multiline':False]['text':' MPhi saves operands in a vector so we iterate in reverse.','line_number':278,'multiline':False]['text':' Assuming |def| is dead, release its operands. If an operand becomes dead,','line_number':289,'multiline':False]['text':' push it to the discard worklist.','line_number':290,'multiline':False]['text':' Discard |def| and mine its operands for any subsequently dead defs.','line_number':302,'multiline':False]['text':' If that was the last definition in the block, it can be safely removed','line_number':339,'multiline':False]['text':' from the graph.','line_number':340,'multiline':False]['text':' As a special case, don't remove a block which is a dominator tree','line_number':345,'multiline':False]['text':' root so that we don't invalidate the iterator in visitGraph. We'll','line_number':346,'multiline':False]['text':' check for this and remove it later.','line_number':347,'multiline':False]['text':' Recursively discard all the defs on the deadDefs_ worklist.','line_number':363,'multiline':False]['text':' Don't invalidate the MDefinition iterator. This is what we're going','line_number':369,'multiline':False]['text':' to visit next, so we won't miss anything.','line_number':370,'multiline':False]['text':' Test whether |block|, which is a loop header, has any predecessors other than','line_number':382,'multiline':False]['text':' |loopPred|, the loop predecessor, which it doesn't dominate.','line_number':383,'multiline':False]['text':' A loop is about to be made reachable only through an OSR entry into one of','line_number':398,'multiline':False]['text':' its nested loops. Fix everything up.','line_number':399,'multiline':False]['text':' Create an empty and unreachable(!) block which jumps to |block|. This','line_number':401,'multiline':False]['text':' allows |block| to remain marked as a loop header, so we don't have to','line_number':402,'multiline':False]['text':' worry about moving a different block into place as the new loop header,','line_number':403,'multiline':False]['text':' which is hard, especially if the OSR is into a nested loop. Doing all','line_number':404,'multiline':False]['text':' that would produce slightly more optimal code, but this is so','line_number':405,'multiline':False]['text':' extraordinarily rare that it isn't worth the complexity.','line_number':406,'multiline':False]['text':' Remove the CFG edge between |pred| and |block|, after releasing the phi','line_number':420,'multiline':False]['text':' operands on that edge and discarding any definitions consequently made dead.','line_number':421,'multiline':False]['text':' Before removing the predecessor edge, scan the phi operands for that edge','line_number':429,'multiline':False]['text':' for dead code before they get removed.','line_number':430,'multiline':False]['text':' If |nextDef_| became dead while we had it pinned, advance the','line_number':447,'multiline':False]['text':' iterator and discard it now.','line_number':448,'multiline':False]['text':' Remove the CFG edge between |pred| and |block|, and if this makes |block|','line_number':465,'multiline':False]['text':' unreachable, mark it so, and remove the rest of its incoming edges too. And','line_number':466,'multiline':False]['text':' discard any instructions made dead by the entailed release of any phi','line_number':467,'multiline':False]['text':' operands.','line_number':468,'multiline':False]['text':' We'll be removing a predecessor, so anything we know about phis in this','line_number':474,'multiline':False]['text':' block will be wrong.','line_number':475,'multiline':False]['text':' If this is a loop header, test whether it will become an unreachable','line_number':481,'multiline':False]['text':' loop, or whether it needs special OSR-related fixups.','line_number':482,'multiline':False]['text':' Deleting the entry into the loop makes the loop unreachable.','line_number':493,'multiline':False]['text':' Actually remove the CFG edge.','line_number':508,'multiline':False]['text':' We've now edited the CFG; check to see if |block| became unreachable.','line_number':514,'multiline':False]['text':' Remove |block| from its dominator parent's subtree. This is the only','line_number':518,'multiline':False]['text':' immediately-dominated-block information we need to update, because','line_number':519,'multiline':False]['text':' everything dominated by this block is about to be swept away.','line_number':520,'multiline':False]['text':' Completely disconnect it from the CFG. We do this now rather than','line_number':526,'multiline':False]['text':' just doing it later when we arrive there in visitUnreachableBlock','line_number':527,'multiline':False]['text':' so that we don't leave a partially broken loop sitting around. This','line_number':528,'multiline':False]['text':' also lets visitUnreachableBlock assert that numPredecessors() == 0,','line_number':529,'multiline':False]['text':' which is a nice invariant.','line_number':530,'multiline':False]['text':' Clear out the resume point operands, as they can hold things that','line_number':540,'multiline':False]['text':' don't appear to dominate them live.','line_number':541,'multiline':False]['text':' Use the mark to note that we've already removed all its predecessors,','line_number':576,'multiline':False]['text':' and we know it's unreachable.','line_number':577,'multiline':False]['text':' Return a simplified form of |def|, if we can.','line_number':584,'multiline':False]['text':' If an equivalent and dominating value already exists in the set, return it.','line_number':589,'multiline':False]['text':' Otherwise insert |def| into the set and return it.','line_number':590,'multiline':False]['text':' If the value isn't suitable for eliminating, don't bother hashing it. The','line_number':592,'multiline':False]['text':' convention is that congruentTo returns false for node kinds that wish to','line_number':593,'multiline':False]['text':' opt out of redundance elimination.','line_number':594,'multiline':False]['text':' TODO: It'd be nice to clean up that convention (bug 1031406).','line_number':595,'multiline':False]['text':' Look for a match.','line_number':597,'multiline':False]['text':' We found a dominating congruent value.','line_number':602,'multiline':False]['text':' The congruent value doesn't dominate. It never will again in this','line_number':606,'multiline':False]['text':' dominator tree, so overwrite it.','line_number':607,'multiline':False]['text':' No match. Add a new entry.','line_number':610,'multiline':False]['text':' Test whether |phi| is dominated by a congruent phi.','line_number':624,'multiline':False]['text':' Test whether there are any phis in |header| which are newly optimizable, as a','line_number':634,'multiline':False]['text':' result of optimizations done inside the loop. This is not a sparse approach,','line_number':635,'multiline':False]['text':' but restarting is rare enough in practice. Termination is ensured by','line_number':636,'multiline':False]['text':' discarding the phi triggering the iteration.','line_number':637,'multiline':False]['text':' If the header is unreachable, don't bother re-optimizing it.','line_number':639,'multiline':False]['text':' Rescan the phis for any that can be simplified, since they may be reading','line_number':644,'multiline':False]['text':' values from backedges.','line_number':645,'multiline':False]['text':' Phi can be simplified.','line_number':652,'multiline':False]['text':' Visit |def|.','line_number':658,'multiline':False]['text':' Nop does not fit in any of the previous optimization, as its only purpose','line_number':660,'multiline':False]['text':' is to reduce the register pressure by keeping additional resume','line_number':661,'multiline':False]['text':' point. Still, there is no need consecutive list of MNop instructions, and','line_number':662,'multiline':False]['text':' this will slow down every other iteration on the Graph.','line_number':663,'multiline':False]['text':' We look backward to know if we can remove the previous Nop, we do not','line_number':668,'multiline':False]['text':' look forward as we would not benefit from the folding made by GVN.','line_number':669,'multiline':False]['text':' This nop is at the beginning of the basic block, just replace the','line_number':672,'multiline':False]['text':' resume point of the basic block by the one from the resume point.','line_number':673,'multiline':False]['text':' The previous instruction is also a Nop, no need to keep it anymore.','line_number':681,'multiline':False]['text':' The Nop is introduced to capture the result and make sure the operands','line_number':689,'multiline':False]['text':' are not live anymore when there are no further uses. Though when','line_number':690,'multiline':False]['text':' all operands are still needed the Nop doesn't decrease the liveness','line_number':691,'multiline':False]['text':' and can get removed.','line_number':692,'multiline':False]['text':' Skip optimizations on instructions which are recovered on bailout, to','line_number':717,'multiline':False]['text':' avoid mixing instructions which are recovered on bailouts with','line_number':718,'multiline':False]['text':' instructions which are not.','line_number':719,'multiline':False]['text':' If this instruction has a dependency() into an unreachable block, we'll','line_number':724,'multiline':False]['text':' need to update AliasAnalysis.','line_number':725,'multiline':False]['text':' TODO: Recomputing alias-analysis could theoretically expose more','line_number':730,'multiline':False]['text':' GVN opportunities.','line_number':731,'multiline':False]['text':' Temporarily clear its dependency, to protect foldsTo, which may','line_number':735,'multiline':False]['text':' wish to use the dependency to do store-to-load forwarding.','line_number':736,'multiline':False]['text':' Look for a simplified form of |def|.','line_number':742,'multiline':False]['text':' If |sim| doesn't belong to a block, insert it next to |def|.','line_number':751,'multiline':False]['text':' The node's foldsTo said |def| can be replaced by |rep|. If |def| is a','line_number':763,'multiline':False]['text':' guard, then either |rep| is also a guard, or a guard isn't actually','line_number':764,'multiline':False]['text':' needed, so we can clear |def|'s guard flag and let it be discarded.','line_number':765,'multiline':False]['text':' If that ended up discarding |sim|, then we're done here.','line_number':781,'multiline':False]['text':' Otherwise, procede to optimize with |sim| in place of |def|.','line_number':795,'multiline':False]['text':' If the simplified instruction was already part of the graph, then we','line_number':798,'multiline':False]['text':' probably already visited and optimized this instruction.','line_number':799,'multiline':False]['text':' Now that foldsTo is done, re-enable the original dependency. Even though','line_number':805,'multiline':False]['text':' it may be pointing into a discarded block, it's still valid for the','line_number':806,'multiline':False]['text':' purposes of detecting congruent loads.','line_number':807,'multiline':False]['text':' Look for a dominating def which makes |def| redundant.','line_number':812,'multiline':False]['text':' The node's congruentTo said |def| is congruent to |rep|, and it's','line_number':825,'multiline':False]['text':' dominated by |rep|. If |def| is a guard, it's covered by |rep|,','line_number':826,'multiline':False]['text':' so we can clear |def|'s guard flag and let it be discarded.','line_number':827,'multiline':False]['text':' discardDef should not add anything to the deadDefs, as the','line_number':831,'multiline':False]['text':' redundant operation should have the same input operands.','line_number':832,'multiline':False]['text':' Visit the control instruction at the end of |block|.','line_number':848,'multiline':False]['text':' Look for a simplified form of the control instruction.','line_number':850,'multiline':False]['text':' If the simplification removes any CFG edges, update the CFG and remove','line_number':870,'multiline':False]['text':' any blocks that become dead.','line_number':871,'multiline':False]['text':' |block| is unreachable. Mine it for opportunities to delete more dead','line_number':910,'multiline':False]['text':' code, and then discard it.','line_number':911,'multiline':False]['text':' Disconnect all outgoing CFG edges.','line_number':926,'multiline':False]['text':' |succ| is still reachable. Make a note of it so that we can scan','line_number':938,'multiline':False]['text':' it for interesting dominator tree changes later.','line_number':939,'multiline':False]['text':' Discard any instructions with no uses. The remaining instructions will be','line_number':947,'multiline':False]['text':' discarded when their last use is discarded.','line_number':948,'multiline':False]['text':' Visit all the phis and instructions |block|.','line_number':966,'multiline':False]['text':' Visit the definitions in the block top-down.','line_number':973,'multiline':False]['text':' Remember where our iterator is so that we don't invalidate it.','line_number':981,'multiline':False]['text':' If the definition is dead, discard it.','line_number':984,'multiline':False]['text':' Visit all the blocks dominated by dominatorRoot.','line_number':1005,'multiline':False]['text':' Visit all blocks dominated by dominatorRoot, in RPO. This has the nice','line_number':1019,'multiline':False]['text':' property that we'll always visit a block before any block it dominates,','line_number':1020,'multiline':False]['text':' so we can make a single pass through the list and see every full','line_number':1021,'multiline':False]['text':' redundance.','line_number':1022,'multiline':False]['text':' We're only visiting blocks in dominatorRoot's tree right now.','line_number':1028,'multiline':False]['text':' If this is a loop backedge, remember the header, as we may not be able','line_number':1033,'multiline':False]['text':' to find it after we simplify the block.','line_number':1034,'multiline':False]['text':' This block has become unreachable; handle it specially.','line_number':1039,'multiline':False]['text':' Visit the block!','line_number':1045,'multiline':False]['text':' If the block is/was a loop backedge, check to see if the block that','line_number':1052,'multiline':False]['text':' is/was its header has optimizable phis, which would want a re-run.','line_number':1053,'multiline':False]['text':' Visit all the blocks in the graph.','line_number':1074,'multiline':False]['text':' Due to OSR blocks, the set of blocks dominated by a blocks may not be','line_number':1076,'multiline':False]['text':' contiguous in the RPO. Do a separate traversal for each dominator tree','line_number':1077,'multiline':False]['text':' root. There's always the main entry, and sometimes there's an OSR entry,','line_number':1078,'multiline':False]['text':' and then there are the roots formed where the OSR paths merge with the','line_number':1079,'multiline':False]['text':' main entry paths.','line_number':1080,'multiline':False]['text':' Normally unreachable blocks would be removed by now, but if this','line_number':1089,'multiline':False]['text':' block is a dominator tree root, it has been special-cased and left','line_number':1090,'multiline':False]['text':' in place in order to avoid invalidating our iterator. Now that','line_number':1091,'multiline':False]['text':' we've finished the tree, increment the iterator, and then if it's','line_number':1092,'multiline':False]['text':' marked for removal, remove it.','line_number':1093,'multiline':False]['text':' This block a dominator tree root. Proceed to the next one.','line_number':1113,'multiline':False]['text':' Only add fixup block above for loops which can be reached from OSR.','line_number':1126,'multiline':False]['text':' If the loop header is not self-dominated, then this loop does not','line_number':1131,'multiline':False]['text':' have to deal with a second entry point, so there is no need to add a','line_number':1132,'multiline':False]['text':' second entry point with a fixup block.','line_number':1133,'multiline':False]['text':' OSR fixups serve the purpose of representing the non-OSR entry into a loop','line_number':1146,'multiline':False]['text':' when the only real entry is an OSR entry into the middle. However, if the','line_number':1147,'multiline':False]['text':' entry into the middle is subsequently folded away, the loop may actually','line_number':1148,'multiline':False]['text':' have become unreachable. Mark-and-sweep all blocks to remove all such code.','line_number':1149,'multiline':False]['text':' Mark.','line_number':1151,'multiline':False]['text':' Unmark fixup blocks if the loop predecessor is marked after','line_number':1172,'multiline':False]['text':' the loop header.','line_number':1173,'multiline':False]['text':' OSR fixup blocks are needed if and only if the loop header is','line_number':1178,'multiline':False]['text':' reachable from its backedge (via the OSR block) and not from its','line_number':1179,'multiline':False]['text':' original loop predecessor.','line_number':1180,'multiline':False]['text':'','line_number':1181,'multiline':False]['text':' Thus OSR fixup blocks are removed if the loop header is not','line_number':1182,'multiline':False]['text':' reachable, or if the loop header is reachable from both its backedge','line_number':1183,'multiline':False]['text':' and its original loop predecessor.','line_number':1184,'multiline':False]['text':' And sweep.','line_number':1209,'multiline':False]['text':' Initialize the value set. It's tempting to pass in a length that is a','line_number':1216,'multiline':False]['text':' function of graph_.getNumInstructionIds(). But if we start out with a','line_number':1217,'multiline':False]['text':' large capacity, it will be far larger than the actual element count for','line_number':1218,'multiline':False]['text':' most of the pass, so when we remove elements, it would often think it','line_number':1219,'multiline':False]['text':' needs to compact itself. Empirically, just letting the HashTable grow','line_number':1220,'multiline':False]['text':' as needed on its own seems to work pretty well.','line_number':1221,'multiline':False]['text':' Adding fixup blocks only make sense iff we have a second entry point into','line_number':1239,'multiline':False]['text':' the graph which cannot be reached any more from the entry point.','line_number':1240,'multiline':False]['text':' Top level non-sparse iteration loop. If an iteration performs a','line_number':1247,'multiline':False]['text':' significant change, such as discarding a block which changes the','line_number':1248,'multiline':False]['text':' dominator tree and may enable more optimization, this loop takes another','line_number':1249,'multiline':False]['text':' iteration.','line_number':1250,'multiline':False]['text':' Test whether any block which was not removed but which had at least','line_number':1257,'multiline':False]['text':' one predecessor removed will have a new dominator parent.','line_number':1258,'multiline':False]['text':' underValueNumberer = ','line_number':1273,'multiline':True]['text':' If no further opportunities have been discovered, we're done.','line_number':1285,'multiline':False]['text':' Enforce an arbitrary iteration limit. This is rarely reached, and','line_number':1292,'multiline':False]['text':' isn't even strictly necessary, as the algorithm is guaranteed to','line_number':1293,'multiline':False]['text':' terminate on its own in a finite amount of time (since every time we','line_number':1294,'multiline':False]['text':' re-run we discard the construct which triggered the re-run), but it','line_number':1295,'multiline':False]['text':' does help avoid slow compile times on pathological code.','line_number':1296,'multiline':False]