['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]['text':'','line_number':7,'multiline':False]['text':' Implement TimeStamp::Now() with POSIX clocks.','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' The "tick" unit for POSIX clocks is simply a nanosecond, as this is','line_number':10,'multiline':False]['text':' the smallest unit of time representable by struct timespec.  That','line_number':11,'multiline':False]['text':' doesn't mean that a nanosecond is the resolution of TimeDurations','line_number':12,'multiline':False]['text':' obtained with this API; see TimeDuration::Resolution;','line_number':13,'multiline':False]['text':'','line_number':14,'multiline':False]['text':' Estimate of the smallest duration of time we can measure.','line_number':58,'multiline':False]['text':' this can't fail: we know &ts is valid, and TimeStamp::Startup()','line_number':78,'multiline':False]['text':' checks that CLOCK_MONOTONIC is supported (and aborts if not)','line_number':79,'multiline':False]['text':' tv_sec is defined to be relative to an arbitrary point in time,','line_number':82,'multiline':False]['text':' but it would be madness for that point in time to be earlier than','line_number':83,'multiline':False]['text':' the Epoch.  So we can safely assume that even if time_t is 32','line_number':84,'multiline':False]['text':' bits, tv_sec won't overflow while the browser is open.  Revisit','line_number':85,'multiline':False]['text':' this argument if we're still building with 32-bit time_t around','line_number':86,'multiline':False]['text':' the year 2037.','line_number':87,'multiline':False]['text':' NB: why not rely on clock_getres()?  Two reasons: (i) it might','line_number':92,'multiline':False]['text':' lie, and (ii) it might return an "ideal" resolution that while','line_number':93,'multiline':False]['text':' theoretically true, could never be measured in practice.  Since','line_number':94,'multiline':False]['text':' clock_gettime() likely involves a system call on your platform,','line_number':95,'multiline':False]['text':' the "actual" timing resolution shouldn't be lower than syscall','line_number':96,'multiline':False]['text':' overhead.','line_number':97,'multiline':False]['text':' 10 total trials is arbitrary: what we're trying to avoid by','line_number':103,'multiline':False]['text':' looping is getting unlucky and being interrupted by a context','line_number':104,'multiline':False]['text':' switch or signal, or being bitten by paging/cache effects','line_number':105,'multiline':False]['text':' measurable resolution is either incredibly low, ~1ns, or very','line_number':117,'multiline':False]['text':' high.  fall back on clock_getres()','line_number':118,'multiline':False]['text':' clock_getres probably failed.  fall back on NSPR's resolution','line_number':126,'multiline':False]['text':' assumption','line_number':127,'multiline':False]['text':' don't report a value < mResolution ...','line_number':141,'multiline':False]['text':' and chop off insignificant digits','line_number':143,'multiline':False]['text':' find the number of significant digits in sResolution, for the','line_number':179,'multiline':False]['text':' sake of ToSecondsSigDigits()','line_number':180,'multiline':False]['text':' Calculates the amount of jiffies that have elapsed since boot and up to the','line_number':201,'multiline':False]['text':' starttime value of a specific process as found in its /proc/*/stat file.','line_number':202,'multiline':False]['text':' Returns 0 if an error occurred.','line_number':203,'multiline':False]['text':' instead of uint64_t to keep GCC quiet','line_number':223,'multiline':False]['text':' Computes the interval that has elapsed between the thread creation and the','line_number':242,'multiline':False]['text':' process creation by comparing the starttime fields in the respective','line_number':243,'multiline':False]['text':' /proc/*/stat files. The resulting value will be a good approximation of the','line_number':244,'multiline':False]['text':' process uptime. This value will be stored at the address pointed by aTime;','line_number':245,'multiline':False]['text':' if an error occurred 0 will be stored instead.','line_number':246,'multiline':False]['text':' Computes and returns the process uptime in us on Linux & its derivatives.','line_number':273,'multiline':False]['text':' Returns 0 if an error was encountered.','line_number':274,'multiline':False]['text':' Computes and returns the process uptime in us on various BSD flavors.','line_number':294,'multiline':False]['text':' Returns 0 if an error was encountered.','line_number':295,'multiline':False]['text':' namespace mozilla','line_number':342,'multiline':False]