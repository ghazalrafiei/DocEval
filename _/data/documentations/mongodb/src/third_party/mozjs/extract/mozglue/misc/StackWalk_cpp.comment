['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]['text':' API for getting a stack trace of the C/C++ stack on the current thread ','line_number':7,'multiline':True]['text':' for _Unwind_Backtrace from libcxxrt or libunwind','line_number':31,'multiline':False]['text':' cxxabi.h from libcxxrt implicitly includes unwind.h first','line_number':32,'multiline':False]['text':' from ld-linux.so','line_number':63,'multiline':False]['text':' Skip frames until we encounter the one we were initialized with,','line_number':76,'multiline':False]['text':' and then never skip again.','line_number':77,'multiline':False]['text':' We need a way to know if we are building for WXP (or later), as if we are, we','line_number':104,'multiline':False]['text':' need to use the newer 64-bit APIs. API_VERSION_NUMBER seems to fit the bill.','line_number':105,'multiline':False]['text':' A value of 9 indicates we want to use the new APIs.','line_number':106,'multiline':False]['text':' Because various Win64 APIs acquire function-table locks, we need a way of','line_number':114,'multiline':False]['text':' preventing stack walking while those APIs are being called. Otherwise, the','line_number':115,'multiline':False]['text':' stack walker may suspend a thread holding such a lock, and deadlock when the','line_number':116,'multiline':False]['text':' stack unwind code attempts to wait for that lock.','line_number':117,'multiline':False]['text':'','line_number':118,'multiline':False]['text':' We're using an atomic counter rather than a critical section because we','line_number':119,'multiline':False]['text':' don't require mutual exclusion with the stack walker. If the stack walker','line_number':120,'multiline':False]['text':' determines that it's safe to start unwinding the suspended thread (i.e.','line_number':121,'multiline':False]['text':' there are no suppressions when the unwind begins), then it's safe to','line_number':122,'multiline':False]['text':' continue unwinding that thread even if other threads request suppressions','line_number':123,'multiline':False]['text':' in the meantime, because we can't deadlock with those other threads.','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':' XXX: This global variable is a larger-than-necessary hammer. A more scoped','line_number':126,'multiline':False]['text':' solution would be to maintain a counter per thread, but then it would be','line_number':127,'multiline':False]['text':' more difficult for WalkStackMain64 to read the suspended thread's counter.','line_number':128,'multiline':False]['text':' Currently we can only handle one JIT code region at a time','line_number':149,'multiline':False]['text':' Currently we can only handle one JIT code region at a time','line_number':157,'multiline':False]['text':' _M_AMD64 || _M_ARM64','line_number':165,'multiline':False]['text':' Routine to print an error message to standard error.','line_number':167,'multiline':False]['text':' Default language','line_number':174,'multiline':False]['text':' Wrapper around a reference to a CONTEXT, to simplify access to main','line_number':191,'multiline':False]['text':' platform-specific execution registers.','line_number':192,'multiline':False]['text':' It also avoids using CONTEXT* nullable pointers.','line_number':193,'multiline':False]['text':'*
 * Walk the stack, translating PC's found into strings and recording the
 * chain in aBuffer. For this to work properly, the DLLs must be rebased
 * so that the address in the file agrees with the address in memory.
 * Otherwise StackWalk will return FALSE when it hits a frame in a DLL
 * whose in memory address doesn't match its in-file address.
 ','line_number':240,'multiline':True]['text':' If not already provided, get a context for the specified thread.','line_number':265,'multiline':False]['text':' Setup initial stack frame to walk from.','line_number':279,'multiline':False]['text':' If there are any active suppressions, then at least one thread (we don't','line_number':292,'multiline':False]['text':' know which) is holding a lock that can deadlock RtlVirtualUnwind. Since','line_number':293,'multiline':False]['text':' that thread may be the one that we're trying to unwind, we can't proceed.','line_number':294,'multiline':False]['text':'','line_number':295,'multiline':False]['text':' But if there are no suppressions, then our target thread can't be holding','line_number':296,'multiline':False]['text':' a lock, and it's safe to proceed. By virtue of being suspended, the target','line_number':297,'multiline':False]['text':' thread can't acquire any new locks during the unwind process, so we only','line_number':298,'multiline':False]['text':' need to do this check once. After that, sStackWalkSuppressions can be','line_number':299,'multiline':False]['text':' changed by other threads while we're unwinding, and that's fine because','line_number':300,'multiline':False]['text':' we can't deadlock with those threads.','line_number':301,'multiline':False]['text':' Now walk the stack.','line_number':315,'multiline':False]['text':' 32-bit frame unwinding.','line_number':321,'multiline':False]['text':' Debug routines are not threadsafe, so grab the lock.','line_number':322,'multiline':False]['text':' function table access routine','line_number':330,'multiline':False]['text':' module base routine','line_number':331,'multiline':False]['text':' If we reach a frame in JIT code, we don't have enough information to','line_number':354,'multiline':False]['text':' unwind, so we have to give up.','line_number':355,'multiline':False]['text':' We must also avoid msmpeg2vdec.dll's JIT region: they don't generate','line_number':361,'multiline':False]['text':' unwind data, so their JIT unwind callback just throws up its hands and','line_number':362,'multiline':False]['text':' terminates the process.','line_number':363,'multiline':False]['text':' 64-bit frame unwinding.','line_number':371,'multiline':False]['text':' Try to look up unwind metadata for the current function.','line_number':372,'multiline':False]['text':' Leaf functions can be unwound by hand.','line_number':384,'multiline':False]['text':' Something went wrong.','line_number':388,'multiline':False]['text':' We don't pass a aFirstFramePC because we walk the stack for another','line_number':424,'multiline':False]['text':' thread.','line_number':425,'multiline':False]['text':'
   * You'll want to control this if we are running on an
   *  architecture where the addresses go the other direction.
   * Not sure this is even a realistic consideration.
   ','line_number':442,'multiline':True]['text':'
   * If it falls in side the known range, load the symbols.
   ','line_number':449,'multiline':True]['text':'
 * SymGetModuleInfoEspecial
 *
 * Attempt to determine the module information.
 * Bug 112196 says this DLL may not have been loaded at the time
 *  SymInitialize was called, and thus the module information
 *  and symbol information is not available.
 * This code rectifies that problem.
 ','line_number':465,'multiline':True]['text':' New members were added to IMAGEHLP_MODULE64 (that show up in the','line_number':475,'multiline':False]['text':' Platform SDK that ships with VC8, but not the Platform SDK that ships','line_number':476,'multiline':False]['text':' with VC7.1, i.e., between DbgHelp 6.0 and 6.1), but we don't need to','line_number':477,'multiline':False]['text':' use them, and it's useful to be able to function correctly with the','line_number':478,'multiline':False]['text':' older library.  (Stock Windows XP SP2 seems to ship with dbghelp.dll','line_number':479,'multiline':False]['text':' version 5.1.)  Since Platform SDK version need not correspond to','line_number':480,'multiline':False]['text':' compiler version, and the version number in debughlp.h was NOT bumped','line_number':481,'multiline':False]['text':' when these changes were made, ifdef based on a constant that was','line_number':482,'multiline':False]['text':' added between these versions.','line_number':483,'multiline':False]['text':'
   * Init the vars if we have em.
   ','line_number':498,'multiline':True]['text':'
   * Give it a go.
   * It may already be loaded.
   ','line_number':506,'multiline':True]['text':'
     * Not loaded, here's the magic.
     * Go through all the modules.
     ','line_number':512,'multiline':True]['text':' Need to cast to PENUMLOADED_MODULES_CALLBACK64 because the','line_number':516,'multiline':False]['text':' constness of the first parameter of','line_number':517,'multiline':False]['text':' PENUMLOADED_MODULES_CALLBACK64 varies over SDK versions (from','line_number':518,'multiline':False]['text':' non-const to const over time).  See bug 391848 and bug','line_number':519,'multiline':False]['text':' 415426.','line_number':520,'multiline':False]['text':'
       * One final go.
       * If it fails, then well, we have other problems.
       ','line_number':525,'multiline':True]['text':'
   * If we got module info, we may attempt line info as well.
   * We will not report failure if this does not work.
   ','line_number':533,'multiline':True]['text':' Clear out aLineInfo to indicate that it's not valid','line_number':542,'multiline':False]['text':' XXX At some point we need to arrange to call SymCleanup ','line_number':567,'multiline':True]['text':' debug routines are not threadsafe, so grab the lock.','line_number':588,'multiline':False]['text':'','line_number':591,'multiline':False]['text':' Attempt to load module info before we attempt to resolve the symbol.','line_number':592,'multiline':False]['text':' This just makes sure we get good info if available.','line_number':593,'multiline':False]['text':'','line_number':594,'multiline':False]['text':' release our lock','line_number':632,'multiline':False]['text':' i386 or PPC Linux stackwalking code','line_number':636,'multiline':False]['text':' On glibc 2.1, the Dl_info api defined in <dlfcn.h> is only exposed','line_number':645,'multiline':False]['text':' if __USE_GNU is defined.  I suppose its some kind of standards','line_number':646,'multiline':False]['text':' adherence thing.','line_number':647,'multiline':False]['text':'','line_number':648,'multiline':False]['text':' This thing is exported by libstdc++','line_number':653,'multiline':False]['text':' Yes, this is a gcc only hack','line_number':654,'multiline':False]['text':' MOZ_DEMANGLE_SYMBOLS','line_number':657,'multiline':False]['text':' See demangle.h in the gcc source for the voodoo ','line_number':665,'multiline':True]['text':' MOZ_DEMANGLE_SYMBOLS','line_number':673,'multiline':False]['text':' namespace mozilla','line_number':676,'multiline':False]['text':' {x86, ppc} x {Linux, Mac} stackwalking code.','line_number':678,'multiline':False]['text':' Get the frame pointer','line_number':690,'multiline':False]['text':' bionic's pthread_attr_getstack doesn't tell the truth for the main','line_number':705,'multiline':False]['text':' thread (see bug 846670). So don't use it for the main thread.','line_number':706,'multiline':False]['text':' So consider the current frame pointer + an arbitrary size of 8MB','line_number':714,'multiline':False]['text':' (modulo overflow ; not really arbitrary as it's the default stack','line_number':715,'multiline':False]['text':' size for the main thread) if pthread_attr_getstack failed for','line_number':716,'multiline':False]['text':' some reason (or was skipped).','line_number':717,'multiline':False]['text':' libgcc_s.so symbols _Unwind_Backtrace@@GCC_3.3 and _Unwind_GetIP@@GCC_3.0','line_number':732,'multiline':False]['text':' TODO Use something like '_Unwind_GetGR()' to get the stack pointer.','line_number':747,'multiline':False]['text':' Again, any error code that stops the walk will do.','line_number':752,'multiline':False]['text':' We ignore the return value from _Unwind_Backtrace. There are three main','line_number':769,'multiline':False]['text':' reasons for this.','line_number':770,'multiline':False]['text':' - On ARM/Android bionic's _Unwind_Backtrace usually (always?) returns','line_number':771,'multiline':False]['text':'   _URC_FAILURE.  See','line_number':772,'multiline':False]['text':'   https://bugzilla.mozilla.org/show_bug.cgi?id=717853#c110.','line_number':773,'multiline':False]['text':' - If aMaxFrames != 0, we want to stop early, and the only way to do that','line_number':774,'multiline':False]['text':'   is to make unwind_callback return something other than _URC_NO_REASON,','line_number':775,'multiline':False]['text':'   which causes _Unwind_Backtrace to return a non-success code.','line_number':776,'multiline':False]['text':' - MozStackWalk doesn't have a return value anyway.','line_number':777,'multiline':False]['text':' On FreeBSD, dli_sname is unusably bad, it often returns things like','line_number':809,'multiline':False]['text':' 'gtk_xtbin_new' or 'XRE_GetBootstrap' instead of long C++ symbols. Just let','line_number':810,'multiline':False]['text':' GetFunction do the lookup directly in the ELF image.','line_number':811,'multiline':False]['text':' Just use the mangled symbol if demangling failed.','line_number':821,'multiline':False]['text':' unsupported platform.','line_number':832,'multiline':False]['text':' On macOS arm64, system libraries are arm64e binaries, and arm64e can do','line_number':854,'multiline':False]['text':' pointer authentication: The low bits of the pointer are the actual pointer','line_number':855,'multiline':False]['text':' value, and the high bits are an encrypted hash. During stackwalking, we need','line_number':856,'multiline':False]['text':' to strip off this hash. In theory, ptrauth_strip would be the right function','line_number':857,'multiline':False]['text':' to call for this. However, that function is a no-op unless it's called from','line_number':858,'multiline':False]['text':' code which also builds as arm64e - which we do not. So we cannot use it. So','line_number':859,'multiline':False]['text':' for now, we hardcode a mask that seems to work today: 40 bits for the pointer','line_number':860,'multiline':False]['text':' and 24 bits for the hash seems to do the trick. We can worry about','line_number':861,'multiline':False]['text':' dynamically computing the correct mask if this ever stops working.','line_number':862,'multiline':False]['text':' 40 bits pointer, 24 bit PAC','line_number':864,'multiline':False]['text':' Stack walking code courtesy Kipp's "leaky".','line_number':874,'multiline':False]['text':' aBp may not be a frame pointer on i386 if code was compiled with','line_number':881,'multiline':False]['text':' -fomit-frame-pointer, so do some sanity checks.','line_number':882,'multiline':False]['text':' (aBp should be a frame pointer on ppc(64) but checking anyway may help','line_number':883,'multiline':False]['text':' a little if the stack has been corrupted.)','line_number':884,'multiline':False]['text':' We don't need to check against the begining of the stack because','line_number':885,'multiline':False]['text':' we can assume that aBp > sp','line_number':886,'multiline':False]['text':' ppc mac or powerpc64 linux','line_number':891,'multiline':False]['text':' i386 or powerpc32 linux','line_number':894,'multiline':False]['text':' Strip off pointer authentication hash, if present. For now, it looks','line_number':899,'multiline':False]['text':' like only return addresses require stripping, and stack pointers do','line_number':900,'multiline':False]['text':' not. This might change in the future.','line_number':901,'multiline':False]['text':' Assume that the SP points to the BP of the function','line_number':905,'multiline':False]['text':' it called. We can't know the exact location of the SP','line_number':906,'multiline':False]['text':' but this should be sufficient for our use the SP','line_number':907,'multiline':False]['text':' to order elements on the stack.','line_number':908,'multiline':False]['text':' We don't pass a aFirstFramePC because we start walking the stack from the','line_number':924,'multiline':False]['text':' frame at aBp.','line_number':925,'multiline':False]['text':' namespace mozilla','line_number':930,'multiline':False]['text':' namespace mozilla','line_number':938,'multiline':False]['text':' We have a filename and (presumably) a line number. Use them.','line_number':958,'multiline':False]['text':' We have no filename, but we do have a library name. Use it and the','line_number':962,'multiline':False]['text':' library offset, and print them in a way that `fix_stacks.py` can','line_number':963,'multiline':False]['text':' post-process.','line_number':964,'multiline':False]['text':' We have nothing useful to go on. (The format string is split because','line_number':969,'multiline':False]['text':' '??)' is a trigraph and causes a warning, sigh.)','line_number':970,'multiline':False]['text':' 1024 + 1 for trailing '\n'','line_number':1014,'multiline':False]