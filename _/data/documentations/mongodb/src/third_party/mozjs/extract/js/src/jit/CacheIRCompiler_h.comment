['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':16,'multiline':False]['text':' [SMDOC] CacheIR Value Representation and Tracking','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' While compiling an IC stub the CacheIR compiler needs to keep track of the','line_number':35,'multiline':False]['text':' physical location for each logical piece of data we care about, as well as','line_number':36,'multiline':False]['text':' ensure that in the case of a stub failing, we are able to restore the input','line_number':37,'multiline':False]['text':' state so that a subsequent stub can attempt to provide a value.','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' OperandIds are created in the CacheIR front-end to keep track of values that','line_number':40,'multiline':False]['text':' are passed between CacheIR ops during the execution of a given CacheIR stub.','line_number':41,'multiline':False]['text':' In the CacheRegisterAllocator these OperandIds are given OperandLocations,','line_number':42,'multiline':False]['text':' that represent the physical location of the OperandId at a given point in','line_number':43,'multiline':False]['text':' time during CacheRegister allocation.','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':' In the CacheRegisterAllocator physical locations include the stack, and','line_number':46,'multiline':False]['text':' registers, as well as whether or not the value has been unboxed or not.','line_number':47,'multiline':False]['text':' Constants are also represented separately to provide for on-demand','line_number':48,'multiline':False]['text':' materialization.','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' Intra-op Register allocation:','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' During the emission of a CacheIR op, code can ask the CacheRegisterAllocator','line_number':53,'multiline':False]['text':' for access to a particular OperandId, and the register allocator will','line_number':54,'multiline':False]['text':' generate the required code to fill that request.','line_number':55,'multiline':False]['text':'','line_number':56,'multiline':False]['text':' Input OperandIds should be considered as immutable, and should not be mutated','line_number':57,'multiline':False]['text':' during the execution of a stub.','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':' There are also a number of RAII classes that interact with the register','line_number':60,'multiline':False]['text':' allocator, in order to provide access to more registers than just those','line_number':61,'multiline':False]['text':' provided for by the OperandIds.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':' - AutoOutputReg: The register which will hold the output value of the stub.','line_number':64,'multiline':False]['text':' - AutoScratchReg: By default, an arbitrary scratch register, however a','line_number':65,'multiline':False]['text':'   specific register can be requested.','line_number':66,'multiline':False]['text':' - AutoScratchRegMaybeOutput: Any arbitrary scratch register, but the output','line_number':67,'multiline':False]['text':'   register may be used as well.','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' These RAII classes take ownership of a register for the duration of their','line_number':70,'multiline':False]['text':' lifetime so they can be used for computation or output. The register','line_number':71,'multiline':False]['text':' allocator can spill values with OperandLocations in order to try to ensure','line_number':72,'multiline':False]['text':' that a register is made available for use.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' If a specific register is required (via AutoScratchRegister), it should be','line_number':75,'multiline':False]['text':' the first register acquired, as the register rallocator will be unable to','line_number':76,'multiline':False]['text':' allocate the fixed register if the current op is using it for something else.','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':' If no register can be provided after attempting to spill, a','line_number':79,'multiline':False]['text':' MOZ_RELEASE_ASSERT ensures the browser will crash. The register allocator is','line_number':80,'multiline':False]['text':' not provided enough information in its current design to insert spills and','line_number':81,'multiline':False]['text':' fills at arbitrary locations, and so it can fail to find an allocation','line_number':82,'multiline':False]['text':' solution. However, this will only happen within the implementation of an','line_number':83,'multiline':False]['text':' operand emitter, and because the cache register allocator is mostly','line_number':84,'multiline':False]['text':' determinstic, so long as the operand id emitter is tested, this won't','line_number':85,'multiline':False]['text':' suddenly crop up in an arbitrary webpage. It's worth noting the most','line_number':86,'multiline':False]['text':' difficult platform to support is x86-32, because it has the least number of','line_number':87,'multiline':False]['text':' registers available.','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':' FailurePaths checkpoint the state of the register allocator so that the input','line_number':90,'multiline':False]['text':' state can be recomputed from the current state before jumping to the next','line_number':91,'multiline':False]['text':' stub in the IC chain. An important invariant is that the FailurePath must be','line_number':92,'multiline':False]['text':' allocated for each op after all the manipulation of OperandLocations has','line_number':93,'multiline':False]['text':' happened, so that its recording is correct.','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' Inter-op Register Allocation:','line_number':96,'multiline':False]['text':'','line_number':97,'multiline':False]['text':' The RAII register management classes are RAII because all register state','line_number':98,'multiline':False]['text':' outside the OperandLocations is reset before the compilation of each','line_number':99,'multiline':False]['text':' individual CacheIR op. This means that you cannot rely on a value surviving','line_number':100,'multiline':False]['text':' between ops, even if you use the ability of AutoScratchRegister to name a','line_number':101,'multiline':False]['text':' specific register. Values that need to be preserved between ops must be given','line_number':102,'multiline':False]['text':' an OperandId.','line_number':103,'multiline':False]['text':' Represents a Value on the Baseline frame's expression stack. Slot 0 is the','line_number':105,'multiline':False]['text':' value on top of the stack (the most recently pushed value), slot 1 is the','line_number':106,'multiline':False]['text':' value pushed before that, etc.','line_number':107,'multiline':False]['text':' OperandLocation represents the location of an OperandId. The operand is','line_number':123,'multiline':False]['text':' either in a register or on the stack, and is either boxed or unboxed.','line_number':124,'multiline':False]['text':' Class to track and allocate registers while emitting IC code.','line_number':304,'multiline':False]['text':' The original location of the inputs to the cache.','line_number':306,'multiline':False]['text':' The current location of each operand.','line_number':309,'multiline':False]['text':' Free lists for value- and payload-slots on stack','line_number':312,'multiline':False]['text':' The registers allocated while emitting the current CacheIR op.','line_number':316,'multiline':False]['text':' This prevents us from allocating a register and then immediately','line_number':317,'multiline':False]['text':' clobbering it for something else, while we're still holding on to it.','line_number':318,'multiline':False]['text':' Registers that are currently unused and available.','line_number':323,'multiline':False]['text':' Registers that are available, but before use they must be saved and','line_number':326,'multiline':False]['text':' then restored when returning from the stub.','line_number':327,'multiline':False]['text':' Registers we took from availableRegsAfterSpill_ and spilled to the stack.','line_number':330,'multiline':False]['text':' The number of bytes pushed on the native stack.','line_number':333,'multiline':False]['text':' Flag used to assert individual CacheIR instructions don't allocate','line_number':337,'multiline':False]['text':' registers after calling addFailurePath.','line_number':338,'multiline':False]['text':' The index of the CacheIR instruction we're currently emitting.','line_number':342,'multiline':False]['text':' Whether the stack contains a double spilled by AutoScratchFloatRegister.','line_number':345,'multiline':False]['text':' Allocates a new register.','line_number':466,'multiline':False]['text':' Releases a register so it can be reused later.','line_number':473,'multiline':False]['text':' Removes spilled values from the native stack. This should only be','line_number':488,'multiline':False]['text':' called after all registers have been allocated.','line_number':489,'multiline':False]['text':' Returns the register for the given operand. If the operand is currently','line_number':496,'multiline':False]['text':' not in a register, it will load it into one.','line_number':497,'multiline':False]['text':' Allocates an output register for the given operand.','line_number':504,'multiline':False]['text':' Loads (potentially coercing) and unboxes a value into a float register','line_number':508,'multiline':False]['text':' This is infallible, as there should have been a previous guard','line_number':509,'multiline':False]['text':' to ensure the value is already a number.','line_number':510,'multiline':False]['text':' Does not change the allocator's state.','line_number':511,'multiline':False]['text':' Loads an unboxed value into a scratch register. This can be useful','line_number':515,'multiline':False]['text':' especially on 32-bit x86 when there are not enough registers for','line_number':516,'multiline':False]['text':' useRegister.','line_number':517,'multiline':False]['text':' Does not change the allocator's state.','line_number':518,'multiline':False]['text':' Returns |val|'s JSValueType or JSVAL_TYPE_UNKNOWN.','line_number':524,'multiline':False]['text':' Emits code to restore registers and stack to the state at the start of','line_number':527,'multiline':False]['text':' the stub.','line_number':528,'multiline':False]['text':' Returns the set of registers storing the IC input operands.','line_number':531,'multiline':False]['text':' RAII class to allocate a scratch register and release it when we're done','line_number':539,'multiline':False]['text':' with it.','line_number':540,'multiline':False]['text':' On x86, spectreBoundsCheck32 can emit better code if it has a scratch','line_number':566,'multiline':False]['text':' register and index masking is enabled.','line_number':567,'multiline':False]['text':' Scratch Register64. Implemented with a single AutoScratchRegister on 64-bit','line_number':591,'multiline':False]['text':' platforms and two AutoScratchRegisters on 32-bit platforms.','line_number':592,'multiline':False]['text':' Scratch ValueOperand. Implemented with a single AutoScratchRegister on 64-bit','line_number':618,'multiline':False]['text':' platforms and two AutoScratchRegisters on 32-bit platforms.','line_number':619,'multiline':False]['text':' The FailurePath class stores everything we need to generate a failure path','line_number':645,'multiline':False]['text':' at the end of the IC code. The failure path restores the input registers, if','line_number':646,'multiline':False]['text':' needed, and jumps to the next stub.','line_number':647,'multiline':False]['text':' Flag to ensure FailurePath::label() isn't taken while there's a scratch','line_number':654,'multiline':False]['text':' float register which still needs to be restored.','line_number':655,'multiline':False]['text':' If canShareFailurePath(other) returns true, the same machine code will','line_number':689,'multiline':False]['text':' be emitted for two failure paths, so we can share them.','line_number':690,'multiline':False]['text':'*
 * Wrap an offset so that a call can decide to embed a constant
 * or load from the stub data.
 ','line_number':708,'multiline':True]['text':' Base class for BaselineCacheIRCompiler and IonCacheIRCompiler.','line_number':727,'multiline':False]['text':' Float registers that are live. Registers not in this set can be','line_number':753,'multiline':False]['text':' clobbered and don't need to be saved before performing a VM call.','line_number':754,'multiline':False]['text':' Doing this for non-float registers is a bit more complicated because','line_number':755,'multiline':False]['text':' the IC register allocator allocates GPRs.','line_number':756,'multiline':False]['text':' Distance from the IC to the stub data; mostly will be','line_number':762,'multiline':False]['text':' sizeof(stubType)','line_number':763,'multiline':False]['text':' Returns the set of volatile float registers that are live. These','line_number':786,'multiline':False]['text':' registers need to be saved when making non-GC calls with callWithABI.','line_number':787,'multiline':False]['text':' Instructions like GuardShape need Spectre mitigations if','line_number':794,'multiline':False]['text':' (1) mitigations are enabled and (2) the object is used by other','line_number':795,'multiline':False]['text':' instructions (if the object is *not* used by other instructions,','line_number':796,'multiline':False]['text':' zeroing its register is pointless).','line_number':797,'multiline':False]['text':' Ensures the IC's output register is available for writing.','line_number':939,'multiline':False]['text':' Instructions that have to perform a callVM require a stub frame. Call its','line_number':975,'multiline':False]['text':' enter() and leave() methods to enter/leave the stub frame.','line_number':976,'multiline':False]['text':' Hoisted from jit/BaselineCacheIRCompiler.cpp. See there for method','line_number':977,'multiline':False]['text':' definitions.','line_number':978,'multiline':False]['text':' AutoSaveLiveRegisters must be used when we make a call that can GC. The','line_number':999,'multiline':False]['text':' constructor ensures all live registers are stored on the stack (where the GC','line_number':1000,'multiline':False]['text':' expects them) and the destructor restores these registers.','line_number':1001,'multiline':False]['text':' Like AutoScratchRegister, but reuse a register of |output| if possible.','line_number':1013,'multiline':False]['text':' Like AutoScratchRegisterMaybeOutput, but tries to use the ValueOperand's','line_number':1037,'multiline':False]['text':' type register for the scratch register on 32-bit.','line_number':1038,'multiline':False]['text':'','line_number':1039,'multiline':False]['text':' Word of warning: Passing an instance of this class and AutoOutputRegister to','line_number':1040,'multiline':False]['text':' functions may not work correctly, because no guarantee is given that the type','line_number':1041,'multiline':False]['text':' register is used last when modifying the output's ValueOperand.','line_number':1042,'multiline':False]['text':' AutoCallVM is a wrapper class that unifies methods shared by','line_number':1070,'multiline':False]['text':' IonCacheIRCompiler and BaselineCacheIRCompiler that perform a callVM, but','line_number':1071,'multiline':False]['text':' require stub specific functionality before performing the VM call.','line_number':1072,'multiline':False]['text':'','line_number':1073,'multiline':False]['text':' Expected Usage:','line_number':1074,'multiline':False]['text':'','line_number':1075,'multiline':False]['text':'   OPs with implementations that may be unified by this class must:','line_number':1076,'multiline':False]['text':'     - Be listed in the CACHEIR_OPS list but not in the CACHE_IR_SHARED_OPS','line_number':1077,'multiline':False]['text':'     list','line_number':1078,'multiline':False]['text':'     - Differ only in their use of `AutoSaveLiveRegisters`,','line_number':1079,'multiline':False]['text':'       `AutoOutputRegister`, and `AutoScratchRegister`. The Ion','line_number':1080,'multiline':False]['text':'       implementation will use `AutoSaveLiveRegisters` and','line_number':1081,'multiline':False]['text':'       `AutoOutputRegister`, while the Baseline implementation will use','line_number':1082,'multiline':False]['text':'       `AutoScratchRegister`.','line_number':1083,'multiline':False]['text':'     - Both use the `callVM` method.','line_number':1084,'multiline':False]['text':'','line_number':1085,'multiline':False]['text':'   Using AutoCallVM:','line_number':1086,'multiline':False]['text':'     - The constructor initializes `AutoOutputRegister` for both compiler','line_number':1087,'multiline':False]['text':'       types. Additionally it initializes an `AutoSaveLiveRegisters` for','line_number':1088,'multiline':False]['text':'       CacheIRCompilers with the mode Ion, and initializes','line_number':1089,'multiline':False]['text':'       `AutoScratchRegisterMaybeOutput` and `AutoStubFrame` variables for','line_number':1090,'multiline':False]['text':'       compilers with mode Baseline.','line_number':1091,'multiline':False]['text':'     - The `prepare()` method calls the IonCacheIRCompiler method','line_number':1092,'multiline':False]['text':'       `prepareVMCall` for IonCacheIRCompilers, calls the `enter()` method of','line_number':1093,'multiline':False]['text':'       `AutoStubFrame` for BaselineCacheIRCompilers, and calls the','line_number':1094,'multiline':False]['text':'       `discardStack` method of the `Register` class for both compiler types.','line_number':1095,'multiline':False]['text':'     - The `call()` method invokes `callVM` on the CacheIRCompiler and stores','line_number':1096,'multiline':False]['text':'       the call result according to its type. Finally it calls the `leave`','line_number':1097,'multiline':False]['text':'       method of `AutoStubFrame` for BaselineCacheIRCompilers.','line_number':1098,'multiline':False]['text':'','line_number':1099,'multiline':False]['text':'   Expected Usage Example:','line_number':1100,'multiline':False]['text':'     See: `CacheIRCompiler::emitCallGetSparseElementResult()`','line_number':1101,'multiline':False]['text':'','line_number':1102,'multiline':False]['text':' Restrictions:','line_number':1103,'multiline':False]['text':'   - OPs that do not meet the criteria listed above can not be unified with','line_number':1104,'multiline':False]['text':'     AutoCallVM','line_number':1105,'multiline':False]['text':'','line_number':1106,'multiline':False]['text':' Baseline specific stuff','line_number':1114,'multiline':False]['text':' Ion specific stuff','line_number':1118,'multiline':False]['text':' RAII class to allocate FloatReg0 as a scratch register and release it when','line_number':1151,'multiline':False]['text':' we're done with it. The previous contents of FloatReg0 may be spilled on the','line_number':1152,'multiline':False]['text':' stack and, if necessary, are restored when the destructor runs.','line_number':1153,'multiline':False]['text':'','line_number':1154,'multiline':False]['text':' When FailurePath is passed to the constructor, FailurePath::label() must not','line_number':1155,'multiline':False]['text':' be used during the life time of the AutoScratchFloatRegister. Instead use','line_number':1156,'multiline':False]['text':' AutoScratchFloatRegister::failure().','line_number':1157,'multiline':False]['text':' This class can be used to assert a certain FloatRegister is available. In','line_number':1180,'multiline':False]['text':' Baseline mode, all float registers are available. In Ion mode, only the','line_number':1181,'multiline':False]['text':' registers added as fixed temps in LIRGenerator are available.','line_number':1182,'multiline':False]['text':' See the 'Sharing Baseline stub code' comment in CacheIR.h for a description','line_number':1202,'multiline':False]['text':' of this class.','line_number':1203,'multiline':False]['text':' These fields don't require 8 bits, but GCC complains if these fields are','line_number':1205,'multiline':False]['text':' smaller than the size of the enums.','line_number':1206,'multiline':False]['text':' namespace jit','line_number':1278,'multiline':False]['text':' namespace js','line_number':1279,'multiline':False]['text':' jit_CacheIRCompiler_h ','line_number':1281,'multiline':True]