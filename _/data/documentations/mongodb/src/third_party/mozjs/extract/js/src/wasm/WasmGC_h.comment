['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2019 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]['text':' For ABIArgIter','line_number':24,'multiline':False]['text':' namespace jit','line_number':33,'multiline':False]['text':' Definitions for stackmaps.','line_number':39,'multiline':False]['text':' A StackMap is a bit-array containing numMappedWords bits, one bit per','line_number':44,'multiline':False]['text':' word of stack.  Bit index zero is for the lowest addressed word in the','line_number':45,'multiline':False]['text':' range.','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' This is a variable-length structure whose size must be known at creation','line_number':48,'multiline':False]['text':' time.','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' Users of the map will know the address of the wasm::Frame that is covered','line_number':51,'multiline':False]['text':' by this map.  In order that they can calculate the exact address range','line_number':52,'multiline':False]['text':' covered by the map, the map also stores the offset, from the highest','line_number':53,'multiline':False]['text':' addressed word of the map, of the embedded wasm::Frame.  This is an','line_number':54,'multiline':False]['text':' offset down from the highest address, rather than up from the lowest, so','line_number':55,'multiline':False]['text':' as to limit its range to 11 bits, where','line_number':56,'multiline':False]['text':' 11 == ceil(log2(MaxParams * sizeof-biggest-param-type-in-words))','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':' The stackmap may also cover a DebugFrame (all DebugFrames get a map).  If','line_number':59,'multiline':False]['text':' so that can be noted, since users of the map need to trace pointers in a','line_number':60,'multiline':False]['text':' DebugFrame.','line_number':61,'multiline':False]['text':'','line_number':62,'multiline':False]['text':' Finally, for sanity checking only, for stackmaps associated with a wasm','line_number':63,'multiline':False]['text':' trap exit stub, the number of words used by the trap exit stub save area','line_number':64,'multiline':False]['text':' is also noted.  This is used in Instance::traceFrame to check that the','line_number':65,'multiline':False]['text':' TrapExitDummyValue is in the expected place in the frame.','line_number':66,'multiline':False]['text':' The total number of stack words covered by the map ..','line_number':68,'multiline':False]['text':' .. of which this many are "exit stub" extras','line_number':71,'multiline':False]['text':' Where is Frame* relative to the top?  This is an offset in words.','line_number':74,'multiline':False]['text':' Notes the presence of a DebugFrame.  The DebugFrame may or may not contain','line_number':77,'multiline':False]['text':' GC-managed data but always gets a stackmap, as computing whether a stack','line_number':78,'multiline':False]['text':' map is definitively needed is brittle and ultimately not a worthwhile','line_number':79,'multiline':False]['text':' optimization.','line_number':80,'multiline':False]['text':' Record the number of words in the map used as a wasm trap exit stub','line_number':112,'multiline':False]['text':' save area.  See comment above.','line_number':113,'multiline':False]['text':' Record the offset from the highest-addressed word of the map, that the','line_number':121,'multiline':False]['text':' wasm::Frame lives at.  See comment above.','line_number':122,'multiline':False]['text':' If the frame described by this StackMap includes a DebugFrame, call here to','line_number':130,'multiline':False]['text':' record that fact.','line_number':131,'multiline':False]['text':' This is the expected size for a map that covers 32 or fewer words.','line_number':162,'multiline':False]['text':' A Maplet holds a single code-address-to-map binding.  Note that the','line_number':167,'multiline':False]['text':' code address is the lowest address of the instruction immediately','line_number':168,'multiline':False]['text':' following the instruction of interest, not of the instruction of','line_number':169,'multiline':False]['text':' interest itself.  In practice (at least for the Wasm Baseline compiler)','line_number':170,'multiline':False]['text':' this means that |nextInsnAddr| points either immediately after a call','line_number':171,'multiline':False]['text':' instruction, after a trap instruction or after a no-op.','line_number':172,'multiline':False]['text':' Supporting code for creation of stackmaps.','line_number':252,'multiline':False]['text':' StackArgAreaSizeUnaligned returns the size, in bytes, of the stack arg area','line_number':254,'multiline':False]['text':' size needed to pass |argTypes|, excluding any alignment padding beyond the','line_number':255,'multiline':False]['text':' size of the area as a whole.  The size is as determined by the platforms','line_number':256,'multiline':False]['text':' native ABI.','line_number':257,'multiline':False]['text':'','line_number':258,'multiline':False]['text':' StackArgAreaSizeAligned returns the same, but rounded up to the nearest 16','line_number':259,'multiline':False]['text':' byte boundary.','line_number':260,'multiline':False]['text':'','line_number':261,'multiline':False]['text':' Note, StackArgAreaSize{Unaligned,Aligned}() must process all the arguments','line_number':262,'multiline':False]['text':' in order to take into account all necessary alignment constraints.  The','line_number':263,'multiline':False]['text':' signature must include any receiver argument -- in other words, it must be','line_number':264,'multiline':False]['text':' the complete native-ABI-level call signature.','line_number':265,'multiline':False]['text':' WasmABIArgIter::ABIArgIter wants the items to be iterated over to be','line_number':277,'multiline':False]['text':' presented in some type that has methods length() and operator[].  So we','line_number':278,'multiline':False]['text':' have to wrap up |saSig|'s array of types in this API-matching class.','line_number':279,'multiline':False]['text':' Assert, at least crudely, that we're not accidentally going to run off','line_number':291,'multiline':False]['text':' the end of the array of types, nor into undefined parts of it, while','line_number':292,'multiline':False]['text':' iterating.','line_number':293,'multiline':False]['text':'the end marker','line_number':296,'multiline':True]['text':' A stackmap creation helper.  Create a stackmap from a vector of booleans.','line_number':311,'multiline':False]['text':' The caller owns the resulting stackmap.','line_number':312,'multiline':False]['text':' Generate a stackmap for a function's stack-overflow-at-entry trap, with','line_number':319,'multiline':False]['text':' the structure:','line_number':320,'multiline':False]['text':'','line_number':321,'multiline':False]['text':'    <reg dump area>','line_number':322,'multiline':False]['text':'    |       ++ <space reserved before trap, if any>','line_number':323,'multiline':False]['text':'    |               ++ <space for Frame>','line_number':324,'multiline':False]['text':'    |                       ++ <inbound arg area>','line_number':325,'multiline':False]['text':'    |                                           |','line_number':326,'multiline':False]['text':'    Lowest Addr                                 Highest Addr','line_number':327,'multiline':False]['text':'','line_number':328,'multiline':False]['text':' The caller owns the resulting stackmap.  This assumes a grow-down stack.','line_number':329,'multiline':False]['text':'','line_number':330,'multiline':False]['text':' For non-debug builds, if the stackmap would contain no pointers, no','line_number':331,'multiline':False]['text':' stackmap is created, and nullptr is returned.  For a debug build, a','line_number':332,'multiline':False]['text':' stackmap is always created and returned.','line_number':333,'multiline':False]['text':'','line_number':334,'multiline':False]['text':' The "space reserved before trap" is the space reserved by','line_number':335,'multiline':False]['text':' MacroAssembler::wasmReserveStackChecked, in the case where the frame is','line_number':336,'multiline':False]['text':' "small", as determined by that function.','line_number':337,'multiline':False]['text':' At a resumable wasm trap, the machine's registers are saved on the stack by','line_number':343,'multiline':False]['text':' (code generated by) GenerateTrapExit().  This function writes into |args| a','line_number':344,'multiline':False]['text':' vector of booleans describing the ref-ness of the saved integer registers.','line_number':345,'multiline':False]['text':' |args[0]| corresponds to the low addressed end of the described section of','line_number':346,'multiline':False]['text':' the save area.','line_number':347,'multiline':False]['text':' Shared write barrier code.','line_number':352,'multiline':False]['text':'','line_number':353,'multiline':False]['text':' A barriered store looks like this:','line_number':354,'multiline':False]['text':'','line_number':355,'multiline':False]['text':'   Label skipPreBarrier;','line_number':356,'multiline':False]['text':'   EmitWasmPreBarrierGuard(..., &skipPreBarrier);','line_number':357,'multiline':False]['text':'   <COMPILER-SPECIFIC ACTIONS HERE>','line_number':358,'multiline':False]['text':'   EmitWasmPreBarrierCall(...);','line_number':359,'multiline':False]['text':'   bind(&skipPreBarrier);','line_number':360,'multiline':False]['text':'','line_number':361,'multiline':False]['text':'   <STORE THE VALUE IN MEMORY HERE>','line_number':362,'multiline':False]['text':'','line_number':363,'multiline':False]['text':'   Label skipPostBarrier;','line_number':364,'multiline':False]['text':'   <COMPILER-SPECIFIC ACTIONS HERE>','line_number':365,'multiline':False]['text':'   EmitWasmPostBarrierGuard(..., &skipPostBarrier);','line_number':366,'multiline':False]['text':'   <CALL POST-BARRIER HERE IN A COMPILER-SPECIFIC WAY>','line_number':367,'multiline':False]['text':'   bind(&skipPostBarrier);','line_number':368,'multiline':False]['text':'','line_number':369,'multiline':False]['text':' The actions are divided up to allow other actions to be placed between them,','line_number':370,'multiline':False]['text':' such as saving and restoring live registers.  The postbarrier call invokes','line_number':371,'multiline':False]['text':' C++ and will kill all live registers.','line_number':372,'multiline':False]['text':' Before storing a GC pointer value in memory, skip to `skipBarrier` if the','line_number':374,'multiline':False]['text':' prebarrier is not needed.  Will clobber `scratch`.','line_number':375,'multiline':False]['text':'','line_number':376,'multiline':False]['text':' It is OK for `tls` and `scratch` to be the same register.','line_number':377,'multiline':False]['text':' Before storing a GC pointer value in memory, call out-of-line prebarrier','line_number':383,'multiline':False]['text':' code. This assumes `PreBarrierReg` contains the address that will be updated.','line_number':384,'multiline':False]['text':' On ARM64 it also assums that x28 (the PseudoStackPointer) has the same value','line_number':385,'multiline':False]['text':' as SP.  `PreBarrierReg` is preserved by the barrier function.  Will clobber','line_number':386,'multiline':False]['text':' `scratch`.','line_number':387,'multiline':False]['text':'','line_number':388,'multiline':False]['text':' It is OK for `tls` and `scratch` to be the same register.','line_number':389,'multiline':False]['text':' After storing a GC pointer value in memory, skip to `skipBarrier` if a','line_number':394,'multiline':False]['text':' postbarrier is not needed.  If the location being set is in an heap-allocated','line_number':395,'multiline':False]['text':' object then `object` must reference that object; otherwise it should be None.','line_number':396,'multiline':False]['text':' The value that was stored is `setValue`.  Will clobber `otherScratch` and','line_number':397,'multiline':False]['text':' will use other available scratch registers.','line_number':398,'multiline':False]['text':'','line_number':399,'multiline':False]['text':' `otherScratch` cannot be a designated scratch register.','line_number':400,'multiline':False]['text':' Check whether |nextPC| is a valid code address for a stackmap created by','line_number':408,'multiline':False]['text':' this compiler.','line_number':409,'multiline':False]['text':' namespace wasm','line_number':413,'multiline':False]['text':' namespace js','line_number':414,'multiline':False]['text':' wasm_gc_h','line_number':416,'multiline':False]