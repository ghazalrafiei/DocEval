['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]['text':' js::jit::JitActivation','line_number':22,'multiline':False]['text':'***************************************************************************','line_number':37,'multiline':True]['text':' WasmFrameIter implementation','line_number':38,'multiline':False]['text':' When the stack is captured during a trap (viz., to create the .stack','line_number':55,'multiline':False]['text':' for an Error object), use the pc/bytecode information captured by the','line_number':56,'multiline':False]['text':' signal handler in the runtime. Take care not to use this trap unwind','line_number':57,'multiline':False]['text':' state for wasm frames in the middle of a JitActivation, i.e., wasm frames','line_number':58,'multiline':False]['text':' that called into JIT frames before the trap.','line_number':59,'multiline':False]['text':' Otherwise, execution exits wasm code via an exit stub which sets exitFP','line_number':77,'multiline':False]['text':' to the exit stub's frame. Thus, in this case, we want to start iteration','line_number':78,'multiline':False]['text':' at the caller of the exit frame, whose Code, CodeRange and CallSite are','line_number':79,'multiline':False]['text':' indicated by the returnAddress of the exit stub's frame. If the caller','line_number':80,'multiline':False]['text':' was Ion, we can just skip the wasm frames.','line_number':81,'multiline':False]['text':' When the iterator is set to unwind, each time the iterator pops a frame,','line_number':96,'multiline':False]['text':' the JitActivation is updated so that the just-popped frame is no longer','line_number':97,'multiline':False]['text':' visible. This is necessary since Debugger::onLeaveFrame is called before','line_number':98,'multiline':False]['text':' popping each frame and, once onLeaveFrame is called for a given frame,','line_number':99,'multiline':False]['text':' that frame must not be visible to subsequent stack iteration (or it','line_number':100,'multiline':False]['text':' could be added as a "new" frame just as it becomes garbage).  When the','line_number':101,'multiline':False]['text':' frame is trapping, then exitFP is included in the callstack (otherwise,','line_number':102,'multiline':False]['text':' it is skipped, as explained above). So to unwind the innermost frame, we','line_number':103,'multiline':False]['text':' just clear the trapping state.','line_number':104,'multiline':False]['text':' We run into a frame pointer which has the low bit set,','line_number':118,'multiline':False]['text':' indicating this is a direct call from the jit into the wasm','line_number':119,'multiline':False]['text':' function's body. The call stack resembles this at this point:','line_number':120,'multiline':False]['text':'','line_number':121,'multiline':False]['text':' |---------------------|','line_number':122,'multiline':False]['text':' |      JIT FRAME      |','line_number':123,'multiline':False]['text':' | JIT FAKE EXIT FRAME | <-- tagged fp_->callerFP_','line_number':124,'multiline':False]['text':' |      WASM FRAME     | <-- fp_','line_number':125,'multiline':False]['text':' |---------------------|','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':' fp_->callerFP_ points to the fake exit frame set up by the jit caller,','line_number':128,'multiline':False]['text':' and the return-address-to-fp is in JIT code, thus doesn't belong to any','line_number':129,'multiline':False]['text':' wasm instance's code (in particular, there's no associated CodeRange).','line_number':130,'multiline':False]['text':' Mark the frame as such and untag FP.','line_number':131,'multiline':False]['text':' We're exiting via the interpreter entry; we can safely reset','line_number':159,'multiline':False]['text':' exitFP.','line_number':160,'multiline':False]['text':' This wasm function has been called through the generic JIT entry by','line_number':174,'multiline':False]['text':' a JIT caller, so the call stack resembles this:','line_number':175,'multiline':False]['text':'','line_number':176,'multiline':False]['text':' |---------------------|','line_number':177,'multiline':False]['text':' |      JIT FRAME      |','line_number':178,'multiline':False]['text':' |  JSJIT TO WASM EXIT | <-- fp_','line_number':179,'multiline':False]['text':' |    WASM JIT ENTRY   | <-- prevFP (already unwound)','line_number':180,'multiline':False]['text':' |      WASM FRAME     | (already unwound)','line_number':181,'multiline':False]['text':' |---------------------|','line_number':182,'multiline':False]['text':'','line_number':183,'multiline':False]['text':' The next value of FP is just a regular jit frame used as a marker to','line_number':184,'multiline':False]['text':' know that we should transition to a JSJit frame iterator.','line_number':185,'multiline':False]['text':' As a terrible hack to avoid changing the tons of places that pass around','line_number':263,'multiline':False]['text':' (url, line, column) tuples to instead passing around a Variant that','line_number':264,'multiline':False]['text':' stores a (url, func-index, bytecode-offset) tuple for wasm frames,','line_number':265,'multiline':False]['text':' wasm stuffs its tuple into the existing (url, line, column) tuple,','line_number':266,'multiline':False]['text':' tagging the high bit of the column to indicate "this is a wasm frame".','line_number':267,'multiline':False]['text':' When knowing clients see this bit, they shall render the tuple','line_number':268,'multiline':False]['text':' (url, line, column|bit) as "url:wasm-function[column]:0xline" according','line_number':269,'multiline':False]['text':' to the WebAssembly Web API's Developer-Facing Display Conventions.','line_number':270,'multiline':False]['text':'   https://webassembly.github.io/spec/web-api/index.html#conventions','line_number':271,'multiline':False]['text':' The wasm bytecode offset continues to be passed as the JS line to avoid','line_number':272,'multiline':False]['text':' breaking existing devtools code written when this used to be the case.','line_number':273,'multiline':False]['text':' Only non-imported functions can have debug frames.','line_number':297,'multiline':False]['text':'','line_number':298,'multiline':False]['text':' Metadata::debugEnabled is only set if debugging is actually enabled (both','line_number':299,'multiline':False]['text':' requested, and available via baseline compilation), and Tier::Debug code','line_number':300,'multiline':False]['text':' will be available.','line_number':301,'multiline':False]['text':' The next instruction is the instruction following the trap instruction.','line_number':323,'multiline':False]['text':'***************************************************************************','line_number':327,'multiline':True]['text':' Prologue/epilogue code generation','line_number':328,'multiline':False]['text':' These constants reflect statically-determined offsets in the','line_number':330,'multiline':False]['text':' prologue/epilogue. The offsets are dynamically asserted during code','line_number':331,'multiline':False]['text':' generation.','line_number':332,'multiline':False]['text':' On ARM64 we do not use push or pop; the prologues and epilogues are','line_number':350,'multiline':False]['text':' structured differently due to restrictions on SP alignment.  Even so,','line_number':351,'multiline':False]['text':' PushedRetAddr and PushedFP are used in some restricted contexts','line_number':352,'multiline':False]['text':' and must be superficially meaningful.','line_number':353,'multiline':False]['text':' Synthetic values to satisfy asserts and avoid compiler warnings.','line_number':367,'multiline':False]['text':' WasmCall pushes a JitActivation.','line_number':378,'multiline':False]['text':' ProfilingFrameIterator needs to know the offsets of several key','line_number':411,'multiline':False]['text':' instructions from entry. To save space, we make these offsets static','line_number':412,'multiline':False]['text':' constants and assert that they match the actual codegen below. On ARM,','line_number':413,'multiline':False]['text':' this requires AutoForbidPoolsAndNops to prevent a constant pool from being','line_number':414,'multiline':False]['text':' randomly inserted between two instructions.','line_number':415,'multiline':False]['text':' The size of the prologue is constrained to be no larger than the difference','line_number':417,'multiline':False]['text':' between WasmCheckedTailEntryOffset and WasmCheckedCallEntryOffset; to','line_number':418,'multiline':False]['text':' conserve code space / avoid excessive padding, this difference is made as','line_number':419,'multiline':False]['text':' tight as possible.','line_number':420,'multiline':False]['text':' We do not use the PseudoStackPointer.  However, we may be called in a','line_number':436,'multiline':False]['text':' context -- compilation using Ion -- in which the PseudoStackPointer is','line_number':437,'multiline':False]['text':' in use.  Rather than risk confusion in the uses of `masm` here, let's','line_number':438,'multiline':False]['text':' just switch in the real SP, do what we need to do, and restore the','line_number':439,'multiline':False]['text':' existing setting afterwards.','line_number':440,'multiline':False]['text':' number of instructions in scope = ','line_number':445,'multiline':True]['text':' And restore the SP-reg setting, per comment above.','line_number':458,'multiline':False]['text':' number of instructions in scope = ','line_number':465,'multiline':True]['text':' The x86/x64 call instruction pushes the return address.','line_number':473,'multiline':False]['text':' See comment at equivalent place in |GenerateCallablePrologue| above.','line_number':509,'multiline':False]['text':' number of instructions in scope = ','line_number':513,'multiline':True]['text':' Reinitialise PSP from SP. This is less than elegant because the prologue','line_number':524,'multiline':False]['text':' operates on the raw stack pointer SP and does not keep the PSP in sync.','line_number':525,'multiline':False]['text':' We can't use initPseudoStackPtr here because we just set up masm to not','line_number':526,'multiline':False]['text':' use it.  Hence we have to do it "by hand".','line_number':527,'multiline':False]['text':' See comment at equivalent place in |GenerateCallablePrologue| above.','line_number':532,'multiline':False]['text':' Forbid pools for the same reason as described in GenerateCallablePrologue.','line_number':536,'multiline':False]['text':' number of instructions in scope = ','line_number':538,'multiline':True]['text':' There is an important ordering constraint here: fp must be repointed to','line_number':541,'multiline':False]['text':' the caller's frame before any field of the frame currently pointed to by','line_number':542,'multiline':False]['text':' fp is popped: asynchronous signal handlers (which use stack space','line_number':543,'multiline':False]['text':' starting at sp) could otherwise clobber these fields while they are still','line_number':544,'multiline':False]['text':' accessible via fp (fp fields are read during frame iteration which is','line_number':545,'multiline':False]['text':' *also* done asynchronously).','line_number':546,'multiline':False]['text':' These constants reflect statically-determined offsets between a function's','line_number':563,'multiline':False]['text':' checked call entry and the checked tail's entry, see diagram below.  The','line_number':564,'multiline':False]['text':' Entry is a call target, so must have CodeAlignment, but the TailEntry is','line_number':565,'multiline':False]['text':' only a jump target from a stub.','line_number':566,'multiline':False]['text':'','line_number':567,'multiline':False]['text':' The CheckedCallEntryOffset is normally zero.','line_number':568,'multiline':False]['text':'','line_number':569,'multiline':False]['text':' CheckedTailEntryOffset > CheckedCallEntryOffset, and if CPSIZE is the size','line_number':570,'multiline':False]['text':' of the callable prologue then TailEntryOffset - CallEntryOffset >= CPSIZE.','line_number':571,'multiline':False]['text':' It is a goal to keep that difference as small as possible to reduce the','line_number':572,'multiline':False]['text':' amount of padding inserted in the prologue.','line_number':573,'multiline':False]['text':' Flush pending pools so they do not get dumped between the 'begin' and','line_number':578,'multiline':False]['text':' 'uncheckedCallEntry' offsets since the difference must be less than','line_number':579,'multiline':False]['text':' UINT8_MAX to be stored in CodeRange::funcbeginToUncheckedCallEntry_.','line_number':580,'multiline':False]['text':' (Pending pools can be large.)','line_number':581,'multiline':False]['text':' We are going to generate the next code layout:','line_number':585,'multiline':False]['text':' ---------------------------------------------','line_number':586,'multiline':False]['text':' checked call entry:    callable prologue','line_number':587,'multiline':False]['text':' checked tail entry:    check signature','line_number':588,'multiline':False]['text':'                        jump functionBody','line_number':589,'multiline':False]['text':' unchecked call entry:  callable prologue','line_number':590,'multiline':False]['text':'                        functionBody','line_number':591,'multiline':False]['text':' -----------------------------------------------','line_number':592,'multiline':False]['text':' checked call entry - used for call_indirect when we have to check the','line_number':593,'multiline':False]['text':' signature.','line_number':594,'multiline':False]['text':'','line_number':595,'multiline':False]['text':' checked tail entry - used by indirect call trampolines which already','line_number':596,'multiline':False]['text':' had pushed Frame on the callee’s behalf.','line_number':597,'multiline':False]['text':'','line_number':598,'multiline':False]['text':' unchecked call entry - used for regular direct same-instance calls.','line_number':599,'multiline':False]['text':' Generate checked call entry. The BytecodeOffset of the trap is fixed up to','line_number':603,'multiline':False]['text':' be the bytecode offset of the callsite by JitActivation::startWasmTrap.','line_number':604,'multiline':False]['text':' Check that we did not overshoot the space budget for the prologue.','line_number':611,'multiline':False]['text':' Pad to WasmCheckedTailEntryOffset.  Don't use nopAlign because the target','line_number':615,'multiline':False]['text':' offset is not necessarily a power of two.  The expected number of NOPs here','line_number':616,'multiline':False]['text':' is very small.','line_number':617,'multiline':False]['text':' Signature check starts at WasmCheckedTailEntryOffset.','line_number':622,'multiline':False]['text':' The preceding code may have generated a small constant pool to support the','line_number':645,'multiline':False]['text':' comparison in the signature check.  But if we flush the pool here we will','line_number':646,'multiline':False]['text':' also force the creation of an unused branch veneer in the pool for the jump','line_number':647,'multiline':False]['text':' to functionBody from the signature check on some platforms, thus needlessly','line_number':648,'multiline':False]['text':' inflating the size of the prologue.','line_number':649,'multiline':False]['text':'','line_number':650,'multiline':False]['text':' On no supported platform that uses a pool (arm, arm64) is there any risk at','line_number':651,'multiline':False]['text':' present of that branch or other elements in the pool going out of range','line_number':652,'multiline':False]['text':' while we're generating the following padding and prologue, therefore no','line_number':653,'multiline':False]['text':' pool elements will be emitted in the prologue, therefore it is safe not to','line_number':654,'multiline':False]['text':' flush here.','line_number':655,'multiline':False]['text':'','line_number':656,'multiline':False]['text':' We assert that this holds at runtime by comparing the expected entry offset','line_number':657,'multiline':False]['text':' to the recorded ditto; if they are not the same then','line_number':658,'multiline':False]['text':' GenerateCallablePrologue flushed a pool before the prologue code, contrary','line_number':659,'multiline':False]['text':' to assumption.','line_number':660,'multiline':False]['text':' Generate unchecked call entry:','line_number':662,'multiline':False]['text':' GenerateCallablePrologue creates a prologue which operates on the raw','line_number':669,'multiline':False]['text':' stack pointer and does not keep the PSP in sync.  So we have to resync it','line_number':670,'multiline':False]['text':' here.  But we can't use initPseudoStackPtr here because masm may not be','line_number':671,'multiline':False]['text':' set up to use it, depending on which compiler is in use.  Hence do it','line_number':672,'multiline':False]['text':' "manually".','line_number':673,'multiline':False]['text':' See comment block in WasmCompile.cpp for an explanation tiering.','line_number':677,'multiline':False]['text':' Inverse of GenerateFunctionPrologue:','line_number':691,'multiline':False]['text':' This frame will be exiting compiled code to C++ so record the fp and','line_number':704,'multiline':False]['text':' reason in the JitActivation so the frame iterators can unwind.','line_number':705,'multiline':False]['text':' Inverse of GenerateExitPrologue:','line_number':714,'multiline':False]['text':' As a general stack invariant, if Activation::packedExitFP is tagged as','line_number':721,'multiline':False]['text':' wasm, it must point to a valid wasm::Frame. The JIT exit stub calls into','line_number':722,'multiline':False]['text':' JIT code and thus does not really exit, thus, when entering/leaving the','line_number':723,'multiline':False]['text':' JIT exit stub from/to normal wasm code, packedExitFP is not tagged wasm.','line_number':724,'multiline':False]['text':' Inverse of GenerateJitExitPrologue:','line_number':751,'multiline':False]['text':' number of instructions in scope = ','line_number':765,'multiline':True]['text':' number of instructions in scope = ','line_number':774,'multiline':True]['text':' Subtract from SP first as SP must be aligned before offsetting.','line_number':777,'multiline':False]['text':' The x86/x64 call instruction pushes the return address.','line_number':782,'multiline':False]['text':' Save jit frame pointer, so unwinding from wasm to jit frames is trivial.','line_number':788,'multiline':False]['text':'***************************************************************************','line_number':797,'multiline':True]['text':' ProfilingFrameIterator','line_number':798,'multiline':False]['text':' Called via an inlined fast JIT to wasm call: in this case, FP is','line_number':835,'multiline':False]['text':' pointing in the middle of the exit frame, right before the exit','line_number':836,'multiline':False]['text':' footer; ensure the exit frame type is the expected one.','line_number':837,'multiline':False]['text':' This is a direct call from the JIT, the caller FP is pointing to a','line_number':881,'multiline':False]['text':' tagged JIT caller's frame.','line_number':882,'multiline':False]['text':' Since we don't have the pc for fp, start unwinding at the caller of fp.','line_number':892,'multiline':False]['text':' This means that the innermost frame is skipped. This is fine because:','line_number':893,'multiline':False]['text':'  - for import exit calls, the innermost frame is a thunk, so the first','line_number':894,'multiline':False]['text':'    frame that shows up is the function calling the import;','line_number':895,'multiline':False]['text':'  - for Math and other builtin calls, we note the absence of an exit','line_number':896,'multiline':False]['text':'    reason and inject a fake "builtin" frame; and','line_number':897,'multiline':False]['text':' checked call entry:    1. push Frame','line_number':934,'multiline':False]['text':'                        2. set FP','line_number':935,'multiline':False]['text':'                        3. signature check <--- check if we are here.','line_number':936,'multiline':False]['text':'                        4. jump 7','line_number':937,'multiline':False]['text':' unchecked call entry:  5. push Frame','line_number':938,'multiline':False]['text':'                        6. set FP','line_number':939,'multiline':False]['text':'                        7. function's code','line_number':940,'multiline':False]['text':' It is a direct call from JIT.','line_number':948,'multiline':False]['text':' Shorthands.','line_number':980,'multiline':False]['text':' The frame pointer might be:','line_number':984,'multiline':False]['text':' - in the process of tagging/untagging when calling into the JITs;','line_number':985,'multiline':False]['text':' make sure it's untagged.','line_number':986,'multiline':False]['text':' - tagged by an direct JIT call.','line_number':987,'multiline':False]['text':' - unreliable if it's not been set yet, in prologues.','line_number':988,'multiline':False]['text':' Get the CodeRange describing pc and the base address to which the','line_number':993,'multiline':False]['text':' CodeRange is relative. If the pc is not in a wasm module or a builtin','line_number':994,'multiline':False]['text':' thunk, then execution must be entering from or leaving to the C++ caller','line_number':995,'multiline':False]['text':' that pushed the JitActivation.','line_number':996,'multiline':False]['text':' When the pc is inside the prologue/epilogue, the innermost call's Frame','line_number':1010,'multiline':False]['text':' is not complete and thus fp points to the second-to-innermost call's','line_number':1011,'multiline':False]['text':' Frame. Since fp can only tell you about its caller, naively unwinding','line_number':1012,'multiline':False]['text':' while pc is in the prologue/epilogue would skip the second-to-innermost','line_number':1013,'multiline':False]['text':' call. To avoid this problem, we use the static structure of the code in','line_number':1014,'multiline':False]['text':' the prologue and epilogue to do the Right Thing.','line_number':1015,'multiline':False]['text':' Compute the offset of the pc from the (unchecked call) entry of the code','line_number':1020,'multiline':False]['text':' range. The checked call entry and the unchecked call entry have common','line_number':1021,'multiline':False]['text':' prefix, so pc before signature check in the checked call entry is','line_number':1022,'multiline':False]['text':' equivalent to the pc of the unchecked-call-entry. Thus, we can simplify the','line_number':1023,'multiline':False]['text':' below case analysis by redirecting all pc-in-checked-call-entry before','line_number':1024,'multiline':False]['text':' signature check cases to the pc-at-unchecked-call-entry case.','line_number':1025,'multiline':False]['text':' Most cases end up unwinding to the caller state; not unwinding is the','line_number':1037,'multiline':False]['text':' exception here.','line_number':1038,'multiline':False]['text':' The FarJumpIsland sequence temporary scrambles ra.','line_number':1052,'multiline':False]['text':' Don't unwind to caller.','line_number':1053,'multiline':False]['text':' On MIPS we rely on register state instead of state saved on','line_number':1061,'multiline':False]['text':' stack until the wasm::Frame is completely built.','line_number':1062,'multiline':False]['text':' On entry the return address is in ra (registers.lr) and','line_number':1063,'multiline':False]['text':' fp holds the caller's fp.','line_number':1064,'multiline':False]['text':' Constraints above ensure that this covers BeforePushRetAddr and','line_number':1071,'multiline':False]['text':' PushedRetAddr.','line_number':1072,'multiline':False]['text':'','line_number':1073,'multiline':False]['text':' On ARM64 we subtract the size of the Frame from SP and then store','line_number':1074,'multiline':False]['text':' values into the stack.  Execution can be interrupted at various','line_number':1075,'multiline':False]['text':' places in that sequence.  We rely on the register state for our','line_number':1076,'multiline':False]['text':' values.','line_number':1077,'multiline':False]['text':' The return address is still in lr and fp holds the caller's fp.','line_number':1084,'multiline':False]['text':' The return address has been pushed on the stack but fp still','line_number':1091,'multiline':False]['text':' points to the caller's fp.','line_number':1092,'multiline':False]['text':' The full Frame has been pushed; fp is still the caller's fp.','line_number':1097,'multiline':False]['text':' The fixedFP field of the Frame has been loaded into fp.','line_number':1109,'multiline':False]['text':' The ra and TLS might also be loaded, but the Frame structure is','line_number':1110,'multiline':False]['text':' still on stack, so we can acess the ra form there.','line_number':1111,'multiline':False]['text':' The stack pointer does not move until all values have','line_number':1117,'multiline':False]['text':' been restored so several cases can be coalesced here.','line_number':1118,'multiline':False]['text':' The fixedFP field of the Frame has been popped into fp.','line_number':1127,'multiline':False]['text':' Both the TLS and fixedFP fields have been popped and fp now','line_number':1132,'multiline':False]['text':' points to the caller's frame.','line_number':1133,'multiline':False]['text':' The jit exit contains a range where the value of FP can't be','line_number':1140,'multiline':False]['text':' trusted. Technically, we could recover fp from sp, but since','line_number':1141,'multiline':False]['text':' the range is so short, for now just drop the stack.','line_number':1142,'multiline':False]['text':' Frame have been pushed and FP has been set.','line_number':1150,'multiline':False]['text':' Not in the prologue/epilogue.','line_number':1158,'multiline':False]['text':' These code stubs execute after the prologue/epilogue have completed','line_number':1169,'multiline':False]['text':' so pc/fp contains the right values here.','line_number':1170,'multiline':False]['text':' The entry trampoline is the final frame in an wasm JitActivation. The','line_number':1178,'multiline':False]['text':' entry trampoline also doesn't GeneratePrologue/Epilogue so we can't','line_number':1179,'multiline':False]['text':' use the general unwinding logic above.','line_number':1180,'multiline':False]['text':' There's a jit frame above the current one; we don't care about pc','line_number':1183,'multiline':False]['text':' since the Jit entry frame is a jit frame which can be considered as','line_number':1184,'multiline':False]['text':' an exit frame.','line_number':1185,'multiline':False]['text':' We haven't pushed the jit return address yet, thus the jit','line_number':1189,'multiline':False]['text':' frame is incomplete. During profiling frame iteration, it means','line_number':1190,'multiline':False]['text':' that the jit profiling frame iterator won't be able to unwind','line_number':1191,'multiline':False]['text':' this frame; drop it.','line_number':1192,'multiline':False]['text':' On the error return path, FP might be set to FailFP. Ignore these','line_number':1200,'multiline':False]['text':' transient frames.','line_number':1201,'multiline':False]['text':' The throw stub executes a small number of instructions before popping','line_number':1207,'multiline':False]['text':' the entire activation. To simplify testing, we simply pretend throw','line_number':1208,'multiline':False]['text':' stubs have already popped the entire stack.','line_number':1209,'multiline':False]['text':' Let wasmExitFP take precedence to StartUnwinding when it is set since','line_number':1229,'multiline':False]['text':' during the body of an exit stub, the register state may not be valid','line_number':1230,'multiline':False]['text':' causing StartUnwinding() to abandon unwinding this activation.','line_number':1231,'multiline':False]['text':' In the case of a function call, if the original FP value is tagged,','line_number':1250,'multiline':False]['text':' then we're being called through a direct JIT call (the interpreter','line_number':1251,'multiline':False]['text':' and the jit entry don't set FP's low bit). We can't observe','line_number':1252,'multiline':False]['text':' transient tagged values of FP (during wasm::SetExitFP) here because','line_number':1253,'multiline':False]['text':' StartUnwinding would not have unwound then.','line_number':1254,'multiline':False]['text':' See comment above. The only way to get a tagged FP here means that','line_number':1262,'multiline':False]['text':' the caller is a fast JIT caller which called into a wasm function.','line_number':1263,'multiline':False]['text':' The parent frame is an inlined wasm call, the tagged FP points to','line_number':1324,'multiline':False]['text':' the fake exit frame.','line_number':1325,'multiline':False]['text':' Use the same string for both time inside and under so that the two','line_number':1545,'multiline':False]['text':' entries will be coalesced by the profiler.','line_number':1546,'multiline':False]['text':' Must be kept in sync with /tools/profiler/tests/test_asm.js','line_number':1547,'multiline':False]