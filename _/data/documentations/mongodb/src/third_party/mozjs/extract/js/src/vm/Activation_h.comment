['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' MOZ_ASSERT','line_number':10,'multiline':False]['text':' MOZ_RAII','line_number':11,'multiline':False]['text':' size_t','line_number':13,'multiline':False]['text':' uint8_t, uint32_t','line_number':14,'multiline':False]['text':' JS_PUBLIC_API','line_number':16,'multiline':False]['text':' js::jit::CalleeToken','line_number':18,'multiline':False]['text':' JS::CallArgs','line_number':19,'multiline':False]['text':' JS::Handle, JS::Rooted','line_number':20,'multiline':False]['text':' jsbytecode','line_number':21,'multiline':False]['text':' js::UniquePtr','line_number':22,'multiline':False]['text':' JS::Value','line_number':23,'multiline':False]['text':' js::SavedFrame','line_number':24,'multiline':False]['text':' js::InterpreterRegs','line_number':25,'multiline':False]['text':' namespace dbg','line_number':39,'multiline':False]['text':' namespace JS','line_number':41,'multiline':False]['text':' namespace jit','line_number':51,'multiline':False]['text':' This class is separate from Activation, because it calls Compartment::wrap()','line_number':53,'multiline':False]['text':' which can GC and walk the stack. It's not safe to do that within the','line_number':54,'multiline':False]['text':' JitActivation constructor.','line_number':55,'multiline':False]['text':' The entry point monitor that was set on cx_->runtime() when this','line_number':59,'multiline':False]['text':' ActivationEntryMonitor was created.','line_number':60,'multiline':False]['text':' [SMDOC] LiveSavedFrameCache: SavedFrame caching to minimize stack walking','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' Since each SavedFrame object includes a 'parent' pointer to the SavedFrame','line_number':81,'multiline':False]['text':' for its caller, if we could easily find the right SavedFrame for a given','line_number':82,'multiline':False]['text':' stack frame, we wouldn't need to walk the rest of the stack. Traversing deep','line_number':83,'multiline':False]['text':' stacks can be expensive, and when we're profiling or instrumenting code, we','line_number':84,'multiline':False]['text':' may want to capture JavaScript stacks frequently, so such cases would benefit','line_number':85,'multiline':False]['text':' if we could avoid walking the entire stack.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' We could have a cache mapping frame addresses to their SavedFrame objects,','line_number':88,'multiline':False]['text':' but invalidating its entries would be a challenge. Popping a stack frame is','line_number':89,'multiline':False]['text':' extremely performance-sensitive, and SpiderMonkey stack frames can be OSR'd,','line_number':90,'multiline':False]['text':' thrown, rematerialized, and perhaps meet other fates; we would rather our','line_number':91,'multiline':False]['text':' cache not depend on handling so many tricky cases.','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':' It turns out that we can keep the cache accurate by reserving a single bit in','line_number':94,'multiline':False]['text':' the stack frame, which must be clear on any newly pushed frame. When we','line_number':95,'multiline':False]['text':' insert an entry into the cache mapping a given frame address to its','line_number':96,'multiline':False]['text':' SavedFrame, we set the bit in the frame. Then, we take care to probe the','line_number':97,'multiline':False]['text':' cache only for frames whose bit is set; the bit tells us that the frame has','line_number':98,'multiline':False]['text':' never left the stack, so its cache entry must be accurate, at least about','line_number':99,'multiline':False]['text':' which function the frame is executing (the line may have changed; more about','line_number':100,'multiline':False]['text':' that below). The code refers to this bit as the 'hasCachedSavedFrame' flag.','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':' We could manage such a cache replacing least-recently used entries, but we','line_number':103,'multiline':False]['text':' can do better than that: the cache can be a stack, of which we need examine','line_number':104,'multiline':False]['text':' only entries from the top.','line_number':105,'multiline':False]['text':'','line_number':106,'multiline':False]['text':' First, observe that stacks are walked from the youngest frame to the oldest,','line_number':107,'multiline':False]['text':' but SavedFrame chains are built from oldest to youngest, to ensure common','line_number':108,'multiline':False]['text':' tails are shared. This means that capturing a stack is necessarily a','line_number':109,'multiline':False]['text':' two-phase process: walk the stack, and then build the SavedFrames.','line_number':110,'multiline':False]['text':'','line_number':111,'multiline':False]['text':' Naturally, the first time we capture the stack, the cache is empty, and we','line_number':112,'multiline':False]['text':' must traverse the entire stack. As we build each SavedFrame, we push an entry','line_number':113,'multiline':False]['text':' associating the frame's address to its SavedFrame on the cache, and set the','line_number':114,'multiline':False]['text':' frame's bit. At the end, every frame has its bit set and an entry in the','line_number':115,'multiline':False]['text':' cache.','line_number':116,'multiline':False]['text':'','line_number':117,'multiline':False]['text':' Then the program runs some more. Some, none, or all of the frames are popped.','line_number':118,'multiline':False]['text':' Any new frames are pushed with their bit clear. Any frame with its bit set','line_number':119,'multiline':False]['text':' has never left the stack. The cache is left untouched.','line_number':120,'multiline':False]['text':'','line_number':121,'multiline':False]['text':' For the next capture, we walk the stack up to the first frame with its bit','line_number':122,'multiline':False]['text':' set, if there is one. Call it F; it must have a cache entry. We pop entries','line_number':123,'multiline':False]['text':' from the cache - all invalid, because they are above F's entry, and hence','line_number':124,'multiline':False]['text':' younger - until we find the entry matching F's address. Since F's bit is set,','line_number':125,'multiline':False]['text':' we know it never left the stack, and hence that no younger frame could have','line_number':126,'multiline':False]['text':' had a colliding address. And since the frame's bit was set when we pushed the','line_number':127,'multiline':False]['text':' cache entry, we know the entry is still valid.','line_number':128,'multiline':False]['text':'','line_number':129,'multiline':False]['text':' F's cache entry's SavedFrame covers the rest of the stack, so we don't need','line_number':130,'multiline':False]['text':' to walk the stack any further. Now we begin building SavedFrame objects for','line_number':131,'multiline':False]['text':' the new frames, pushing cache entries, and setting bits on the frames. By the','line_number':132,'multiline':False]['text':' end, the cache again covers the full stack, and every frame's bit is set.','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':' If we walk the stack to the end, and find no frame with its bit set, then the','line_number':135,'multiline':False]['text':' entire cache is invalid. At this point, it must be emptied, so that the new','line_number':136,'multiline':False]['text':' entries we are about to push are the only frames in the cache.','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' For example, suppose we have the following stack (let 'A > B' mean "A called','line_number':139,'multiline':False]['text':' B", so the frames are listed oldest first):','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':'     P  > Q  > R  > S          Initial stack, bits not set.','line_number':142,'multiline':False]['text':'     P* > Q* > R* > S*         Capture a SavedFrame stack, set bits.','line_number':143,'multiline':False]['text':'                               The cache now holds: P > Q > R > S.','line_number':144,'multiline':False]['text':'     P* > Q* > R*              Return from S.','line_number':145,'multiline':False]['text':'     P* > Q*                   Return from R.','line_number':146,'multiline':False]['text':'     P* > Q* > T  > U          Call T and U. New frames have clear bits.','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':' If we capture the stack now, the cache still holds:','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':'     P  > Q  > R  > S','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':' As we traverse the stack, we'll cross U and T, and then find Q with its bit','line_number':153,'multiline':False]['text':' set. We pop entries from the cache until we find the entry for Q; this','line_number':154,'multiline':False]['text':' removes entries R and S, which were indeed invalid. In Q's cache entry, we','line_number':155,'multiline':False]['text':' find the SavedFrame representing the stack P > Q. Now we build SavedFrames','line_number':156,'multiline':False]['text':' for the new portion of the stack, pushing an entry for T and setting the bit','line_number':157,'multiline':False]['text':' on the frame, and then doing the same for U. In the end, the call stack again','line_number':158,'multiline':False]['text':' has bits set on all its frames:','line_number':159,'multiline':False]['text':'','line_number':160,'multiline':False]['text':'     P* > Q* > T* > U*         All frames are now in the cache.','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':' And the cache again holds entries for the entire stack:','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':'     P  > Q  > T  > U','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':' Details:','line_number':167,'multiline':False]['text':'','line_number':168,'multiline':False]['text':' - When we find a cache entry whose frame address matches our frame F, we know','line_number':169,'multiline':False]['text':'   that F has never left the stack, but it may certainly be the case that','line_number':170,'multiline':False]['text':'   execution took place in that frame, and that the current source position','line_number':171,'multiline':False]['text':'   within F's function has changed. This means that the entry's SavedFrame,','line_number':172,'multiline':False]['text':'   which records the source line and column as well as the function, is not','line_number':173,'multiline':False]['text':'   correct. To detect this case, when we push a cache entry, we record the','line_number':174,'multiline':False]['text':'   frame's pc. When consulting the cache, if a frame's address matches but its','line_number':175,'multiline':False]['text':'   pc does not, then we pop the cache entry, clear the frame's bit, and','line_number':176,'multiline':False]['text':'   continue walking the stack. The next stack frame will definitely hit: since','line_number':177,'multiline':False]['text':'   its callee frame never left the stack, the calling frame never got the','line_number':178,'multiline':False]['text':'   chance to execute.','line_number':179,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' - Generators, at least conceptually, have long-lived stack frames that','line_number':181,'multiline':False]['text':'   disappear from the stack when the generator yields, and reappear on the','line_number':182,'multiline':False]['text':'   stack when the generator's 'next' method is called. When a generator's','line_number':183,'multiline':False]['text':'   frame is placed again atop the stack, its bit must be cleared - for the','line_number':184,'multiline':False]['text':'   purposes of the cache, treating the frame as a new frame - to respect the','line_number':185,'multiline':False]['text':'   invariants we used to justify the algorithm above. Async function','line_number':186,'multiline':False]['text':'   activations usually appear atop empty stacks, since they are invoked as a','line_number':187,'multiline':False]['text':'   promise callback, but the same rule applies.','line_number':188,'multiline':False]['text':'','line_number':189,'multiline':False]['text':' - SpiderMonkey has many types of stack frames, and not all have a place to','line_number':190,'multiline':False]['text':'   store a bit indicating a cached SavedFrame. But as long as we don't create','line_number':191,'multiline':False]['text':'   cache entries for frames we can't mark, simply omitting them from the cache','line_number':192,'multiline':False]['text':'   is harmless. Uncacheable frame types include inlined Ion frames and','line_number':193,'multiline':False]['text':'   non-Debug wasm frames. The LiveSavedFrameCache::FramePtr type represents','line_number':194,'multiline':False]['text':'   only pointers to frames that can be cached, so if you have a FramePtr, you','line_number':195,'multiline':False]['text':'   don't need to further check the frame for cachability. FramePtr provides','line_number':196,'multiline':False]['text':'   access to the hasCachedSavedFrame bit.','line_number':197,'multiline':False]['text':'','line_number':198,'multiline':False]['text':' - We actually break up the cache into one cache per Activation. Popping an','line_number':199,'multiline':False]['text':'   activation invalidates all its cache entries, simply by freeing the cache','line_number':200,'multiline':False]['text':'   altogether.','line_number':201,'multiline':False]['text':'','line_number':202,'multiline':False]['text':' - The entire chain of SavedFrames for a given stack capture is created in the','line_number':203,'multiline':False]['text':'   compartment of the code that requested the capture, *not* in that of the','line_number':204,'multiline':False]['text':'   frames it represents, so in general, different compartments may have','line_number':205,'multiline':False]['text':'   different SavedFrame objects representing the same actual stack frame. The','line_number':206,'multiline':False]['text':'   LiveSavedFrameCache simply records whichever SavedFrames were used in the','line_number':207,'multiline':False]['text':'   most recent captures. When we find a cache hit, we check the entry's','line_number':208,'multiline':False]['text':'   SavedFrame's compartment against the current compartment; if they do not','line_number':209,'multiline':False]['text':'   match, we clear the entire cache.','line_number':210,'multiline':False]['text':'','line_number':211,'multiline':False]['text':'   This means that it is not always true that, if a frame's','line_number':212,'multiline':False]['text':'   hasCachedSavedFrame bit is set, it must have an entry in the cache. The','line_number':213,'multiline':False]['text':'   actual invariant is: either the cache is completely empty, or the frames'','line_number':214,'multiline':False]['text':'   bits are trustworthy. This invariant holds even though capture can be','line_number':215,'multiline':False]['text':'   interrupted at many places by OOM failures. Clearing the cache is a single,','line_number':216,'multiline':False]['text':'   uninterruptible step. When we try to look up a frame whose bit is set and','line_number':217,'multiline':False]['text':'   find an empty cache, we clear the frame's bit. And we only add the first','line_number':218,'multiline':False]['text':'   frame to an empty cache once we've walked the stack all the way, so we know','line_number':219,'multiline':False]['text':'   that all frames' bits are cleared by that point.','line_number':220,'multiline':False]['text':'','line_number':221,'multiline':False]['text':' - When the Debugger API evaluates an expression in some frame (the 'target','line_number':222,'multiline':False]['text':'   frame'), it's SpiderMonkey's convention that the target frame be treated as','line_number':223,'multiline':False]['text':'   the parent of the eval frame. In reality, of course, the eval frame is','line_number':224,'multiline':False]['text':'   pushed on the top of the stack like any other frame, but stack captures','line_number':225,'multiline':False]['text':'   simply jump straight over the intervening frames, so that the '.parent'','line_number':226,'multiline':False]['text':'   property of a SavedFrame for the eval is the SavedFrame for the target.','line_number':227,'multiline':False]['text':'   This is arranged by giving the eval frame an 'evalInFramePrev` link','line_number':228,'multiline':False]['text':'   pointing to the target, which an ordinary FrameIter will notice and','line_number':229,'multiline':False]['text':'   respect.','line_number':230,'multiline':False]['text':'','line_number':231,'multiline':False]['text':'   If the LiveSavedFrameCache were presented with stack traversals that','line_number':232,'multiline':False]['text':'   skipped frames in this way, it would cause havoc. First, with no debugger','line_number':233,'multiline':False]['text':'   eval frames present, capture the stack, populating the cache. Then push a','line_number':234,'multiline':False]['text':'   debugger eval frame and capture again; the skipped frames to appear to be','line_number':235,'multiline':False]['text':'   absent from the stack. Now pop the debugger eval frame, and capture a third','line_number':236,'multiline':False]['text':'   time: the no-longer-skipped frames seem to reappear on the stack, with','line_number':237,'multiline':False]['text':'   their cached bits still set.','line_number':238,'multiline':False]['text':'','line_number':239,'multiline':False]['text':'   The LiveSavedFrameCache assumes that the stack it sees is used in a','line_number':240,'multiline':False]['text':'   stack-like fashion: if a frame has its bit set, it has never left the','line_number':241,'multiline':False]['text':'   stack. To support this assumption, when the cache is in use, we do not skip','line_number':242,'multiline':False]['text':'   the frames between a debugger eval frame an its target; we always traverse','line_number':243,'multiline':False]['text':'   the entire stack, invalidating and populating the cache in the usual way.','line_number':244,'multiline':False]['text':'   Instead, when we construct a SavedFrame for a debugger eval frame, we','line_number':245,'multiline':False]['text':'   select the appropriate parent at that point: rather than the next-older','line_number':246,'multiline':False]['text':'   frame, we find the SavedFrame for the eval's target frame. The skip appears','line_number':247,'multiline':False]['text':'   in the SavedFrame chains, even as the traversal covers all the frames.','line_number':248,'multiline':False]['text':'','line_number':249,'multiline':False]['text':' - Rematerialized frames (see ../jit/RematerializedFrame.h) are always created','line_number':250,'multiline':False]['text':'   with their hasCachedSavedFrame bits clear: although there may be extant','line_number':251,'multiline':False]['text':'   SavedFrames built from the original IonMonkey frame, the Rematerialized','line_number':252,'multiline':False]['text':'   frames will not have cache entries for them until they are traversed in a','line_number':253,'multiline':False]['text':'   capture themselves.','line_number':254,'multiline':False]['text':'','line_number':255,'multiline':False]['text':'   This means that, oddly, it is not always true that, once we reach a frame','line_number':256,'multiline':False]['text':'   with its hasCachedSavedFrame bit set, all its parents will have the bit set','line_number':257,'multiline':False]['text':'   as well. However, clear bits under younger set bits will only occur on','line_number':258,'multiline':False]['text':'   Rematerialized frames.','line_number':259,'multiline':False]['text':' The address of a live frame for which we can cache SavedFrames: it has a','line_number':262,'multiline':False]['text':' 'hasCachedSavedFrame' bit we can examine and set, and can be converted to','line_number':263,'multiline':False]['text':' a Key to index the cache.','line_number':264,'multiline':False]['text':' We use jit::CommonFrameLayout for both Baseline frames and Ion','line_number':266,'multiline':False]['text':' physical frames.','line_number':267,'multiline':False]['text':' If iter's frame is of a type that can be cached, construct a FramePtr','line_number':281,'multiline':False]['text':' for its frame. Otherwise, return Nothing.','line_number':282,'multiline':False]['text':' Return true if this FramePtr refers to an interpreter frame.','line_number':289,'multiline':False]['text':' If this FramePtr is an interpreter frame, return a pointer to it.','line_number':294,'multiline':False]['text':' Return true if this FramePtr refers to a rematerialized frame.','line_number':299,'multiline':False]['text':' A key in the cache: the address of a frame, live or dead, for which we','line_number':309,'multiline':False]['text':' can cache SavedFrames. Since the pointer may not be live, the only','line_number':310,'multiline':False]['text':' operation this type permits is comparison.','line_number':311,'multiline':False]['text':' Set |frame| to the cached SavedFrame corresponding to |framePtr| at |pc|.','line_number':366,'multiline':False]['text':' |framePtr|'s hasCachedSavedFrame bit must be set. Remove all cache','line_number':367,'multiline':False]['text':' entries for frames younger than that one.','line_number':368,'multiline':False]['text':'','line_number':369,'multiline':False]['text':' This may set |frame| to nullptr if |pc| is different from the pc supplied','line_number':370,'multiline':False]['text':' when the cache entry was inserted. In this case, the cached SavedFrame','line_number':371,'multiline':False]['text':' (probably) has the wrong source position. Entries for younger frames are','line_number':372,'multiline':False]['text':' still removed. The next frame, if any, will be a cache hit.','line_number':373,'multiline':False]['text':'','line_number':374,'multiline':False]['text':' This may also set |frame| to nullptr if the cache was populated with','line_number':375,'multiline':False]['text':' SavedFrame objects for a different compartment than cx's current','line_number':376,'multiline':False]['text':' compartment. In this case, the entire cache is flushed.','line_number':377,'multiline':False]['text':' Search the cache for a frame matching |framePtr|, without removing any','line_number':381,'multiline':False]['text':' entries. Return the matching saved frame, or nullptr if none is found.','line_number':382,'multiline':False]['text':' This is used for resolving |evalInFramePrev| links.','line_number':383,'multiline':False]['text':' Push a cache entry mapping |framePtr| and |pc| to |savedFrame| on the top','line_number':387,'multiline':False]['text':' of the cache's stack. You must insert entries for frames from oldest to','line_number':388,'multiline':False]['text':' youngest. They must all be younger than the frame that the |find| method','line_number':389,'multiline':False]['text':' found a hit for; or you must have cleared the entire cache with the','line_number':390,'multiline':False]['text':' |clear| method.','line_number':391,'multiline':False]['text':' Remove all entries from the cache.','line_number':395,'multiline':False]['text':' Counter incremented by JS::HideScriptedCaller and decremented by','line_number':417,'multiline':False]['text':' JS::UnhideScriptedCaller. If > 0 for the top activation,','line_number':418,'multiline':False]['text':' DescribeScriptedCaller will return null instead of querying that','line_number':419,'multiline':False]['text':' activation, which should prompt the caller to consult embedding-specific','line_number':420,'multiline':False]['text':' data structures instead.','line_number':421,'multiline':False]['text':' The cache of SavedFrame objects we have already captured when walking','line_number':424,'multiline':False]['text':' this activation's stack.','line_number':425,'multiline':False]['text':' Youngest saved frame of an async stack that will be iterated during stack','line_number':428,'multiline':False]['text':' capture in place of the actual stack of previous activations. Note that','line_number':429,'multiline':False]['text':' the stack of this activation is captured entirely before this is used.','line_number':430,'multiline':False]['text':'','line_number':431,'multiline':False]['text':' Usually this is nullptr, meaning that normal stack capture will occur.','line_number':432,'multiline':False]['text':' When this is set, the stack of any previous activation is ignored.','line_number':433,'multiline':False]['text':' Value of asyncCause to be attached to asyncStack_.','line_number':436,'multiline':False]['text':' True if the async call was explicitly requested, e.g. via','line_number':439,'multiline':False]['text':' callFunctionWithAsyncStack.','line_number':440,'multiline':False]['text':' This variable holds a special opcode value which is greater than all normal','line_number':494,'multiline':False]['text':' opcodes, and is chosen such that the bitwise or of this value with any','line_number':495,'multiline':False]['text':' opcode is this value.','line_number':496,'multiline':False]['text':' For debugger interrupts, see js::Interpret.','line_number':513,'multiline':False]['text':' If this js::Interpret frame is running |script|, enable interrupts.','line_number':539,'multiline':False]['text':' Iterates over a thread's activation list.','line_number':551,'multiline':False]['text':' namespace js','line_number':566,'multiline':False]['text':' vm_Activation_h','line_number':568,'multiline':False]