['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
******************************************************************************
*
*   Copyright (C) 2000-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  ucnvmbcs.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2000jul03
*   created by: Markus W. Scherer
*
*   The current code in this file replaces the previous implementation
*   of conversion code from multi-byte codepages to Unicode and back.
*   This implementation supports the following:
*   - legacy variable-length codepages with up to 4 bytes per character
*   - all Unicode code points (up to 0x10ffff)
*   - efficient distinction of unassigned vs. illegal byte sequences
*   - it is possible in fromUnicode() to directly deal with simple
*     stateful encodings (used for EBCDIC_STATEFUL)
*   - it is possible to convert Unicode code points
*     to a single zero byte (but not as a fallback except for SBCS)
*
*   Remaining limitations in fromUnicode:
*   - byte sequences must not have leading zero bytes
*   - except for SBCS codepages: no fallback mapping from Unicode to a zero byte
*   - limitation to up to 4 bytes per character
*
*   ICU 2.8 (late 2003) adds a secondary data structure which lifts some of these
*   limitations and adds m:n character mappings and other features.
*   See ucnv_ext.h for details.
*
*   Change history: 
*
*    5/6/2001       Ram       Moved  MBCS_SINGLE_RESULT_FROM_U,MBCS_STAGE_2_FROM_U,
*                             MBCS_VALUE_2_FROM_STAGE_2, MBCS_VALUE_4_FROM_STAGE_2
*                             macros to ucnvmbcs.h file
','line_number':3,'multiline':True]['text':' control optimizations according to the platform ','line_number':64,'multiline':True]['text':'
 * _MBCSHeader versions 5.3 & 4.3
 * (Note that the _MBCSHeader version is in addition to the converter formatVersion.)
 *
 * This version is optional. Version 5 is used for incompatible data format changes.
 * makeconv will continue to generate version 4 files if possible.
 *
 * Changes from version 4:
 *
 * The main difference is an additional _MBCSHeader field with
 * - the length (number of uint32_t) of the _MBCSHeader
 * - flags for further incompatible data format changes
 * - flags for further, backward compatible data format changes
 *
 * The MBCS_OPT_FROM_U flag indicates that most of the fromUnicode data is omitted from
 * the file and needs to be reconstituted at load time.
 * This requires a utf8Friendly format with an additional mbcsIndex table for fast
 * (and UTF-8-friendly) fromUnicode conversion for Unicode code points up to maxFastUChar.
 * (For details about these structures see below, and see ucnvmbcs.h.)
 *
 *   utf8Friendly also implies that the fromUnicode mappings are stored in ascending order
 *   of the Unicode code points. (This requires that the .ucm file has the |0 etc.
 *   precision markers for all mappings.)
 *
 *   All fallbacks have been moved to the extension table, leaving only roundtrips in the
 *   omitted data that can be reconstituted from the toUnicode data.
 *
 *   Of the stage 2 table, the part corresponding to maxFastUChar and below is omitted.
 *   With only roundtrip mappings in the base fromUnicode data, this part is fully
 *   redundant with the mbcsIndex and will be reconstituted from that (also using the
 *   stage 1 table which contains the information about how stage 2 was compacted).
 *
 *   The rest of the stage 2 table, the part for code points above maxFastUChar,
 *   is stored in the file and will be appended to the reconstituted part.
 *
 *   The entire fromUBytes array is omitted from the file and will be reconstitued.
 *   This is done by enumerating all toUnicode roundtrip mappings, performing
 *   each mapping (using the stage 1 and reconstituted stage 2 tables) and
 *   writing instead of reading the byte values.
 *
 * _MBCSHeader version 4.3
 *
 * Change from version 4.2:
 * - Optional utf8Friendly data structures, with 64-entry stage 3 block
 *   allocation for parts of the BMP, and an additional mbcsIndex in non-SBCS
 *   files which can be used instead of stages 1 & 2.
 *   Faster lookups for roundtrips from most commonly used characters,
 *   and lookups from UTF-8 byte sequences with a natural bit distribution.
 *   See ucnvmbcs.h for more details.
 *
 * Change from version 4.1:
 * - Added an optional extension table structure at the end of the .cnv file.
 *   It is present if the upper bits of the header flags field contains a non-zero
 *   byte offset to it.
 *   Files that contain only a conversion table and no base table
 *   use the special outputType MBCS_OUTPUT_EXT_ONLY.
 *   These contain the base table name between the MBCS header and the extension
 *   data.
 *
 * Change from version 4.0:
 * - Replace header.reserved with header.fromUBytesLength so that all
 *   fields in the data have length.
 *
 * Changes from version 3 (for performance improvements):
 * - new bit distribution for state table entries
 * - reordered action codes
 * - new data structure for single-byte fromUnicode
 *   + stage 2 only contains indexes
 *   + stage 3 stores 16 bits per character with classification bits 15..8
 * - no multiplier for stage 1 entries
 * - stage 2 for non-single-byte codepages contains the index and the flags in
 *   one 32-bit value
 * - 2-byte and 4-byte fromUnicode results are stored directly as 16/32-bit integers
 *
 * For more details about old versions of the MBCS data structure, see
 * the corresponding versions of this file.
 *
 * Converting stateless codepage data ---------------------------------------***
 * (or codepage data with simple states) to Unicode.
 *
 * Data structure and algorithm for converting from complex legacy codepages
 * to Unicode. (Designed before 2000-may-22.)
 *
 * The basic idea is that the structure of legacy codepages can be described
 * with state tables.
 * When reading a byte stream, each input byte causes a state transition.
 * Some transitions result in the output of a code point, some result in
 * "unassigned" or "illegal" output.
 * This is used here for character conversion.
 *
 * The data structure begins with a state table consisting of a row
 * per state, with 256 entries (columns) per row for each possible input
 * byte value.
 * Each entry is 32 bits wide, with two formats distinguished by
 * the sign bit (bit 31):
 *
 * One format for transitional entries (bit 31 not set) for non-final bytes, and
 * one format for final entries (bit 31 set).
 * Both formats contain the number of the next state in the same bit
 * positions.
 * State 0 is the initial state.
 *
 * Most of the time, the offset values of subsequent states are added
 * up to a scalar value. This value will eventually be the index of
 * the Unicode code point in a table that follows the state table.
 * The effect is that the code points for final state table rows
 * are contiguous. The code points of final state rows follow each other
 * in the order of the references to those final states by previous
 * states, etc.
 *
 * For some terminal states, the offset is itself the output Unicode
 * code point (16 bits for a BMP code point or 20 bits for a supplementary
 * code point (stored as code point minus 0x10000 so that 20 bits are enough).
 * For others, the code point in the Unicode table is stored with either
 * one or two code units: one for BMP code points, two for a pair of
 * surrogates.
 * All code points for a final state entry take up the same number of code
 * units, regardless of whether they all actually _use_ the same number
 * of code units. This is necessary for simple array access.
 *
 * An additional feature comes in with what in ICU is called "fallback"
 * mappings:
 *
 * In addition to round-trippable, precise, 1:1 mappings, there are often
 * mappings defined between similar, though not the same, characters.
 * Typically, such mappings occur only in fromUnicode mapping tables because
 * Unicode has a superset repertoire of most other codepages. However, it
 * is possible to provide such mappings in the toUnicode tables, too.
 * In this case, the fallback mappings are partly integrated into the
 * general state tables because the structure of the encoding includes their
 * byte sequences.
 * For final entries in an initial state, fallback mappings are stored in
 * the entry itself like with roundtrip mappings.
 * For other final entries, they are stored in the code units table if
 * the entry is for a pair of code units.
 * For single-unit results in the code units table, there is no space to
 * alternatively hold a fallback mapping; in this case, the code unit
 * is stored as U+fffe (unassigned), and the fallback mapping needs to
 * be looked up by the scalar offset value in a separate table.
 *
 * "Unassigned" state entries really mean "structurally unassigned",
 * i.e., such a byte sequence will never have a mapping result.
 *
 * The interpretation of the bits in each entry is as follows:
 *
 * Bit 31 not set, not a terminal entry ("transitional"):
 * 30..24 next state
 * 23..0  offset delta, to be added up
 *
 * Bit 31 set, terminal ("final") entry:
 * 30..24 next state (regardless of action code)
 * 23..20 action code:
 *        action codes 0 and 1 result in precise-mapping Unicode code points
 *        0  valid byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point
 *                  never U+fffe or U+ffff
 *        1  valid byte sequence
 *           19..0  20-bit Unicode supplementary code point
 *                  never U+fffe or U+ffff
 *
 *        action codes 2 and 3 result in fallback (unidirectional-mapping) Unicode code points
 *        2  valid byte sequence (fallback)
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point as fallback result
 *        3  valid byte sequence (fallback)
 *           19..0  20-bit Unicode supplementary code point as fallback result
 *
 *        action codes 4 and 5 may result in roundtrip/fallback/unassigned/illegal results
 *        depending on the code units they result in
 *        4  valid byte sequence
 *           19..9  not used, 0
 *            8..0  final offset delta
 *                  pointing to one 16-bit code unit which may be
 *                  fffe  unassigned -- look for a fallback for this offset
 *                  ffff  illegal
 *        5  valid byte sequence
 *           19..9  not used, 0
 *            8..0  final offset delta
 *                  pointing to two 16-bit code units
 *                  (typically UTF-16 surrogates)
 *                  the result depends on the first code unit as follows:
 *                  0000..d7ff  roundtrip BMP code point (1st alone)
 *                  d800..dbff  roundtrip surrogate pair (1st, 2nd)
 *                  dc00..dfff  fallback surrogate pair (1st-400, 2nd)
 *                  e000        roundtrip BMP code point (2nd alone)
 *                  e001        fallback BMP code point (2nd alone)
 *                  fffe        unassigned
 *                  ffff        illegal
 *           (the final offset deltas are at most 255 * 2,
 *            times 2 because of storing code unit pairs)
 *
 *        6  unassigned byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point U+fffe (new with version 2)
 *                  this does not contain a final offset delta because the main
 *                  purpose of this action code is to save scalar offset values;
 *                  therefore, fallback values cannot be assigned to byte
 *                  sequences that result in this action code
 *        7  illegal byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point U+ffff (new with version 2)
 *        8  state change only
 *           19..0  not used, 0
 *           useful for state changes in simple stateful encodings,
 *           at Shift-In/Shift-Out codes
 *
 *
 *        9..15 reserved for future use
 *           current implementations will only perform a state change
 *           and ignore bits 19..0
 *
 * An encoding with contiguous ranges of unassigned byte sequences, like
 * Shift-JIS and especially EUC-TW, can be stored efficiently by having
 * at least two states for the trail bytes:
 * One trail byte state that results in code points, and one that only
 * has "unassigned" and "illegal" terminal states.
 *
 * Note: partly by accident, this data structure supports simple stateful
 * encodings without any additional logic.
 * Currently, only simple Shift-In/Shift-Out schemes are handled with
 * appropriate state tables (especially EBCDIC_STATEFUL!).
 *
 * MBCS version 2 added:
 * unassigned and illegal action codes have U+fffe and U+ffff
 * instead of unused bits; this is useful for _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP()
 *
 * Converting from Unicode to codepage bytes --------------------------------***
 *
 * The conversion data structure for fromUnicode is designed for the known
 * structure of Unicode. It maps from 21-bit code points (0..0x10ffff) to
 * a sequence of 1..4 bytes, in addition to a flag that indicates if there is
 * a roundtrip mapping.
 *
 * The lookup is done with a 3-stage trie, using 11/6/4 bits for stage 1/2/3
 * like in the character properties table.
 * The beginning of the trie is at offsetFromUTable, the beginning of stage 3
 * with the resulting bytes is at offsetFromUBytes.
 *
 * Beginning with version 4, single-byte codepages have a significantly different
 * trie compared to other codepages.
 * In all cases, the entry in stage 1 is directly the index of the block of
 * 64 entries in stage 2.
 *
 * Single-byte lookup:
 *
 * Stage 2 only contains 16-bit indexes directly to the 16-blocks in stage 3.
 * Stage 3 contains one 16-bit word per result:
 * Bits 15..8 indicate the kind of result:
 *    f  roundtrip result
 *    c  fallback result from private-use code point
 *    8  fallback result from other code points
 *    0  unassigned
 * Bits 7..0 contain the codepage byte. A zero byte is always possible.
 *
 * In version 4.3, the runtime code can build an sbcsIndex for a utf8Friendly
 * file. For 2-byte UTF-8 byte sequences and some 3-byte sequences the lookup
 * becomes a 2-stage (single-index) trie lookup with 6 bits for stage 3.
 * ASCII code points can be looked up with a linear array access into stage 3.
 * See maxFastUChar and other details in ucnvmbcs.h.
 *
 * Multi-byte lookup:
 *
 * Stage 2 contains a 32-bit word for each 16-block in stage 3:
 * Bits 31..16 contain flags for which stage 3 entries contain roundtrip results
 *             test: MBCS_FROM_U_IS_ROUNDTRIP(stage2Entry, c)
 *             If this test is false, then a non-zero result will be interpreted as
 *             a fallback mapping.
 * Bits 15..0  contain the index to stage 3, which must be multiplied by 16*(bytes per char)
 *
 * Stage 3 contains 2, 3, or 4 bytes per result.
 * 2 or 4 bytes are stored as uint16_t/uint32_t in platform endianness,
 * while 3 bytes are stored as bytes in big-endian order.
 * Leading zero bytes are ignored, and the number of bytes is counted.
 * A zero byte mapping result is possible as a roundtrip result.
 * For some output types, the actual result is processed from this;
 * see ucnv_MBCSFromUnicodeWithOffsets().
 *
 * Note that stage 1 always contains 0x440=1088 entries (0x440==0x110000>>10),
 * or (version 3 and up) for BMP-only codepages, it contains 64 entries.
 *
 * In version 4.3, a utf8Friendly file contains an mbcsIndex table.
 * For 2-byte UTF-8 byte sequences and most 3-byte sequences the lookup
 * becomes a 2-stage (single-index) trie lookup with 6 bits for stage 3.
 * ASCII code points can be looked up with a linear array access into stage 3.
 * See maxFastUChar, mbcsIndex and other details in ucnvmbcs.h.
 *
 * In version 3, stage 2 blocks may overlap by multiples of the multiplier
 * for compaction.
 * In version 4, stage 2 blocks (and for single-byte codepages, stage 3 blocks)
 * may overlap by any number of entries.
 *
 * MBCS version 2 added:
 * the converter checks for known output types, which allows
 * adding new ones without crashing an unaware converter
 ','line_number':68,'multiline':True]['text':'*
 * Callback from ucnv_MBCSEnumToUnicode(), takes 32 mappings from
 * consecutive sequences of bytes, starting from the one encoded in value,
 * to Unicode code points. (Multiple mappings to reduce per-function call overhead.)
 * Does not currently support m:n mappings or reverse fallbacks.
 * This function will not be called for sequences of bytes with leading zeros.
 *
 * @param context an opaque pointer, as passed into ucnv_MBCSEnumToUnicode()
 * @param value contains 1..4 bytes of the first byte sequence, right-aligned
 * @param codePoints resulting Unicode code points, or negative if a byte sequence does
 *        not map to anything
 * @return TRUE to continue enumeration, FALSE to stop
 ','line_number':365,'multiline':True]['text':' Static data is in tools/makeconv/ucnvstat.c for data-based
 * converters. Be sure to update it as well.
 ','line_number':511,'multiline':True]['text':' GB 18030 data ------------------------------------------------------------ ','line_number':522,'multiline':True]['text':' helper macros for linear values for GB 18030 four-byte sequences ','line_number':524,'multiline':True]['text':'
 * Some ranges of GB 18030 where both the Unicode code points and the
 * GB four-byte sequences are contiguous and are handled algorithmically by
 * the special callback functions below.
 * The values are start & end of Unicode & GB codes.
 *
 * Note that single surrogates are not mapped by GB 18030
 * as of the re-released mapping tables from 2000-nov-30.
 ','line_number':531,'multiline':True]['text':' bit flag for UConverter.options indicating GB 18030 special handling ','line_number':558,'multiline':True]['text':' bit flag for UConverter.options indicating KEIS,JEF,JIF special handling ','line_number':561,'multiline':True]['text':' Should never happen. ','line_number':624,'multiline':True]['text':' Miscellaneous ------------------------------------------------------------ ','line_number':631,'multiline':True]['text':' similar to ucnv_MBCSGetNextUChar() but recursive ','line_number':633,'multiline':True]['text':' becomes non-negative if there is a mapping ','line_number':650,'multiline':True]['text':' skip byte sequences with leading zeros because they are not stored in the fromUnicode table ','line_number':654,'multiline':True]['text':' recurse to a state with non-ignorable actions ','line_number':664,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':679,'multiline':True]['text':' output BMP code point ','line_number':685,'multiline':True]['text':' output BMP code point ','line_number':691,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':699,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':701,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':704,'multiline':True]['text':' output supplementary code point ','line_number':710,'multiline':True]['text':'
 * Only called if stateProps[state]==-1.
 * A recursive call may do stateProps[state]|=0x40 if this state is the target of an
 * MBCS_STATE_CHANGE_ONLY.
 ','line_number':731,'multiline':True]['text':' find first non-ignorable state ','line_number':744,'multiline':True]['text':' (int8_t)0xc0 ','line_number':759,'multiline':True]['text':' find last non-ignorable state ','line_number':765,'multiline':True]['text':' recurse further and collect direct-state information ','line_number':782,'multiline':True]['text':'
 * Internal function enumerating the toUnicode data of an MBCS converter.
 * Currently only used for reconstituting data for a MBCS_OPT_NO_FROM_U
 * table, but could also be used for a future ucnv_getUnicodeSet() option
 * that includes reverse fallbacks (after updating this function's implementation).
 * Currently only handles roundtrip mappings.
 * Does not currently handle extensions.
 ','line_number':800,'multiline':True]['text':'
     * Properties for each state, to speed up the enumeration.
     * Ignorable actions are unassigned/illegal/state-change-only:
     * They do not lead to mappings.
     *
     * Bits 7..6:
     * 1 direct/initial state (stateful converters have multiple)
     * 0 non-initial state with transitions or with non-ignorable result actions
     * -1 final state with only ignorable actions
     *
     * Bits 5..3:
     * The lowest byte value with non-ignorable actions is
     * value<<5 (rounded down).
     *
     * Bits 2..0:
     * The highest byte value with non-ignorable actions is
     * (value<<5)&0x1f (rounded up).
     ','line_number':812,'multiline':True]['text':' recurse from state 0 and set all stateProps ','line_number':835,'multiline':True]['text':'if(stateProps[state]==-1) {
            printf("unused/unreachable <icu:state> %d\n", state);
        }','line_number':839,'multiline':True]['text':' start from each direct state ','line_number':843,'multiline':True]['text':' enumerate the from-Unicode trie table ','line_number':866,'multiline':True]['text':' keep track of the current code point while enumerating ','line_number':875,'multiline':True]['text':'
         * Set a threshold variable for selecting which mappings to use.
         * See ucnv_MBCSSingleFromBMPWithOffsets() and
         * MBCS_SINGLE_RESULT_FROM_U() for details.
         ','line_number':883,'multiline':True]['text':' use only roundtrips ','line_number':889,'multiline':True]['text':' UCNV_ROUNDTRIP_AND_FALLBACK_SET ','line_number':891,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':892,'multiline':True]['text':' read the stage 3 block ','line_number':902,'multiline':True]['text':' empty stage 3 block ','line_number':911,'multiline':True]['text':' empty stage 2 block ','line_number':915,'multiline':True]['text':' read the stage 3 block ','line_number':948,'multiline':True]['text':' get the roundtrip flags for the stage 3 block ','line_number':951,'multiline':True]['text':'
                         * Add code points for which the roundtrip flag is set,
                         * or which map to non-zero bytes if we use fallbacks.
                         * See ucnv_MBCSFromUnicodeWithOffsets() for details.
                         ','line_number':954,'multiline':True]['text':' Ignore single-byte results (<0x100). ','line_number':989,'multiline':True]['text':' +=st3Multiplier ','line_number':995,'multiline':True]['text':' Only add code points that map to CNS 11643 planes 1 & 2 for non-EXT ISO-2022-CN. ','line_number':999,'multiline':True]['text':' +=st3Multiplier ','line_number':1005,'multiline':True]['text':' Only add code points that map to Shift-JIS codes corresponding to JIS X 0208. ','line_number':1009,'multiline':True]['text':' +=st3Multiplier ','line_number':1015,'multiline':True]['text':' Only add code points that map to ISO 2022 GR 94 DBCS codes (each byte A1..FE). ','line_number':1019,'multiline':True]['text':' +=st3Multiplier ','line_number':1028,'multiline':True]['text':' Only add code points that are suitable for HZ DBCS (lead byte A1..FD). ','line_number':1032,'multiline':True]['text':' +=st3Multiplier ','line_number':1041,'multiline':True]['text':' empty stage 3 block ','line_number':1049,'multiline':True]['text':' empty stage 2 block ','line_number':1053,'multiline':True]['text':' conversion extensions for input not in the main table -------------------- ','line_number':1087,'multiline':True]['text':'
 * Hardcoded extension handling for GB 18030.
 * Definition of LINEAR macros and gb18030Ranges see near the beginning of the file.
 *
 * In the future, conversion extensions may handle m:n mappings and delta tables,
 * see http://source.icu-project.org/repos/icu/icuhtml/trunk/design/conversion/conversion_extensions.html
 *
 * If an input character cannot be mapped, then these functions set an error
 * code. The framework will then call the callback function.
 ','line_number':1089,'multiline':True]['text':'
 * @return if(U_FAILURE) return the code point for cnv->fromUChar32
 *         else return 0 after output has been written to the target
 ','line_number':1100,'multiline':True]['text':' an extension mapping handled the input ','line_number':1125,'multiline':True]['text':' GB 18030 ','line_number':1128,'multiline':True]['text':' found the Unicode code point, output the four-byte sequence for it ','line_number':1136,'multiline':True]['text':' get the linear value of the first GB 18030 code in this range ','line_number':1140,'multiline':True]['text':' add the offset from the beginning of the range ','line_number':1143,'multiline':True]['text':' turn this into a four-byte sequence ','line_number':1146,'multiline':True]['text':' output this sequence ','line_number':1152,'multiline':True]['text':' no mapping ','line_number':1161,'multiline':True]['text':'
 * Input sequence: cnv->toUBytes[0..length[
 * @return if(U_FAILURE) return the length (toULength, byteIndex) for the input
 *         else return 0 after output has been written to the target
 ','line_number':1166,'multiline':True]['text':' an extension mapping handled the input ','line_number':1190,'multiline':True]['text':' GB 18030 ','line_number':1193,'multiline':True]['text':' found the sequence, output the Unicode code point for it ','line_number':1203,'multiline':True]['text':' add the linear difference between the input and start sequences to the start code point ','line_number':1206,'multiline':True]['text':' output this code point ','line_number':1209,'multiline':True]['text':' no mapping ','line_number':1217,'multiline':True]['text':' EBCDIC swap LF<->NL ------------------------------------------------------ ','line_number':1222,'multiline':True]['text':'
 * This code modifies a standard EBCDIC<->Unicode mapping table for
 * OS/390 (z/OS) Unix System Services (Open Edition).
 * The difference is in the mapping of Line Feed and New Line control codes:
 * Standard EBCDIC maps
 *
 *   <U000A> \x25 |0
 *   <U0085> \x15 |0
 *
 * but OS/390 USS EBCDIC swaps the control codes for LF and NL,
 * mapping
 *
 *   <U000A> \x15 |0
 *   <U0085> \x25 |0
 *
 * This code modifies a loaded standard EBCDIC<->Unicode mapping table
 * by copying it into allocated memory and swapping the LF and NL values.
 * It allows to support the same EBCDIC charset in both versions without
 * duplicating the entire installed table.
 ','line_number':1224,'multiline':True]['text':' standard EBCDIC codes ','line_number':1245,'multiline':True]['text':' standard EBCDIC codes with roundtrip flag as stored in Unicode-to-single-byte tables ','line_number':1249,'multiline':True]['text':' Unicode code points ','line_number':1253,'multiline':True]['text':'
     * Check that this is an EBCDIC table with SBCS portion -
     * SBCS or EBCDIC_STATEFUL with standard EBCDIC LF and NL mappings.
     *
     * If not, ignore the option. Options are always ignored if they do not apply.
     ','line_number':1278,'multiline':True]['text':' MBCS_OUTPUT_2_SISO ','line_number':1299,'multiline':True]['text':'
         * We _know_ the number of bytes in the fromUnicodeBytes array
         * starting with header.version 4.1.
         ','line_number':1318,'multiline':True]['text':'
         * Otherwise:
         * There used to be code to enumerate the fromUnicode
         * trie and find the highest entry, but it was removed in ICU 3.2
         * because it was not tested and caused a low code coverage number.
         * See Jitterbug 3674.
         * This affects only some .cnv file formats with a header.version
         * below 4.1, and only when swaplfnl is requested.
         *
         * ucnvmbcs.c revision 1.99 is the last one with the
         * ucnv_MBCSSizeofFromUBytes() function.
         ','line_number':1324,'multiline':True]['text':'
     * The table has an appropriate format.
     * Allocate and build
     * - a modified to-Unicode state table
     * - a modified from-Unicode output array
     * - a converter name string with the swap option appended
     ','line_number':1340,'multiline':True]['text':' copy and modify the to-Unicode state table ','line_number':1357,'multiline':True]['text':' copy and modify the from-Unicode result table ','line_number':1364,'multiline':True]['text':' conveniently, the table access macros work on the left side of expressions ','line_number':1368,'multiline':True]['text':' MBCS_OUTPUT_2_SISO ','line_number':1372,'multiline':True]['text':' set the canonical converter name ','line_number':1380,'multiline':True]['text':' set the pointers ','line_number':1385,'multiline':True]['text':' release the allocated memory if another thread beat us to it ','line_number':1396,'multiline':True]['text':' reconstitute omitted fromUnicode data ------------------------------------ ','line_number':1403,'multiline':True]['text':' for details, compare with genmbcs.c MBCSAddFromUnicode() and transformEUC() ','line_number':1405,'multiline':True]['text':' for EUC outputTypes, modify the value like genmbcs.c's transformEUC() ','line_number':1418,'multiline':True]['text':' short sequences are stored directly ','line_number':1422,'multiline':True]['text':' code set 0 or 1 ','line_number':1423,'multiline':True]['text':' code set 2 ','line_number':1425,'multiline':True]['text':' first byte is 0x8f ','line_number':1427,'multiline':True]['text':' code set 3 ','line_number':1428,'multiline':True]['text':' short sequences are stored directly ','line_number':1434,'multiline':True]['text':' code set 0 or 1 ','line_number':1435,'multiline':True]['text':' code set 2 ','line_number':1437,'multiline':True]['text':' first byte is 0x8f ','line_number':1439,'multiline':True]['text':' code set 3 ','line_number':1440,'multiline':True]['text':' locate the stage 2 & 3 data ','line_number':1454,'multiline':True]['text':' write the codepage bytes into stage 3 ','line_number':1459,'multiline':True]['text':' 2 bytes per character ','line_number':1472,'multiline':True]['text':' set the roundtrip flag ','line_number':1477,'multiline':True]['text':' lengths are numbers of units, not bytes ','line_number':1486,'multiline':True]['text':' copy existing data and reroute the pointers ','line_number':1498,'multiline':True]['text':' indexes into stage 2 count from the bottom of the fromUnicodeTable ','line_number':1510,'multiline':True]['text':' reconstitute the initial part of stage 2 from the mbcsIndex ','line_number':1513,'multiline':True]['text':' each stage 2 block has 64 entries corresponding to 16 entries in the mbcsIndex ','line_number':1522,'multiline':True]['text':' an stage 2 entry's index is per stage 3 16-block, not per stage 3 entry ','line_number':1526,'multiline':True]['text':'
                         * 4 stage 2 entries point to 4 consecutive stage 3 16-blocks which are
                         * allocated together as a single 64-block for access from the mbcsIndex
                         ','line_number':1528,'multiline':True]['text':' no stage 3 block, skip ','line_number':1537,'multiline':True]['text':' no stage 2 block, skip ','line_number':1542,'multiline':True]['text':' reconstitute fromUnicodeBytes with roundtrips from toUnicode data ','line_number':1548,'multiline':True]['text':' MBCS setup functions ----------------------------------------------------- ','line_number':1552,'multiline':True]['text':' extension data, header version 4.2 and higher ','line_number':1583,'multiline':True]['text':' extension-only file, load the base table and set values appropriately ','line_number':1595,'multiline':True]['text':' extension-only file without extension ','line_number':1597,'multiline':True]['text':' an extension table must not be loaded as a base table ','line_number':1603,'multiline':True]['text':' load the base table ','line_number':1608,'multiline':True]['text':' forbid loading this same extension-only file ','line_number':1611,'multiline':True]['text':' TODO parse package name out of the prefix of the base name in the extension .cnv file? ','line_number':1616,'multiline':True]['text':'
             * Exit as soon as we know that we can load the converter
             * and the format is valid and supported.
             * The worst that can happen in the following code is a memory
             * allocation error.
             ','line_number':1636,'multiline':True]['text':' copy the base table data ','line_number':1646,'multiline':True]['text':' overwrite values with relevant ones for the extension converter ','line_number':1649,'multiline':True]['text':'
         * It would be possible to share the swapLFNL data with a base converter,
         * but the generated name would have to be different, and the memory
         * would have to be free'd only once.
         * It is easier to just create the data for the extension converter
         * separately when it is requested.
         ','line_number':1653,'multiline':True]['text':'
         * The reconstitutedData must be deleted only when the base converter
         * is unloaded.
         ','line_number':1664,'multiline':True]['text':'
         * Set a special, runtime-only outputType if the extension converter
         * is a DBCS version of a base converter that also maps single bytes.
         ','line_number':1670,'multiline':True]['text':' the base converter is SI/SO-stateful ','line_number':1679,'multiline':True]['text':' get the dbcs state from the state table entry for SO=0x0e ','line_number':1682,'multiline':True]['text':' non-stateful base converter, need to modify the state table ','line_number':1698,'multiline':True]['text':' allocate a new state table and copy the base state table contents ','line_number':1703,'multiline':True]['text':' change all final single-byte entries to go to a new all-illegal state ','line_number':1714,'multiline':True]['text':' build the new all-illegal state ','line_number':1722,'multiline':True]['text':'
         * unlike below for files with base tables, do not get the unicodeMask
         * from the sharedData; instead, use the base table's unicodeMask,
         * which we copied in the memcpy above;
         * this is necessary because the static data unicodeMask, especially
         * the UCNV_HAS_SUPPLEMENTARY flag, is part of the base table data
         ','line_number':1735,'multiline':True]['text':' conversion file with a base table; an additional extension table is optional ','line_number':1743,'multiline':True]['text':' make sure that the output type is known ','line_number':1744,'multiline':True]['text':' OK ','line_number':1753,'multiline':True]['text':'
             * Exit as soon as we know that we can load the converter
             * and the format is valid and supported.
             * The worst that can happen in the following code is a memory
             * allocation error.
             ','line_number':1760,'multiline':True]['text':'
         * converter versions 6.1 and up contain a unicodeMask that is
         * used here to select the most efficient function implementations
         ','line_number':1779,'multiline':True]['text':' mask off possible future extensions to be safe ','line_number':1786,'multiline':True]['text':' for older versions, assume worst case: contains anything possible (prevent over-optimizations) ','line_number':1789,'multiline':True]['text':'
         * _MBCSHeader.version 4.3 adds utf8Friendly data structures.
         * Check for the header version, SBCS vs. MBCS, and for whether the
         * data structures are optimized for code points as high as what the
         * runtime code is designed for.
         * The implementation does not handle mapping tables with entries for
         * unpaired surrogates.
         ','line_number':1793,'multiline':True]['text':'
                 * SBCS: Stage 3 is allocated in 64-entry blocks for U+0000..SBCS_FAST_MAX or higher.
                 * Build a table with indexes to each block, to be used instead of
                 * the regular stage 1/2 table.
                 ','line_number':1811,'multiline':True]['text':' set SBCS_FAST_MAX to reflect the reach of sbcsIndex[] even if header->version[2]>(SBCS_FAST_MAX>>8) ','line_number':1820,'multiline':True]['text':'
                 * MBCS: Stage 3 is allocated in 64-entry blocks for U+0000..MBCS_FAST_MAX or higher.
                 * The .cnv file is prebuilt with an additional stage table with indexes
                 * to each block.
                 ','line_number':1823,'multiline':True]['text':' calculate a bit set of 4 ASCII characters per bit that round-trip to ASCII bytes ','line_number':1835,'multiline':True]['text':' Set the impl pointer here so that it is set for both extension-only and base tables. ','line_number':1859,'multiline':True]['text':'
         * MBCS_OUTPUT_DBCS_ONLY: No SBCS mappings, therefore ASCII does not roundtrip.
         * MBCS_OUTPUT_2_SISO: Bypass the ASCII fastpath to handle prevLength correctly.
         ','line_number':1871,'multiline':True]['text':' the swaplfnl option does not apply, remove it ','line_number':1914,'multiline':True]['text':' do this because double-checked locking is broken ','line_number':1919,'multiline':True]['text':' something went wrong ','line_number':1929,'multiline':True]['text':' the option does not apply, remove it ','line_number':1932,'multiline':True]['text':' set a flag for GB 18030 mode, which changes the callback behavior ','line_number':1940,'multiline':True]['text':' set a flag for KEIS converter, which changes the SI/SO character sequence ','line_number':1944,'multiline':True]['text':' set a flag for JEF converter, which changes the SI/SO character sequence ','line_number':1947,'multiline':True]['text':' set a flag for JIPS converter, which changes the SI/SO character sequence ','line_number':1950,'multiline':True]['text':' fix maxBytesPerUChar depending on outputType and options etc. ','line_number':1954,'multiline':True]['text':' SO+DBCS ','line_number':1956,'multiline':True]['text':' SO + multiple DBCS ','line_number':1963,'multiline':True]['text':'
     * documentation of UConverter fields used for status
     * all of these fields are (re)set to 0 by ucnv_bld.c and ucnv_reset()
     ','line_number':1972,'multiline':True]['text':' toUnicode ','line_number':1977,'multiline':True]['text':' offset ','line_number':1978,'multiline':True]['text':' state ','line_number':1979,'multiline':True]['text':' byteIndex ','line_number':1980,'multiline':True]['text':' fromUnicode ','line_number':1982,'multiline':True]['text':' prevLength ','line_number':1984,'multiline':True]['text':' MBCS-to-Unicode conversion functions ------------------------------------- ','line_number':2001,'multiline':True]['text':' do a binary search for the fallback mapping ','line_number':2010,'multiline':True]['text':' did we really find it? ','line_number':2022,'multiline':True]['text':' This version of ucnv_MBCSToUnicodeWithOffsets() is optimized for single-byte, single-state codepages. ','line_number':2031,'multiline':True]['text':' set up the local pointers ','line_number':2049,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2063,'multiline':True]['text':' conversion loop ','line_number':2066,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one code unit that
         * overflows as a result of a surrogate pair or callback output
         * from the last source byte.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':2068,'multiline':True]['text':' target is full ','line_number':2077,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2083,'multiline':True]['text':' test the most common case first ','line_number':2085,'multiline':True]['text':' output BMP code point ','line_number':2087,'multiline':True]['text':' normal end of action codes: prepare for a new character ','line_number':2093,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2098,'multiline':True]['text':' output surrogate pair ','line_number':2107,'multiline':True]['text':' target overflow ','line_number':2119,'multiline':True]['text':' output BMP code point ','line_number':2130,'multiline':True]['text':' just fall through ','line_number':2140,'multiline':True]['text':' callback(illegal) ','line_number':2142,'multiline':True]['text':' reserved, must never occur ','line_number':2145,'multiline':True]['text':' callback(illegal) ','line_number':2151,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2153,'multiline':True]['text':' try an extension mapping ','line_number':2154,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2166,'multiline':True]['text':' write back the updated pointers ','line_number':2172,'multiline':True]['text':'
 * This version of ucnv_MBCSSingleToUnicodeWithOffsets() is optimized for single-byte, single-state codepages
 * that only map to and from the BMP.
 * In addition to single-byte optimizations, the offset calculations
 * become much easier.
 ','line_number':2178,'multiline':True]['text':' set up the local pointers ','line_number':2200,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2214,'multiline':True]['text':'
     * since the conversion here is 1:1 UChar:uint8_t, we need only one counter
     * for the minimum of the sourceLength and targetCapacity
     ','line_number':2218,'multiline':True]['text':' unrolling makes it faster on Pentium III/Windows 2000 ','line_number':2228,'multiline':True]['text':' unroll the loop with the most common case ','line_number':2229,'multiline':True]['text':' were all 16 entries really valid? ','line_number':2269,'multiline':True]['text':' no, return to the first of these 16 ','line_number':2271,'multiline':True]['text':' conversion loop ','line_number':2305,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2308,'multiline':True]['text':' test the most common case first ','line_number':2310,'multiline':True]['text':' output BMP code point ','line_number':2312,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2318,'multiline':True]['text':' output BMP code point ','line_number':2325,'multiline':True]['text':' just fall through ','line_number':2331,'multiline':True]['text':' callback(illegal) ','line_number':2333,'multiline':True]['text':' reserved, must never occur ','line_number':2336,'multiline':True]['text':' set offsets since the start or the last extension ','line_number':2340,'multiline':True]['text':' predecrement: do not set the offset for the callback-causing character ','line_number':2344,'multiline':True]['text':' offset and sourceIndex are now set for the current character ','line_number':2348,'multiline':True]['text':' callback(illegal) ','line_number':2352,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2354,'multiline':True]['text':' try an extension mapping ','line_number':2355,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2367,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':2371,'multiline':True]['text':' unrolling makes it faster on Pentium III/Windows 2000 ','line_number':2380,'multiline':True]['text':' target is full ','line_number':2386,'multiline':True]['text':' set offsets since the start or the last callback ','line_number':2390,'multiline':True]['text':' write back the updated pointers ','line_number':2399,'multiline':True]['text':' First test for final entries in this state for some commonly valid byte values. ','line_number':2409,'multiline':True]['text':' Then test for final entries in this state. ','line_number':2422,'multiline':True]['text':' Then recurse for transition entries. ','line_number':2431,'multiline':True]['text':'
 * Is byte b a single/lead byte in this state?
 * Recurse for transition states, because here we don't want to say that
 * b is a lead byte if all byte sequences that start with b are illegal.
 ','line_number':2443,'multiline':True]['text':' lead byte ','line_number':2452,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':2457,'multiline':True]['text':' use optimized function if possible ','line_number':2487,'multiline':True]['text':'
         * pass sourceIndex=-1 because we continue from an earlier buffer
         * in the future, this may change with continuous offsets
         ','line_number':2491,'multiline':True]['text':' set up the local pointers ','line_number':2511,'multiline':True]['text':' get the converter state from UConverter ','line_number':2525,'multiline':True]['text':'
     * if we are in the SBCS state for a DBCS-only converter,
     * then load the DBCS state from the MBCS data
     * (dbcsOnlyState==0 if it is not a DBCS-only converter)
     ','line_number':2530,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2539,'multiline':True]['text':' conversion loop ','line_number':2543,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one code unit that
         * overflows as a result of a surrogate pair or callback output
         * from the last source byte.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':2545,'multiline':True]['text':' target is full ','line_number':2554,'multiline':True]['text':' optimized loop for 1/2-byte input and BMP output ','line_number':2560,'multiline':True]['text':' typically 0 ','line_number':2576,'multiline':True]['text':' set the state and leave the optimized loop ','line_number':2579,'multiline':True]['text':' output BMP code point ','line_number':2586,'multiline':True]['text':' typically 0 ','line_number':2589,'multiline':True]['text':' leave the optimized loop ','line_number':2591,'multiline':True]['text':' offsets!=NULL ','line_number':2596,'multiline':True]['text':' typically 0 ','line_number':2615,'multiline':True]['text':' set the state and leave the optimized loop ','line_number':2618,'multiline':True]['text':' output BMP code point ','line_number':2626,'multiline':True]['text':' typically 0 ','line_number':2633,'multiline':True]['text':' leave the optimized loop ','line_number':2635,'multiline':True]['text':'
             * these tests and break statements could be put inside the loop
             * if C had "break outerLoop" like Java
             ','line_number':2642,'multiline':True]['text':' target is full ','line_number':2650,'multiline':True]['text':' byteIndex>0 ','line_number':2657,'multiline':True]['text':' save the previous state for proper extension mapping with SI/SO-stateful converters ','line_number':2668,'multiline':True]['text':' set the next state early so that we can reuse the entry variable ','line_number':2671,'multiline':True]['text':' typically 0 ','line_number':2672,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2674,'multiline':True]['text':' output BMP code point ','line_number':2683,'multiline':True]['text':' output fallback BMP code point ','line_number':2691,'multiline':True]['text':' callback(illegal) ','line_number':2699,'multiline':True]['text':' output BMP code point ','line_number':2703,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':2713,'multiline':True]['text':' output roundtrip or fallback surrogate pair ','line_number':2720,'multiline':True]['text':' target overflow ','line_number':2732,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':2741,'multiline':True]['text':' callback(illegal) ','line_number':2748,'multiline':True]['text':' output surrogate pair ','line_number':2755,'multiline':True]['text':' target overflow ','line_number':2768,'multiline':True]['text':'
             * This serves as a state change without any output.
             * It is useful for reading simple stateful encodings,
             * for example using just Shift-In/Shift-Out codes.
             * The 21 unused bits may later be used for more sophisticated
             * state transitions.
             ','line_number':2777,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':2787,'multiline':True]['text':' restore the previous state ','line_number':2788,'multiline':True]['text':' callback(illegal) ','line_number':2790,'multiline':True]['text':' output BMP code point ','line_number':2795,'multiline':True]['text':' just fall through ','line_number':2803,'multiline':True]['text':' callback(illegal) ','line_number':2805,'multiline':True]['text':' reserved, must never occur ','line_number':2808,'multiline':True]['text':' end of action codes: prepare for a new character ','line_number':2812,'multiline':True]['text':' callback(illegal) ','line_number':2818,'multiline':True]['text':'
                 * Ticket 5691: consistent illegal sequences:
                 * - We include at least the first byte in the illegal sequence.
                 * - If any of the non-initial bytes could be the start of a character,
                 *   we stop the illegal sequence before the first one of those.
                 ','line_number':2820,'multiline':True]['text':' Back out some bytes. ','line_number':2832,'multiline':True]['text':' length of reported illegal byte sequence ','line_number':2835,'multiline':True]['text':' Back out bytes from the previous buffer: Need to replay them. ','line_number':2839,'multiline':True]['text':' preToULength is negative! ','line_number':2841,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2848,'multiline':True]['text':' try an extension mapping ','line_number':2849,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2860,'multiline':True]['text':' set the converter state back into UConverter ','line_number':2866,'multiline':True]['text':' write back the updated pointers ','line_number':2871,'multiline':True]['text':'
 * This version of ucnv_MBCSGetNextUChar() is optimized for single-byte, single-state codepages.
 * We still need a conversion loop in case we find reserved action codes, which are to be ignored.
 ','line_number':2877,'multiline':True]['text':' set up the local pointers ','line_number':2891,'multiline':True]['text':' conversion loop ','line_number':2901,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2904,'multiline':True]['text':' write back the updated pointer early so that we can return directly ','line_number':2906,'multiline':True]['text':' output BMP code point ','line_number':2910,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2914,'multiline':True]['text':' output supplementary code point ','line_number':2922,'multiline':True]['text':' output BMP code point ','line_number':2926,'multiline':True]['text':' just fall through ','line_number':2930,'multiline':True]['text':' callback(illegal) ','line_number':2932,'multiline':True]['text':' reserved, must never occur ','line_number':2935,'multiline':True]['text':' callback(illegal) ','line_number':2940,'multiline':True]['text':' unassigned sequence ','line_number':2942,'multiline':True]['text':' defer to the generic implementation ','line_number':2943,'multiline':True]['text':' no output because of empty input or only state changes ','line_number':2949,'multiline':True]['text':'
 * Version of _MBCSToUnicodeWithOffsets() optimized for single-character
 * conversion without offset handling.
 *
 * When a character does not have a mapping to Unicode, then we return to the
 * generic ucnv_getNextUChar() code for extension/GB 18030 and error/callback
 * handling.
 * We also defer to the generic code in other complicated cases and have them
 * ultimately handled by _MBCSToUnicodeWithOffsets() itself.
 *
 * All normal mappings and errors are handled here.
 ','line_number':2954,'multiline':True]['text':' use optimized function if possible ','line_number':2982,'multiline':True]['text':' use the generic code in ucnv_getNextUChar() to continue with a partial match ','line_number':2986,'multiline':True]['text':'
         * Using the generic ucnv_getNextUChar() code lets us deal correctly
         * with the rare case of a codepage that maps single surrogates
         * without adding the complexity to this already complicated function here.
         ','line_number':2991,'multiline':True]['text':' set up the local pointers ','line_number':3001,'multiline':True]['text':' get the converter state from UConverter ','line_number':3012,'multiline':True]['text':'
     * if we are in the SBCS state for a DBCS-only converter,
     * then load the DBCS state from the MBCS data
     * (dbcsOnlyState==0 if it is not a DBCS-only converter)
     ','line_number':3015,'multiline':True]['text':' conversion loop ','line_number':3024,'multiline':True]['text':' optimization for 1/2-byte input and BMP output ','line_number':3032,'multiline':True]['text':' typically 0 ','line_number':3039,'multiline':True]['text':' output BMP code point ','line_number':3040,'multiline':True]['text':' save the previous state for proper extension mapping with SI/SO-stateful converters ','line_number':3044,'multiline':True]['text':' set the next state early so that we can reuse the entry variable ','line_number':3047,'multiline':True]['text':' typically 0 ','line_number':3048,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':3050,'multiline':True]['text':' output BMP code point ','line_number':3056,'multiline':True]['text':' output BMP code point ','line_number':3063,'multiline':True]['text':' callback(illegal) ','line_number':3070,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':3077,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':3080,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':3084,'multiline':True]['text':' callback(illegal) ','line_number':3088,'multiline':True]['text':' output supplementary code point ','line_number':3094,'multiline':True]['text':'
                 * This serves as a state change without any output.
                 * It is useful for reading simple stateful encodings,
                 * for example using just Shift-In/Shift-Out codes.
                 * The 21 unused bits may later be used for more sophisticated
                 * state transitions.
                 ','line_number':3098,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':3106,'multiline':True]['text':' restore the previous state ','line_number':3107,'multiline':True]['text':' callback(illegal) ','line_number':3109,'multiline':True]['text':' output BMP code point ','line_number':3114,'multiline':True]['text':' just fall through ','line_number':3119,'multiline':True]['text':' callback(illegal) ','line_number':3121,'multiline':True]['text':' reserved (must never occur), or only state change ','line_number':3124,'multiline':True]['text':' end of action codes: prepare for a new character ','line_number':3130,'multiline':True]['text':' callback(illegal) ','line_number':3134,'multiline':True]['text':' unassigned sequence ','line_number':3136,'multiline':True]['text':' defer to the generic implementation ','line_number':3137,'multiline':True]['text':' incomplete character byte sequence ','line_number':3148,'multiline':True]['text':' callback(illegal) ','line_number':3156,'multiline':True]['text':'
             * Ticket 5691: consistent illegal sequences:
             * - We include at least the first byte in the illegal sequence.
             * - If any of the non-initial bytes could be the start of a character,
             *   we stop the illegal sequence before the first one of those.
             ','line_number':3157,'multiline':True]['text':' first byte ','line_number':3165,'multiline':True]['text':' lastSource<source: multi-byte character ','line_number':3168,'multiline':True]['text':' no output because of empty input or only state changes ','line_number':3180,'multiline':True]['text':' set the converter state back into UConverter, ready for a new character ','line_number':3186,'multiline':True]['text':' write back the updated pointer ','line_number':3190,'multiline':True]['text':'
 * Code disabled 2002dec09 (ICU 2.4) because it is not currently used in ICU. markus
 * Removal improves code coverage.
 ','line_number':3196,'multiline':True]['text':'*
 * This version of ucnv_MBCSSimpleGetNextUChar() is optimized for single-byte, single-state codepages.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It does not handle conversion extensions (_extToU()).
 ','line_number':3200,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':3212,'multiline':True]['text':' output BMP code point ','line_number':3215,'multiline':True]['text':'
     * An if-else-if chain provides more reliable performance for
     * the most common cases compared to a switch.
     ','line_number':3219,'multiline':True]['text':' output supplementary code point ','line_number':3225,'multiline':True]['text':' output BMP code point ','line_number':3231,'multiline':True]['text':' output supplementary code point ','line_number':3237,'multiline':True]['text':' reserved, must never occur ','line_number':3244,'multiline':True]['text':'
 * This is a simple version of _MBCSGetNextUChar() that is used
 * by other converter implementations.
 * It only returns an "assigned" result if it consumes the entire input.
 * It does not use state from the converter, nor error codes.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It handles conversion extensions but not GB 18030.
 *
 * Return value:
 * U+fffe   unassigned
 * U+ffff   illegal
 * otherwise the Unicode code point
 ','line_number':3250,'multiline':True]['text':' no input at all: "illegal" ','line_number':3277,'multiline':True]['text':'
 * Code disabled 2002dec09 (ICU 2.4) because it is not currently used in ICU. markus
 * TODO In future releases, verify that this function is never called for SBCS
 * conversions, i.e., that sharedData->mbcs.countStates==1 is still true.
 * Removal improves code coverage.
 ','line_number':3282,'multiline':True]['text':' use optimized function if possible ','line_number':3288,'multiline':True]['text':' illegal: more than a single byte for an SBCS converter ','line_number':3293,'multiline':True]['text':' set up the local pointers ','line_number':3298,'multiline':True]['text':' converter state ','line_number':3302,'multiline':True]['text':' conversion loop ','line_number':3306,'multiline':True]['text':' truncated character ','line_number':3314,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':3317,'multiline':True]['text':' done ','line_number':3326,'multiline':True]['text':' else done with 0xfffe ','line_number':3329,'multiline':True]['text':' output BMP code point ','line_number':3333,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':3340,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':3342,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':3345,'multiline':True]['text':' output supplementary code point ','line_number':3354,'multiline':True]['text':' output BMP code point ','line_number':3362,'multiline':True]['text':' output supplementary code point ','line_number':3370,'multiline':True]['text':'
             * forbid MBCS_STATE_CHANGE_ONLY for this function,
             * and MBCS_STATE_ILLEGAL and reserved action codes
             ','line_number':3378,'multiline':True]['text':' illegal for this function: not all input consumed ','line_number':3387,'multiline':True]['text':' try an extension mapping ','line_number':3392,'multiline':True]['text':' MBCS-from-Unicode conversion functions ----------------------------------- ','line_number':3402,'multiline':True]['text':' This version of ucnv_MBCSFromUnicodeWithOffsets() is optimized for double-byte codepages. ','line_number':3404,'multiline':True]['text':' use optimized function if possible ','line_number':3427,'multiline':True]['text':' set up the local pointers ','line_number':3431,'multiline':True]['text':' get the converter state from UConverter ','line_number':3447,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3450,'multiline':True]['text':' conversion loop ','line_number':3454,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':3460,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':3469,'multiline':True]['text':'
             * utf8Friendly table: Test for <=0xd7ff rather than <=MBCS_FAST_MAX
             * to avoid dealing with surrogates.
             * MBCS_FAST_MAX must be >=0xd7ff.
             ','line_number':3486,'multiline':True]['text':' There are only roundtrips (!=0) and no-mapping (==0) entries. ','line_number':3493,'multiline':True]['text':' output the value ','line_number':3497,'multiline':True]['text':'
                 * This also tests if the codepage maps single surrogates.
                 * If it does, then surrogates are not paired but mapped separately.
                 * Note that in this case unmatched surrogates are not detected.
                 ','line_number':3499,'multiline':True]['text':' test the following code unit ','line_number':3508,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':3515,'multiline':True]['text':' callback(unassigned) ','line_number':3516,'multiline':True]['text':' convert this supplementary code point ','line_number':3519,'multiline':True]['text':' exit this condition tree ','line_number':3520,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3522,'multiline':True]['text':' callback(illegal) ','line_number':3523,'multiline':True]['text':' no more input ','line_number':3528,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3532,'multiline':True]['text':' callback(illegal) ','line_number':3533,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3539,'multiline':True]['text':' get the bytes and the length for the output ','line_number':3542,'multiline':True]['text':' MBCS_OUTPUT_2 ','line_number':3543,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3546,'multiline':True]['text':'
                     * We allow a 0 byte output if the "assigned" bit is set for this entry.
                     * There is no way with this data structure for fallback output
                     * to be a zero byte.
                     ','line_number':3550,'multiline':True]['text':' try an extension mapping ','line_number':3557,'multiline':True]['text':' not mappable or buffer overflow ','line_number':3568,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':3571,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':3573,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3576,'multiline':True]['text':' write the output character bytes from value and length ','line_number':3583,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':3584,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3586,'multiline':True]['text':' length==2 ','line_number':3592,'multiline':True]['text':' target overflow ','line_number':3608,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3616,'multiline':True]['text':' target is full ','line_number':3621,'multiline':True]['text':' set the converter state back into UConverter ','line_number':3627,'multiline':True]['text':' write back the updated pointers ','line_number':3630,'multiline':True]['text':' This version of ucnv_MBCSFromUnicodeWithOffsets() is optimized for single-byte codepages. ','line_number':3636,'multiline':True]['text':' set up the local pointers ','line_number':3656,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':3672,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':3675,'multiline':True]['text':' get the converter state from UConverter ','line_number':3680,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3683,'multiline':True]['text':' conversion loop ','line_number':3687,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':3693,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':3702,'multiline':True]['text':' test the following code unit ','line_number':3713,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':3720,'multiline':True]['text':' callback(unassigned) ','line_number':3721,'multiline':True]['text':' convert this supplementary code point ','line_number':3724,'multiline':True]['text':' exit this condition tree ','line_number':3725,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3727,'multiline':True]['text':' callback(illegal) ','line_number':3728,'multiline':True]['text':' no more input ','line_number':3733,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3737,'multiline':True]['text':' callback(illegal) ','line_number':3738,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3744,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3747,'multiline':True]['text':' assigned, write the output character bytes from value and length ','line_number':3749,'multiline':True]['text':' length==1 ','line_number':3750,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3751,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3758,'multiline':True]['text':' unassigned ','line_number':3761,'multiline':True]['text':' try an extension mapping ','line_number':3763,'multiline':True]['text':' not mappable or buffer overflow ','line_number':3774,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':3777,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':3779,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3782,'multiline':True]['text':' target is full ','line_number':3787,'multiline':True]['text':' set the converter state back into UConverter ','line_number':3793,'multiline':True]['text':' write back the updated pointers ','line_number':3796,'multiline':True]['text':'
 * This version of ucnv_MBCSFromUnicode() is optimized for single-byte codepages
 * that map only to and from the BMP.
 * In addition to single-byte/state optimizations, the offset calculations
 * become much easier.
 * It would be possible to use the sbcsIndex for UTF-8-friendly tables,
 * but measurements have shown that this diminishes performance
 * in more cases than it improves it.
 * See SVN revision 21013 (2007-feb-06) for the last version with #if switches
 * for various MBCS and SBCS optimizations.
 ','line_number':3802,'multiline':True]['text':' set up the local pointers ','line_number':3832,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':3849,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':3852,'multiline':True]['text':' get the converter state from UConverter ','line_number':3856,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3859,'multiline':True]['text':'
     * since the conversion here is 1:1 UChar:uint8_t, we need only one counter
     * for the minimum of the sourceLength and targetCapacity
     ','line_number':3863,'multiline':True]['text':' conversion loop ','line_number':3872,'multiline':True]['text':' unrolling makes it slower on Pentium III/Windows 2000?! ','line_number':3878,'multiline':True]['text':' unroll the loop with the most common case ','line_number':3879,'multiline':True]['text':' were all 4 entries really valid? ','line_number':3900,'multiline':True]['text':' no, return to the first of these 4 ','line_number':3902,'multiline':True]['text':'
         * Get a correct Unicode code point:
         * a single UChar for a BMP code point or
         * a matched surrogate pair for a "supplementary code point".
         ','line_number':3927,'multiline':True]['text':'
         * Do not immediately check for single surrogates:
         * Assume that they are unassigned and check for them in that case.
         * This speeds up the conversion of assigned characters.
         ','line_number':3933,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3938,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3946,'multiline':True]['text':' assigned, write the output character bytes from value and length ','line_number':3948,'multiline':True]['text':' length==1 ','line_number':3949,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3950,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3954,'multiline':True]['text':' normal, unassigned BMP character ','line_number':3958,'multiline':True]['text':' test the following code unit ','line_number':3962,'multiline':True]['text':' this codepage does not map supplementary code points ','line_number':3967,'multiline':True]['text':' callback(unassigned) ','line_number':3968,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3970,'multiline':True]['text':' callback(illegal) ','line_number':3971,'multiline':True]['text':' no more input ','line_number':3976,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3983,'multiline':True]['text':' callback(illegal) ','line_number':3984,'multiline':True]['text':' c does not have a mapping ','line_number':3989,'multiline':True]['text':' get the number of code units for c to correctly advance sourceIndex ','line_number':3991,'multiline':True]['text':' set offsets since the start or the last extension ','line_number':3994,'multiline':True]['text':' do not set the offset for this character ','line_number':3998,'multiline':True]['text':' offsets and sourceIndex are now set for the current character ','line_number':4005,'multiline':True]['text':' try an extension mapping ','line_number':4008,'multiline':True]['text':' not mappable or buffer overflow ','line_number':4020,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':4023,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':4025,'multiline':True]['text':' unrolling makes it slower on Pentium III/Windows 2000?! ','line_number':4034,'multiline':True]['text':' target is full ','line_number':4040,'multiline':True]['text':' set offsets since the start or the last callback ','line_number':4044,'multiline':True]['text':'
            Caller gave us a partial supplementary character,
            which this function couldn't convert in any case.
            The callback will handle the offset.
            ','line_number':4048,'multiline':True]['text':' set the converter state back into UConverter ','line_number':4061,'multiline':True]['text':' write back the updated pointers ','line_number':4064,'multiline':True]['text':' Shift-In and Shift-Out byte sequences differ by encoding scheme. ','line_number':4091,'multiline':True]['text':'
         * pass sourceIndex=-1 because we continue from an earlier buffer
         * in the future, this may change with continuous offsets
         ','line_number':4101,'multiline':True]['text':' use optimized function if possible ','line_number':4112,'multiline':True]['text':' set up the local pointers ','line_number':4127,'multiline':True]['text':' get the converter state from UConverter ','line_number':4147,'multiline':True]['text':' set the real value ','line_number':4153,'multiline':True]['text':' prevent fromUnicodeStatus from being set to something non-0 ','line_number':4157,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':4161,'multiline':True]['text':' Get the SI/SO character for the converter ','line_number':4166,'multiline':True]['text':' conversion loop ','line_number':4170,'multiline':True]['text':'
     * This is another piece of ugly code:
     * A goto into the loop if the converter state contains a first surrogate
     * from the previous function call.
     * It saves me to check in each loop iteration a check of if(c==0)
     * and duplicating the trail-surrogate-handling code in the else
     * branch of that check.
     * I could not find any other way to get around this other than
     * using a function call for the conversion and callback, which would
     * be even more inefficient.
     *
     * Markus Scherer 2000-jul-19
     ','line_number':4171,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':4189,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':4198,'multiline':True]['text':'
             * utf8Friendly table: Test for <=0xd7ff rather than <=MBCS_FAST_MAX
             * to avoid dealing with surrogates.
             * MBCS_FAST_MAX must be >=0xd7ff.
             ','line_number':4216,'multiline':True]['text':' get the bytes and the length for the output (copied from below and adapted for utf8Friendly data) ','line_number':4224,'multiline':True]['text':' There are only roundtrips (!=0) and no-mapping (==0) entries. ','line_number':4225,'multiline':True]['text':' 1/2-byte stateful with Shift-In/Shift-Out ','line_number':4240,'multiline':True]['text':'
                     * Save the old state in the converter object
                     * right here, then change the local prevLength state variable if necessary.
                     * Then, if this character turns out to be unassigned or a fallback that
                     * is not taken, the callback code must not save the new state in the converter
                     * because the new state is for a character that is not output.
                     * However, the callback must still restore the state from the converter
                     * in case the callback function changed it for its output.
                     ','line_number':4241,'multiline':True]['text':' save the old state ','line_number':4250,'multiline':True]['text':' change from double-byte mode to single-byte ','line_number':4258,'multiline':True]['text':' change from single-byte mode to double-byte ','line_number':4273,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4287,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4290,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4329,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4349,'multiline':True]['text':' must not occur ','line_number':4369,'multiline':True]['text':'
                     * To avoid compiler warnings that value & length may be
                     * used without having been initialized, we set them here.
                     * In reality, this is unreachable code.
                     * Not having a default branch also causes warnings with
                     * some compilers.
                     ','line_number':4370,'multiline':True]['text':' output the value ','line_number':4381,'multiline':True]['text':'
                 * This also tests if the codepage maps single surrogates.
                 * If it does, then surrogates are not paired but mapped separately.
                 * Note that in this case unmatched surrogates are not detected.
                 ','line_number':4383,'multiline':True]['text':' test the following code unit ','line_number':4392,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4399,'multiline':True]['text':' save the old state ','line_number':4400,'multiline':True]['text':' callback(unassigned) ','line_number':4401,'multiline':True]['text':' convert this supplementary code point ','line_number':4404,'multiline':True]['text':' exit this condition tree ','line_number':4405,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':4407,'multiline':True]['text':' callback(illegal) ','line_number':4408,'multiline':True]['text':' no more input ','line_number':4413,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':4417,'multiline':True]['text':' callback(illegal) ','line_number':4418,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':4424,'multiline':True]['text':'
                 * The basic lookup is a triple-stage compact array (trie) lookup.
                 * For details see the beginning of this file.
                 *
                 * Single-byte codepages are handled with a different data structure
                 * by _MBCSSingle... functions.
                 *
                 * The result consists of a 32-bit value from stage 2 and
                 * a pointer to as many bytes as are stored per character.
                 * The pointer points to the character's bytes in stage 3.
                 * Bits 15..0 of the stage 2 entry contain the stage 3 index
                 * for that pointer, while bits 31..16 are flags for which of
                 * the 16 characters in the block are roundtrip-assigned.
                 *
                 * For 2-byte and 4-byte codepages, the bytes are stored as uint16_t
                 * respectively as uint32_t, in the platform encoding.
                 * For 3-byte codepages, the bytes are always stored in big-endian order.
                 *
                 * For EUC encodings that use only either 0x8e or 0x8f as the first
                 * byte of their longest byte sequences, the first two bytes in
                 * this third stage indicate with their 7th bits whether these bytes
                 * are to be written directly or actually need to be preceeded by
                 * one of the two Single-Shift codes. With this, the third stage
                 * stores one byte fewer per character than the actual maximum length of
                 * EUC byte sequences.
                 *
                 * Other than that, leading zero bytes are removed and the other
                 * bytes output. A single zero byte may be output if the "assigned"
                 * bit in stage 2 was on.
                 * The data structure does not support zero byte output as a fallback,
                 * and also does not allow output of leading zeros.
                 ','line_number':4426,'multiline':True]['text':' get the bytes and the length for the output ','line_number':4460,'multiline':True]['text':' 1/2-byte stateful with Shift-In/Shift-Out ','line_number':4471,'multiline':True]['text':'
                     * Save the old state in the converter object
                     * right here, then change the local prevLength state variable if necessary.
                     * Then, if this character turns out to be unassigned or a fallback that
                     * is not taken, the callback code must not save the new state in the converter
                     * because the new state is for a character that is not output.
                     * However, the callback must still restore the state from the converter
                     * in case the callback function changed it for its output.
                     ','line_number':4472,'multiline':True]['text':' save the old state ','line_number':4481,'multiline':True]['text':' no mapping, leave value==0 ','line_number':4485,'multiline':True]['text':' change from double-byte mode to single-byte ','line_number':4490,'multiline':True]['text':' change from single-byte mode to double-byte ','line_number':4505,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4519,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4522,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4523,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4554,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4570,'multiline':True]['text':' must not occur ','line_number':4586,'multiline':True]['text':'
                     * To avoid compiler warnings that value & length may be
                     * used without having been initialized, we set them here.
                     * In reality, this is unreachable code.
                     * Not having a default branch also causes warnings with
                     * some compilers.
                     ','line_number':4587,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4594,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4599,'multiline':True]['text':'
                     * We allow a 0 byte output if the "assigned" bit is set for this entry.
                     * There is no way with this data structure for fallback output
                     * to be a zero byte.
                     ','line_number':4603,'multiline':True]['text':' try an extension mapping ','line_number':4610,'multiline':True]['text':' restore SISO state ','line_number':4619,'multiline':True]['text':' not mappable or buffer overflow ','line_number':4622,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':4625,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':4627,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':4630,'multiline':True]['text':' write the output character bytes from value and length ','line_number':4640,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':4641,'multiline':True]['text':' each branch falls through to the next one ','line_number':4645,'multiline':True]['text':' will never occur ','line_number':4659,'multiline':True]['text':' each branch falls through to the next one ','line_number':4664,'multiline':True]['text':' will never occur ','line_number':4682,'multiline':True]['text':'
                 * We actually do this backwards here:
                 * In order to save an intermediate variable, we output
                 * first to the overflow buffer what does not fit into the
                 * regular target.
                 ','line_number':4690,'multiline':True]['text':' we know that 1<=targetCapacity<length<=4 ','line_number':4696,'multiline':True]['text':' each branch falls through to the next one ','line_number':4700,'multiline':True]['text':' will never occur ','line_number':4711,'multiline':True]['text':' now output what fits into the regular target ','line_number':4716,'multiline':True]['text':' length was reduced by targetCapacity ','line_number':4717,'multiline':True]['text':' each branch falls through to the next one ','line_number':4719,'multiline':True]['text':' will never occur ','line_number':4739,'multiline':True]['text':' target overflow ','line_number':4743,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':4750,'multiline':True]['text':' target is full ','line_number':4758,'multiline':True]['text':'
     * the end of the input stream and detection of truncated input
     * are handled by the framework, but for EBCDIC_STATEFUL conversion
     * we need to emit an SI at the very end
     *
     * conditions:
     *   successful
     *   EBCDIC_STATEFUL in DBCS mode
     *   end of input and no truncated input
     ','line_number':4764,'multiline':True]['text':' EBCDIC_STATEFUL ending with DBCS: emit an SI to return the output stream to SBCS ','line_number':4778,'multiline':True]['text':' set the last source character's index (sourceIndex points at sourceLimit now) ','line_number':4791,'multiline':True]['text':' target is full ','line_number':4795,'multiline':True]['text':' we switched into SBCS ','line_number':4803,'multiline':True]['text':' set the converter state back into UConverter ','line_number':4806,'multiline':True]['text':' write back the updated pointers ','line_number':4810,'multiline':True]['text':'
 * This is another simple conversion function for internal use by other
 * conversion implementations.
 * It does not use the converter state nor call callbacks.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It handles conversion extensions but not GB 18030.
 *
 * It converts one single Unicode code point into codepage bytes, encoded
 * as one 32-bit value. The function returns the number of bytes in *pValue:
 * 1..4 the number of bytes in *pValue
 * 0    unassigned (*pValue undefined)
 * -1   illegal (currently not used, *pValue undefined)
 *
 * *pValue will contain the resulting bytes with the last byte in bits 7..0,
 * the second to last byte in bits 15..8, etc.
 * Currently, the function assumes but does not check that 0<=c<=0x10ffff.
 ','line_number':4816,'multiline':True]['text':' #if 0 because this is not currently used in ICU - reduce code, increase code coverage ','line_number':4840,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4847,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes (same as in _MBCSFromUnicodeWithOffsets) ','line_number':4851,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4854,'multiline':True]['text':' outputType!=MBCS_OUTPUT_1 ','line_number':4859,'multiline':True]['text':' get the bytes and the length for the output ','line_number':4862,'multiline':True]['text':' #if 0 because this is not currently used in ICU - reduce code, increase code coverage ','line_number':4873,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4875,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4878,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4879,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4910,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4926,'multiline':True]['text':' must not occur ','line_number':4943,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4947,'multiline':True]['text':'
                 * We allow a 0 byte output if the "assigned" bit is set for this entry.
                 * There is no way with this data structure for fallback output
                 * to be a zero byte.
                 ','line_number':4951,'multiline':True]['text':' assigned ','line_number':4956,'multiline':True]['text':' return abs(length); ','line_number':4966,'multiline':True]['text':' unassigned ','line_number':4969,'multiline':True]['text':'
 * This function has been moved to ucnv2022.c for inlining.
 * This implementation is here only for documentation purposes
 ','line_number':4975,'multiline':True]['text':'*
 * This version of ucnv_MBCSFromUChar32() is optimized for single-byte codepages.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It does not handle conversion extensions (_extFromU()).
 *
 * It returns the codepage byte for the code point, or -1 if it is unassigned.
 ','line_number':4980,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4994,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes (same as in _MBCSFromUnicodeWithOffsets) ','line_number':4999,'multiline':True]['text':' get the byte for the output ','line_number':5002,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':5004,'multiline':True]['text':' MBCS-from-UTF-8 conversion functions ------------------------------------- ','line_number':5013,'multiline':True]['text':' offsets for n-byte UTF-8 sequences that were calculated with ((lead<<6)+trail)<<6+trail... ','line_number':5015,'multiline':True]['text':' set up the local pointers ','line_number':5040,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':5058,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':5061,'multiline':True]['text':' get the converter state from the UTF-8 UConverter ','line_number':5066,'multiline':True]['text':' The conversion loop checks source<sourceLimit only once per 1/2/3-byte character.','line_number':5076,'multiline':False]['text':' If the buffer ends with a truncated 2- or 3-byte sequence,','line_number':5077,'multiline':False]['text':' then we reduce the sourceLimit to before that,','line_number':5078,'multiline':False]['text':' and collect the remaining bytes after the conversion loop.','line_number':5079,'multiline':False]['text':' Do not go back into the bytes that will be read for finishing a partial','line_number':5081,'multiline':False]['text':' sequence from the previous buffer.','line_number':5082,'multiline':False]['text':' common ASCII character','line_number':5087,'multiline':False]['text':' truncated 3-byte sequence','line_number':5091,'multiline':False]['text':' truncated 2- or 3-byte sequence','line_number':5095,'multiline':False]['text':'
         * Note: We could avoid the goto by duplicating some of the moreBytes
         * code, but only up to the point of collecting a complete UTF-8
         * sequence; then recurse for the toUBytes[toULength]
         * and then continue with normal conversion.
         *
         * If so, move this code to just after initializing the minimum
         * set of local variables for reading the UTF-8 input
         * (utf8, source, target, limits but not cnv, table, minValue, etc.).
         *
         * Potential advantages:
         * - avoid the goto
         * - oldToULength could become a local variable in just those code blocks
         *   that deal with buffer boundaries
         * - possibly faster if the goto prevents some compiler optimizations
         *   (this would need measuring to confirm)
         * Disadvantage:
         * - code duplication
         ','line_number':5105,'multiline':True]['text':' conversion loop ','line_number':5126,'multiline':True]['text':' convert ASCII ','line_number':5131,'multiline':True]['text':' handle U+0080..U+07FF inline ','line_number':5142,'multiline':True]['text':' handle U+0800..U+0FFF inline ','line_number':5160,'multiline':True]['text':' handle "complicated" and error cases, and continuing partial characters ','line_number':5182,'multiline':True]['text':'
                         * The sourceLimit may have been adjusted before the conversion loop
                         * to stop before a truncated sequence.
                         * Here we need to use the real limit in case we have two truncated
                         * sequences at the end.
                         * See ticket #7492.
                         ','line_number':5189,'multiline':True]['text':' sequence too short, stop with toULength<toULimit ','line_number':5203,'multiline':True]['text':' store the partial UTF-8 character, compatible with the regular UTF-8 converter ','line_number':5206,'multiline':True]['text':' BMP ','line_number':5222,'multiline':True]['text':' supplementary code point ','line_number':5225,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':5227,'multiline':True]['text':' error handling: illegal UTF-8 byte sequence ','line_number':5234,'multiline':True]['text':' output the mapping for c ','line_number':5249,'multiline':True]['text':' value<minValue means c is unassigned (unmappable) ','line_number':5253,'multiline':True]['text':'
                 * Try an extension mapping.
                 * Pass in no source because we don't have UTF-16 input.
                 * If we have a partial match on c, we will return and revert
                 * to UTF-8->UTF-16->charset conversion.
                 ','line_number':5254,'multiline':True]['text':' not mappable or buffer overflow ','line_number':5270,'multiline':True]['text':'
                     * Partial match, return and revert to pivoting.
                     * In normal from-UTF-16 conversion, we would just continue
                     * but then exit the loop because the extension match would
                     * have consumed the source.
                     ','line_number':5274,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':5283,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':5285,'multiline':True]['text':' target is full ','line_number':5290,'multiline':True]['text':'
     * The sourceLimit may have been adjusted before the conversion loop
     * to stop before a truncated sequence.
     * If so, then collect the truncated sequence now.
     ','line_number':5296,'multiline':True]['text':' write back the updated pointers ','line_number':5316,'multiline':True]['text':' set up the local pointers ','line_number':5343,'multiline':True]['text':' get the converter state from the UTF-8 UConverter ','line_number':5362,'multiline':True]['text':' The conversion loop checks source<sourceLimit only once per 1/2/3-byte character.','line_number':5372,'multiline':False]['text':' If the buffer ends with a truncated 2- or 3-byte sequence,','line_number':5373,'multiline':False]['text':' then we reduce the sourceLimit to before that,','line_number':5374,'multiline':False]['text':' and collect the remaining bytes after the conversion loop.','line_number':5375,'multiline':False]['text':' Do not go back into the bytes that will be read for finishing a partial','line_number':5377,'multiline':False]['text':' sequence from the previous buffer.','line_number':5378,'multiline':False]['text':' common ASCII character','line_number':5383,'multiline':False]['text':' truncated 3-byte sequence','line_number':5387,'multiline':False]['text':' truncated 2- or 3-byte sequence','line_number':5391,'multiline':False]['text':' See note in ucnv_SBCSFromUTF8() about this goto. ','line_number':5401,'multiline':True]['text':' conversion loop ','line_number':5404,'multiline':True]['text':' convert ASCII ','line_number':5409,'multiline':True]['text':' handle U+0800..U+D7FF inline ','line_number':5423,'multiline':True]['text':' do not assume maxFastUChar>0xd7ff','line_number':5424,'multiline':False]['text':' handle U+0080..U+07FF inline ','line_number':5439,'multiline':True]['text':' handle "complicated" and error cases, and continuing partial characters ','line_number':5456,'multiline':True]['text':'
                         * The sourceLimit may have been adjusted before the conversion loop
                         * to stop before a truncated sequence.
                         * Here we need to use the real limit in case we have two truncated
                         * sequences at the end.
                         * See ticket #7492.
                         ','line_number':5463,'multiline':True]['text':' sequence too short, stop with toULength<toULimit ','line_number':5477,'multiline':True]['text':' store the partial UTF-8 character, compatible with the regular UTF-8 converter ','line_number':5480,'multiline':True]['text':' BMP ','line_number':5496,'multiline':True]['text':' supplementary code point ','line_number':5499,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':5501,'multiline':True]['text':' error handling: illegal UTF-8 byte sequence ','line_number':5508,'multiline':True]['text':' get the bytes and the length for the output ','line_number':5520,'multiline':True]['text':' MBCS_OUTPUT_2 ','line_number':5521,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':5524,'multiline':True]['text':' write the output character bytes from value and length ','line_number':5533,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':5534,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':5536,'multiline':True]['text':' length==2 ','line_number':5539,'multiline':True]['text':' target overflow ','line_number':5548,'multiline':True]['text':'
                 * Try an extension mapping.
                 * Pass in no source because we don't have UTF-16 input.
                 * If we have a partial match on c, we will return and revert
                 * to UTF-8->UTF-16->charset conversion.
                 ','line_number':5557,'multiline':True]['text':' not mappable or buffer overflow ','line_number':5573,'multiline':True]['text':'
                     * Partial match, return and revert to pivoting.
                     * In normal from-UTF-16 conversion, we would just continue
                     * but then exit the loop because the extension match would
                     * have consumed the source.
                     ','line_number':5577,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':5586,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':5588,'multiline':True]['text':' target is full ','line_number':5594,'multiline':True]['text':'
     * The sourceLimit may have been adjusted before the conversion loop
     * to stop before a truncated sequence.
     * If so, then collect the truncated sequence now.
     ','line_number':5600,'multiline':True]['text':' write back the updated pointers ','line_number':5620,'multiline':True]['text':' miscellaneous ------------------------------------------------------------ ','line_number':5625,'multiline':True]['text':' all bytes that cause a state transition from state 0 are lead bytes ','line_number':5636,'multiline':True]['text':'
 * This is an internal function that allows other converter implementations
 * to check whether a byte is a lead byte.
 ','line_number':5641,'multiline':True]['text':' first, select between subChar and subChar1 ','line_number':5659,'multiline':True]['text':' select subChar1 if it is set (not 0) and the unmappable Unicode code point is up to U+00ff (IBM MBCS behavior) ','line_number':5665,'multiline':True]['text':' select subChar in all other cases ','line_number':5669,'multiline':True]['text':' reset the selector for the next code point ','line_number':5674,'multiline':True]['text':' fromUnicodeStatus contains prevLength ','line_number':5680,'multiline':True]['text':' DBCS mode and SBCS sub char: change to SBCS ','line_number':5684,'multiline':True]['text':' SBCS mode and DBCS sub char: change to DBCS ','line_number':5692,'multiline':True]['text':' SBCS, DBCS, and EBCDIC_STATEFUL are replaced by MBCS, but here we cheat a little ','line_number':5712,'multiline':True]['text':' #if !UCONFIG_NO_LEGACY_CONVERSION ','line_number':5723,'multiline':True]