['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
*******************************************************************************
*
*   Copyright (C) 2001-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  ustrcase.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2002feb20
*   created by: Markus W. Scherer
*
*   Implementation file for string casing C API functions.
*   Uses functions from uchar.c for basic functionality that requires access
*   to the Unicode Character Database (uprops.dat).
','line_number':3,'multiline':True]['text':' Appends a full case mapping result, see UCASE_MAX_STRING_LENGTH. ','line_number':55,'multiline':True]['text':' decode the result ','line_number':63,'multiline':True]['text':' (not) original code point ','line_number':65,'multiline':True]['text':' BMP slightly-fastpath','line_number':73,'multiline':False]['text':' BMP slightly-fastpath','line_number':82,'multiline':False]['text':' integer overflow','line_number':97,'multiline':False]['text':' append the result ','line_number':101,'multiline':True]['text':' code point ','line_number':103,'multiline':True]['text':' overflow, nothing written ','line_number':107,'multiline':True]['text':' string ','line_number':111,'multiline':True]['text':' overflow ','line_number':118,'multiline':True]['text':' preflight ','line_number':123,'multiline':True]['text':' integer overflow','line_number':134,'multiline':False]['text':' integer overflow','line_number':149,'multiline':False]['text':' reset for backward iteration ','line_number':172,'multiline':True]['text':' reset for forward iteration ','line_number':176,'multiline':True]['text':' continue current iteration direction ','line_number':180,'multiline':True]['text':'*
 * caseLocale >= 0: Lowercases [srcStart..srcLimit[ but takes context [0..srcLength[ into account.
 * caseLocale < 0: Case-folds [srcStart..srcLimit[.
 ','line_number':198,'multiline':True]['text':' fast path for simple cases','line_number':220,'multiline':False]['text':' surrogate or higher','line_number':232,'multiline':False]['text':' slow path','line_number':259,'multiline':False]['text':' fast path for simple cases','line_number':315,'multiline':False]['text':' surrogate or higher','line_number':327,'multiline':False]['text':' slow path','line_number':354,'multiline':False]['text':' namespace','line_number':391,'multiline':False]['text':' set up local variables ','line_number':409,'multiline':True]['text':' titlecasing loop ','line_number':417,'multiline':True]['text':' find next index where to titlecase ','line_number':419,'multiline':True]['text':'
         * Segment [prev..index[ into 3 parts:
         * a) skipped characters (copy as-is) [prev..titleStart[
         * b) first letter (titlecase)              [titleStart..titleLimit[
         * c) subsequent characters (lowercase)                 [titleLimit..index[
         ','line_number':431,'multiline':True]['text':' Find and copy skipped characters [prev..titleStart[','line_number':438,'multiline':False]['text':' Adjust the titlecasing index to the next cased character,','line_number':444,'multiline':False]['text':' or to the next letter/number/symbol/private use.','line_number':445,'multiline':False]['text':' Stop with titleStart<titleLimit<=index','line_number':446,'multiline':False]['text':' if there is a character to be titlecased,','line_number':447,'multiline':False]['text':' or else stop with titleStart==titleLimit==index.','line_number':448,'multiline':False]['text':' titlecase c which is from [titleStart..titleLimit[ ','line_number':468,'multiline':True]['text':' Special case Dutch IJ titlecasing ','line_number':480,'multiline':True]['text':' Keep the capital J from getting lowercased.','line_number':495,'multiline':False]['text':' lowercase [titleLimit..index[ ','line_number':506,'multiline':True]['text':' Normal operation: Lowercase the rest of the word. ','line_number':509,'multiline':True]['text':' Optionally just copy the rest of the word unchanged. ','line_number':523,'multiline':True]['text':' !UCONFIG_NO_BREAK_ITERATION','line_number':541,'multiline':False]['text':' Data generated by prototype code, see','line_number':546,'multiline':False]['text':' http://site.icu-project.org/design/case/greek-upper','line_number':547,'multiline':False]['text':' TODO: Move this data into ucase.icu.','line_number':548,'multiline':False]['text':' U+0370..03FF','line_number':550,'multiline':False]['text':' U+1F00..1FFF','line_number':698,'multiline':False]['text':' U+2126 Ohm sign','line_number':957,'multiline':False]['text':' varia','line_number':976,'multiline':False]['text':' tonos = oxia','line_number':977,'multiline':False]['text':' perispomeni','line_number':978,'multiline':False]['text':' circumflex can look like perispomeni','line_number':979,'multiline':False]['text':' tilde can look like perispomeni','line_number':980,'multiline':False]['text':' inverted breve can look like perispomeni','line_number':981,'multiline':False]['text':' dialytika = diaeresis','line_number':983,'multiline':False]['text':' dialytika tonos','line_number':985,'multiline':False]['text':' ypogegrammeni = iota subscript','line_number':987,'multiline':False]['text':' macron','line_number':989,'multiline':False]['text':' breve','line_number':990,'multiline':False]['text':' comma above','line_number':991,'multiline':False]['text':' reversed comma above','line_number':992,'multiline':False]['text':' koronis','line_number':993,'multiline':False]['text':' Case-ignorable, continue with the loop.','line_number':1006,'multiline':False]['text':' Followed by cased letter.','line_number':1008,'multiline':False]['text':' Uncased and not case-ignorable.','line_number':1010,'multiline':False]['text':' Not followed by cased letter.','line_number':1013,'multiline':False]['text':'*
 * Greek string uppercasing with a state machine.
 * Probably simpler than a stateless function that has to figure out complex context-before
 * for each character.
 * TODO: Try to re-consolidate one way or another with the non-Greek function.
 ','line_number':1016,'multiline':True]['text':' c is case-ignorable','line_number':1036,'multiline':False]['text':' c is cased','line_number':1039,'multiline':False]['text':' Add a dialytika to this iota or ypsilon vowel','line_number':1045,'multiline':False]['text':' if we removed a tonos from the previous vowel,','line_number':1046,'multiline':False]['text':' and that previous vowel did not also have (or gain) a dialytika.','line_number':1047,'multiline':False]['text':' Adding one only to the final vowel in a longer sequence','line_number':1048,'multiline':False]['text':' (which does not occur in normal writing) would require lookahead.','line_number':1049,'multiline':False]['text':' Set the same flag as for preserving an existing dialytika.','line_number':1050,'multiline':False]['text':' Map each one to a trailing, spacing, capital iota.','line_number':1055,'multiline':False]['text':' Skip combining diacritics after this Greek letter.','line_number':1059,'multiline':False]['text':' not a Greek diacritic','line_number':1069,'multiline':False]['text':' Map according to Greek rules.','line_number':1075,'multiline':False]['text':' Keep disjunctive "or" with (only) a tonos.','line_number':1082,'multiline':False]['text':' We use the same "word boundary" conditions as for the Final_Sigma test.','line_number':1083,'multiline':False]['text':' Preserve the precomposed form.','line_number':1085,'multiline':False]['text':' Preserve a vowel with dialytika in precomposed form if it exists.','line_number':1090,'multiline':False]['text':' common, simple usage','line_number':1102,'multiline':False]['text':' Find out first whether we are changing the text.','line_number':1104,'multiline':False]['text':' Write unchanged text?','line_number':1126,'multiline':False]['text':' restore or add a dialytika','line_number':1134,'multiline':False]['text':' namespace GreekUpper','line_number':1165,'multiline':False]['text':' functions available in the common library (for unistr_case.cpp) ','line_number':1168,'multiline':True]['text':' caseLocale ','line_number':1211,'multiline':True]['text':' check argument values ','line_number':1233,'multiline':True]['text':' get the string length ','line_number':1246,'multiline':True]['text':' check for overlapping source and destination ','line_number':1251,'multiline':True]['text':' check argument values ','line_number':1279,'multiline':True]['text':' get the string length ','line_number':1292,'multiline':True]['text':' check for overlapping source and destination ','line_number':1297,'multiline':True]['text':' overlap: provide a temporary destination buffer and later copy the result ','line_number':1302,'multiline':True]['text':' the stack buffer is large enough ','line_number':1304,'multiline':True]['text':' allocate a buffer ','line_number':1307,'multiline':True]['text':' copy the result string to the destination buffer ','line_number':1321,'multiline':True]['text':' public API functions ','line_number':1333,'multiline':True]['text':' case-insensitive string comparisons -------------------------------------- ','line_number':1363,'multiline':True]['text':'
 * This function is a copy of unorm_cmpEquivFold() minus the parts for
 * canonical equivalence.
 * Keep the functions in sync, and see there for how this works.
 * The duplication is for modularization:
 * It makes caseless (but not canonical caseless) matches independent of
 * the normalization code.
 ','line_number':1365,'multiline':True]['text':' stack element for previous-level source/decomposition pointers ','line_number':1374,'multiline':True]['text':'*
 * Internal implementation code comparing string with case fold.
 * This function is called from u_strcmpFold() and u_caseInsensitivePrefixMatch().
 *
 * @param s1            input string 1
 * @param length1       length of string 1, or -1 (NULL terminated)
 * @param s2            input string 2
 * @param length2       length of string 2, or -1 (NULL terminated)
 * @param options       compare options
 * @param matchLen1     (output) length of partial prefix match in s1
 * @param matchLen2     (output) length of partial prefix match in s2
 * @param pErrorCode    receives error status
 * @return The result of comparison
 ','line_number':1380,'multiline':True]['text':' current-level start/limit - s1/s2 as current ','line_number':1402,'multiline':True]['text':' points to the original start address ','line_number':1405,'multiline':True]['text':' points to the end of match + 1 ','line_number':1408,'multiline':True]['text':' case folding variables ','line_number':1411,'multiline':True]['text':' stacks of previous-level start/current/limit ','line_number':1415,'multiline':True]['text':' case folding buffers, only use current-level start/limit ','line_number':1418,'multiline':True]['text':' track which is the current level per string ','line_number':1421,'multiline':True]['text':' current code units, and code points for lookups ','line_number':1424,'multiline':True]['text':' no argument error checking because this itself is not an API ','line_number':1427,'multiline':True]['text':'
     * assume that at least the option U_COMPARE_IGNORE_CASE is set
     * otherwise this function would have to behave exactly as uprv_strCompare()
     ','line_number':1429,'multiline':True]['text':' initialize ','line_number':1437,'multiline':True]['text':' comparison loop ','line_number':1461,'multiline':True]['text':'
         * here a code unit value of -1 means "get another code unit"
         * below it will mean "this source is finished"
         ','line_number':1463,'multiline':True]['text':' get next code unit from string 1, post-increment ','line_number':1469,'multiline':True]['text':' reached end of level buffer, pop one level ','line_number':1481,'multiline':True]['text':'Not uninitialized','line_number':1484,'multiline':True]['text':'Not uninitialized','line_number':1486,'multiline':True]['text':'Not uninitialized','line_number':1487,'multiline':True]['text':' get next code unit from string 2, post-increment ','line_number':1492,'multiline':True]['text':' reached end of level buffer, pop one level ','line_number':1504,'multiline':True]['text':'Not uninitialized','line_number':1507,'multiline':True]['text':'Not uninitialized','line_number':1509,'multiline':True]['text':'Not uninitialized','line_number':1510,'multiline':True]['text':'
         * compare c1 and c2
         * either variable c1, c2 is -1 only if the corresponding string is finished
         ','line_number':1514,'multiline':True]['text':' c1==c2==-1 indicating end of strings ','line_number':1522,'multiline':True]['text':'
             * Note: Move the match positions in both strings at the same time
             *      only when corresponding code point(s) in the original strings
             *      are fully consumed. For example, when comparing s1="Fust" and
             *      s2="Fu\u00dfball", s2[2] is folded into "ss", and s1[2] matches
             *      the first code point in the case-folded data. But the second "s"
             *      has no matching code point in s1, so this implementation returns
             *      2 as the prefix match length ("Fu").
             ','line_number':1526,'multiline':True]['text':' Note: This implementation only use a single level of stack.
                 *      If this code needs to be changed to use multiple levels
                 *      of stacks, the code above should check if the current
                 *      code is at the end of all stacks.
                 ','line_number':1539,'multiline':True]['text':' is s1 at the end of the current stack? ','line_number':1546,'multiline':True]['text':' is s2 at the end of the current stack? ','line_number':1556,'multiline':True]['text':' make us fetch new code units ','line_number':1564,'multiline':True]['text':' string 1 ends before string 2 ','line_number':1567,'multiline':True]['text':' string 2 ends before string 1 ','line_number':1570,'multiline':True]['text':' c1!=c2 && c1>=0 && c2>=0 ','line_number':1573,'multiline':True]['text':' get complete code points for c1, c2 for lookups if either is a surrogate ','line_number':1575,'multiline':True]['text':' advance ++s1; only below if cp1 decomposes/case-folds ','line_number':1582,'multiline':True]['text':' isTrail(c1) ','line_number':1585,'multiline':True]['text':' advance ++s2; only below if cp2 decomposes/case-folds ','line_number':1598,'multiline':True]['text':' isTrail(c2) ','line_number':1601,'multiline':True]['text':'
         * go down one level for each string
         * continue with the main loop as soon as there is a real change
         ','line_number':1608,'multiline':True]['text':' cp1 case-folds to the code point "length" or to p[length] ','line_number':1616,'multiline':True]['text':' advance beyond source surrogate pair if it case-folds ','line_number':1619,'multiline':True]['text':' isTrail(c1) ','line_number':1621,'multiline':True]['text':'
                     * we got a supplementary code point when hitting its trail surrogate,
                     * therefore the lead surrogate must have been the same as in the other string;
                     * compare this decomposition with the lead surrogate in the other string
                     * remember that this simulates bulk text replacement:
                     * the decomposition would replace the entire code point
                     ','line_number':1622,'multiline':True]['text':' push current level pointers ','line_number':1635,'multiline':True]['text':' copy the folding result to fold1[] ','line_number':1641,'multiline':True]['text':' set next level pointers to case folding ','line_number':1650,'multiline':True]['text':' get ready to read from decomposition, continue with loop ','line_number':1654,'multiline':True]['text':' cp2 case-folds to the code point "length" or to p[length] ','line_number':1662,'multiline':True]['text':' advance beyond source surrogate pair if it case-folds ','line_number':1665,'multiline':True]['text':' isTrail(c2) ','line_number':1667,'multiline':True]['text':'
                     * we got a supplementary code point when hitting its trail surrogate,
                     * therefore the lead surrogate must have been the same as in the other string;
                     * compare this decomposition with the lead surrogate in the other string
                     * remember that this simulates bulk text replacement:
                     * the decomposition would replace the entire code point
                     ','line_number':1668,'multiline':True]['text':' push current level pointers ','line_number':1681,'multiline':True]['text':' copy the folding result to fold2[] ','line_number':1687,'multiline':True]['text':' set next level pointers to case folding ','line_number':1696,'multiline':True]['text':' get ready to read from decomposition, continue with loop ','line_number':1700,'multiline':True]['text':'
         * no decomposition/case folding, max level for both sides:
         * return difference result
         *
         * code point order comparison must not just return cp1-cp2
         * because when single surrogates are present then the surrogate pairs
         * that formed cp1 and cp2 may be from different string indexes
         *
         * example: { d800 d800 dc01 } vs. { d800 dc00 }, compare at second code units
         * c1=d800 cp1=10001 c2=dc00 cp2=10000
         * cp1-cp2>0 but c1-c2<0 and in fact in UTF-32 it is { d800 10001 } < { 10000 }
         *
         * therefore, use same fix-up as in ustring.c/uprv_strCompare()
         * except: uprv_strCompare() fetches c=*s while this functions fetches c=*s++
         * so we have slightly different pointer/start/limit comparisons here
         ','line_number':1705,'multiline':True]['text':' subtract 0x2800 from BMP code points to make them smaller than supplementary ones ','line_number':1723,'multiline':True]['text':' part of a surrogate pair, leave >=d800 ','line_number':1728,'multiline':True]['text':' BMP code point - may be surrogate code point - make <d800 ','line_number':1730,'multiline':True]['text':' part of a surrogate pair, leave >=d800 ','line_number':1738,'multiline':True]['text':' BMP code point - may be surrogate code point - make <d800 ','line_number':1740,'multiline':True]['text':' internal function ','line_number':1756,'multiline':True]['text':' public API functions ','line_number':1765,'multiline':True]['text':' argument checking ','line_number':1772,'multiline':True]['text':' internal API - detect length of shared prefix ','line_number':1809,'multiline':True]