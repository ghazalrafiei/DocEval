['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' TaggedParserAtomIndex','line_number':10,'multiline':False]['text':' TaggedParserAtomIndexHasher','line_number':11,'multiline':False]['text':' A data structure for tracking used names per parsing session in order to','line_number':22,'multiline':False]['text':' compute which bindings are closed over. Scripts and scopes are numbered','line_number':23,'multiline':False]['text':' monotonically in textual order and unresolved uses of a name are tracked by','line_number':24,'multiline':False]['text':' lists of identifier uses, which are a pair of (ScriptId,ScopeId).','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' For an identifier `i` with a use (ScriptId,ScopeId) in the Used list,','line_number':27,'multiline':False]['text':' ScriptId tracks the most nested script that has a use of u, and ScopeId','line_number':28,'multiline':False]['text':' tracks the most nested scope that is still being parsed (as the lists will be','line_number':29,'multiline':False]['text':' filtered as we finish processing a particular scope).','line_number':30,'multiline':False]['text':'','line_number':31,'multiline':False]['text':' ScriptId is used to answer the question "is `i` used by a nested function?"','line_number':32,'multiline':False]['text':' ScopeId is used to answer the question "is `i` used in any scopes currently','line_number':33,'multiline':False]['text':'                                         being parsed?"','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' The algorithm:','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' Let Used be a map of names to lists.','line_number':38,'multiline':False]['text':' Let Declared(ScopeId) be a list of declarations for a scope numbered with','line_number':39,'multiline':False]['text':' ScopeId','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' 1. Number all scopes in monotonic increasing order in textual order.','line_number':42,'multiline':False]['text':' 2. Number all scripts in monotonic increasing order in textual order.','line_number':43,'multiline':False]['text':' 3. When an identifier `i` is used in (ScriptId,ScopeId), append that use to','line_number':44,'multiline':False]['text':'    the list Used[i] (creating the list and table entry if necessary).','line_number':45,'multiline':False]['text':' 4. When an identifier `i` is declared in a scope numbered ScopeId, append `i`','line_number':46,'multiline':False]['text':'    to Declared(ScopeId).','line_number':47,'multiline':False]['text':' 5. When we finish parsing a scope numbered with ScopeId, in script numbered','line_number':48,'multiline':False]['text':'    ScriptId, for each declared name d in Declared(ScopeId):','line_number':49,'multiline':False]['text':'   a. If d is found in Used, mark d as closed over if there is a value','line_number':50,'multiline':False]['text':'      (UsedScriptId, UsedScopeId) in Used[d] such that UsedScriptId > ScriptId','line_number':51,'multiline':False]['text':'      and UsedScopeId > ScopeId.','line_number':52,'multiline':False]['text':'   b. Remove all values uses in Used[d] where UsedScopeId > ScopeId.','line_number':53,'multiline':False]['text':'','line_number':54,'multiline':False]['text':' Steps 1 and 2 are implemented by UsedNameTracker::next{Script,Scope}Id.','line_number':55,'multiline':False]['text':' Step 3 is implemented by UsedNameTracker::noteUsedInScope.','line_number':56,'multiline':False]['text':' Step 4 is implemented by ParseContext::Scope::addDeclaredName.','line_number':57,'multiline':False]['text':' Step 5 is implemented by UsedNameTracker::noteBoundInScope and','line_number':58,'multiline':False]['text':' Parser::propagateFreeNamesAndMarkClosedOverBindings','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':' The following is a worked example to show how the algorithm works on a','line_number':61,'multiline':False]['text':' relatively simple piece of code. (clang-format is disabled due to the width','line_number':62,'multiline':False]['text':' of the example).','line_number':63,'multiline':False]['text':' clang-format off','line_number':65,'multiline':False]['text':'','line_number':66,'multiline':False]['text':' // Script 1, Scope 1','line_number':67,'multiline':False]['text':' var x = 1;                              // Declared(1) = [x];','line_number':68,'multiline':False]['text':' function f() {// Script 2, Scope 2','line_number':69,'multiline':False]['text':'     if (x > 10) { //Scope 3             // Used[x] = [(2,2)];','line_number':70,'multiline':False]['text':'         var x = 12;                     // Declared(3) = [x];','line_number':71,'multiline':False]['text':'         function g() // Script 3','line_number':72,'multiline':False]['text':'         { // Scope 4','line_number':73,'multiline':False]['text':'             return x;                   // Used[x] = [(2,2), (3,4)]','line_number':74,'multiline':False]['text':'         }                               // Leaving Script 3, Scope 4: No declared variables.','line_number':75,'multiline':False]['text':'     }                                   // Leaving Script 2, Scope 3: Declared(3) = [x];','line_number':76,'multiline':False]['text':'                                         // - Used[x][1] = (2,2) is not > (2,3)','line_number':77,'multiline':False]['text':'                                         // - Used[x][2] = (3,4) is > (2,3), so mark x as closed over.','line_number':78,'multiline':False]['text':'                                         // - Update Used[x]: [] -- Makes sense, as at this point we have','line_number':79,'multiline':False]['text':'                                         //                         bound all the unbound x to a particlar','line_number':80,'multiline':False]['text':'                                         //                         declaration..','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':'     else { // Scope 5','line_number':83,'multiline':False]['text':'         var x = 14;                     // Declared(5) = [x]','line_number':84,'multiline':False]['text':'         function g() // Script 4','line_number':85,'multiline':False]['text':'         { // Scope 6','line_number':86,'multiline':False]['text':'             return y;                   // Used[y] = [(4,6)]','line_number':87,'multiline':False]['text':'         }                               // Leaving Script 4, Scope 6: No declarations.','line_number':88,'multiline':False]['text':'     }                                   // Leaving Script 2, Scope 5: Declared(5) = [x]','line_number':89,'multiline':False]['text':'                                         // - Used[x] = [], so don't mark x as closed over.','line_number':90,'multiline':False]['text':'     var y = 12;                         // Declared(2) = [y]','line_number':91,'multiline':False]['text':' }                                       // Leaving Script 2, Scope 2: Declared(2) = [y]','line_number':92,'multiline':False]['text':'                                         // - Used[y][1] = (4,6) is > (2,2), so mark y as closed over.','line_number':93,'multiline':False]['text':'                                         // - Update Used[y]: [].','line_number':94,'multiline':False]['text':' clang-format on','line_number':96,'multiline':False]['text':' The first place this name was used. This is important to track','line_number':122,'multiline':False]['text':' for private names, as we will use this location to issue','line_number':123,'multiline':False]['text':' diagnostics for using a name that's not defined lexically.','line_number':124,'multiline':False]['text':' To allow disambiguating public and private symbols','line_number':160,'multiline':False]['text':' The map of names to chains of uses.','line_number':172,'multiline':False]['text':' Monotonically increasing id for all nested scripts.','line_number':175,'multiline':False]['text':' Monotonically increasing id for all nested scopes.','line_number':178,'multiline':False]['text':' Set if a private name was encountered.','line_number':181,'multiline':False]['text':' Used to short circuit some private field early error checks','line_number':182,'multiline':False]['text':' Fill maybeUnboundName with the first (source order) unbound name, or','line_number':212,'multiline':False]['text':' Nothing() if there are no unbound names.','line_number':213,'multiline':False]['text':' Return a list of unbound private names, sorted by increasing location in','line_number':217,'multiline':False]['text':' the source.','line_number':218,'multiline':False]['text':' Resets state so that scriptId and scopeId are the innermost script and','line_number':236,'multiline':False]['text':' scope, respectively. Used for rewinding state on syntax parse failure.','line_number':237,'multiline':False]['text':' namespace frontend','line_number':241,'multiline':False]['text':' namespace js','line_number':242,'multiline':False]