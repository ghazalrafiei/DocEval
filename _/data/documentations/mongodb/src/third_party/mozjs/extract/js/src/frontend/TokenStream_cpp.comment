['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JS lexical scanner.','line_number':7,'multiline':False]['text':' js::GetErrorMessage, JSMSG_*','line_number':40,'multiline':False]['text':' JS_smprintf','line_number':41,'multiline':False]['text':' JS::RegExpFlags','line_number':42,'multiline':False]['text':' js::{,NonBuiltin}FrameIter','line_number':47,'multiline':False]['text':' js_*_str','line_number':52,'multiline':False]['text':' C string with reserved word text','line_number':73,'multiline':False]['text':' Returns a ReservedWordInfo for the specified characters, or nullptr if the','line_number':90,'multiline':False]['text':' string is not a reserved word.','line_number':91,'multiline':False]['text':' Skip over any private name marker.','line_number':244,'multiline':False]['text':' Skip over any private name marker.','line_number':288,'multiline':False]['text':' The identifier part of a private name mustn't be empty.','line_number':290,'multiline':False]['text':' This is actually necessary!  Removing it causes compile errors on','line_number':368,'multiline':False]['text':' GCC and clang.  You could try declaring this:','line_number':369,'multiline':False]['text':'','line_number':370,'multiline':False]['text':'   const uint32_t SourceCoords::MAX_PTR;','line_number':371,'multiline':False]['text':'','line_number':372,'multiline':False]['text':' which fixes the GCC/clang error, but causes bustage on Windows.  Sigh.','line_number':373,'multiline':False]['text':'','line_number':374,'multiline':False]['text':' The first line begins at buffer offset |initialOffset|.  MAX_PTR is the','line_number':377,'multiline':False]['text':' sentinel.  The appends cannot fail because |lineStartOffsets_| has','line_number':378,'multiline':False]['text':' statically-allocated elements.','line_number':379,'multiline':False]['text':' We haven't seen this newline before.  Update lineStartOffsets_','line_number':395,'multiline':False]['text':' only if lineStartOffsets_.append succeeds, to keep sentinel.','line_number':396,'multiline':False]['text':' Otherwise return false to tell TokenStream about OOM.','line_number':397,'multiline':False]['text':' We have seen this newline before (and ungot it).  Do nothing (other','line_number':409,'multiline':False]['text':' than checking it hasn't mysteriously changed).','line_number':410,'multiline':False]['text':' This path can be executed after hitting OOM, so check index.','line_number':411,'multiline':False]['text':' If we reach here, offset is on a line the same as or higher than','line_number':444,'multiline':False]['text':' last time.  Check first for the +0, +1, +2 cases, because they','line_number':445,'multiline':False]['text':' typically cover 85--98% of cases.','line_number':446,'multiline':False]['text':' index is same as last time','line_number':448,'multiline':False]['text':' If we reach here, there must be at least one more entry (plus the','line_number':451,'multiline':False]['text':' sentinel).  Try it.','line_number':452,'multiline':False]['text':' index is one higher than last time','line_number':455,'multiline':False]['text':' The same logic applies here.','line_number':458,'multiline':False]['text':' index is two higher than last time','line_number':461,'multiline':False]['text':' No luck.  Oh well, we have a better-than-default starting point for','line_number':464,'multiline':False]['text':' the binary search.','line_number':465,'multiline':False]['text':' -1 due to the sentinel','line_number':468,'multiline':False]['text':' This is a binary search with deferred detection of equality, which was','line_number':474,'multiline':False]['text':' marginally faster in this case than a standard binary search.','line_number':475,'multiline':False]['text':' The -2 is because |lineStartOffsets_.length() - 1| is the sentinel, and we','line_number':476,'multiline':False]['text':' want one before that.','line_number':477,'multiline':False]['text':' offset is above lineStartOffsets_[iMid]','line_number':482,'multiline':False]['text':' offset is below or within lineStartOffsets_[iMid]','line_number':484,'multiline':False]['text':' |isExprEnding| was initially zeroed: overwrite the true entries here.','line_number':511,'multiline':False]['text':' Constrain starting columns to where they will saturate.','line_number':596,'multiline':False]['text':' On overflow, report error.','line_number':628,'multiline':False]['text':' This is all roughly indulgence of paranoia only for assertions, so the','line_number':660,'multiline':False]['text':' reimplementation of UTF-8 encoding a code point is (we think) a virtue.','line_number':661,'multiline':False]['text':' DEBUG','line_number':685,'multiline':False]['text':' |limit| is a code point boundary.','line_number':691,'multiline':False]['text':' Otherwise rewind past trailing units to the start of the code point.','line_number':696,'multiline':False]['text':' |limit| is a code point boundary.','line_number':716,'multiline':False]['text':' Otherwise the pointer must be retracted by one iff it splits a two-unit','line_number':721,'multiline':False]['text':' code point.','line_number':722,'multiline':False]['text':' Outside test suites testing garbage WTF-16, it's basically guaranteed','line_number':724,'multiline':False]['text':' here that |(*ptr)[-1] (*ptr)[0]| is a surrogate pair.','line_number':725,'multiline':False]['text':' Reset the previous offset/column cache for this line, if the previous','line_number':741,'multiline':False]['text':' lookup wasn't on this line.','line_number':742,'multiline':False]['text':' Compute and return the final column number from a partial offset/column,','line_number':750,'multiline':False]['text':' using the last-cached offset/column if they're more optimal.','line_number':751,'multiline':False]['text':' If the last lookup on this line was closer to |offset|, use it.','line_number':757,'multiline':False]['text':' We won't add an entry to |longLineColumnInfo_| for lines where the maximum','line_number':787,'multiline':False]['text':' column has offset less than this value.  The most common (non-minified)','line_number':788,'multiline':False]['text':' long line length is likely 80ch, maybe 100ch, so we use that, rounded up to','line_number':789,'multiline':False]['text':' the next power of two for efficient division/multiplication below.','line_number':790,'multiline':False]['text':' The index within any associated |Vector<ChunkInfo>| of |offset|'s chunk.','line_number':794,'multiline':False]['text':' We don't know from an |offset| in the zeroth chunk that this line is even','line_number':797,'multiline':False]['text':' long.  First-chunk info is mostly useless, anyway -- we have |start|','line_number':798,'multiline':False]['text':' already.  So if we have *easy* access to that zeroth chunk, use it --','line_number':799,'multiline':False]['text':' otherwise just count pessimally.  (This will still benefit from caching','line_number':800,'multiline':False]['text':' the last column/offset for computations for successive offsets, so it's','line_number':801,'multiline':False]['text':' not *always* worst-case.)','line_number':802,'multiline':False]['text':' If this line has no chunk vector yet, insert one in the hash map.  (The','line_number':814,'multiline':False]['text':' required index is allocated and filled further down.)','line_number':815,'multiline':False]['text':' This could rehash and invalidate a cached vector pointer, but the outer','line_number':819,'multiline':False]['text':' condition means we don't have a cached pointer.','line_number':820,'multiline':False]['text':' In case of OOM, just count columns from the start of the line.','line_number':822,'multiline':False]['text':' Note that adding elements to this vector won't invalidate this pointer.','line_number':828,'multiline':False]['text':' We've computed the chunk |offset| resides in.  Compute the column number','line_number':864,'multiline':False]['text':' from the chunk.','line_number':865,'multiline':False]['text':' This is exact if |chunkIndex| isn't the last chunk.','line_number':869,'multiline':False]['text':' Otherwise the last chunk is pessimistically assumed to contain multi-unit','line_number':872,'multiline':False]['text':' code points because we haven't fully examined its contents yet -- they','line_number':873,'multiline':False]['text':' may not have been tokenized yet, they could contain encoding errors, or','line_number':874,'multiline':False]['text':' they might not even exist.','line_number':875,'multiline':False]['text':' Extend the vector from its last entry or the start of the line.  (This is','line_number':880,'multiline':False]['text':' also a suitable partial start point if we must recover from OOM.)','line_number':881,'multiline':False]['text':' As earlier, just start from the greatest offset/column in case of OOM.','line_number':891,'multiline':False]['text':' OOM is no longer possible now.  \o/','line_number':897,'multiline':False]['text':' The vector always begins with the column of the line start, i.e. zero,','line_number':899,'multiline':False]['text':' with chunk units pessimally assumed not single-unit.','line_number':900,'multiline':False]['text':' Prior tokenizing ensured that [begin, limit) is validly encoded, and','line_number':920,'multiline':False]['text':' |begin < chunkLimit|, so any retraction here can't underflow.','line_number':921,'multiline':False]['text':' If this chunk (which will become non-final at the end of the loop) is','line_number':930,'multiline':False]['text':' all single-unit code points, annotate the chunk accordingly.','line_number':931,'multiline':False]['text':' We're at a spot in the current final chunk, and final chunks never have','line_number':943,'multiline':False]['text':' complete units information, so be pessimistic.','line_number':944,'multiline':False]['text':' As this is an encoding error, the computed window-end must be','line_number':1009,'multiline':False]['text':' identical to the location of the error -- any further on and the','line_number':1010,'multiline':False]['text':' window would contain invalid Unicode.','line_number':1011,'multiline':False]['text':' The largest encoding of a UTF-8 code point is 4 units.  (Encoding an','line_number':1022,'multiline':False]['text':' obsolete 5- or 6-byte code point will complain only about a bad lead','line_number':1023,'multiline':False]['text':' code unit.)','line_number':1024,'multiline':False]['text':' |toHexChar| produces the desired decimal numbers for values < 4.','line_number':1080,'multiline':False]['text':' Construct a string like "0x203D" (including null terminator) to include','line_number':1106,'multiline':False]['text':' in the error message.  Write the string end-to-start from end to start','line_number':1107,'multiline':False]['text':' of an adequately sized |char| array, shifting least significant nibbles','line_number':1108,'multiline':False]['text':' off the number and writing the corresponding hex digits until done, then','line_number':1109,'multiline':False]['text':' prefixing with "0x".  |codePointStr| points at the incrementally','line_number':1110,'multiline':False]['text':' computed string, within |codePointCharsArray|'s bounds.','line_number':1111,'multiline':False]['text':' 0x1F'FFFF is the maximum value that can fit in 3+6+6+6 unconstrained','line_number':1113,'multiline':False]['text':' bits in a four-byte UTF-8 code unit sequence.','line_number':1114,'multiline':False]['text':' including '\0'','line_number':1117,'multiline':False]['text':' Note that by do-while looping here rather than while-looping, this','line_number':1123,'multiline':False]['text':' writes a '0' when |codePoint == 0|.','line_number':1124,'multiline':False]['text':' If a valid code point is decoded, this function call consumes its code','line_number':1162,'multiline':False]['text':' units.  If not, it ungets the lead code unit and invokes the right error','line_number':1163,'multiline':False]['text':' handler, so on failure we must immediately return false.','line_number':1164,'multiline':False]['text':' The code point is usually |lead|: overwrite later if needed.','line_number':1186,'multiline':False]['text':' ECMAScript specifically requires that unpaired UTF-16 surrogates be','line_number':1189,'multiline':False]['text':' treated as the corresponding code point and not as an error.  See','line_number':1190,'multiline':False]['text':' <https://tc39.github.io/ecma262/#sec-ecmascript-language-types-string-type>.','line_number':1191,'multiline':False]['text':' Thus this function does not consider any sequence of 16-bit numbers to','line_number':1192,'multiline':False]['text':' be intrinsically in error.','line_number':1193,'multiline':False]['text':' Dispense with single-unit code points and lone trailing surrogates.','line_number':1195,'multiline':False]['text':' sentinel value to hopefully cause errors','line_number':1201,'multiline':False]['text':' Also handle a lead surrogate not paired with a trailing surrogate.','line_number':1215,'multiline':False]['text':' Otherwise we have a multi-unit code point.','line_number':1223,'multiline':False]['text':' This consumes the full, valid code point or ungets |lead| and calls the','line_number':1278,'multiline':False]['text':' appropriate error functor on failure.','line_number':1279,'multiline':False]['text':' sentinel value to hopefully cause errors','line_number':1293,'multiline':False]['text':' This is JS's understanding of UTF-16 that allows lone surrogates, so','line_number':1310,'multiline':False]['text':' we have to exclude lone surrogates from [windowStart, offset) ourselves.','line_number':1311,'multiline':False]['text':' This stops at U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR in','line_number':1331,'multiline':False]['text':' string and template literals.  These code points do affect line and','line_number':1332,'multiline':False]['text':' column coordinates, even as they encode their literal values.','line_number':1333,'multiline':False]['text':' Don't allow invalid UTF-16 in pre-context.  (Current users don't','line_number':1338,'multiline':False]['text':' require this, and this behavior isn't currently imposed on','line_number':1339,'multiline':False]['text':' pre-context, but these facts might change someday.)','line_number':1340,'multiline':False]['text':' Optimistically include the code unit, reverting below if needed.','line_number':1346,'multiline':False]['text':' If it's not a surrogate at all, keep going.','line_number':1349,'multiline':False]['text':' Stop if we don't have a usable surrogate pair.','line_number':1354,'multiline':False]['text':' trail surrogate at low end','line_number':1356,'multiline':False]['text':' no paired lead surrogate','line_number':1357,'multiline':False]['text':' |offset| must be the location of the error or somewhere before it, so we','line_number':1372,'multiline':False]['text':' know preceding data is valid UTF-8.','line_number':1373,'multiline':False]['text':' Peek backward for a line break, and only decrement if there is none.','line_number':1391,'multiline':False]['text':' First check for the ASCII LineTerminators.','line_number':1394,'multiline':False]['text':' Now check for the non-ASCII LineTerminators U+2028 LINE SEPARATOR','line_number':1399,'multiline':False]['text':' (0xE2 0x80 0xA8) and U+2029 PARAGRAPH (0xE2 0x80 0xA9).  If there','line_number':1400,'multiline':False]['text':' aren't three code units available, some comparison here will fail','line_number':1401,'multiline':False]['text':' before we'd underflow.','line_number':1402,'multiline':False]['text':' Rewind over the non-LineTerminator.  This can't underflow','line_number':1408,'multiline':False]['text':' |earliestPossibleStart| because it begins a code point.','line_number':1409,'multiline':False]['text':' But if we underflowed |WindowRadius|, adjust forward and stop.','line_number':1416,'multiline':False]['text':' This stops at U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR in','line_number':1453,'multiline':False]['text':' string and template literals.  These code points do affect line and','line_number':1454,'multiline':False]['text':' column coordinates, even as they encode their literal values.','line_number':1455,'multiline':False]['text':' Don't allow invalid UTF-16 in post-context.  (Current users don't','line_number':1460,'multiline':False]['text':' require this, and this behavior isn't currently imposed on','line_number':1461,'multiline':False]['text':' pre-context, but these facts might change someday.)','line_number':1462,'multiline':False]['text':' Optimistically consume the code unit, ungetting it below if needed.','line_number':1468,'multiline':False]['text':' If it's not a surrogate at all, keep going.','line_number':1471,'multiline':False]['text':' Retract if the lead surrogate would stand alone at the end of the','line_number':1476,'multiline':False]['text':' window.','line_number':1477,'multiline':False]['text':' split pair','line_number':1478,'multiline':False]['text':' half-pair at end of source','line_number':1479,'multiline':False]['text':' no paired trail surrogate','line_number':1480,'multiline':False]['text':' A non-encoding error might be followed by an encoding error within','line_number':1508,'multiline':False]['text':' |maxEnd|, so we must validate as we go to not include invalid UTF-8','line_number':1509,'multiline':False]['text':' in the computed window.  What joy!','line_number':1510,'multiline':False]['text':' encoding error','line_number':1524,'multiline':False]['text':' allowPoisoned = ','line_number':1571,'multiline':True]['text':' If this TokenStreamAnyChars doesn't have location information, try to','line_number':1608,'multiline':False]['text':' get it from the caller.','line_number':1609,'multiline':False]['text':' Otherwise use this TokenStreamAnyChars's location information.','line_number':1620,'multiline':False]['text':' ASCII contributes a single UTF-16 code unit.','line_number':1655,'multiline':False]['text':' Compute the token offset from |i == 0| and the initial |encodedWindow|.','line_number':1670,'multiline':False]['text':' Compute the window length, picking up from |i| and |encodedWindow| that,','line_number':1675,'multiline':False]['text':' in general, were modified just above.','line_number':1676,'multiline':False]['text':' Rename the variable to make meaning clearer: an offset into source units','line_number':1683,'multiline':False]['text':' in Unit encoding.','line_number':1684,'multiline':False]['text':' These are also offsets into source units in Unit encoding.','line_number':1687,'multiline':False]['text':' Don't add a useless "line" of context when the window ends up empty','line_number':1694,'multiline':False]['text':' because of an invalid encoding at the start of a line.','line_number':1695,'multiline':False]['text':' The windowed string is null-terminated.','line_number':1713,'multiline':False]['text':' The length in UTF-8 code units of a code point is always greater than or','line_number':1728,'multiline':False]['text':' equal to the same code point's length in UTF-16 code points.  ASCII code','line_number':1729,'multiline':False]['text':' points are 1 unit in either encoding.  Code points in [U+0080, U+10000)','line_number':1730,'multiline':False]['text':' are 2-3 UTF-8 code units to 1 UTF-16 code unit.  And code points in','line_number':1731,'multiline':False]['text':' [U+10000, U+10FFFF] are 4 UTF-8 code units to 2 UTF-16 code units.','line_number':1732,'multiline':False]['text':'','line_number':1733,'multiline':False]['text':' Therefore, if encoded window length equals the length in UTF-16 (this is','line_number':1734,'multiline':False]['text':' always the case for Unit=char16_t), the UTF-16 offsets are exactly the','line_number':1735,'multiline':False]['text':' encoded offsets.  Otherwise we must convert offset/length from UTF-8 to','line_number':1736,'multiline':False]['text':' UTF-16.','line_number':1737,'multiline':False]['text':' This function's return value isn't a success/failure indication: it','line_number':1782,'multiline':False]['text':' returns true if this TokenStream can be used to provide a line of','line_number':1783,'multiline':False]['text':' context.','line_number':1784,'multiline':False]['text':' Add a line of context from this TokenStream to help with debugging.','line_number':1786,'multiline':False]['text':' We can't fill in any more here.','line_number':1790,'multiline':False]['text':' We have encountered a '\': check for a Unicode escape sequence after it.','line_number':1805,'multiline':False]['text':' Return the length of the escape sequence and the encoded code point (by','line_number':1806,'multiline':False]['text':' value) if we found a Unicode escape sequence, and skip all code units','line_number':1807,'multiline':False]['text':' involed.  Otherwise, return 0 and don't advance along the buffer.','line_number':1808,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':1816,'multiline':False]['text':' NOTE: |unit| may be EOF here, so this ungets either one or two units.','line_number':1833,'multiline':False]['text':' Skip leading zeroes.','line_number':1848,'multiline':False]['text':' 'u{'','line_number':1864,'multiline':False]['text':' significant hexdigits','line_number':1865,'multiline':False]['text':' subtract a get if it didn't contribute to length','line_number':1866,'multiline':False]['text':' We could point "into" a mistyped escape, e.g. for "\u{41H}" we','line_number':1932,'multiline':False]['text':' could point at the 'H'.  But we don't do that now, so the code','line_number':1933,'multiline':False]['text':' unit after the '\' isn't necessarily bad, so just point at the','line_number':1934,'multiline':False]['text':' start of the actually-invalid escape.','line_number':1935,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':1943,'multiline':False]['text':' Match directive comments used in debugging, such as "//# sourceURL" and','line_number':1952,'multiline':False]['text':' "//# sourceMappingURL". Use of "//@" instead of "//#" is deprecated.','line_number':1953,'multiline':False]['text':'','line_number':1954,'multiline':False]['text':' To avoid a crashing bug in IE, several JavaScript transpilers wrap single','line_number':1955,'multiline':False]['text':' line comments containing a source mapping URL inside a multiline','line_number':1956,'multiline':False]['text':' comment. To avoid potentially expensive lookahead and backtracking, we','line_number':1957,'multiline':False]['text':' only check for this case if we encounter a '#' code unit.','line_number':1958,'multiline':False]['text':' Stop if we don't find |directive|.  (Note that |directive| must be','line_number':1988,'multiline':False]['text':' ASCII, so there are no tricky encoding issues to consider in matching','line_number':1989,'multiline':False]['text':' UTF-8/16-agnostically.)','line_number':1990,'multiline':False]['text':' Debugging directives can occur in both single- and multi-line','line_number':2016,'multiline':False]['text':' comments. If we're currently inside a multi-line comment, we','line_number':2017,'multiline':False]['text':' also must recognize multi-line comment terminators.','line_number':2018,'multiline':False]['text':' This ignores encoding errors: subsequent caller-side code to','line_number':2031,'multiline':False]['text':' handle the remaining source text in the comment will do so.','line_number':2032,'multiline':False]['text':' The directive's URL was missing, but comments can contain anything,','line_number':2049,'multiline':False]['text':' so it isn't an error.','line_number':2050,'multiline':False]['text':' Match comments of the form "//# sourceURL=<url>" or','line_number':2060,'multiline':False]['text':' "/\* //# sourceURL=<url> *\/"','line_number':2061,'multiline':False]['text':'','line_number':2062,'multiline':False]['text':' Note that while these are labeled "sourceURL" in the source text,','line_number':2063,'multiline':False]['text':' internally we refer to it as a "displayURL" to distinguish what the','line_number':2064,'multiline':False]['text':' developer would like to refer to the source as from the source's actual','line_number':2065,'multiline':False]['text':' URL.','line_number':2066,'multiline':False]['text':' Match comments of the form "//# sourceMappingURL=<url>" or','line_number':2078,'multiline':False]['text':' "/\* //# sourceMappingURL=<url> *\/"','line_number':2079,'multiline':False]['text':' NOTE: |token->modifier| is set in |newToken()| so that optimized,','line_number':2108,'multiline':False]['text':' non-debug code won't do any work to pass a modifier-argument that will','line_number':2109,'multiline':False]['text':' never be used.','line_number':2110,'multiline':False]['text':' We didn't get a token, so don't set |flags.isDirtyLine|.','line_number':2117,'multiline':False]['text':' Poisoning sourceUnits on error establishes an invariant: once an','line_number':2120,'multiline':False]['text':' erroneous token has been seen, sourceUnits will not be consulted again.','line_number':2121,'multiline':False]['text':' This is true because the parser will deal with the illegal token by','line_number':2122,'multiline':False]['text':' aborting parsing immediately.','line_number':2123,'multiline':False]['text':' |restoreNextRawCharAddress| undoes all gets, and this function','line_number':2183,'multiline':False]['text':' doesn't update line/column info.','line_number':2184,'multiline':False]['text':' Run the bad-token code for every path out of this function except the','line_number':2208,'multiline':False]['text':' two success-cases.','line_number':2209,'multiline':False]['text':' We've already consumed an initial code point in the identifer, to *know*','line_number':2212,'multiline':False]['text':' that this is an identifier.  So no need to worry about not consuming any','line_number':2213,'multiline':False]['text':' code points in the loop below.','line_number':2214,'multiline':False]['text':' Handle a Unicode escape -- otherwise it's not part of the','line_number':2227,'multiline':False]['text':' identifier.','line_number':2228,'multiline':False]['text':' This ignores encoding errors: subsequent caller-side code to','line_number':2238,'multiline':False]['text':' handle source text after the IdentifierName will do so.','line_number':2239,'multiline':False]['text':' Identifiers containing Unicode escapes have to be converted into','line_number':2255,'multiline':False]['text':' tokenbuf before atomizing.','line_number':2256,'multiline':False]['text':' Escape-free identifiers can be created directly from sourceUnits.','line_number':2263,'multiline':False]['text':' Private identifiers start with a '#', and so cannot be reserved words.','line_number':2267,'multiline':False]['text':' Represent reserved words lacking escapes as reserved word tokens.','line_number':2269,'multiline':False]['text':' A char16_t has the 'OneChar' kind if it, by itself, constitutes a valid','line_number':2293,'multiline':False]['text':' token that cannot also be a prefix of a longer token.  E.g. ';' has the','line_number':2294,'multiline':False]['text':' OneChar kind, but '+' does not, because '++' and '+=' are valid longer','line_number':2295,'multiline':False]['text':' tokens','line_number':2296,'multiline':False]['text':' that begin with '+'.','line_number':2297,'multiline':False]['text':'','line_number':2298,'multiline':False]['text':' The few token kinds satisfying these properties cover roughly 35--45%','line_number':2299,'multiline':False]['text':' of the tokens seen in practice.','line_number':2300,'multiline':False]['text':'','line_number':2301,'multiline':False]['text':' We represent the 'OneChar' kind with any positive value less than','line_number':2302,'multiline':False]['text':' TokenKind::Limit.  This representation lets us associate','line_number':2303,'multiline':False]['text':' each one-char token char16_t with a TokenKind and thus avoid','line_number':2304,'multiline':False]['text':' a subsequent char16_t-to-TokenKind conversion.','line_number':2305,'multiline':False]['text':' OneChar: 40,  41,  44,  58,  59,  91,  93,  123, 125, 126:','line_number':2320,'multiline':False]['text':'          '(', ')', ',', ':', ';', '[', ']', '{', '}', '~'','line_number':2321,'multiline':False]['text':' Ident:   36, 65..90, 95, 97..122: '$', 'A'..'Z', '_', 'a'..'z'','line_number':2322,'multiline':False]['text':' Dot:     46: '.'','line_number':2323,'multiline':False]['text':' Equals:  61: '='','line_number':2324,'multiline':False]['text':' String:  34, 39, 96: '"', '\'', '`'','line_number':2325,'multiline':False]['text':' Dec:     49..57: '1'..'9'','line_number':2326,'multiline':False]['text':' Plus:    43: '+'','line_number':2327,'multiline':False]['text':' ZeroDigit:  48: '0'','line_number':2328,'multiline':False]['text':' Space:   9, 11, 12, 32: '\t', '\v', '\f', ' '','line_number':2329,'multiline':False]['text':' EOL:     10, 13: '\n', '\r'','line_number':2330,'multiline':False]['text':'','line_number':2331,'multiline':False]['text':' clang-format off','line_number':2344,'multiline':False]['text':'         0        1        2        3        4        5        6        7        8        9    ','line_number':2345,'multiline':True]['text':'   0+ ','line_number':2346,'multiline':True]['text':'  10+ ','line_number':2347,'multiline':True]['text':'  20+ ','line_number':2348,'multiline':True]['text':'  30+ ','line_number':2349,'multiline':True]['text':'  40+ ','line_number':2350,'multiline':True]['text':'  50+ ','line_number':2351,'multiline':True]['text':'  60+ ','line_number':2352,'multiline':True]['text':'  70+ ','line_number':2353,'multiline':True]['text':'  80+ ','line_number':2354,'multiline':True]['text':'  90+ ','line_number':2355,'multiline':True]['text':' 100+ ','line_number':2356,'multiline':True]['text':' 110+ ','line_number':2357,'multiline':True]['text':' 120+ ','line_number':2358,'multiline':True]['text':' clang-format on','line_number':2359,'multiline':False]['text':' Run the bad-token code for every path out of this function except the','line_number':2460,'multiline':False]['text':' one success-case.','line_number':2461,'multiline':False]['text':' Consume integral component digits.','line_number':2464,'multiline':False]['text':' Numbers contain no escapes, so we can read directly from |sourceUnits|.','line_number':2471,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':2476,'multiline':False]['text':' Most numbers are pure decimal integers without fractional component','line_number':2479,'multiline':False]['text':' or exponential notation.  Handle that with optimized code.','line_number':2480,'multiline':False]['text':' Consume any decimal dot and fractional component.','line_number':2489,'multiline':False]['text':' Consume any exponential notation.','line_number':2497,'multiline':False]['text':' Exponential notation must contain at least one digit.','line_number':2504,'multiline':False]['text':' Consume exponential digits.','line_number':2511,'multiline':False]['text':' "0." and "0e..." numbers parse "." or "e..." here.  Neither range','line_number':2519,'multiline':False]['text':' contains a number, so we can't use |FullStringToDouble|.  (Parse','line_number':2520,'multiline':False]['text':' failures return 0.0, so we'll still get the right result.)','line_number':2521,'multiline':False]['text':' Number followed by IdentifierStart is an error.  (This is the only place','line_number':2529,'multiline':False]['text':' in ECMAScript where token boundary is inadequate to properly separate','line_number':2530,'multiline':False]['text':' two tokens, necessitating this unaesthetic lookahead.)','line_number':2531,'multiline':False]['text':' This ignores encoding errors: subsequent caller-side code to','line_number':2539,'multiline':False]['text':' handle source text after the number will do so.','line_number':2540,'multiline':False]['text':' Fallthrough only handles ASCII code points, so','line_number':2617,'multiline':False]['text':' deal with non-ASCII and skip everything else.','line_number':2618,'multiline':False]['text':' For IE compat, allow unescaped / in char classes.','line_number':2631,'multiline':False]['text':' NOTE: Non-ASCII LineTerminators were handled by','line_number':2635,'multiline':False]['text':'       ProcessNonAsciiCodePoint calls above.','line_number':2636,'multiline':False]['text':' Char buffer may start with a 0[bBoOxX] prefix, then follows with','line_number':2700,'multiline':False]['text':' binary, octal, decimal, or hex digits.  Already checked by caller, as','line_number':2701,'multiline':False]['text':' the "n" indicating bigint comes at the end.','line_number':2702,'multiline':False]['text':' Skip over any separators.','line_number':2704,'multiline':False]['text':' HashbangComment ::','line_number':2723,'multiline':False]['text':'   #!  SingleLineCommentChars_opt','line_number':2724,'multiline':False]['text':' HashbangComment is optional at start of Script or Module.','line_number':2727,'multiline':False]['text':' # not followed by ! at start of Script or Module is an error, but normal','line_number':2732,'multiline':False]['text':' parsing code will handle that error just fine if we let it.','line_number':2733,'multiline':False]['text':' This doesn't consume a concluding LineTerminator, and it stops consuming','line_number':2738,'multiline':False]['text':' just before any encoding error.  The subsequent |getToken| call will call','line_number':2739,'multiline':False]['text':' |getTokenInternal| below which will handle these possibilities.','line_number':2740,'multiline':False]['text':' Assume we'll fail: success cases will overwrite this.','line_number':2747,'multiline':False]['text':' This loop runs more than once only when whitespace or comments are','line_number':2753,'multiline':False]['text':' encountered.','line_number':2754,'multiline':False]['text':' Non-ASCII code points can only be identifiers or whitespace.  It would','line_number':2766,'multiline':False]['text':' be nice to compute these *after* discarding whitespace, but IN A WORLD','line_number':2767,'multiline':False]['text':' where |unicode::IsSpace| requires consuming a variable number of code','line_number':2768,'multiline':False]['text':' units, it's easier to assume it's an identifier and maybe do a little','line_number':2769,'multiline':False]['text':' wasted work, than to unget and compute and reget if whitespace.','line_number':2770,'multiline':False]['text':' !isAsciiCodePoint(unit)','line_number':2817,'multiline':False]['text':' Get the token kind, based on the first char.  The ordering of c1kind','line_number':2821,'multiline':False]['text':' comparison is based on the frequency of tokens in real code:','line_number':2822,'multiline':False]['text':' Parsemark (which represents typical JS code on the web) and the','line_number':2823,'multiline':False]['text':' Unreal demo (which represents asm.js code).','line_number':2824,'multiline':False]['text':'','line_number':2825,'multiline':False]['text':'                  Parsemark   Unreal','line_number':2826,'multiline':False]['text':'  OneChar         32.9%       39.7%','line_number':2827,'multiline':False]['text':'  Space           25.0%        0.6%','line_number':2828,'multiline':False]['text':'  Ident           19.2%       36.4%','line_number':2829,'multiline':False]['text':'  Dec              7.2%        5.1%','line_number':2830,'multiline':False]['text':'  String           7.9%        0.0%','line_number':2831,'multiline':False]['text':'  EOL              1.7%        0.0%','line_number':2832,'multiline':False]['text':'  ZeroDigit        0.4%        4.9%','line_number':2833,'multiline':False]['text':'  Other            5.7%       13.3%','line_number':2834,'multiline':False]['text':'','line_number':2835,'multiline':False]['text':' The ordering is based mostly only Parsemark frequencies, with Unreal','line_number':2836,'multiline':False]['text':' frequencies used to break close categories (e.g. |Dec| and','line_number':2837,'multiline':False]['text':' |String|).  |Other| is biggish, but no other token kind is common','line_number':2838,'multiline':False]['text':' enough for it to be worth adding extra values to FirstCharKind.','line_number':2839,'multiline':False]['text':' Look for an unambiguous single-char token.','line_number':2842,'multiline':False]['text':'','line_number':2843,'multiline':False]['text':' Skip over non-EOL whitespace chars.','line_number':2850,'multiline':False]['text':'','line_number':2851,'multiline':False]['text':' Look for an identifier.','line_number':2856,'multiline':False]['text':'','line_number':2857,'multiline':False]['text':' Look for a decimal number.','line_number':2865,'multiline':False]['text':'','line_number':2866,'multiline':False]['text':' Look for a string or a template string.','line_number':2873,'multiline':False]['text':'','line_number':2874,'multiline':False]['text':' Skip over EOL chars, updating line state along the way.','line_number':2879,'multiline':False]['text':'','line_number':2880,'multiline':False]['text':' From a '0', look for a hexadecimal, binary, octal, or "noctal" (a','line_number':2894,'multiline':False]['text':' number starting with '0' that contains '8' or '9' and is treated as','line_number':2895,'multiline':False]['text':' decimal) number.','line_number':2896,'multiline':False]['text':'','line_number':2897,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':2908,'multiline':False]['text':' one past the '0x'','line_number':2914,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':2924,'multiline':False]['text':' one past the '0b'','line_number':2930,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':2940,'multiline':False]['text':' one past the '0o'','line_number':2946,'multiline':False]['text':' Reject octal literals that appear in strict mode code.','line_number':2953,'multiline':False]['text':' The above test doesn't catch a few edge cases; see','line_number':2958,'multiline':False]['text':' |GeneralParser::maybeParseDirective|.  Record the violation so that','line_number':2959,'multiline':False]['text':' that function can handle them.','line_number':2960,'multiline':False]['text':' one past the '0'','line_number':2964,'multiline':False]['text':' Use the decimal scanner for the rest of the number.','line_number':2986,'multiline':False]['text':' Give a more explicit error message when '_' is used after '0'.','line_number':2990,'multiline':False]['text':' '0' not followed by [XxBbOo0-9_];  scan as a decimal number.','line_number':2994,'multiline':False]['text':' NOTE: |unit| may be EOF here.  (This is permitted by case #3','line_number':2997,'multiline':False]['text':'       in TokenStream.h docs for this function.)','line_number':2998,'multiline':False]['text':' Error if an identifier-start code point appears immediately','line_number':3009,'multiline':False]['text':' after the number.  Somewhat surprisingly, if we don't check','line_number':3010,'multiline':False]['text':' here, we'll never check at all.','line_number':3011,'multiline':False]['text':' This ignores encoding errors: subsequent caller-side code to','line_number':3018,'multiline':False]['text':' handle source text after the number will do so.','line_number':3019,'multiline':False]['text':' This handles everything else.  Simple tokens distinguished solely by','line_number':3044,'multiline':False]['text':' TokenKind should set |simpleKind| and break, to share simple-token','line_number':3045,'multiline':False]['text':' creation code for all such tokens.  All other tokens must be handled','line_number':3046,'multiline':False]['text':' by returning (or by continuing from the loop enclosing this).','line_number':3047,'multiline':False]['text':'','line_number':3048,'multiline':False]['text':' sentinel value for code after switch','line_number':3052,'multiline':False]['text':' The block a ways above eliminated all non-ASCII, so cast to the','line_number':3055,'multiline':False]['text':' smallest type possible to assist the C++ compiler.','line_number':3056,'multiline':False]['text':' NOTE: |unit| may be EOF here.  A stray '.' at EOF would be an','line_number':3073,'multiline':False]['text':'       error, but subsequent code will handle it.','line_number':3074,'multiline':False]['text':' We could point "into" a mistyped escape, e.g. for "\u{41H}" we','line_number':3126,'multiline':False]['text':' could point at the 'H'.  But we don't do that now, so the code','line_number':3127,'multiline':False]['text':' unit after the '\' isn't necessarily bad, so just point at the','line_number':3128,'multiline':False]['text':' start of the actually-invalid escape.','line_number':3129,'multiline':False]['text':' if the code unit is followed by a number, for example it has the','line_number':3163,'multiline':False]['text':' following form `<...> ?.5 <..> then it should be treated as a','line_number':3164,'multiline':False]['text':' ternary rather than as an optional chain','line_number':3165,'multiline':False]['text':' Treat HTML begin-comment as comment-till-end-of-line.','line_number':3191,'multiline':False]['text':' Look for a single-line comment.','line_number':3236,'multiline':False]['text':' NOTE: |unit| may be EOF here.','line_number':3245,'multiline':False]['text':' Look for a multi-line comment.','line_number':3253,'multiline':False]['text':' Look for a regexp.','line_number':3294,'multiline':False]['text':' We consumed a bad ASCII code point/unit.  Put it back so the','line_number':3324,'multiline':False]['text':' error location is the bad code point.','line_number':3325,'multiline':False]['text':' switch (AssertedCast<uint8_t>(CodeUnitValue(toUnit(unit))))','line_number':3329,'multiline':False]['text':' Run the bad-token code for every path out of this function except the','line_number':3352,'multiline':False]['text':' one success-case.','line_number':3353,'multiline':False]['text':' Unicode separators aren't end-of-line in template or (as of','line_number':3357,'multiline':False]['text':' recently) string literals, so this assertion doesn't allow them.','line_number':3358,'multiline':False]['text':' The various errors reported here include language like "in a ''','line_number':3364,'multiline':False]['text':' literal" or similar, with '' being '', "", or `` as appropriate.','line_number':3365,'multiline':False]['text':' We need to detect any of these chars:  " or ', \n (or its','line_number':3372,'multiline':False]['text':' equivalents), \\, EOF.  Because we detect EOL sequences here and','line_number':3373,'multiline':False]['text':' put them back immediately, we can use getCodeUnit().','line_number':3374,'multiline':False]['text':' Non-ASCII code points are always directly appended -- even','line_number':3382,'multiline':False]['text':' U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR that are','line_number':3383,'multiline':False]['text':' ordinarily LineTerminatorSequences.  (They contribute their literal','line_number':3384,'multiline':False]['text':' values to template and [as of recently] string literals, but they're','line_number':3385,'multiline':False]['text':' line terminators when computing line/column coordinates.)  Handle','line_number':3386,'multiline':False]['text':' the non-ASCII case early for readability.','line_number':3387,'multiline':False]['text':' When parsing templates, we don't immediately report errors for','line_number':3413,'multiline':False]['text':' invalid escapes; these are handled by the parser.  We don't','line_number':3414,'multiline':False]['text':' append to charBuffer in those cases because it won't be read.','line_number':3415,'multiline':False]['text':' Non-ASCII |unit| isn't handled by code after this, so dedicate','line_number':3422,'multiline':False]['text':' an unlikely special-case to it and then continue.','line_number':3423,'multiline':False]['text':' If we consumed U+2028 LINE SEPARATOR or U+2029 PARAGRAPH','line_number':3430,'multiline':False]['text':' SEPARATOR, they'll be normalized to '\n'.  '\' followed by','line_number':3431,'multiline':False]['text':' LineContinuation represents no code points, so don't append','line_number':3432,'multiline':False]['text':' in this case.','line_number':3433,'multiline':False]['text':' The block above eliminated all non-ASCII, so cast to the','line_number':3444,'multiline':False]['text':' smallest type possible to assist the C++ compiler.','line_number':3445,'multiline':False]['text':' LineContinuation represents no code points.  We're manually','line_number':3470,'multiline':False]['text':' consuming a LineTerminatorSequence, so we must manually','line_number':3471,'multiline':False]['text':' update line/column info.','line_number':3472,'multiline':False]['text':' Unicode character specification.','line_number':3480,'multiline':False]['text':' First handle a delimited Unicode escape, e.g. \u{1F4A9}.','line_number':3488,'multiline':False]['text':' Beware: |u3| may be a non-ASCII code point here; if','line_number':3522,'multiline':False]['text':' so it'll pass into this |if|-block.','line_number':3523,'multiline':False]['text':' We put the code unit back so that we read it','line_number':3526,'multiline':False]['text':' on the next pass, which matters if it was','line_number':3527,'multiline':False]['text':' '`' or '\'.','line_number':3528,'multiline':False]['text':' end of delimited Unicode escape handling','line_number':3568,'multiline':False]['text':' Otherwise it must be a fixed-length \uXXXX Unicode escape.','line_number':3570,'multiline':False]['text':' If it isn't, this is usually an error -- but if this is a','line_number':3571,'multiline':False]['text':' template literal, we must defer error reporting because','line_number':3572,'multiline':False]['text':' malformed escapes are okay in *tagged* template literals.','line_number':3573,'multiline':False]['text':' Beware: |c2| may not be an ASCII code point here!','line_number':3578,'multiline':False]['text':' case 'u'','line_number':3591,'multiline':False]['text':' Hexadecimal character specification.','line_number':3593,'multiline':False]['text':' \8 or \9 in an untagged template literal is a syntax error,','line_number':3614,'multiline':False]['text':' reported in GeneralParser::noSubstitutionUntaggedTemplate.','line_number':3615,'multiline':False]['text':'','line_number':3616,'multiline':False]['text':' Tagged template literals, however, may contain \8 and \9.  The','line_number':3617,'multiline':False]['text':' "cooked" representation of such a part will be |undefined|, and','line_number':3618,'multiline':False]['text':' the "raw" representation will contain the literal characters.','line_number':3619,'multiline':False]['text':'','line_number':3620,'multiline':False]['text':'   function f(parts) {','line_number':3621,'multiline':False]['text':'     assertEq(parts[0], undefined);','line_number':3622,'multiline':False]['text':'     assertEq(parts.raw[0], "\\8");','line_number':3623,'multiline':False]['text':'     return "composed";','line_number':3624,'multiline':False]['text':'   }','line_number':3625,'multiline':False]['text':'   assertEq(f`\8`, "composed");','line_number':3626,'multiline':False]['text':' \8 and \9 are forbidden in string literals in strict mode code.','line_number':3636,'multiline':False]['text':' The above test doesn't catch a few edge cases; see','line_number':3641,'multiline':False]['text':' |GeneralParser::maybeParseDirective|.  Record the violation so','line_number':3642,'multiline':False]['text':' that that function can handle them.','line_number':3643,'multiline':False]['text':' Octal character specification.','line_number':3649,'multiline':False]['text':' Strict mode code allows only \0 followed by a non-digit.','line_number':3658,'multiline':False]['text':' The above test doesn't catch a few edge cases; see','line_number':3671,'multiline':False]['text':' |GeneralParser::maybeParseDirective|.  Record the violation so','line_number':3672,'multiline':False]['text':' that that function can handle them.','line_number':3673,'multiline':False]['text':' default','line_number':3700,'multiline':False]['text':' switch (AssertedCast<uint8_t>(CodeUnitValue(toUnit(unit))))','line_number':3701,'multiline':False]['text':' (unit == '\\')','line_number':3708,'multiline':False]['text':' String literals don't allow ASCII line breaks.','line_number':3712,'multiline':False]['text':' namespace frontend','line_number':3825,'multiline':False]['text':' namespace js','line_number':3827,'multiline':False]