['text':' Â© 2017 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'* Helper function for safe subtraction (no overflow). ','line_number':38,'multiline':True]['text':' Note: In C++, signed integer subtraction is undefined behavior.','line_number':40,'multiline':False]['text':' namespace','line_number':71,'multiline':False]['text':' sets scale, precision, hasDouble, origDouble, origDelta, and BCD data','line_number':131,'multiline':False]['text':' Validation should happen outside of DecimalQuantity, e.g., in the Precision class.','line_number':135,'multiline':False]['text':' Special behavior: do not set minInt to be less than what is already set.','line_number':138,'multiline':False]['text':' This is so significant digits rounding can set the integer length.','line_number':139,'multiline':False]['text':' Save values into internal state','line_number':144,'multiline':False]['text':' Validation should happen outside of DecimalQuantity, e.g., in the Precision class.','line_number':149,'multiline':False]['text':' Save values into internal state','line_number':152,'multiline':False]['text':' Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE','line_number':153,'multiline':False]['text':' Validation should happen outside of DecimalQuantity, e.g., in the Precision class.','line_number':158,'multiline':False]['text':' Do not call this method with an increment having only a 1 or a 5 digit!','line_number':186,'multiline':False]['text':' Use a more efficient call to either roundToMagnitude() or roundToNickel().','line_number':187,'multiline':False]['text':' Check a few popular rounding increments; a more thorough check is in Java.','line_number':188,'multiline':False]['text':' Divide this DecimalQuantity by the increment, round, then multiply back.','line_number':200,'multiline':False]['text':' Convert to DecNum, multiply, and convert back.','line_number':213,'multiline':False]['text':' Convert to DecNum, multiply, and convert back.','line_number':226,'multiline':False]['text':' i.e., scale += delta; origDelta += delta','line_number':246,'multiline':False]['text':' Make sure that precision + scale won't overflow, either','line_number':249,'multiline':False]['text':' If this assertion fails, you need to call roundToInfinity() or some other rounding method.','line_number':258,'multiline':False]['text':' See the comment at the top of this file explaining the "isApproximate" field.','line_number':259,'multiline':False]['text':' Invert the negative sign if necessary','line_number':264,'multiline':False]['text':' Plural operand `c` is currently an alias for `e`.','line_number':277,'multiline':False]['text':' If this assertion fails, you need to call roundToInfinity() or some other rounding method.','line_number':297,'multiline':False]['text':' See the comment in the header file explaining the "isApproximate" field.','line_number':298,'multiline':False]['text':' If this assertion fails, you need to call roundToInfinity() or some other rounding method.','line_number':307,'multiline':False]['text':' See the comment in the header file explaining the "isApproximate" field.','line_number':308,'multiline':False]['text':' If this assertion fails, you need to call roundToInfinity() or some other rounding method.','line_number':317,'multiline':False]['text':' See the comment at the top of this file explaining the "isApproximate" field.','line_number':318,'multiline':False]['text':' max(-fractionCountWithExponent, 0)','line_number':331,'multiline':False]['text':' leave as INT32_MIN; handled below in _setToInt()','line_number':369,'multiline':False]['text':' unexpected','line_number':408,'multiline':False]['text':' signbit() from <math.h> handles +0.0 vs -0.0','line_number':421,'multiline':False]['text':' Make sure the double is an IEEE 754 double.  If not, fall back to the slow path right now.','line_number':442,'multiline':False]['text':' TODO: Make a fast path for other types of doubles.','line_number':443,'multiline':False]['text':' To get the bits from the double, use memcpy, which takes care of endianness.','line_number':449,'multiline':False]['text':' Not all integers can be represented exactly for exponent > 52','line_number':454,'multiline':False]['text':' The extreme values of exponent are special; use slow path.','line_number':461,'multiline':False]['text':' 3.3219... is log2(10)','line_number':466,'multiline':False]['text':' 1e22 is the largest exact double.','line_number':470,'multiline':False]['text':' 1e22 is the largest exact double.','line_number':475,'multiline':False]['text':' Call the slow oracle function (Double.toString in Java, DoubleToAscii in C++).','line_number':490,'multiline':False]['text':' unused; always positive','line_number':492,'multiline':False]['text':' Compute the decNumber representation','line_number':516,'multiline':False]['text':' NOTE: Call sites should be guarded by fitsInLong(), like this:','line_number':544,'multiline':False]['text':' if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }','line_number':545,'multiline':False]['text':' Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.','line_number':546,'multiline':False]['text':' i.e., -result','line_number':556,'multiline':False]['text':' Remove trailing zeros; this can happen during integer overflow cases.','line_number':571,'multiline':False]['text':' Hard case: the magnitude is 10^18.','line_number':597,'multiline':False]['text':' The largest int64 is: 9,223,372,036,854,775,807','line_number':598,'multiline':False]['text':' Exactly equal to max long plus one.','line_number':608,'multiline':False]['text':' If this assertion fails, you need to call roundToInfinity() or some other rounding method.','line_number':613,'multiline':False]['text':' See the comment in the header file explaining the "isApproximate" field.','line_number':614,'multiline':False]['text':' We are processing well-formed input, so we don't need any special options to StringToDoubleConverter.','line_number':623,'multiline':False]['text':' Special handling for zero','line_number':634,'multiline':False]['text':' Use the BCD constructor. We need to do a little bit of work to convert, though.','line_number':639,'multiline':False]['text':' The decNumber constructor expects most-significant first, but we store least-significant first.','line_number':640,'multiline':False]['text':' The position in the BCD at which rounding will be performed; digits to the right of position','line_number':669,'multiline':False]['text':' will be rounded away.','line_number':670,'multiline':False]['text':' "trailing" = least significant digit to the left of rounding','line_number':673,'multiline':False]['text':' All digits are to the left of the rounding magnitude.','line_number':677,'multiline':False]['text':' No rounding for zero.','line_number':679,'multiline':False]['text':' Perform rounding logic.','line_number':681,'multiline':False]['text':' "leading" = most significant digit to the right of rounding','line_number':682,'multiline':False]['text':' Compute which section of the number we are in.','line_number':685,'multiline':False]['text':' EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)','line_number':686,'multiline':False]['text':' LOWER means we are between the bottom edge and the midpoint, like 1.391','line_number':687,'multiline':False]['text':' MIDPOINT means we are exactly in the middle, like 1.500','line_number':688,'multiline':False]['text':' UPPER means we are between the midpoint and the top edge, like 1.916','line_number':689,'multiline':False]['text':' Nickel rounding, and not at .02x or .07x','line_number':693,'multiline':False]['text':' .00, .01 => down to .00','line_number':695,'multiline':False]['text':' .03, .04 => up to .05','line_number':698,'multiline':False]['text':' .05, .06 => down to .05','line_number':701,'multiline':False]['text':' .08, .09 => up to .10','line_number':704,'multiline':False]['text':' Includes nickel rounding .020-.024 and .070-.074','line_number':708,'multiline':False]['text':' Includes nickel rounding .026-.029 and .076-.079','line_number':711,'multiline':False]['text':' Includes nickel rounding .025 and .075','line_number':714,'multiline':False]['text':' Nickel rounding, and not at .02x or .07x','line_number':759,'multiline':False]['text':' .00, .01 => down to .00','line_number':761,'multiline':False]['text':' .03, .04 => up to .05','line_number':764,'multiline':False]['text':' .05, .06 => down to .05','line_number':767,'multiline':False]['text':' .08, .09 => up to .10','line_number':770,'multiline':False]['text':' Includes nickel rounding .020-.024 and .070-.074','line_number':774,'multiline':False]['text':' Includes nickel rounding .026-.029 and .076-.079','line_number':777,'multiline':False]['text':' i.e. at upper or lower edge ','line_number':784,'multiline':True]['text':' Oops! This means that we have to get the exact representation of the double,','line_number':785,'multiline':False]['text':' because the zone of uncertainty is along the rounding boundary.','line_number':786,'multiline':False]['text':' start over','line_number':788,'multiline':False]['text':' Turn off the approximate double flag, since the value is now confirmed to be exact.','line_number':792,'multiline':False]['text':' All digits are to the left of the rounding magnitude.','line_number':798,'multiline':False]['text':' Good to continue rounding.','line_number':802,'multiline':False]['text':' Nickel rounding "half even" goes to the nearest whole (away from the 5).','line_number':807,'multiline':False]['text':' Perform truncation','line_number':823,'multiline':False]['text':' do not return: use the bubbling logic below','line_number':839,'multiline':False]['text':' compact not necessary: digit at position 0 is nonzero','line_number':842,'multiline':False]['text':' Bubble the result to the higher digits','line_number':847,'multiline':False]['text':' Note: in the long implementation, the most digits BCD can have at this point is','line_number':851,'multiline':False]['text':' 15, so bubblePos <= 15 and getDigitPos(bubblePos) is safe.','line_number':852,'multiline':False]['text':' shift off the trailing 9s','line_number':854,'multiline':False]['text':' in case an extra digit got added','line_number':859,'multiline':False]['text':' Zero requires special handling to maintain the invariant that the least-significant digit','line_number':875,'multiline':False]['text':' in the BCD is nonzero.','line_number':876,'multiline':False]['text':' Deal with trailing zeros','line_number':884,'multiline':False]['text':' Append digit','line_number':892,'multiline':False]['text':' Fix scale if in integer mode','line_number':896,'multiline':False]['text':'//////////////////////////////////////////////////','line_number':979,'multiline':False]['text':'/ End of DecimalQuantity_AbstractBCD.java      ///','line_number':980,'multiline':False]['text':'/ Start of DecimalQuantity_DualStorageBCD.java ///','line_number':981,'multiline':False]['text':'//////////////////////////////////////////////////','line_number':982,'multiline':False]['text':' ints always fit inside the long implementation.','line_number':1070,'multiline':False]['text':' NOTE: Despite the fact that double-conversion's API is called','line_number':1127,'multiline':False]['text':' "DoubleToAscii", they actually use '0' (as opposed to u8'0').','line_number':1128,'multiline':False]['text':' Number is zero','line_number':1150,'multiline':False]['text':' Remove trailing zeros','line_number':1154,'multiline':False]['text':' Compute precision','line_number':1158,'multiline':False]['text':' Switch storage mechanism if possible','line_number':1163,'multiline':False]['text':' Number is zero','line_number':1170,'multiline':False]['text':' Compact the number (remove trailing zeros)','line_number':1175,'multiline':False]['text':' TODO: Use a more efficient algorithm here and below. There is a logarithmic one.','line_number':1176,'multiline':False]['text':' Compute precision','line_number':1182,'multiline':False]['text':' TODO: There is nothing being done to check for memory allocation failures.','line_number':1197,'multiline':False]['text':' TODO: Consider indexing by nybbles instead of bytes in C++, so that we can','line_number':1198,'multiline':False]['text':' make these arrays half the size.','line_number':1199,'multiline':False]['text':' Initialize the byte array to zeros (this is done automatically in Java)','line_number':1202,'multiline':False]['text':' Initialize the rest of the byte array to zeros (this is done automatically in Java)','line_number':1207,'multiline':False]['text':' Change from bytes to long','line_number':1218,'multiline':False]['text':' Change from long to bytes','line_number':1229,'multiline':False]['text':' Copy the long into a local variable since it will get munged when we allocate the bytes','line_number':1230,'multiline':False]['text':' Take ownership away from the old instance:','line_number':1257,'multiline':False]['text':' No error','line_number':1299,'multiline':False]['text':' terminate buffer','line_number':1338,'multiline':False]['text':' #if !UCONFIG_NO_FORMATTING ','line_number':1354,'multiline':True]