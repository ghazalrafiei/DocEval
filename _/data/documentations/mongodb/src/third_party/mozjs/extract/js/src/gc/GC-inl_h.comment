['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' Upon entry, |thing| points to any thing (free or used) and finds the','line_number':59,'multiline':False]['text':' first used thing, which may be |thing|.','line_number':60,'multiline':False]['text':' Note: if |span| is empty, this test will fail, which is what we want','line_number':64,'multiline':False]['text':' -- |span| being empty means that we're past the end of the last free','line_number':65,'multiline':False]['text':' thing, all the remaining things in the arena are used, and we'll','line_number':66,'multiline':False]['text':' never need to move forward.','line_number':67,'multiline':False]['text':' For use when a subclass wants to insert some setup before init().','line_number':125,'multiline':False]['text':' If called from outside a GC, ensure that the heap is in a state','line_number':138,'multiline':False]['text':' that allows us to iterate.','line_number':139,'multiline':False]['text':' Assert that no GCs can occur while a ZoneAllCellIter is live.','line_number':141,'multiline':False]['text':' We have a single-threaded runtime, so there's no need to protect','line_number':145,'multiline':False]['text':' against other threads iterating or allocating. However, we do have','line_number':146,'multiline':False]['text':' background finalization; we may have to wait for this to finish if','line_number':147,'multiline':False]['text':' it's currently active.','line_number':148,'multiline':False]['text':' If we are iterating a nursery-allocated kind then we need to','line_number':158,'multiline':False]['text':' evict first so that we can see all things.','line_number':159,'multiline':False]['text':' No need to evict the nursery. (This constructor is known statically','line_number':169,'multiline':False]['text':' to not GC.)','line_number':170,'multiline':False]['text':' clang-format off ','line_number':186,'multiline':True]['text':'','line_number':187,'multiline':False]['text':' Iterator over the cells in a Zone, where the GC type (JSString, JSObject) is','line_number':188,'multiline':False]['text':' known, for a single AllocKind. Example usages:','line_number':189,'multiline':False]['text':'','line_number':190,'multiline':False]['text':'   for (auto obj = zone->cellIter<JSObject>(AllocKind::OBJECT0); !obj.done(); obj.next()) {','line_number':191,'multiline':False]['text':'       ...','line_number':192,'multiline':False]['text':'   }','line_number':193,'multiline':False]['text':'','line_number':194,'multiline':False]['text':'   for (auto script = zone->cellIter<JSScript>(); !script.done(); script.next()) {','line_number':195,'multiline':False]['text':'       f(script->code());','line_number':196,'multiline':False]['text':'   }','line_number':197,'multiline':False]['text':'','line_number':198,'multiline':False]['text':' As this code demonstrates, you can use 'script' as if it were a JSScript*.','line_number':199,'multiline':False]['text':' Its actual type is ZoneAllCellIter<JSScript>, but for most purposes it will','line_number':200,'multiline':False]['text':' autoconvert to JSScript*.','line_number':201,'multiline':False]['text':'','line_number':202,'multiline':False]['text':' Note that in the JSScript case, ZoneAllCellIter is able to infer the AllocKind','line_number':203,'multiline':False]['text':' from the type 'JSScript', whereas in the JSObject case, the kind must be','line_number':204,'multiline':False]['text':' given (because there are multiple AllocKinds for objects).','line_number':205,'multiline':False]['text':'','line_number':206,'multiline':False]['text':' Also, the static rooting hazard analysis knows that the JSScript case will','line_number':207,'multiline':False]['text':' not GC during construction. The JSObject case needs to GC, or more precisely','line_number':208,'multiline':False]['text':' to empty the nursery and clear out the store buffer, so that it can see all','line_number':209,'multiline':False]['text':' objects to iterate over (the nursery is not iterable) and remove the','line_number':210,'multiline':False]['text':' possibility of having pointers from the store buffer to data hanging off','line_number':211,'multiline':False]['text':' stuff we're iterating over that we are going to delete. (The latter should','line_number':212,'multiline':False]['text':' not be a problem, since such instances should be using RelocatablePtr do','line_number':213,'multiline':False]['text':' remove themselves from the store buffer on deletion, but currently for','line_number':214,'multiline':False]['text':' subtle reasons that isn't good enough.)','line_number':215,'multiline':False]['text':'','line_number':216,'multiline':False]['text':' If the iterator is used within a GC, then there is no need to evict the','line_number':217,'multiline':False]['text':' nursery (again). You may select a variant that will skip the eviction either','line_number':218,'multiline':False]['text':' by specializing on a GCType that is never allocated in the nursery, or','line_number':219,'multiline':False]['text':' explicitly by passing in a trailing AutoAssertEmptyNursery argument.','line_number':220,'multiline':False]['text':'','line_number':221,'multiline':False]['text':' NOTE: This class can return items that are about to be swept/finalized.','line_number':222,'multiline':False]['text':'       You must not keep pointers to such items across GCs.  Use','line_number':223,'multiline':False]['text':'       ZoneCellIter below to filter these out.','line_number':224,'multiline':False]['text':'','line_number':225,'multiline':False]['text':' NOTE: This class also does not read barrier returned items, so may return','line_number':226,'multiline':False]['text':'       gray cells. You must not store such items anywhere on the heap without','line_number':227,'multiline':False]['text':'       gray-unmarking them. Use ZoneCellIter to automatically unmark them.','line_number':228,'multiline':False]['text':'','line_number':229,'multiline':False]['text':' clang-format on ','line_number':230,'multiline':True]['text':' Non-nursery allocated (equivalent to having an entry in','line_number':234,'multiline':False]['text':' MapTypeToFinalizeKind). The template declaration here is to discard this','line_number':235,'multiline':False]['text':' constructor overload if MapTypeToFinalizeKind<GCType>::kind does not','line_number':236,'multiline':False]['text':' exist. Note that there will be no remaining overloads that will work,','line_number':237,'multiline':False]['text':' which makes sense given that you haven't specified which of the','line_number':238,'multiline':False]['text':' AllocKinds to use for GCType.','line_number':239,'multiline':False]['text':'','line_number':240,'multiline':False]['text':' If we later add a nursery allocable GCType with a single AllocKind, we','line_number':241,'multiline':False]['text':' will want to add an overload of this constructor that does the right','line_number':242,'multiline':False]['text':' thing (ie, it empties the nursery before iterating.)','line_number':243,'multiline':False]['text':' Non-nursery allocated, nursery is known to be empty: same behavior as','line_number':248,'multiline':False]['text':' above.','line_number':249,'multiline':False]['text':' Arbitrary kind, which will be assumed to be nursery allocable (and','line_number':253,'multiline':False]['text':' therefore the nursery will be emptied before iterating.)','line_number':254,'multiline':False]['text':' Arbitrary kind, which will be assumed to be nursery allocable, but the','line_number':258,'multiline':False]['text':' nursery is known to be empty already: same behavior as non-nursery types.','line_number':259,'multiline':False]['text':' Like the above class but filter out cells that are about to be finalized.','line_number':269,'multiline':False]['text':' Also, read barrier all cells returned (unless the Unbarriered variants are','line_number':270,'multiline':False]['text':' used) to prevent gray cells from escaping.','line_number':271,'multiline':False]['text':'
   * The same constructors as above.
   ','line_number':277,'multiline':True]['text':' This can result in a new reference being created to an object that an','line_number':307,'multiline':False]['text':' ongoing incremental GC may find to be unreachable, so we may need a','line_number':308,'multiline':False]['text':' barrier here.','line_number':309,'multiline':False]['text':' namespace gc ','line_number':338,'multiline':True]['text':' namespace js ','line_number':339,'multiline':True]['text':' gc_GC_inl_h ','line_number':341,'multiline':True]