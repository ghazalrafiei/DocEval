['text':' Copyright 2015, ARM Limited','line_number':1,'multiline':False]['text':' All rights reserved.','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':4,'multiline':False]['text':' modification, are permitted provided that the following conditions are met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'   * Redistributions of source code must retain the above copyright notice,','line_number':7,'multiline':False]['text':'     this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'   * Redistributions in binary form must reproduce the above copyright notice,','line_number':9,'multiline':False]['text':'     this list of conditions and the following disclaimer in the documentation','line_number':10,'multiline':False]['text':'     and/or other materials provided with the distribution.','line_number':11,'multiline':False]['text':'   * Neither the name of ARM Limited nor the names of its contributors may be','line_number':12,'multiline':False]['text':'     used to endorse or promote products derived from this software without','line_number':13,'multiline':False]['text':'     specific prior written permission.','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS CONTRIBUTORS "AS IS" AND','line_number':16,'multiline':False]['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED','line_number':17,'multiline':False]['text':' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE','line_number':18,'multiline':False]['text':' DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE','line_number':19,'multiline':False]['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':20,'multiline':False]['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR','line_number':21,'multiline':False]['text':' SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER','line_number':22,'multiline':False]['text':' CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,','line_number':23,'multiline':False]['text':' OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':24,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':25,'multiline':False]['text':' CPURegList utilities.','line_number':35,'multiline':False]['text':' Try to create a CPURegister for each element in the list.','line_number':64,'multiline':False]['text':' We can't use IsEmpty here because that asserts IsValid().','line_number':72,'multiline':False]['text':' The list must already be empty, so do nothing.','line_number':88,'multiline':False]['text':' Registers x0-x18 and lr (x30) are caller-saved.','line_number':135,'multiline':False]['text':' Do not use lr directly to avoid initialisation order fiasco bugs for users.','line_number':137,'multiline':False]['text':' Registers d0-d7 and d16-d31 are caller-saved.','line_number':144,'multiline':False]['text':' Registers.','line_number':157,'multiline':False]['text':' Operand.','line_number':311,'multiline':False]['text':' Extend modes SXTX and UXTX require a 64-bit register.','line_number':341,'multiline':False]['text':' MemOperand','line_number':377,'multiline':False]['text':' SXTX extend mode requires a 64-bit offset register.','line_number':394,'multiline':False]['text':' These assertions match those in the shifted-register constructor.','line_number':427,'multiline':False]['text':' These assertions match those in the extended-register constructor.','line_number':441,'multiline':False]['text':' Assembler','line_number':475,'multiline':False]['text':' Mozilla change: always use maximally-present features.','line_number':480,'multiline':False]['text':' Mozilla change: Compile time hard-coded value from js-config.mozbuild.','line_number':483,'multiline':False]['text':' Note, vixl backend implements the JSCVT flag as a boolean despite having 3','line_number':487,'multiline':False]['text':' extra bits reserved for forward compatibility in the ARMv8 documentation.','line_number':488,'multiline':False]['text':' Code generation.','line_number':494,'multiline':False]['text':' Logical instructions.','line_number':715,'multiline':False]['text':' Bitfield operations.','line_number':801,'multiline':False]['text':' 'rt' and 'rt2' can only be aliased for stores.','line_number':1188,'multiline':False]['text':' Memory instructions.','line_number':1245,'multiline':False]['text':' Exclusive-access instructions.','line_number':1408,'multiline':False]['text':' NEON structure loads and stores.','line_number':1627,'multiline':False]['text':' The immediate post index addressing mode is indicated by rm = 31.','line_number':1640,'multiline':False]['text':' The immediate is implied by the number of vector registers used.','line_number':1641,'multiline':False]['text':' Assert that addressing mode is either offset (with immediate 0), post','line_number':1654,'multiline':False]['text':' index by immediate of the size of the register list, or post index by a','line_number':1655,'multiline':False]['text':' value in a core register.','line_number':1656,'multiline':False]['text':' We support vt arguments of the form vt.VxT() or vt.T(), where x is the','line_number':1983,'multiline':False]['text':' number of lanes, and T is b, h, s or d.','line_number':1984,'multiline':False]['text':' Lane size is encoded in the opcode field. Lane index is encoded in the Q,','line_number':1988,'multiline':False]['text':' S and size fields.','line_number':1989,'multiline':False]['text':' Moves involving the stack pointer are encoded as add immediate with','line_number':2219,'multiline':False]['text':' second operand of zero. Otherwise, orr with first operand zr is','line_number':2220,'multiline':False]['text':' used.','line_number':2221,'multiline':False]['text':' Although the fcmp{e} instructions can strictly only take an immediate','line_number':2377,'multiline':False]['text':' value of +0.0, we don't need to check for -0.0 because the sign of 0.0','line_number':2378,'multiline':False]['text':' doesn't affect the result of the comparison.','line_number':2379,'multiline':False]['text':' NEON NOT and RBIT are distinguised by bit 22, the bottom bit of "size".','line_number':3412,'multiline':False]['text':' We support vn arguments of the form vn.VxT() or vn.T(), where x is the','line_number':3445,'multiline':False]['text':' number of lanes, and T is b, h, s or d.','line_number':3446,'multiline':False]['text':' We support vd arguments of the form vd.VxT() or vd.T(), where x is the','line_number':3493,'multiline':False]['text':' number of lanes, and T is b, h, s or d.','line_number':3494,'multiline':False]['text':' We support vd arguments of the form vd.VxT() or vd.T(), where x is the','line_number':3527,'multiline':False]['text':' number of lanes, and T is b, h, s or d.','line_number':3528,'multiline':False]['text':' We support vd arguments of the form vd.VxT() or vd.T(), where x is the','line_number':3558,'multiline':False]['text':' number of lanes, and T is b, h, s or d.','line_number':3559,'multiline':False]['text':' We support vd arguments of the form vd.VxT() or vd.T(), where x is the','line_number':3592,'multiline':False]['text':' number of lanes, and T is b, h, s.','line_number':3593,'multiline':False]['text':' Note:','line_number':4213,'multiline':False]['text':' Below, a difference in case for the same letter indicates a','line_number':4214,'multiline':False]['text':' negated bit.','line_number':4215,'multiline':False]['text':' If b is 1, then B is 0.','line_number':4216,'multiline':False]['text':' bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000','line_number':4219,'multiline':False]['text':' bit7: a000.0000','line_number':4221,'multiline':False]['text':' bit6: 0b00.0000','line_number':4223,'multiline':False]['text':' bit5_to_0: 00cd.efgh','line_number':4225,'multiline':False]['text':' bits: aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000','line_number':4239,'multiline':False]['text':'       0000.0000.0000.0000.0000.0000.0000.0000','line_number':4240,'multiline':False]['text':' bit7: a000.0000','line_number':4242,'multiline':False]['text':' bit6: 0b00.0000','line_number':4244,'multiline':False]['text':' bit5_to_0: 00cd.efgh','line_number':4246,'multiline':False]['text':' Code generation helpers.','line_number':4258,'multiline':False]['text':' Ignore the top 32 bits of an immediate if we're moving to a W register.','line_number':4263,'multiline':False]['text':' Check that the top 32 bits are zero (a positive 32-bit number) or top','line_number':4265,'multiline':False]['text':' 33 bits are one (a negative 32-bit number, sign extended to 64 bits).','line_number':4266,'multiline':False]['text':' Explicit shift specified.','line_number':4273,'multiline':False]['text':' Calculate a new immediate and shift combination to encode the immediate','line_number':4279,'multiline':False]['text':' argument.','line_number':4280,'multiline':False]['text':' Nothing to do.','line_number':4283,'multiline':False]['text':' For instructions of the form:','line_number':4321,'multiline':False]['text':'   add/sub   wsp, <Wn>, <Wm> [, LSL #0-3 ]','line_number':4322,'multiline':False]['text':'   add/sub   <Wd>, wsp, <Wm> [, LSL #0-3 ]','line_number':4323,'multiline':False]['text':'   add/sub   wsp, wsp, <Wm> [, LSL #0-3 ]','line_number':4324,'multiline':False]['text':'   adds/subs <Wd>, wsp, <Wm> [, LSL #0-3 ]','line_number':4325,'multiline':False]['text':' or their 64-bit register equivalents, convert the operand from shifted to','line_number':4326,'multiline':False]['text':' extended register mode, and emit an add/sub extended instruction.','line_number':4327,'multiline':False]['text':' Use the correct size of register.','line_number':4496,'multiline':False]['text':' Bits extracted are high_bit:0.','line_number':4498,'multiline':False]['text':' Number of bits left in the result that are not introduced by the shift.','line_number':4500,'multiline':False]['text':' Nothing to extend. Just shift.','line_number':4514,'multiline':False]['text':' No need to extend as the extended bits would be shifted away.','line_number':4521,'multiline':False]['text':' Use the unscaled addressing mode.','line_number':4549,'multiline':False]['text':' Use the scaled addressing mode.','line_number':4556,'multiline':False]['text':' Use the unscaled addressing mode.','line_number':4562,'multiline':False]['text':' All remaining addressing modes are register-offset, pre-indexed or','line_number':4568,'multiline':False]['text':' post-indexed modes.','line_number':4569,'multiline':False]['text':' LSL is encoded in the option field as UXTX.','line_number':4578,'multiline':False]['text':' Shifts are encoded in one bit, indicating a left shift by the memory','line_number':4583,'multiline':False]['text':' access size.','line_number':4584,'multiline':False]['text':' If this point is reached, the MemOperand (addr) cannot be encoded.','line_number':4598,'multiline':False]['text':' Valid values will have the form:','line_number':4634,'multiline':False]['text':' aBbb.bbbc.defg.h000.0000.0000.0000.0000','line_number':4635,'multiline':False]['text':' bits[19..0] are cleared.','line_number':4637,'multiline':False]['text':' bits[29..25] are all set or all cleared.','line_number':4642,'multiline':False]['text':' bit[30] and bit[29] are opposite.','line_number':4648,'multiline':False]['text':' Valid values will have the form:','line_number':4658,'multiline':False]['text':' aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000','line_number':4659,'multiline':False]['text':' 0000.0000.0000.0000.0000.0000.0000.0000','line_number':4660,'multiline':False]['text':' bits[47..0] are cleared.','line_number':4662,'multiline':False]['text':' bits[61..54] are all set or all cleared.','line_number':4667,'multiline':False]['text':' bit[62] and bit[61] are opposite.','line_number':4673,'multiline':False]['text':' The movn instruction can generate immediates containing an arbitrary 16-bit','line_number':4703,'multiline':False]['text':' value, with remaining bits set, eg. 0xffff1234, 0xffff1234ffffffff.','line_number':4704,'multiline':False]['text':' The movz instruction can generate immediates containing an arbitrary 16-bit','line_number':4710,'multiline':False]['text':' value, with remaining bits clear, eg. 0x00001234, 0x0000123400000000.','line_number':4711,'multiline':False]['text':' Test if a given value can be encoded in the immediate field of a logical','line_number':4718,'multiline':False]['text':' instruction.','line_number':4719,'multiline':False]['text':' If it can be encoded, the function returns true, and values pointed to by n,','line_number':4720,'multiline':False]['text':' imm_s and imm_r are updated with immediates encoded in the format required','line_number':4721,'multiline':False]['text':' by the corresponding fields in the logical instruction.','line_number':4722,'multiline':False]['text':' If it can not be encoded, the function returns false, and the values pointed','line_number':4723,'multiline':False]['text':' to by n, imm_s and imm_r are undefined.','line_number':4724,'multiline':False]['text':' Logical immediates are encoded using parameters n, imm_s and imm_r using','line_number':4734,'multiline':False]['text':' the following table:','line_number':4735,'multiline':False]['text':'','line_number':4736,'multiline':False]['text':'    N   imms    immr    size        S             R','line_number':4737,'multiline':False]['text':'    1  ssssss  rrrrrr    64    UInt(ssssss)  UInt(rrrrrr)','line_number':4738,'multiline':False]['text':'    0  0sssss  xrrrrr    32    UInt(sssss)   UInt(rrrrr)','line_number':4739,'multiline':False]['text':'    0  10ssss  xxrrrr    16    UInt(ssss)    UInt(rrrr)','line_number':4740,'multiline':False]['text':'    0  110sss  xxxrrr     8    UInt(sss)     UInt(rrr)','line_number':4741,'multiline':False]['text':'    0  1110ss  xxxxrr     4    UInt(ss)      UInt(rr)','line_number':4742,'multiline':False]['text':'    0  11110s  xxxxxr     2    UInt(s)       UInt(r)','line_number':4743,'multiline':False]['text':' (s bits must not be all set)','line_number':4744,'multiline':False]['text':'','line_number':4745,'multiline':False]['text':' A pattern is constructed of size bits, where the least significant S+1 bits','line_number':4746,'multiline':False]['text':' are set. The pattern is rotated right by R, and repeated across a 32 or','line_number':4747,'multiline':False]['text':' 64-bit value, depending on destination register width.','line_number':4748,'multiline':False]['text':'','line_number':4749,'multiline':False]['text':' Put another way: the basic format of a logical immediate is a single','line_number':4750,'multiline':False]['text':' contiguous stretch of 1 bits, repeated across the whole word at intervals','line_number':4751,'multiline':False]['text':' given by a power of 2. To identify them quickly, we first locate the','line_number':4752,'multiline':False]['text':' lowest stretch of 1 bits, then the next 1 bit above that; that combination','line_number':4753,'multiline':False]['text':' is different for every logical immediate, so it gives us all the','line_number':4754,'multiline':False]['text':' information we need to identify the only logical immediate that our input','line_number':4755,'multiline':False]['text':' could be, and then we simply check if that's the value we actually have.','line_number':4756,'multiline':False]['text':'','line_number':4757,'multiline':False]['text':' (The rotation parameter does give the possibility of the stretch of 1 bits','line_number':4758,'multiline':False]['text':' going 'round the end' of the word. To deal with that, we observe that in','line_number':4759,'multiline':False]['text':' any situation where that happens the bitwise NOT of the value is also a','line_number':4760,'multiline':False]['text':' valid logical immediate. So we simply invert the input whenever its low bit','line_number':4761,'multiline':False]['text':' is set, and then we know that the rotated case can't arise.)','line_number':4762,'multiline':False]['text':' If the low bit is 1, negate the value, and set a flag to remember that we','line_number':4765,'multiline':False]['text':' did (so that we can adjust the return values appropriately).','line_number':4766,'multiline':False]['text':' To handle 32-bit logical immediates, the very easiest thing is to repeat','line_number':4772,'multiline':False]['text':' the input value twice to make a 64-bit word. The correct encoding of that','line_number':4773,'multiline':False]['text':' as a logical immediate will also be the correct encoding of the 32-bit','line_number':4774,'multiline':False]['text':' value.','line_number':4775,'multiline':False]['text':' Avoid making the assumption that the most-significant 32 bits are zero by','line_number':4777,'multiline':False]['text':' shifting the value left and duplicating it.','line_number':4778,'multiline':False]['text':' The basic analysis idea: imagine our input word looks like this.','line_number':4783,'multiline':False]['text':'','line_number':4784,'multiline':False]['text':'    0011111000111110001111100011111000111110001111100011111000111110','line_number':4785,'multiline':False]['text':'                                                          c  b    a','line_number':4786,'multiline':False]['text':'                                                          |<--d-->|','line_number':4787,'multiline':False]['text':'','line_number':4788,'multiline':False]['text':' We find the lowest set bit (as an actual power-of-2 value, not its index)','line_number':4789,'multiline':False]['text':' and call it a. Then we add a to our original number, which wipes out the','line_number':4790,'multiline':False]['text':' bottommost stretch of set bits and replaces it with a 1 carried into the','line_number':4791,'multiline':False]['text':' next zero bit. Then we look for the new lowest set bit, which is in','line_number':4792,'multiline':False]['text':' position b, and subtract it, so now our number is just like the original','line_number':4793,'multiline':False]['text':' but with the lowest stretch of set bits completely gone. Now we find the','line_number':4794,'multiline':False]['text':' lowest set bit again, which is position c in the diagram above. Then we'll','line_number':4795,'multiline':False]['text':' measure the distance d between bit positions a and c (using CLZ), and that','line_number':4796,'multiline':False]['text':' tells us that the only valid logical immediate that could possibly be equal','line_number':4797,'multiline':False]['text':' to this number is the one in which a stretch of bits running from a to just','line_number':4798,'multiline':False]['text':' below b is replicated every d bits.','line_number':4799,'multiline':False]['text':' The general case, in which there is more than one stretch of set bits.','line_number':4810,'multiline':False]['text':' Compute the repeat distance d, and set up a bitmask covering the basic','line_number':4811,'multiline':False]['text':' unit of repetition (i.e. a word with the bottom d bits set). Also, in all','line_number':4812,'multiline':False]['text':' of these cases the N bit of the output will be zero.','line_number':4813,'multiline':False]['text':' Handle degenerate cases.','line_number':4820,'multiline':False]['text':'','line_number':4821,'multiline':False]['text':' If any of those 'find lowest set bit' operations didn't find a set bit at','line_number':4822,'multiline':False]['text':' all, then the word will have been zero thereafter, so in particular the','line_number':4823,'multiline':False]['text':' last lowest_set_bit operation will have returned zero. So we can test for','line_number':4824,'multiline':False]['text':' all the special case conditions in one go by seeing if c is zero.','line_number':4825,'multiline':False]['text':' The input was zero (or all 1 bits, which will come to here too after we','line_number':4827,'multiline':False]['text':' inverted it at the start of the function), for which we just return','line_number':4828,'multiline':False]['text':' false.','line_number':4829,'multiline':False]['text':' Otherwise, if c was zero but a was not, then there's just one stretch','line_number':4832,'multiline':False]['text':' of set bits in our word, meaning that we have the trivial case of','line_number':4833,'multiline':False]['text':' d == 64 and only one 'repetition'. Set up all the same variables as in','line_number':4834,'multiline':False]['text':' the general case above, and set the N bit in the output.','line_number':4835,'multiline':False]['text':' If the repeat period d is not a power of two, it can't be encoded.','line_number':4843,'multiline':False]['text':' If the bit stretch (b - a) does not fit within the mask derived from the','line_number':4849,'multiline':False]['text':' repeat period, then fail.','line_number':4850,'multiline':False]['text':' The only possible option is b - a repeated every d bits. Now we're going to','line_number':4854,'multiline':False]['text':' actually construct the valid logical immediate derived from that','line_number':4855,'multiline':False]['text':' specification, and see if it equals our original input.','line_number':4856,'multiline':False]['text':'','line_number':4857,'multiline':False]['text':' To repeat a value every d bits, we multiply it by a number of the form','line_number':4858,'multiline':False]['text':' (1 + 2^d + 2^(2d) + ...), i.e. 0x0001000100010001 or similar. These can','line_number':4859,'multiline':False]['text':' be derived using a table lookup on CLZ(d).','line_number':4860,'multiline':False]['text':' The candidate pattern doesn't match our input value, so fail.','line_number':4873,'multiline':False]['text':' We have a match! This is a valid logical immediate, so now we have to','line_number':4877,'multiline':False]['text':' construct the bits and pieces of the instruction encoding that generates','line_number':4878,'multiline':False]['text':' it.','line_number':4879,'multiline':False]['text':' Count the set bits in our basic stretch. The special case of clz(0) == -1','line_number':4881,'multiline':False]['text':' makes the answer come out right for stretches that reach the very top of','line_number':4882,'multiline':False]['text':' the word (e.g. numbers like 0xffffc00000000000).','line_number':4883,'multiline':False]['text':' Decide how many bits to rotate right by, to put the low bit of that basic','line_number':4887,'multiline':False]['text':' stretch in position a.','line_number':4888,'multiline':False]['text':' If we inverted the input right at the start of this function, here's','line_number':4891,'multiline':False]['text':' where we compensate: the number of set bits becomes the number of clear','line_number':4892,'multiline':False]['text':' bits, and the rotation count is based on position b rather than position','line_number':4893,'multiline':False]['text':' a (since b is the location of the 'lowest' 1 bit after inversion).','line_number':4894,'multiline':False]['text':' Now we're done, except for having to encode the S output in such a way that','line_number':4901,'multiline':False]['text':' it gives both the number of set bits and the length of the repeated','line_number':4902,'multiline':False]['text':' segment. The s field is encoded like this:','line_number':4903,'multiline':False]['text':'','line_number':4904,'multiline':False]['text':'     imms    size        S','line_number':4905,'multiline':False]['text':'    ssssss    64    UInt(ssssss)','line_number':4906,'multiline':False]['text':'    0sssss    32    UInt(sssss)','line_number':4907,'multiline':False]['text':'    10ssss    16    UInt(ssss)','line_number':4908,'multiline':False]['text':'    110sss     8    UInt(sss)','line_number':4909,'multiline':False]['text':'    1110ss     4    UInt(ss)','line_number':4910,'multiline':False]['text':'    11110s     2    UInt(s)','line_number':4911,'multiline':False]['text':'','line_number':4912,'multiline':False]['text':' So we 'or' (-d << 1) with our computed s to form imms.','line_number':4913,'multiline':False]['text':' Core registers are available without any particular CPU features.','line_number':5033,'multiline':False]['text':' The architecture does not allow FP and NEON to be implemented separately,','line_number':5036,'multiline':False]['text':' but we can crudely categorise them based on register size, since FP only','line_number':5037,'multiline':False]['text':' uses D, S and (occasionally) H registers.','line_number':5038,'multiline':False]['text':' This is currently only used for loads and stores, where rt and rt2 must','line_number':5048,'multiline':False]['text':' have the same size and type. We could extend this to cover other cases if','line_number':5049,'multiline':False]['text':' necessary, but for now we can avoid checking both registers.','line_number':5050,'multiline':False]['text':' namespace vixl','line_number':5145,'multiline':False]