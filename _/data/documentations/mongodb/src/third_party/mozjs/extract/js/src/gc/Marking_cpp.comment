['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::DumpObject','line_number':25,'multiline':False]['text':' JS_FOR_EACH_PUBLIC_{,TAGGED_}GC_POINTER_TYPE','line_number':26,'multiline':False]['text':' GetScopeDataTrailingNames','line_number':38,'multiline':False]['text':' js::PlainObject','line_number':52,'multiline':False]['text':' [SMDOC] GC Tracing','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':' Tracing Overview','line_number':69,'multiline':False]['text':' ================','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':' Tracing, in this context, refers to an abstract visitation of some or all of','line_number':72,'multiline':False]['text':' the GC-controlled heap. The effect of tracing an edge of the graph depends','line_number':73,'multiline':False]['text':' on the subclass of the JSTracer on whose behalf we are tracing.','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' Marking','line_number':76,'multiline':False]['text':' -------','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':' The primary JSTracer is the GCMarker. The marking tracer causes the target','line_number':79,'multiline':False]['text':' of each traversed edge to be marked black and the target edge's children to','line_number':80,'multiline':False]['text':' be marked either gray (in the gc algorithm sense) or immediately black.','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':' Callback','line_number':83,'multiline':False]['text':' --------','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':' The secondary JSTracer is the CallbackTracer. This simply invokes a callback','line_number':86,'multiline':False]['text':' on each edge in a child.','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' The following is a rough outline of the general struture of the tracing','line_number':89,'multiline':False]['text':' internals.','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':' clang-format off ','line_number':92,'multiline':True]['text':'','line_number':93,'multiline':False]['text':'  +----------------------+                             ...................','line_number':94,'multiline':False]['text':'  |                      |                             :                 :','line_number':95,'multiline':False]['text':'  |                      v                             v                 :','line_number':96,'multiline':False]['text':'  |      TraceRoot   TraceEdge   TraceRange        GCMarker::            :','line_number':97,'multiline':False]['text':'  |          |           |           |         processMarkStackTop   +---+---+','line_number':98,'multiline':False]['text':'  |          +-----------+-----------+                 |             |       |','line_number':99,'multiline':False]['text':'  |                      |                             |             | Mark  |','line_number':100,'multiline':False]['text':'  |                      v                             |             | Stack |','line_number':101,'multiline':False]['text':'  |              TraceEdgeInternal                     |             |       |','line_number':102,'multiline':False]['text':'  |                      |                             |             +---+---+','line_number':103,'multiline':False]['text':'  |                      |                             |                 ^','line_number':104,'multiline':False]['text':'  |         +------------+---------------+             +<----------+     :','line_number':105,'multiline':False]['text':'  |         |                            |             |           |     :','line_number':106,'multiline':False]['text':'  |         v                            v             v           |     :','line_number':107,'multiline':False]['text':'  |    DoCallback                    DoMarking markAndTraverseEdge |     :','line_number':108,'multiline':False]['text':'  |         |                            |             |           |     :','line_number':109,'multiline':False]['text':'  |         |                            +------+------+           |     :','line_number':110,'multiline':False]['text':'  |         |                                   |                  |     :','line_number':111,'multiline':False]['text':'  |         v                                   v                  |     :','line_number':112,'multiline':False]['text':'  |  CallbackTracer::                    markAndTraverse           |     :','line_number':113,'multiline':False]['text':'  |    onSomeEdge                               |                  |     :','line_number':114,'multiline':False]['text':'  |                                             |                  |     :','line_number':115,'multiline':False]['text':'  |                                          traverse              |     :','line_number':116,'multiline':False]['text':'  |                                             |                  |     :','line_number':117,'multiline':False]['text':'  |             +-------------------+-----------+------+           |     :','line_number':118,'multiline':False]['text':'  |             |                   |                  |           |     :','line_number':119,'multiline':False]['text':'  |             v                   v                  v           |     :','line_number':120,'multiline':False]['text':'  |    markAndTraceChildren    markAndPush    eagerlyMarkChildren  |     :','line_number':121,'multiline':False]['text':'  |             |                   :                  |           |     :','line_number':122,'multiline':False]['text':'  |             v                   :                  +-----------+     :','line_number':123,'multiline':False]['text':'  |      T::traceChildren           :                                    :','line_number':124,'multiline':False]['text':'  |             |                   :                                    :','line_number':125,'multiline':False]['text':'  +-------------+                   ......................................','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':'   Legend:','line_number':128,'multiline':False]['text':'     ------- Direct calls','line_number':129,'multiline':False]['text':'     ....... Data flow','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':' clang-format on ','line_number':132,'multiline':True]['text':'** Tracing Invariants ****************************************************','line_number':134,'multiline':True]['text':' Note: all free patterns are odd to make the common, not-poisoned case a','line_number':153,'multiline':False]['text':' single test.','line_number':154,'multiline':False]['text':' This function uses data that's not available in the nursery. ','line_number':190,'multiline':True]['text':'
   * Permanent atoms and things in the self-hosting zone are not associated
   * with this runtime, but will be ignored during marking.
   ','line_number':195,'multiline':True]['text':' If we're on the main thread we must have access to the runtime and zone.','line_number':212,'multiline':False]['text':' Check that we don't stray from the current compartment and zone without','line_number':240,'multiline':False]['text':' using TraceCrossCompartmentEdge.','line_number':241,'multiline':False]['text':'
   * Try to assert that the thing is allocated.
   *
   * We would like to assert that the thing is not in the free list, but this
   * check is very slow. Instead we check whether the thing has been poisoned:
   * if it has not then we assume it is allocated, but if it has then it is
   * either free or uninitialized in which case we check the free list.
   *
   * Further complications are that background sweeping may be running and
   * concurrently modifiying the free list and that tracing is done off
   * thread during compacting GC and reading the contents of the thing by
   * IsThingPoisoned would be racy in this case.
   ','line_number':249,'multiline':True]['text':' namespace js','line_number':278,'multiline':False]['text':' Check our sweep groups are correct: we should never have to','line_number':298,'multiline':False]['text':' mark something in a zone that we have started sweeping.','line_number':299,'multiline':False]['text':'
     * Having black->gray edges violates our promise to the cycle collector so
     * we ensure that gray things we encounter when marking black end up getting
     * marked black.
     *
     * This can happen for two reasons:
     *
     * 1) If we're collecting a compartment and it has an edge to an uncollected
     * compartment it's possible that the source and destination of the
     * cross-compartment edge should be gray, but the source was marked black by
     * the write barrier.
     *
     * 2) If we yield during gray marking and the write barrier marks a gray
     * thing black.
     *
     * We handle the first case before returning whereas the second case happens
     * as part of normal marking.
     ','line_number':302,'multiline':True]['text':' Check our sweep groups are correct as above.','line_number':328,'multiline':False]['text':'
       * The destination compartment is being not being marked gray now,
       * but it will be later, so record the cell so it can be marked gray
       * at the appropriate time.
       ','line_number':332,'multiline':True]['text':'** Tracing Interface *****************************************************','line_number':388,'multiline':True]['text':' namespace js','line_number':417,'multiline':False]['text':' Define TraceExternalEdge for each public GC pointer type.','line_number':425,'multiline':False]['text':' Define UnsafeTraceRoot for each public GC pointer type.','line_number':437,'multiline':False]['text':' Also, for the moment, define UnsafeTraceRoot for internal GC pointer types.','line_number':441,'multiline':False]['text':' namespace gc','line_number':464,'multiline':False]['text':' namespace js','line_number':465,'multiline':False]['text':' In debug builds, makes a note of the current compartment before calling a','line_number':467,'multiline':False]['text':' trace hook or traceChildren() method on a GC thing.','line_number':468,'multiline':False]['text':' In debug builds, clear the trace hook compartment. This happens','line_number':498,'multiline':False]['text':' after the trace hook has called back into one of our trace APIs and we've','line_number':499,'multiline':False]['text':' checked the traced thing.','line_number':500,'multiline':False]['text':' Clear expected compartment for cross-compartment edge.','line_number':535,'multiline':False]['text':' Clear expected compartment for cross-compartment edge.','line_number':583,'multiline':False]['text':' We can't use ShouldTraceCrossCompartment here because that assumes the','line_number':594,'multiline':False]['text':' source of the edge is a CCW object which could be used to delay gray','line_number':595,'multiline':False]['text':' marking. Instead, assert that the weak map zone is in the same marking','line_number':596,'multiline':False]['text':' state as the target thing's zone and therefore we can go ahead and mark it.','line_number':597,'multiline':False]['text':' Clear expected compartment for cross-compartment edge.','line_number':606,'multiline':False]['text':' We have to mark permanent atoms and well-known symbols through a special','line_number':624,'multiline':False]['text':' method because the default DoMarking implementation automatically skips','line_number':625,'multiline':False]['text':' them. Fortunately, atoms (permanent and non) cannot refer to other GC','line_number':626,'multiline':False]['text':' things so they do not need to go through the mark stack and may simply','line_number':627,'multiline':False]['text':' be marked directly.  Moreover, well-known symbols can refer only to','line_number':628,'multiline':False]['text':' permanent atoms, so likewise require no subsequent marking.','line_number':629,'multiline':False]['text':' We shouldn't move process global roots.','line_number':639,'multiline':False]['text':' Return true by default. For some types the lambda below won't be called.','line_number':723,'multiline':False]['text':' Only update *thingp if the value changed, to avoid TSan false positives for','line_number':737,'multiline':False]['text':' template objects when using DumpHeapTracer or UbiNode tracers while Ion','line_number':738,'multiline':False]['text':' compiling off-thread.','line_number':739,'multiline':False]['text':' This method is responsible for dynamic dispatch to the real tracer','line_number':747,'multiline':False]['text':' implementation. Consider replacing this choke point with virtual dispatch:','line_number':748,'multiline':False]['text':' a sufficiently smart C++ compiler may be able to devirtualize some paths.','line_number':749,'multiline':False]['text':'** GC Marking Interface **************************************************','line_number':781,'multiline':True]['text':' For now, we only handle JSObject* and BaseScript* keys, but the linear time','line_number':792,'multiline':False]['text':' algorithm can be easily extended by adding in more types here, then making','line_number':793,'multiline':False]['text':' GCMarker::traverse<T> call markImplicitEdges.','line_number':794,'multiline':False]['text':' The above marking always goes through markAndPush, which will not cause','line_number':815,'multiline':False]['text':' 'edges' to be appended to while iterating.','line_number':816,'multiline':False]['text':' 'delegate' is no longer the delegate of 'key'.','line_number':820,'multiline':False]['text':' We are losing 3 edges here: key -> delegate, delegate -> key, and','line_number':834,'multiline':False]['text':' <delegate, map> -> value. Maintain snapshot-at-beginning (hereafter,','line_number':835,'multiline':False]['text':' S-A-B) by conservatively assuming the delegate will end up black and','line_number':836,'multiline':False]['text':' marking through the latter 2 edges.','line_number':837,'multiline':False]['text':'','line_number':838,'multiline':False]['text':' Note that this does not fully give S-A-B:','line_number':839,'multiline':False]['text':'','line_number':840,'multiline':False]['text':'  1. If the map is gray, then the value will only be marked gray here even','line_number':841,'multiline':False]['text':'  though the map could later be discovered to be black.','line_number':842,'multiline':False]['text':'','line_number':843,'multiline':False]['text':'  2. If the map has not yet been marked, we won't have any entries to mark','line_number':844,'multiline':False]['text':'  here in the first place.','line_number':845,'multiline':False]['text':'','line_number':846,'multiline':False]['text':'  3. We're not marking the delegate, since that would cause eg nukeAllCCWs','line_number':847,'multiline':False]['text':'  to keep everything alive for another collection.','line_number':848,'multiline':False]['text':'','line_number':849,'multiline':False]['text':' We can't even assume that the delegate passed in here is live, because we','line_number':850,'multiline':False]['text':' could have gotten here from nukeAllCCWs, which iterates over all CCWs','line_number':851,'multiline':False]['text':' including dead ones.','line_number':852,'multiline':False]['text':'','line_number':853,'multiline':False]['text':' This is ok because S-A-B is only needed to prevent the case where an','line_number':854,'multiline':False]['text':' unmarked object is removed from the graph and then re-inserted where it is','line_number':855,'multiline':False]['text':' reachable only by things that have already been marked. None of the 3','line_number':856,'multiline':False]['text':' target objects will be re-inserted anywhere as a result of this action.','line_number':857,'multiline':False]['text':' 'delegate' is now the delegate of 'key'. Update weakmap marking state.','line_number':864,'multiline':False]['text':' Similar to severWeakDelegate above, mark through the key -> value edge.','line_number':878,'multiline':False]['text':' markedThing might be a key in a debugger weakmap, which can end up marking','line_number':900,'multiline':False]['text':' values that are in a different compartment.','line_number':901,'multiline':False]['text':' namespace js','line_number':920,'multiline':False]['text':' Don't trace things that are owned by another runtime.','line_number':924,'multiline':False]['text':' We may encounter nursery things during normal marking since we don't','line_number':929,'multiline':False]['text':' collect the nursery at the start of every GC slice.','line_number':930,'multiline':False]['text':' Don't mark things outside a zone if we are in a per-zone GC.','line_number':935,'multiline':False]['text':' Do per-type marking precondition checks.','line_number':941,'multiline':False]['text':' Mark the compartment as live.','line_number':952,'multiline':False]['text':' Optimized marking for read barriers. This is called from','line_number':962,'multiline':False]['text':' ExposeGCThingToActiveJS which has already checked the prerequisites for','line_number':963,'multiline':False]['text':' performing a read barrier. This means we can skip a bunch of checks and','line_number':964,'multiline':False]['text':' call info the tracer directly.','line_number':965,'multiline':False]['text':' Skip dispatching on known tracer type.','line_number':974,'multiline':False]['text':' Internal version of previous function called for both read and pre-write','line_number':980,'multiline':False]['text':' barriers.','line_number':981,'multiline':False]['text':' Skip disptaching on known tracer type.','line_number':989,'multiline':False]['text':' Skip recording ropes. Buffering them is problematic because they will have','line_number':998,'multiline':False]['text':' their flags temporarily overwritten during flattening. Fortunately their','line_number':999,'multiline':False]['text':' children will also be barriered by flattening process so we don't need to','line_number':1000,'multiline':False]['text':' traverse them.','line_number':1001,'multiline':False]['text':' The simplest traversal calls out to the fully generic traceChildren function','line_number':1021,'multiline':False]['text':' to visit the child edges. In the absence of other traversal mechanisms, this','line_number':1022,'multiline':False]['text':' function will rapidly grow the stack past its bounds and crash the process.','line_number':1023,'multiline':False]['text':' Thus, this generic tracing should only be used in cases where subsequent','line_number':1024,'multiline':False]['text':' tracing will not recurse.','line_number':1025,'multiline':False]['text':' namespace js','line_number':1054,'multiline':False]['text':' Strings, Shapes, and Scopes are extremely common, but have simple patterns of','line_number':1056,'multiline':False]['text':' recursion. We traverse trees of these edges immediately, with aggressive,','line_number':1057,'multiline':False]['text':' manual inlining, implemented by eagerlyTraceChildren.','line_number':1058,'multiline':False]['text':' namespace js','line_number':1082,'multiline':False]['text':' Object and ObjectGroup are extremely common and can contain arbitrarily','line_number':1084,'multiline':False]['text':' nested graphs, so are not trivially inlined. In this case we use a mark','line_number':1085,'multiline':False]['text':' stack to control recursion. JitCode shares none of these properties, but is','line_number':1086,'multiline':False]['text':' included for historical reasons. JSScript normally cannot recurse, but may','line_number':1087,'multiline':False]['text':' be used as a weakmap key and thereby recurse into weakmapped values.','line_number':1088,'multiline':False]['text':' namespace js','line_number':1108,'multiline':False]['text':' Atoms and Symbols do not have or mark their internal pointers,','line_number':1120,'multiline':False]['text':' respectively.','line_number':1121,'multiline':False]['text':' No further checks for parmanent/shared things.','line_number':1127,'multiline':False]['text':' Atoms and Symbols do not have access to a compartment pointer, or we'd need','line_number':1134,'multiline':False]['text':' to adjust the subsequent check to catch that case.','line_number':1135,'multiline':False]['text':' The Zones must match, unless the target is an atom.','line_number':1138,'multiline':False]['text':' If we are marking an atom, that atom must be marked in the source zone's','line_number':1141,'multiline':False]['text':' atom bitmap.','line_number':1142,'multiline':False]['text':' If we have access to a compartment pointer for both things, they must','line_number':1149,'multiline':False]['text':' match.','line_number':1150,'multiline':False]['text':' namespace','line_number':1182,'multiline':False]['text':'** Inline, Eager GC Marking **********************************************','line_number':1214,'multiline':True]['text':' Each of the eager, inline marking paths is directly preceeded by the','line_number':1216,'multiline':False]['text':' out-of-line, generic tracing code for comparison. Both paths must end up','line_number':1217,'multiline':False]['text':' traversing equivalent subgraphs.','line_number':1218,'multiline':False]['text':' Use iterative marking to avoid blowing out the stack.','line_number':1278,'multiline':False]['text':' It's possible to observe a rope as the base of a linear string if we','line_number':1282,'multiline':False]['text':' process barriers during rope flattening. See the assignment of base in','line_number':1283,'multiline':False]['text':' JSRope::flattenInternal's finish_node section.','line_number':1284,'multiline':False]['text':' This function tries to scan the whole rope tree using the marking stack','line_number':1306,'multiline':False]['text':' as temporary storage. If that becomes full, the unscanned ropes are','line_number':1307,'multiline':False]['text':' added to the delayed marking list. When the function returns, the','line_number':1308,'multiline':False]['text':' marking stack is at the same depth as it was on entry. This way we avoid','line_number':1309,'multiline':False]['text':' using tags when pushing ropes to the stack as ropes never leak to other','line_number':1310,'multiline':False]['text':' users of the stack. This also assumes that a rope can only point to','line_number':1311,'multiline':False]['text':' other ropes or linear strings, it cannot refer to GC things of other','line_number':1312,'multiline':False]['text':' types.','line_number':1313,'multiline':False]['text':' When both children are ropes, set aside the right one to','line_number':1338,'multiline':False]['text':' scan it later.','line_number':1339,'multiline':False]['text':' Note: the realm's global can be nullptr if we GC while creating the global.','line_number':1511,'multiline':False]['text':' Special case: if a map has a table then all its pointers must point to','line_number':1566,'multiline':False]['text':' this map or an ancestor. Since these pointers will be traced by this','line_number':1567,'multiline':False]['text':' loop they do not need to be traced here as well.','line_number':1568,'multiline':False]['text':' For shared maps follow the |parent| link and not the |previous| link.','line_number':1575,'multiline':False]['text':' They're different when a map had a branch that wasn't at the end of the','line_number':1576,'multiline':False]['text':' map, but in this case they must have the same |previous| map. This is','line_number':1577,'multiline':False]['text':' asserted in SharedPropMap::addChild. In other words, marking all','line_number':1578,'multiline':False]['text':' |parent| maps will also mark all |previous| maps.','line_number':1579,'multiline':False]['text':' Call the trace hook set on the object, if present.','line_number':1587,'multiline':False]['text':'** Mark-stack Marking ****************************************************','line_number':1598,'multiline':True]['text':' If the queue wants to be gray marking, but we've pushed a black object','line_number':1612,'multiline':False]['text':' since set-color-gray was processed, then we can't switch to gray and must','line_number':1613,'multiline':False]['text':' again wait until gray marking is possible.','line_number':1614,'multiline':False]['text':'','line_number':1615,'multiline':False]['text':' Remove this code if the restriction against marking gray during black is','line_number':1616,'multiline':False]['text':' relaxed.','line_number':1617,'multiline':False]['text':' If the queue wants to be marking a particular color, switch to that color.','line_number':1622,'multiline':False]['text':' In any case, restore the mark color to whatever it was when we entered','line_number':1623,'multiline':False]['text':' this function.','line_number':1624,'multiline':False]['text':' Process the mark queue by taking each object in turn, pushing it onto the','line_number':1627,'multiline':False]['text':' mark stack, and processing just the top element with processMarkStackTop','line_number':1628,'multiline':False]['text':' without recursing into reachable objects.','line_number':1629,'multiline':False]['text':' If we have started sweeping, obey sweep group ordering. But note that','line_number':1639,'multiline':False]['text':' we will first be called during the initial sweep slice, when the sweep','line_number':1640,'multiline':False]['text':' group indexes have not yet been computed. In that case, we can mark','line_number':1641,'multiline':False]['text':' freely.','line_number':1642,'multiline':False]['text':' Too late. This must have been added after we started collecting,','line_number':1645,'multiline':False]['text':' and we've already processed its sweep group. Skip it.','line_number':1646,'multiline':False]['text':' Not ready yet. Wait until we reach the object's sweep group.','line_number':1650,'multiline':False]['text':' Have not yet reached the point where we can mark this object, so','line_number':1657,'multiline':False]['text':' continue with the GC.','line_number':1658,'multiline':False]['text':' Mark the object and push it onto the stack.','line_number':1663,'multiline':False]['text':' Process just the one object that is now on top of the mark stack,','line_number':1673,'multiline':False]['text':' possibly pushing more stuff onto the stack.','line_number':1674,'multiline':False]['text':' If we overflow the stack here and delay marking, then we won't be','line_number':1677,'multiline':False]['text':' testing what we think we're testing.','line_number':1678,'multiline':False]['text':' We can't enter weak marking mode at just any time, so instead','line_number':1692,'multiline':False]['text':' we'll stop processing the queue and continue on with the GC. Once','line_number':1693,'multiline':False]['text':' we enter weak marking mode, we can continue to the rest of the','line_number':1694,'multiline':False]['text':' queue. Note that we will also suspend for aborting, and then abort','line_number':1695,'multiline':False]['text':' the earliest following weak marking mode.','line_number':1696,'multiline':False]['text':' Cannot mark gray yet, so continue with the GC.','line_number':1710,'multiline':False]['text':' This method leaves the mark color as it found it.','line_number':1753,'multiline':False]['text':' Do all normal marking before any delayed marking.','line_number':1785,'multiline':False]['text':'','line_number':1786,'multiline':False]['text':' We can end up marking black during gray marking in the following case: a','line_number':1787,'multiline':False]['text':' WeakMap has a CCW key whose delegate (target) is black, and during gray','line_number':1788,'multiline':False]['text':' marking we mark the map (gray). The delegate's color will be propagated','line_number':1789,'multiline':False]['text':' to the key. (And we can't avoid this by marking the key gray, because','line_number':1790,'multiline':False]['text':' even though the value will end up gray in either case, the WeakMap entry','line_number':1791,'multiline':False]['text':' must be preserved because the CCW could get collected and then we could','line_number':1792,'multiline':False]['text':' re-wrap the delegate and look it up in the map again, and need to get','line_number':1793,'multiline':False]['text':' back the original value.)','line_number':1794,'multiline':False]['text':' Mark children of things that caused too deep recursion during the','line_number':1800,'multiline':False]['text':' above tracing.','line_number':1801,'multiline':False]['text':'
   * This function uses explicit goto and scans objects directly. This allows us
   * to eliminate tail recursion and significantly improve the marking
   * performance, see bug 641025.
   *
   * Note that the mutator can change the size and layout of objects between
   * marking slices, so we must check slots and element ranges read from the
   * stack.
   ','line_number':1837,'multiline':True]['text':' The object being scanned.','line_number':1847,'multiline':False]['text':' The kind of slot range being scanned, if any.','line_number':1848,'multiline':False]['text':' Slot range base pointer.','line_number':1849,'multiline':False]['text':' Index of the next slot to mark.','line_number':1850,'multiline':False]['text':' End of slot range to mark.','line_number':1851,'multiline':False]['text':' Account for shifted elements.','line_number':1879,'multiline':False]['text':' Save the rest of this value range for later and start scanning obj2's','line_number':1940,'multiline':False]['text':' children.','line_number':1941,'multiline':False]['text':' v.toGCCellPtr cannot be inlined, so construct one manually.','line_number':1951,'multiline':False]['text':'** Mark Stack ************************************************************','line_number':2016,'multiline':True]['text':' If the realloc fails, just keep using the existing stack; it's','line_number':2156,'multiline':False]['text':' not ideal but better than failing.','line_number':2157,'multiline':False]['text':'** GCMarker **************************************************************','line_number':2312,'multiline':True]['text':'
 * WeakMapTraceAction::Expand: the GC is recomputing the liveness of WeakMap
 * entries by expanding each live WeakMap into its constituent key->value edges,
 * a table of which will be consulted in a later phase whenever marking a
 * potential key.
 ','line_number':2314,'multiline':True]['text':' During weak marking mode, we maintain a table mapping weak keys to','line_number':2482,'multiline':False]['text':' entries in known-live weakmaps. Initialize it with the keys of marked','line_number':2483,'multiline':False]['text':' weakmaps -- or more precisely, the keys of marked weakmaps that are','line_number':2484,'multiline':False]['text':' mapped to not yet live values. (Once bug 1167452 implements incremental','line_number':2485,'multiline':False]['text':' weakmap marking, this initialization step will become unnecessary, as','line_number':2486,'multiline':False]['text':' the table will already hold all such keys.)','line_number':2487,'multiline':False]['text':' Set state before doing anything else, so any new key that is marked','line_number':2489,'multiline':False]['text':' during the following gcEphemeronEdges scan will itself be looked up in','line_number':2490,'multiline':False]['text':' gcEphemeronEdges and marked according to ephemeron rules.','line_number':2491,'multiline':False]['text':' If there was an 'enter-weak-marking-mode' token in the queue, then it','line_number':2494,'multiline':False]['text':' and everything after it will still be in the queue so we can process','line_number':2495,'multiline':False]['text':' them now.','line_number':2496,'multiline':False]['text':' gcEphemeronEdges contains the keys from all weakmaps marked so far, or at','line_number':2516,'multiline':False]['text':' least the keys that might still need to be marked through. Scan through','line_number':2517,'multiline':False]['text':' gcEphemeronEdges and mark all values whose keys are marked. This marking','line_number':2518,'multiline':False]['text':' may recursively mark through other weakmap entries (immediately since we','line_number':2519,'multiline':False]['text':' are now in WeakMarking mode). The end result is a consistent state where','line_number':2520,'multiline':False]['text':' all values are marked if both their map and key are marked -- though note','line_number':2521,'multiline':False]['text':' that we may later leave weak marking mode, do some more marking, and then','line_number':2522,'multiline':False]['text':' enter back in.','line_number':2523,'multiline':False]['text':' An OrderedHashMap::Range stays valid even when the underlying table','line_number':2530,'multiline':False]['text':' (zone->gcEphemeronEdges) is mutated, which is useful here since we may add','line_number':2531,'multiline':False]['text':' additional entries while iterating over the Range.','line_number':2532,'multiline':False]['text':' Pop before any mutations happen.','line_number':2541,'multiline':False]['text':' The gcEphemeronEdges table is still populated and may be used during a','line_number':2566,'multiline':False]['text':' future weak marking mode within this GC.','line_number':2567,'multiline':False]['text':'
 * Process arenas from |delayedMarkingList| by marking the unmarked children of
 * marked cells of color |color|. Return early if the |budget| is exceeded.
 *
 * This is called twice, first to mark gray children and then to mark black
 * children.
 ','line_number':2604,'multiline':True]['text':' Marking delayed children may add more arenas to the list, including arenas','line_number':2612,'multiline':False]['text':' we are currently processing or have previously processed. Handle this by','line_number':2613,'multiline':False]['text':' clearing a flag on each arena before marking its children. This flag will','line_number':2614,'multiline':False]['text':' be set again if the arena is re-added. Iterate the list until no new arenas','line_number':2615,'multiline':False]['text':' were added.','line_number':2616,'multiline':False]['text':' We have a list of arenas containing marked cells with unmarked children','line_number':2648,'multiline':False]['text':' where we ran out of stack space during marking.','line_number':2649,'multiline':False]['text':'','line_number':2650,'multiline':False]['text':' Both black and gray cells in these arenas may have unmarked children, and','line_number':2651,'multiline':False]['text':' we must mark gray children first as gray entries always sit before black','line_number':2652,'multiline':False]['text':' entries on the mark stack. Therefore the list is processed in two stages.','line_number':2653,'multiline':False]['text':' Rebuild the delayed marking list, removing arenas which do not need further','line_number':2674,'multiline':False]['text':' marking.','line_number':2675,'multiline':False]['text':'** Tenuring Tracer *******************************************************','line_number':2721,'multiline':True]['text':' Take a fast path for tenuring a plain object which is by far the most','line_number':2740,'multiline':False]['text':' common case.','line_number':2741,'multiline':False]['text':' We only care about a few kinds of GC thing here and this generates much','line_number':2803,'multiline':False]['text':' tighter code than using MapGCThingTyped.','line_number':2804,'multiline':False]['text':' namespace gc','line_number':2842,'multiline':False]['text':' namespace js','line_number':2843,'multiline':False]['text':' Beware JSObject::swap exchanging a native object for a non-native one.','line_number':2849,'multiline':False]['text':' Non-deduplicatable marking is necessary because of the following 2 reasons:','line_number':2884,'multiline':False]['text':'','line_number':2885,'multiline':False]['text':' 1. Tenured string chars cannot be updated:','line_number':2886,'multiline':False]['text':'','line_number':2887,'multiline':False]['text':'    If any of the tenured string's bases were deduplicated during tenuring,','line_number':2888,'multiline':False]['text':'    the tenured string's chars pointer would need to be adjusted. This would','line_number':2889,'multiline':False]['text':'    then require updating any other tenured strings that are dependent on the','line_number':2890,'multiline':False]['text':'    first tenured string, and we have no way to find them without scanning','line_number':2891,'multiline':False]['text':'    the entire tenured heap.','line_number':2892,'multiline':False]['text':'','line_number':2893,'multiline':False]['text':' 2. Tenured string cannot store its nursery base or base's chars:','line_number':2894,'multiline':False]['text':'','line_number':2895,'multiline':False]['text':'    Tenured strings have no place to stash a pointer to their nursery base or','line_number':2896,'multiline':False]['text':'    its chars. You need to be able to traverse any dependent string's chain','line_number':2897,'multiline':False]['text':'    of bases up to a nursery "root base" that points to the malloced chars','line_number':2898,'multiline':False]['text':'    that the dependent strings started out pointing to, so that you can','line_number':2899,'multiline':False]['text':'    calculate the offset of any dependent string and update the ptr+offset if','line_number':2900,'multiline':False]['text':'    the root base gets deduplicated to a different allocation. Tenured','line_number':2901,'multiline':False]['text':'    strings in this base chain will stop you from reaching the nursery','line_number':2902,'multiline':False]['text':'    version of the root base; you can only get to the tenured version, and it','line_number':2903,'multiline':False]['text':'    has no place to store the original chars pointer.','line_number':2904,'multiline':False]['text':' Walk along the chain of dependent strings' base string pointers','line_number':2911,'multiline':False]['text':' to mark them all non-deduplicatable.','line_number':2912,'multiline':False]['text':' baseOrRelocOverlay can be one of the three cases:','line_number':2914,'multiline':False]['text':' 1. forwarded nursery string:','line_number':2915,'multiline':False]['text':'    The forwarded string still retains the flag that can tell whether','line_number':2916,'multiline':False]['text':'    this string is a dependent string with a base. Its','line_number':2917,'multiline':False]['text':'    StringRelocationOverlay holds a saved pointer to its base in the','line_number':2918,'multiline':False]['text':'    nursery.','line_number':2919,'multiline':False]['text':' 2. not yet forwarded nursery string:','line_number':2920,'multiline':False]['text':'    Retrieve the base field directly from the string.','line_number':2921,'multiline':False]['text':' 3. tenured string:','line_number':2922,'multiline':False]['text':'    The nursery base chain ends here, so stop traversing.','line_number':2923,'multiline':False]['text':' Mark all strings reachable from the tenured string `str` as','line_number':2951,'multiline':False]['text':' non-deduplicatable. These strings are the bases of the tenured dependent','line_number':2952,'multiline':False]['text':' string.','line_number':2953,'multiline':False]['text':' Clear the low bit.','line_number':2980,'multiline':False]['text':' Verify that all string whole cells are traced first before any other','line_number':3016,'multiline':False]['text':' strings are visited for any reason.','line_number':3017,'multiline':False]['text':' Trace all of the strings to mark the non-deduplicatable bits, then trace','line_number':3021,'multiline':False]['text':' all other whole cells.','line_number':3022,'multiline':False]['text':' Nursery string deduplication requires all tenured string -> nursery','line_number':3051,'multiline':False]['text':' string edges to be registered with the whole cell buffer in order to','line_number':3052,'multiline':False]['text':' correctly set the non-deduplicatable bit.','line_number':3053,'multiline':False]['text':' Visit all object children of the object and trace them.','line_number':3067,'multiline':False]['text':' Insert the given relocation entry into the list of things to visit. ','line_number':3128,'multiline':True]['text':'
   * Arrays do not necessarily have the same AllocKind between src and dst.
   * We deal with this by copying elements manually, possibly re-inlining
   * them if there is adequate room inline in dst.
   *
   * For Arrays we're reducing tenuredSize to the smaller srcSize
   * because moveElementsToTenured() accounts for all Array elements,
   * even if they are inlined.
   ','line_number':3161,'multiline':True]['text':' Typed arrays with inline data do not necessarily have the same','line_number':3174,'multiline':False]['text':' AllocKind between src and dst. The nursery does not allocate an','line_number':3175,'multiline':False]['text':' inline data buffer that has the same size as the slow path will do.','line_number':3176,'multiline':False]['text':' In the slow path, the Typed Array Object stores the inline data','line_number':3177,'multiline':False]['text':' in the allocated space that fits the AllocKind. In the fast path,','line_number':3178,'multiline':False]['text':' the nursery will allocate another buffer that is directly behind the','line_number':3179,'multiline':False]['text':' minimal JSObject. That buffer size plus the JSObject size is not','line_number':3180,'multiline':False]['text':' necessarily as large as the slow path's AllocKind size.','line_number':3181,'multiline':False]['text':' Copy the Cell contents.','line_number':3192,'multiline':False]['text':' Move the slots and elements, if we need to.','line_number':3197,'multiline':False]['text':' There is a pointer into a dictionary mode object from the head of its','line_number':3204,'multiline':False]['text':' shape list. This is updated in Nursery::sweepDictionaryModeObjects().','line_number':3205,'multiline':False]['text':' Tell the hazard analysis that the object moved hook can't GC.','line_number':3211,'multiline':False]['text':' Fast path version of moveToTenuredSlow() for specialized for PlainObject.','line_number':3228,'multiline':False]['text':' Copy the Cell contents.','line_number':3240,'multiline':False]['text':' Move the slots and elements.','line_number':3245,'multiline':False]['text':' Fixed slots have already been copied over. ','line_number':3260,'multiline':True]['text':' TODO Bug 874151: Prefer to put element data inline if we have space. ','line_number':3310,'multiline':True]['text':' Shifted elements are copied too.','line_number':3320,'multiline':False]['text':' Unlike other objects, Arrays can have fixed elements. ','line_number':3323,'multiline':True]['text':' If this string is in the StringToAtomCache, try to deduplicate it by using','line_number':3371,'multiline':False]['text':' the atom. Don't do this for dependent strings because they're more','line_number':3372,'multiline':False]['text':' complicated. See StringRelocationOverlay and DeduplicationStringHasher','line_number':3373,'multiline':False]['text':' comments.','line_number':3374,'multiline':False]['text':' Only deduplicate if both strings have the same encoding, to not confuse','line_number':3381,'multiline':False]['text':' dependent strings.','line_number':3382,'multiline':False]['text':' The StringToAtomCache isn't used for inline strings (due to the minimum','line_number':3384,'multiline':False]['text':' length) so canOwnDependentChars must be true for both src and atom.','line_number':3385,'multiline':False]['text':' This means if there are dependent strings floating around using str's','line_number':3386,'multiline':False]['text':' chars, they will be able to use the chars from the atom.','line_number':3387,'multiline':False]['text':' A live nursery string can only get deduplicated when:','line_number':3403,'multiline':False]['text':' 1. Its length is smaller than MAX_DEDUPLICATABLE_STRING_LENGTH:','line_number':3404,'multiline':False]['text':'    Hashing a long string can affect performance.','line_number':3405,'multiline':False]['text':' 2. It is linear:','line_number':3406,'multiline':False]['text':'    Deduplicating every node in it would end up doing O(n^2) hashing work.','line_number':3407,'multiline':False]['text':' 3. It is deduplicatable:','line_number':3408,'multiline':False]['text':'    The JSString NON_DEDUP_BIT flag is unset.','line_number':3409,'multiline':False]['text':' 4. It matches an entry in stringDeDupSet.','line_number':3410,'multiline':False]['text':' Deduplicate to the looked-up string!','line_number':3415,'multiline':False]['text':' When there is oom caused by the stringDeDupSet, stop deduplicating','line_number':3426,'multiline':False]['text':' strings.','line_number':3427,'multiline':False]['text':' dst or one of its leaves might have a base that will be deduplicated.','line_number':3441,'multiline':False]['text':' Insert the overlay into the fixup list to relocate it later.','line_number':3442,'multiline':False]['text':' Traverse the dependent string nursery base chain to find the base that','line_number':3463,'multiline':False]['text':' it's using chars from.','line_number':3464,'multiline':False]['text':' The nursery root base is relocOverlay, it is tenured to tenuredBase.','line_number':3472,'multiline':False]['text':' Relocate tenuredDependentStr chars and reassign the tenured root base','line_number':3473,'multiline':False]['text':' as its base.','line_number':3474,'multiline':False]['text':' The root base is not forwarded yet, it is simply base.','line_number':3491,'multiline':False]['text':' The root base can be in either the nursery or the tenured heap.','line_number':3494,'multiline':False]['text':' dependentStr chars needs to be relocated after traceString if the','line_number':3495,'multiline':False]['text':' root base is in the nursery.','line_number':3496,'multiline':False]['text':' To ensure the NON_DEDUP_BIT was reset properly.','line_number':3542,'multiline':False]['text':' The nursery root base might not be forwarded before','line_number':3545,'multiline':False]['text':' traceString(tenuredStr). traceString(tenuredStr) will forward the root','line_number':3546,'multiline':False]['text':' base if that's the case. Dependent string chars needs to be relocated','line_number':3547,'multiline':False]['text':' after traceString if root base was not forwarded.','line_number':3548,'multiline':False]['text':' At the moment, strings always have the same AllocKind between src and','line_number':3591,'multiline':False]['text':' dst. This may change in the future.','line_number':3592,'multiline':False]['text':' Copy the Cell contents.','line_number':3595,'multiline':False]['text':' At the moment, BigInts always have the same AllocKind between src and','line_number':3612,'multiline':False]['text':' dst. This may change in the future.','line_number':3613,'multiline':False]['text':' Copy the Cell contents.','line_number':3616,'multiline':False]['text':'** IsMarked / IsAboutToBeFinalized ***************************************','line_number':3650,'multiline':True]['text':' Allow any thread access to uncollected things.','line_number':3663,'multiline':False]['text':' Allow the current thread access if it is sweeping or in sweep-marking, but','line_number':3668,'multiline':False]['text':' try to check the zone. Some threads have access to all zones when sweeping.','line_number':3669,'multiline':False]['text':' Otherwise only allow access from the main thread or this zone's associated','line_number':3680,'multiline':False]['text':' thread.','line_number':3681,'multiline':False]['text':' Don't depend on the mark state of other cells during finalization.','line_number':3710,'multiline':False]['text':' Don't depend on the mark state of other cells during finalization.','line_number':3733,'multiline':False]['text':' Permanent atoms are never finalized by non-owning runtimes. ','line_number':3741,'multiline':True]['text':' TODO: We should assert the zone of the tenured cell is in Sweeping state,','line_number':3787,'multiline':False]['text':' however we need to fix atoms and JitcodeGlobalTable first.','line_number':3788,'multiline':False]['text':' Bug 1501334 : IsAboutToBeFinalized doesn't work for atoms','line_number':3789,'multiline':False]['text':' Bug 1071218 : Refactor Debugger::sweepAll and','line_number':3790,'multiline':False]['text':'               JitRuntime::SweepJitcodeGlobalTable to work per sweep group','line_number':3791,'multiline':False]['text':' Instantiate a copy of the Tracing templates for each public GC type.','line_number':3839,'multiline':False]['text':' namespace gc ','line_number':3866,'multiline':True]['text':' namespace js ','line_number':3867,'multiline':True]['text':'** Cycle Collector Barrier Implementation ********************************','line_number':3869,'multiline':True]['text':'
 * The GC and CC are run independently. Consequently, the following sequence of
 * events can occur:
 * 1. GC runs and marks an object gray.
 * 2. The mutator runs (specifically, some C++ code with access to gray
 *    objects) and creates a pointer from a JS root or other black object to
 *    the gray object. If we re-ran a GC at this point, the object would now be
 *    black.
 * 3. Now we run the CC. It may think it can collect the gray object, even
 *    though it's reachable from the JS heap.
 *
 * To prevent this badness, we unmark the gray bit of an object when it is
 * accessed by callers outside XPConnect. This would cause the object to go
 * black in step 2 above. This must be done on everything reachable from the
 * object being returned. The following code takes care of the recursive
 * re-coloring.
 *
 * There is an additional complication for certain kinds of edges that are not
 * contained explicitly in the source object itself, such as from a weakmap key
 * to its value. These "implicit edges" are represented in some other
 * container object, such as the weakmap itself. In these
 * cases, calling unmark gray on an object won't find all of its children.
 *
 * Handling these implicit edges has two parts:
 * - A special pass enumerating all of the containers that know about the
 *   implicit edges to fix any black-gray edges that have been created. This
 *   is implemented in nsXPConnect::FixWeakMappingGrayBits.
 * - To prevent any incorrectly gray objects from escaping to live JS outside
 *   of the containers, we must add unmark-graying read barriers to these
 *   containers.
 ','line_number':3871,'multiline':True]['text':' This is used by the UnmarkGray tracer only, and needs to report itself as','line_number':3905,'multiline':False]['text':' the non-gray tracer to not trigger assertions.  Do not use it in another','line_number':3906,'multiline':False]['text':' context without making this more generic.','line_number':3907,'multiline':False]['text':' We set weakMapAction to WeakMapTraceAction::Skip because the cycle','line_number':3918,'multiline':False]['text':' collector will fix up any color mismatches involving weakmaps when it runs.','line_number':3919,'multiline':False]['text':' Whether we unmarked anything.','line_number':3929,'multiline':False]['text':' Whether we ran out of memory.','line_number':3932,'multiline':False]['text':' Stack of cells to traverse.','line_number':3936,'multiline':False]['text':' Cells in the nursery cannot be gray, and nor can certain kinds of tenured','line_number':3945,'multiline':False]['text':' cells. These must necessarily point only to black edges.','line_number':3946,'multiline':False]['text':' If the cell is in a zone whose mark bits are being cleared, then it will','line_number':3960,'multiline':False]['text':' end up white.','line_number':3961,'multiline':False]['text':' If the cell is in a zone that we're currently marking, then it's possible','line_number':3966,'multiline':False]['text':' that it is currently white but will end up gray. To handle this case,','line_number':3967,'multiline':False]['text':' trigger the barrier for any cells in zones that are currently being','line_number':3968,'multiline':False]['text':' marked. This will ensure they will eventually get marked black.','line_number':3969,'multiline':False]['text':' Skip disptaching on known tracer type.','line_number':3972,'multiline':False]['text':' If we run out of memory, we take a drastic measure: require that we','line_number':4002,'multiline':False]['text':' GC again before the next CC.','line_number':4003,'multiline':False]['text':' Mark bits are being cleared in preparation for GC.','line_number':4029,'multiline':False]['text':' static ','line_number':4088,'multiline':True]['text':' If the barrier buffer grows too large, trace all barriered things at that','line_number':4147,'multiline':False]['text':' point.','line_number':4148,'multiline':False]['text':' Mark the cell here to prevent us recording it again.','line_number':4156,'multiline':False]['text':' NOTE: This assumes that cells that don't have children do not require their','line_number':4161,'multiline':False]['text':' traceChildren method to be called.','line_number':4162,'multiline':False]['text':' This string is an interior node of a rope that is currently being','line_number':4212,'multiline':False]['text':' flattened. The flattening process invokes the barrier on all nodes in','line_number':4213,'multiline':False]['text':' the tree, so interior nodes need not be traversed.','line_number':4214,'multiline':False]['text':' namespace debug','line_number':4272,'multiline':False]['text':' namespace js','line_number':4273,'multiline':False]