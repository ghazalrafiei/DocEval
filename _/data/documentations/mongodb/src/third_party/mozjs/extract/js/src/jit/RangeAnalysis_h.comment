['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' An upper bound computed on the number of backedges a loop will take.','line_number':43,'multiline':False]['text':' This count only includes backedges taken while running Ion code: for OSR','line_number':44,'multiline':False]['text':' loops, this will exclude iterations that executed in the interpreter or in','line_number':45,'multiline':False]['text':' baseline compiled code.','line_number':46,'multiline':False]['text':' Loop for which this bound applies.','line_number':48,'multiline':False]['text':' Test from which this bound was derived; after executing exactly 'bound'','line_number':51,'multiline':False]['text':' times this test will exit the loop. Code in the loop body which this','line_number':52,'multiline':False]['text':' test dominates (will include the backedge) will execute at most 'bound'','line_number':53,'multiline':False]['text':' times. Other code in the loop will execute at most '1 + Max(bound, 0)'','line_number':54,'multiline':False]['text':' times.','line_number':55,'multiline':False]['text':' Symbolic bound computed for the number of backedge executions. The terms','line_number':58,'multiline':False]['text':' in this bound are all loop invariant.','line_number':59,'multiline':False]['text':' Linear sum for the number of iterations already executed, at the start','line_number':62,'multiline':False]['text':' of the loop header. This will use loop invariant terms and header phis.','line_number':63,'multiline':False]['text':' A symbolic upper or lower bound computed for a term.','line_number':77,'multiline':False]['text':' Any loop iteration bound from which this was derived.','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':' If non-nullptr, then 'sum' is only valid within the loop body, at','line_number':86,'multiline':False]['text':' points dominated by the loop bound's test (see LoopIterationBound).','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' If nullptr, then 'sum' is always valid.','line_number':89,'multiline':False]['text':' Computed symbolic bound, see above.','line_number':97,'multiline':False]['text':' Any iteration bounds discovered for loops in the graph.','line_number':131,'multiline':False]['text':' Int32 are signed. INT32_MAX is pow(2,31)-1 and INT32_MIN is -pow(2,31),','line_number':146,'multiline':False]['text':' so the greatest exponent we need is 31.','line_number':147,'multiline':False]['text':' UInt32 are unsigned. UINT32_MAX is pow(2,32)-1, so it's the greatest','line_number':150,'multiline':False]['text':' value that has an exponent of 31.','line_number':151,'multiline':False]['text':' Maximal exponenent under which we have no precission loss on double','line_number':154,'multiline':False]['text':' operations. Double has 52 bits of mantissa, so 2^52+1 cannot be','line_number':155,'multiline':False]['text':' represented without loss.','line_number':156,'multiline':False]['text':' Maximum exponent for finite values.','line_number':160,'multiline':False]['text':' An special exponent value representing all non-NaN values. This','line_number':164,'multiline':False]['text':' includes finite values and the infinities.','line_number':165,'multiline':False]['text':' An special exponent value representing all possible double-precision','line_number':168,'multiline':False]['text':' values. This includes finite values, the infinities, and NaNs.','line_number':169,'multiline':False]['text':' This range class uses int32_t ranges, but has several interfaces which','line_number':172,'multiline':False]['text':' use int64_t, which either holds an int32_t value, or one of the following','line_number':173,'multiline':False]['text':' special values which mean a value which is beyond the int32 range,','line_number':174,'multiline':False]['text':' potentially including infinity or NaN. These special values are','line_number':175,'multiline':False]['text':' guaranteed to compare greater, and less than, respectively, any int32_t','line_number':176,'multiline':False]['text':' value.','line_number':177,'multiline':False]['text':' Absolute ranges.','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' We represent ranges where the endpoints can be in the set:','line_number':193,'multiline':False]['text':' {-infty} U [INT_MIN, INT_MAX] U {infty}.  A bound of +/-','line_number':194,'multiline':False]['text':' infty means that the value may have overflowed in that','line_number':195,'multiline':False]['text':' direction. When computing the range of an integer','line_number':196,'multiline':False]['text':' instruction, the ranges of the operands can be clamped to','line_number':197,'multiline':False]['text':' [INT_MIN, INT_MAX], since if they had overflowed they would','line_number':198,'multiline':False]['text':' no longer be integers. This is important for optimizations','line_number':199,'multiline':False]['text':' and somewhat subtle.','line_number':200,'multiline':False]['text':'','line_number':201,'multiline':False]['text':' N.B.: All of the operations that compute new ranges based','line_number':202,'multiline':False]['text':' on existing ranges will ignore the hasInt32*Bound_ flags of the','line_number':203,'multiline':False]['text':' input ranges; that is, they implicitly clamp the ranges of','line_number':204,'multiline':False]['text':' the inputs to [INT_MIN, INT_MAX]. Therefore, while our range might','line_number':205,'multiline':False]['text':' be unbounded (and could overflow), when using this information to','line_number':206,'multiline':False]['text':' propagate through other ranges, we disregard this fact; if that code','line_number':207,'multiline':False]['text':' executes, then the overflow did not occur, so we may safely assume','line_number':208,'multiline':False]['text':' that the range is [INT_MIN, INT_MAX] instead.','line_number':209,'multiline':False]['text':'','line_number':210,'multiline':False]['text':' To facilitate this trick, we maintain the invariants that:','line_number':211,'multiline':False]['text':' 1) hasInt32LowerBound_ == false implies lower_ == JSVAL_INT_MIN','line_number':212,'multiline':False]['text':' 2) hasInt32UpperBound_ == false implies upper_ == JSVAL_INT_MAX','line_number':213,'multiline':False]['text':'','line_number':214,'multiline':False]['text':' As a second and less precise range analysis, we represent the maximal','line_number':215,'multiline':False]['text':' exponent taken by a value. The exponent is calculated by taking the','line_number':216,'multiline':False]['text':' absolute value and looking at the position of the highest bit.  All','line_number':217,'multiline':False]['text':' exponent computation have to be over-estimations of the actual result. On','line_number':218,'multiline':False]['text':' the Int32 this over approximation is rectified.','line_number':219,'multiline':False]['text':' Any symbolic lower or upper bound computed for this term.','line_number':231,'multiline':False]['text':' This function simply makes several MOZ_ASSERTs to verify the internal','line_number':235,'multiline':False]['text':' consistency of this range.','line_number':236,'multiline':False]['text':' Basic sanity :).','line_number':238,'multiline':False]['text':' When hasInt32LowerBound_ or hasInt32UpperBound_ are false, we set','line_number':241,'multiline':False]['text':' lower_ and upper_ to these specific values as it simplifies the','line_number':242,'multiline':False]['text':' implementation in some places.','line_number':243,'multiline':False]['text':' max_exponent_ must be one of three possible things.','line_number':247,'multiline':False]['text':' Forbid the max_exponent_ field from implying better bounds for','line_number':252,'multiline':False]['text':' lower_/upper_ fields. We have to add 1 to the max_exponent_ when','line_number':253,'multiline':False]['text':' canHaveFractionalPart_ is true in order to accomodate','line_number':254,'multiline':False]['text':' fractional offsets. For example, 2147483647.9 is greater than','line_number':255,'multiline':False]['text':' INT32_MAX, so a range containing that value will have','line_number':256,'multiline':False]['text':' hasInt32UpperBound_ set to false, however that value also has','line_number':257,'multiline':False]['text':' exponent 30, which is strictly less than MaxInt32Exponent. For','line_number':258,'multiline':False]['text':' another example, 1.9 has an exponent of 0 but requires upper_ to be','line_number':259,'multiline':False]['text':' at least 2, which has exponent 1.','line_number':260,'multiline':False]['text':' The following are essentially static assertions, but FloorLog2 isn't','line_number':268,'multiline':False]['text':' trivially suitable for constexpr :(.','line_number':269,'multiline':False]['text':' Set the lower_ and hasInt32LowerBound_ values.','line_number':276,'multiline':False]['text':' Set the upper_ and hasInt32UpperBound_ values.','line_number':289,'multiline':False]['text':' Compute the least exponent value that would be compatible with the','line_number':303,'multiline':False]['text':' values of lower() and upper().','line_number':304,'multiline':False]['text':'','line_number':305,'multiline':False]['text':' Note:','line_number':306,'multiline':False]['text':'     exponent of JSVAL_INT_MIN == 31','line_number':307,'multiline':False]['text':'     exponent of JSVAL_INT_MAX == 30','line_number':308,'multiline':False]['text':' The number of bits needed to encode |max| is the power of 2 plus one.','line_number':310,'multiline':False]['text':' When converting a range which contains fractional values to a range','line_number':318,'multiline':False]['text':' containing only integers, the old max_exponent_ value may imply a better','line_number':319,'multiline':False]['text':' lower and/or upper bound than was previously available, because they no','line_number':320,'multiline':False]['text':' longer need to be conservative about fractional offsets and the ends of','line_number':321,'multiline':False]['text':' the range.','line_number':322,'multiline':False]['text':'','line_number':323,'multiline':False]['text':' Given an exponent value and pointers to the lower and upper bound values,','line_number':324,'multiline':False]['text':' this function refines the lower and upper bound values to the tighest','line_number':325,'multiline':False]['text':' bound for integer values implied by the exponent.','line_number':326,'multiline':False]['text':' pow(2, max_exponent_+1)-1 to compute a maximum absolute value.','line_number':330,'multiline':False]['text':' If the value of any of the fields implies a stronger possible value for','line_number':339,'multiline':False]['text':' any other field, update that field to the stronger value. The range must','line_number':340,'multiline':False]['text':' be completely valid before and it is guaranteed to be kept valid.','line_number':341,'multiline':False]['text':' Examine lower() and upper(), and if they imply a better exponent','line_number':346,'multiline':False]['text':' bound than max_exponent_, set that value as the new','line_number':347,'multiline':False]['text':' max_exponent_.','line_number':348,'multiline':False]['text':' If we have a completely precise range, the value is an integer,','line_number':355,'multiline':False]['text':' since we can only represent integers.','line_number':356,'multiline':False]['text':' If the range doesn't include zero, it doesn't include negative zero.','line_number':363,'multiline':False]['text':' Set the range fields to the given raw values.','line_number':370,'multiline':False]['text':' Construct a range from the given raw values.','line_number':384,'multiline':False]['text':' Construct a range from the given MDefinition. This differs from the','line_number':414,'multiline':False]['text':' MDefinition's range() method in that it describes the range of values','line_number':415,'multiline':False]['text':' *after* any bailout checks.','line_number':416,'multiline':False]['text':' Construct an int32 range containing just i. This is just a convenience','line_number':424,'multiline':False]['text':' wrapper around NewInt32Range.','line_number':425,'multiline':False]['text':' For now, just pass them to the constructor as int64_t values.','line_number':431,'multiline':False]['text':' They'll become unbounded if they're not in the int32_t range.','line_number':432,'multiline':False]['text':' Construct a range containing values >= l and <= h. Note that this','line_number':437,'multiline':False]['text':' function treats negative zero as equal to zero, as >= and <= do. If the','line_number':438,'multiline':False]['text':' range includes zero, it is assumed to include negative zero too.','line_number':439,'multiline':False]['text':' Construct the strictest possible range containing d, or null if d is NaN.','line_number':450,'multiline':False]['text':' This function treats negative zero as distinct from zero, since this','line_number':451,'multiline':False]['text':' makes the strictest possible range containin zero a range which','line_number':452,'multiline':False]['text':' contains one value rather than two.','line_number':453,'multiline':False]['text':' Unlike the other operations, unionWith is an in-place','line_number':468,'multiline':False]['text':' modification. This is to avoid a bunch of useless extra','line_number':469,'multiline':False]['text':' copying when chaining together unions when handling Phi','line_number':470,'multiline':False]['text':' nodes.','line_number':471,'multiline':False]['text':' Test whether the value is known to be within [INT32_MIN,INT32_MAX].','line_number':512,'multiline':False]['text':' Note that this does not necessarily mean the value is an integer.','line_number':513,'multiline':False]['text':' Test whether the value is known to be representable as an int32.','line_number':518,'multiline':False]['text':' Test whether the given value is known to be either 0 or 1.','line_number':523,'multiline':False]['text':' Test if an integer x belongs to the range.','line_number':534,'multiline':False]['text':' Test whether the range contains zero (of either sign).','line_number':537,'multiline':False]['text':' Test whether the range contains NaN values.','line_number':540,'multiline':False]['text':' Test whether the range contains infinities or NaN values.','line_number':543,'multiline':False]['text':' 2^0 -> 1','line_number':558,'multiline':False]['text':' Return the lower bound. Asserts that the value has an int32 bound.','line_number':561,'multiline':False]['text':' Return the upper bound. Asserts that the value has an int32 bound.','line_number':567,'multiline':False]['text':' Test whether all values in this range can are finite and negative.','line_number':573,'multiline':False]['text':' Test whether all values in this range can are finite and non-negative.','line_number':576,'multiline':False]['text':' Test whether a value in this range can possibly be a finite','line_number':581,'multiline':False]['text':' negative value. Note that "negative zero" is not considered negative.','line_number':582,'multiline':False]['text':' Test whether a value in this range can possibly be a finite','line_number':585,'multiline':False]['text':' non-negative value.','line_number':586,'multiline':False]['text':' Test whether a value in this range can have the sign bit set (not','line_number':589,'multiline':False]['text':' counting NaN, where the sign bit is meaningless).','line_number':590,'multiline':False]['text':' Set this range to have a lower bound not less than x.','line_number':596,'multiline':False]['text':' Set this range to have an upper bound not greater than x.','line_number':604,'multiline':False]['text':' Set this range to exclude negative zero.','line_number':612,'multiline':False]['text':' Set this range to include values >= l and <= h. Note that this','line_number':630,'multiline':False]['text':' function treats negative zero as equal to zero, as >= and <= do. If the','line_number':631,'multiline':False]['text':' range includes zero, it is assumed to include negative zero too.','line_number':632,'multiline':False]['text':' Set this range to the narrowest possible range containing d.','line_number':635,'multiline':False]['text':' This function treats negative zero as distinct from zero, since this','line_number':636,'multiline':False]['text':' makes the narrowest possible range containin zero a range which','line_number':637,'multiline':False]['text':' contains one value rather than two.','line_number':638,'multiline':False]['text':' Make the lower end of this range at least INT32_MIN, and make','line_number':657,'multiline':False]['text':' the upper end of this range at most INT32_MAX.','line_number':658,'multiline':False]['text':' If this range exceeds int32_t range, at either or both ends, change','line_number':661,'multiline':False]['text':' it to int32_t range.  Otherwise do nothing.','line_number':662,'multiline':False]['text':' If this range exceeds [0, 32) range, at either or both ends, change','line_number':665,'multiline':False]['text':' it to the [0, 32) range.  Otherwise do nothing.','line_number':666,'multiline':False]['text':' If this range exceeds [0, 1] range, at either or both ends, change','line_number':669,'multiline':False]['text':' it to the [0, 1] range.  Otherwise do nothing.','line_number':670,'multiline':False]['text':' namespace jit','line_number':680,'multiline':False]['text':' namespace js','line_number':681,'multiline':False]['text':' jit_RangeAnalysis_h ','line_number':683,'multiline':True]