['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::GetErrorMessage, JSMSG_*','line_number':27,'multiline':False]['text':'*
 * Maximum number of saved frames returned for an async stack.
 ','line_number':54,'multiline':True]['text':' There should not already be an entry for this frame. Checking the full','line_number':77,'multiline':False]['text':' stack really slows down some tests, so just check the first and last five','line_number':78,'multiline':False]['text':' hundred.','line_number':79,'multiline':False]['text':' The assertions here check that either 1) frames' hasCachedSavedFrame flags','line_number':103,'multiline':False]['text':' accurately indicate the presence of a cache entry for that frame (ignoring','line_number':104,'multiline':False]['text':' pc mismatches), or 2) the cache is completely empty, having been flushed','line_number':105,'multiline':False]['text':' for a realm mismatch.','line_number':106,'multiline':False]['text':' If we flushed the cache due to a realm mismatch, then we shouldn't','line_number':108,'multiline':False]['text':' expect to find any frames in the cache.','line_number':109,'multiline':False]['text':' All our SavedFrames should be in the same realm. If the last','line_number':115,'multiline':False]['text':' entry's SavedFrame's realm doesn't match cx's, flush the cache.','line_number':116,'multiline':False]['text':' Check that they are, indeed, all in the same realm.','line_number':119,'multiline':False]['text':' framePtr must have an entry, but apparently it's below this one on the','line_number':134,'multiline':False]['text':' stack; frames->back() must correspond to a frame younger than framePtr's.','line_number':135,'multiline':False]['text':' SavedStacks::insertFrames is going to push new cache entries for','line_number':136,'multiline':False]['text':' everything younger than framePtr, so this entry should be popped.','line_number':137,'multiline':False]['text':' If the frame's bit was set, the frame should always have an entry in','line_number':140,'multiline':False]['text':' the cache. (If we purged the entire cache because its SavedFrames had','line_number':141,'multiline':False]['text':' been captured for a different realm, then we would have','line_number':142,'multiline':False]['text':' returned early above.)','line_number':143,'multiline':False]['text':' The youngest valid frame may have run some code, so its current pc may','line_number':147,'multiline':False]['text':' not match its cache entry's pc. In this case, just treat it as a miss. No','line_number':148,'multiline':False]['text':' older frame has executed any code; it would have been necessary to pop','line_number':149,'multiline':False]['text':' this frame for that to happen, but this frame's bit is set.','line_number':150,'multiline':False]['text':' These are used only by the LiveSavedFrameCache and not used for identity or','line_number':227,'multiline':False]['text':' hashing.','line_number':228,'multiline':False]['text':' static ','line_number':277,'multiline':True]['text':' static ','line_number':282,'multiline':True]['text':' static ','line_number':287,'multiline':True]['text':' Assume that we can take line mod 2^32 without losing anything of','line_number':290,'multiline':False]['text':' interest.  If that assumption changes, we'll just need to start with 0','line_number':291,'multiline':False]['text':' and add another overload of AddToHash with more arguments.','line_number':292,'multiline':False]['text':' static ','line_number':299,'multiline':True]['text':' static ','line_number':337,'multiline':True]['text':' static ','line_number':342,'multiline':True]['text':' addProperty','line_number':349,'multiline':False]['text':' delProperty','line_number':350,'multiline':False]['text':' enumerate','line_number':351,'multiline':False]['text':' newEnumerate','line_number':352,'multiline':False]['text':' resolve','line_number':353,'multiline':False]['text':' mayResolve','line_number':354,'multiline':False]['text':' finalize','line_number':355,'multiline':False]['text':' call','line_number':356,'multiline':False]['text':' hasInstance','line_number':357,'multiline':False]['text':' construct','line_number':358,'multiline':False]['text':' trace','line_number':359,'multiline':False]['text':' static ','line_number':372,'multiline':True]['text':' static ','line_number':383,'multiline':True]['text':' static ','line_number':385,'multiline':True]['text':' static ','line_number':389,'multiline':True]['text':' static ','line_number':401,'multiline':True]['text':' Make sure any atoms used in the lookup are marked in the current zone.','line_number':522,'multiline':False]['text':' Normally we would try to keep these mark bits up to date around the','line_number':523,'multiline':False]['text':' points where the context moves between compartments, but Lookups live on','line_number':524,'multiline':False]['text':' the stack (where the atoms are kept alive regardless) and this is a','line_number':525,'multiline':False]['text':' more convenient pinchpoint.','line_number':526,'multiline':False]['text':' static ','line_number':547,'multiline':True]['text':' Ensure that we don't try to capture the stack again in the','line_number':552,'multiline':False]['text':' `SavedStacksMetadataBuilder` for this new SavedFrame object, and','line_number':553,'multiline':False]['text':' accidentally cause O(n^2) behavior.','line_number':554,'multiline':False]['text':' See WasmFrameIter::computeLine() comment.','line_number':573,'multiline':False]['text':' See WasmFrameIter::computeLine() comment.','line_number':578,'multiline':False]['text':' See WasmFrameIter::computeLine() comment.','line_number':584,'multiline':False]['text':' static ','line_number':589,'multiline':True]['text':' Handle SavedFrames that have been reconstructed from stacks in a heap','line_number':608,'multiline':False]['text':' snapshot.','line_number':609,'multiline':False]['text':' Return the first SavedFrame in the chain that starts with |frame| whose','line_number':620,'multiline':False]['text':' for which the given match function returns true. If there is no such frame,','line_number':621,'multiline':False]['text':' return nullptr. |skippedAsync| is set to true if any of the skipped frames','line_number':622,'multiline':False]['text':' had the |asyncCause| property set, otherwise it is explicitly set to false.','line_number':623,'multiline':False]['text':' Return the first SavedFrame in the chain that starts with |frame| whose','line_number':650,'multiline':False]['text':' principals are subsumed by |principals|, according to |subsumes|. If there is','line_number':651,'multiline':False]['text':' no such frame, return nullptr. |skippedAsync| is set to true if any of the','line_number':652,'multiline':False]['text':' skipped frames had the |asyncCause| property set, otherwise it is explicitly','line_number':653,'multiline':False]['text':' set to false.','line_number':654,'multiline':False]['text':' Now set "frame" to the actual object we were invoked in (which may be a','line_number':706,'multiline':False]['text':' wrapper), not the unwrapped version.  Consumers will need to know what','line_number':707,'multiline':False]['text':' that original object was, and will do principal checks as needed.','line_number':708,'multiline':False]['text':' Get the SavedFrame * from the current this value and handle any errors that','line_number':713,'multiline':False]['text':' might occur therein.','line_number':714,'multiline':False]['text':'','line_number':715,'multiline':False]['text':' These parameters must already exist when calling this macro:','line_number':716,'multiline':False]['text':'   - JSContext* cx','line_number':717,'multiline':False]['text':'   - unsigned   argc','line_number':718,'multiline':False]['text':'   - Value*     vp','line_number':719,'multiline':False]['text':'   - const char* fnName','line_number':720,'multiline':False]['text':' These parameters will be defined after calling this macro:','line_number':721,'multiline':False]['text':'   - CallArgs args','line_number':722,'multiline':False]['text':'   - Rooted<SavedFrame*> frame (will be non-null)','line_number':723,'multiline':False]['text':' namespace js ','line_number':729,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':752,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':776,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':795,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':815,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':835,'multiline':True]['text':' = SavedFrameSelfHosted::Include ','line_number':859,'multiline':True]['text':' This function is always called with self-hosted frames excluded by','line_number':866,'multiline':False]['text':' GetValueIfNotCached in dom/bindings/Exceptions.cpp. However, we want','line_number':867,'multiline':False]['text':' to include them because our Promise implementation causes us to have','line_number':868,'multiline':False]['text':' the async cause on a self-hosted frame. So we just ignore the','line_number':869,'multiline':False]['text':' parameter and always include self-hosted frames.','line_number':870,'multiline':False]['text':' = SavedFrameSelfHosted::Include ','line_number':892,'multiline':True]['text':' The current value of |skippedAsync| is not interesting, because we are','line_number':906,'multiline':False]['text':' interested in whether we would cross any async parents to get from here','line_number':907,'multiline':False]['text':' to the first subsumed parent frame instead.','line_number':908,'multiline':False]['text':' Even if |parent| is not subsumed, we still want to return a pointer to it','line_number':913,'multiline':False]['text':' rather than |subsumedParent| so it can pick up any |asyncCause| from the','line_number':914,'multiline':False]['text':' inaccessible part of the chain.','line_number':915,'multiline':False]['text':' = SavedFrameSelfHosted::Include ','line_number':927,'multiline':True]['text':' The current value of |skippedAsync| is not interesting, because we are','line_number':941,'multiline':False]['text':' interested in whether we would cross any async parents to get from here','line_number':942,'multiline':False]['text':' to the first subsumed parent frame instead.','line_number':943,'multiline':False]['text':' Even if |parent| is not subsumed, we still want to return a pointer to it','line_number':948,'multiline':False]['text':' rather than |subsumedParent| so it can pick up any |asyncCause| from the','line_number':949,'multiline':False]['text':' inaccessible part of the chain.','line_number':950,'multiline':False]['text':' See comment in WasmFrameIter::computeLine().','line_number':962,'multiline':False]['text':' See comment in WasmFrameIter::computeLine().','line_number':975,'multiline':False]['text':' Enter a new block to constrain the scope of possibly entering the stack's','line_number':1034,'multiline':False]['text':' realm. This ensures that when we finish the StringBuffer, we are back in','line_number':1035,'multiline':False]['text':' the cx's original compartment, and fulfill our contract with callers to','line_number':1036,'multiline':False]['text':' place the output string in the cx's current realm.','line_number':1037,'multiline':False]['text':' namespace JS ','line_number':1157,'multiline':True]['text':' static ','line_number':1161,'multiline':True]['text':' static ','line_number':1178,'multiline':True]['text':' static ','line_number':1192,'multiline':True]['text':' static ','line_number':1206,'multiline':True]['text':' static ','line_number':1220,'multiline':True]['text':' static ','line_number':1239,'multiline':True]['text':' static ','line_number':1257,'multiline':True]['text':' static ','line_number':1270,'multiline':True]['text':' static ','line_number':1283,'multiline':True]['text':' = JS::StackCapture(JS::AllFrames()) ','line_number':1297,'multiline':True]['text':' Given that we have captured a stack frame with the given principals and','line_number':1351,'multiline':False]['text':' source, return true if the requested `StackCapture` has been satisfied and','line_number':1352,'multiline':False]['text':' stack walking can halt. Return false otherwise (and stack walking and frame','line_number':1353,'multiline':False]['text':' capturing should continue).','line_number':1354,'multiline':False]['text':' In order to look up a cached SavedFrame object, we need to have its parent','line_number':1385,'multiline':False]['text':' SavedFrame, which means we need to walk the stack from oldest frame to','line_number':1386,'multiline':False]['text':' youngest. However, FrameIter walks the stack from youngest frame to','line_number':1387,'multiline':False]['text':' oldest. The solution is to append stack frames to a vector as we walk the','line_number':1388,'multiline':False]['text':' stack with FrameIter, and then do a second pass through that vector in','line_number':1389,'multiline':False]['text':' reverse order after the traversal has completed and get or create the','line_number':1390,'multiline':False]['text':' SavedFrame objects at that time.','line_number':1391,'multiline':False]['text':'','line_number':1392,'multiline':False]['text':' To avoid making many copies of FrameIter (whose copy constructor is','line_number':1393,'multiline':False]['text':' relatively slow), we use a vector of `SavedFrame::Lookup` objects, which','line_number':1394,'multiline':False]['text':' only contain the FrameIter data we need. The `SavedFrame::Lookup`','line_number':1395,'multiline':False]['text':' objects are partially initialized with everything except their parent','line_number':1396,'multiline':False]['text':' pointers on the first pass, and then we fill in the parent pointers as we','line_number':1397,'multiline':False]['text':' return in the second pass.','line_number':1398,'multiline':False]['text':' Accumulate the vector of Lookup objects here, youngest to oldest.','line_number':1400,'multiline':False]['text':' If we find a cached saved frame, then that supplies the parent of the','line_number':1403,'multiline':False]['text':' frames we have placed in stackChain. If we walk the stack all the way','line_number':1404,'multiline':False]['text':' to the end, this remains null.','line_number':1405,'multiline':False]['text':' Choose the right frame iteration strategy to accomodate both','line_number':1408,'multiline':False]['text':' evalInFramePrev links and the LiveSavedFrameCache. For background, see','line_number':1409,'multiline':False]['text':' the LiveSavedFrameCache comments in Stack.h.','line_number':1410,'multiline':False]['text':'','line_number':1411,'multiline':False]['text':' If we're using the LiveSavedFrameCache, then don't handle evalInFramePrev','line_number':1412,'multiline':False]['text':' links by skipping over the frames altogether; that violates the cache's','line_number':1413,'multiline':False]['text':' assumptions. Instead, traverse the entire stack, but choose each','line_number':1414,'multiline':False]['text':' SavedFrame's parent as directed by the evalInFramePrev link, if any.','line_number':1415,'multiline':False]['text':'','line_number':1416,'multiline':False]['text':' If we're not using the LiveSavedFrameCache, it's hard to recover the','line_number':1417,'multiline':False]['text':' frame to which the evalInFramePrev link refers, so we just let FrameIter','line_number':1418,'multiline':False]['text':' skip those frames. Then each SavedFrame's parent is simply the frame that','line_number':1419,'multiline':False]['text':' follows it in the stackChain vector, even when it has an evalInFramePrev','line_number':1420,'multiline':False]['text':' link.','line_number':1421,'multiline':False]['text':' Once we've seen one frame with its hasCachedSavedFrame bit set, all its','line_number':1426,'multiline':False]['text':' parents (that can be cached) ought to have it set too.','line_number':1427,'multiline':False]['text':' See the comment in Stack.h for why RematerializedFrames','line_number':1438,'multiline':False]['text':' are a special case here.','line_number':1439,'multiline':False]['text':' Even though iter.hasCachedSavedFrame() was true, we may still get a','line_number':1457,'multiline':False]['text':' cache miss, if the frame's pc doesn't match the cache entry's, or if','line_number':1458,'multiline':False]['text':' the cache was emptied due to a realm mismatch.','line_number':1459,'multiline':False]['text':' This frame doesn't have a cache entry, despite its hasCachedSavedFrame','line_number':1464,'multiline':False]['text':' flag being set. If this was due to a pc mismatch, we can clear the flag','line_number':1465,'multiline':False]['text':' here and set things right. If the cache was emptied due to a realm','line_number':1466,'multiline':False]['text':' mismatch, we should clear all the frames' flags as we walk to the','line_number':1467,'multiline':False]['text':' bottom of the stack, so that they are all clear before we start pushing','line_number':1468,'multiline':False]['text':' any new entries.','line_number':1469,'multiline':False]['text':' We'll be pushing this frame onto stackChain. Gather the information','line_number':1473,'multiline':False]['text':' needed to construct the SavedFrame::Lookup.','line_number':1474,'multiline':False]['text':' asyncCause','line_number':1490,'multiline':False]['text':' parent (not known yet)','line_number':1491,'multiline':False]['text':' If there were no cache hits in the entire activation, clear its','line_number':1506,'multiline':False]['text':' cache so we'll be able to push new ones when we build the','line_number':1507,'multiline':False]['text':' SavedFrame chain.','line_number':1508,'multiline':False]['text':' If we have crossed into a new activation, check whether the prior','line_number':1512,'multiline':False]['text':' activation had an async parent set.','line_number':1513,'multiline':False]['text':'','line_number':1514,'multiline':False]['text':' If the async call was explicit (async function resumptions, most','line_number':1515,'multiline':False]['text':' testing facilities), then the async parent stack has priority over','line_number':1516,'multiline':False]['text':' any actual frames still on the JavaScript stack. If the async call','line_number':1517,'multiline':False]['text':' was implicit (DOM CallbackObject::CallSetup calls), then the async','line_number':1518,'multiline':False]['text':' parent stack is used only if there were no other frames on the','line_number':1519,'multiline':False]['text':' stack.','line_number':1520,'multiline':False]['text':'','line_number':1521,'multiline':False]['text':' Captures using FirstSubsumedFrame expect us to ignore async parents.','line_number':1522,'multiline':False]['text':' Atomize the async cause string. There should only be a few','line_number':1526,'multiline':False]['text':' different strings used.','line_number':1527,'multiline':False]['text':' Translate our capture into a frame count limit for','line_number':1534,'multiline':False]['text':' adoptAsyncStack, which will impose further limits.','line_number':1535,'multiline':False]['text':' Clip the stack if needed, attach the async cause string to the','line_number':1542,'multiline':False]['text':' top frame, and copy it into our compartment if necessary.','line_number':1543,'multiline':False]['text':' In the case of a JS::AllFrames capture, we will be populating the','line_number':1550,'multiline':False]['text':' LiveSavedFrameCache in the second loop. In the case where there is','line_number':1551,'multiline':False]['text':' a debugger eval frame on the stack, the second loop will use','line_number':1552,'multiline':False]['text':' checkForEvalInFramePrev to skip from the eval frame to the "prev"','line_number':1553,'multiline':False]['text':' frame and assert that when this happens, the "prev"','line_number':1554,'multiline':False]['text':' frame is in the cache. In cases where there is an async stack','line_number':1555,'multiline':False]['text':' activation between the debugger eval frame and the "prev" frame,','line_number':1556,'multiline':False]['text':' breaking here would not populate the "prev" cache entry, causing','line_number':1557,'multiline':False]['text':' checkForEvalInFramePrev to fail.','line_number':1558,'multiline':False]['text':' Iterate through |stackChain| in reverse order and get or create the','line_number':1568,'multiline':False]['text':' actual SavedFrame instances.','line_number':1569,'multiline':False]['text':' The frame may already have an async parent frame set explicitly','line_number':1574,'multiline':False]['text':' on its activation.','line_number':1575,'multiline':False]['text':' If necessary, adjust the parent of a debugger eval frame to point to','line_number':1579,'multiline':False]['text':' the frame in whose scope the eval occurs - if we're using','line_number':1580,'multiline':False]['text':' LiveSavedFrameCache. Otherwise, we simply ask the FrameIter to follow','line_number':1581,'multiline':False]['text':' evalInFramePrev links, so that the parent is always the last frame we','line_number':1582,'multiline':False]['text':' created.','line_number':1583,'multiline':False]['text':' If maxFrameCount is Nothing, the caller asked for an unlimited number of','line_number':1614,'multiline':False]['text':' stack frames, but async stacks are not limited by the available stack','line_number':1615,'multiline':False]['text':' memory, so we need to set an arbitrary limit when collecting them. We','line_number':1616,'multiline':False]['text':' still don't enforce an upper limit if the caller requested more frames.','line_number':1617,'multiline':False]['text':' Turn the chain of frames starting with asyncStack into a vector of Lookup','line_number':1620,'multiline':False]['text':' objects in |stackChain|, youngest to oldest.','line_number':1621,'multiline':False]['text':' Attach the asyncCause to the youngest frame.','line_number':1633,'multiline':False]['text':' If we walked the entire stack, and it's in cx's realm, we don't','line_number':1636,'multiline':False]['text':' need to rebuild the full chain again using the lookup objects - we can','line_number':1637,'multiline':False]['text':' just use the existing chain. Only the asyncCause on the youngest frame','line_number':1638,'multiline':False]['text':' needs to be changed.','line_number':1639,'multiline':False]['text':' If we captured the maximum number of frames and the caller requested no','line_number':1647,'multiline':False]['text':' specific limit, we only return half of them. This means that if we do','line_number':1648,'multiline':False]['text':' many subsequent captures with the same async stack, it's likely we can','line_number':1649,'multiline':False]['text':' use the optimization above.','line_number':1650,'multiline':False]['text':' Iterate through |stackChain| in reverse order and get or create the','line_number':1655,'multiline':False]['text':' actual SavedFrame instances.','line_number':1656,'multiline':False]['text':' Given a |lookup| for which we're about to construct a SavedFrame, if it','line_number':1671,'multiline':False]['text':' refers to a Debugger eval frame, adjust |lookup|'s parent to be the frame's','line_number':1672,'multiline':False]['text':' evalInFramePrev target.','line_number':1673,'multiline':False]['text':'','line_number':1674,'multiline':False]['text':' Debugger eval frames run code in the scope of some random older frame on the','line_number':1675,'multiline':False]['text':' stack (the 'target' frame). It is our custom to report the target as the','line_number':1676,'multiline':False]['text':' immediate parent of the eval frame. The LiveSavedFrameCache requires us not','line_number':1677,'multiline':False]['text':' to skip frames, so instead we walk the entire stack, and just give Debugger','line_number':1678,'multiline':False]['text':' eval frames the right parents as we encounter them.','line_number':1679,'multiline':False]['text':'','line_number':1680,'multiline':False]['text':' Call this function only if we are using the LiveSavedFrameCache; otherwise,','line_number':1681,'multiline':False]['text':' FrameIter has already taken care of getting us the right parent.','line_number':1682,'multiline':False]['text':' If we're caching the frame to which |lookup| refers, then we should','line_number':1708,'multiline':False]['text':' definitely have the target frame in the cache as well.','line_number':1709,'multiline':False]['text':' Search the chain of activations for a LiveSavedFrameCache that has an','line_number':1712,'multiline':False]['text':' entry for target.','line_number':1713,'multiline':False]['text':' It's okay to force allocation of a cache here; we're about to put','line_number':1716,'multiline':False]['text':' something in the top cache, and all the lower ones should exist','line_number':1717,'multiline':False]['text':' already.','line_number':1718,'multiline':False]['text':' Since |target| has its cached bit set, we should have found it.','line_number':1730,'multiline':False]['text':' Because we use findWithoutInvalidation here, we can technically get a','line_number':1733,'multiline':False]['text':' SavedFrame here for any realm. That shouldn't happen here because','line_number':1734,'multiline':False]['text':' checkForEvalInFramePrev is only called _after_ the parent frames have','line_number':1735,'multiline':False]['text':' been constructed, but if something prevents the chain from being properly','line_number':1736,'multiline':False]['text':' reconstructed, that invariant could be accidentally broken.','line_number':1737,'multiline':False]['text':' We should only ever be caching location values for scripts in this','line_number':1782,'multiline':False]['text':' compartment. Otherwise, we would get dead cross-compartment scripts in','line_number':1783,'multiline':False]['text':' the cache because our compartment's sweep method isn't called when their','line_number':1784,'multiline':False]['text':' compartment gets collected.','line_number':1785,'multiline':False]['text':' When we have a |JSScript| for this frame, use a potentially memoized','line_number':1789,'multiline':False]['text':' location from our PCLocationMap and copy it into |locationp|. When we do','line_number':1790,'multiline':False]['text':' not have a |JSScript| for this frame (wasm frames), we take a slow path','line_number':1791,'multiline':False]['text':' that doesn't employ memoization, and update |locationp|'s slots directly.','line_number':1792,'multiline':False]['text':' Only asm.js has a displayURL.','line_number':1795,'multiline':False]['text':' See WasmFrameIter::computeLine() comment.','line_number':1806,'multiline':False]['text':' Make the column 1-based. See comment above.','line_number':1835,'multiline':False]['text':' The runtime is tracking allocations across all realms, in this case','line_number':1851,'multiline':False]['text':' ignore all of the debugger values, and use the runtime's probability.','line_number':1852,'multiline':False]['text':' Use unbarriered version to prevent triggering read barrier while','line_number':1858,'multiline':False]['text':' collecting, this is safe as long as global does not escape.','line_number':1859,'multiline':False]['text':' The following code translates the JS-specific information, into an','line_number':1907,'multiline':False]['text':' RecordAllocationInfo object that can be consumed outside of SpiderMonkey.','line_number':1908,'multiline':False]['text':' Pass the non-SpiderMonkey specific information back to the','line_number':1912,'multiline':False]['text':' callback to get it out of the JS engine.','line_number':1913,'multiline':False]['text':' static ','line_number':1927,'multiline':True]['text':' static ','line_number':1929,'multiline':True]['text':' As described in WasmFrameIter::computeLine(), for wasm frames, the','line_number':1944,'multiline':False]['text':' function index is returned as the column with the high bit set. In paths','line_number':1945,'multiline':False]['text':' that format error stacks into strings, this information can be used to','line_number':1946,'multiline':False]['text':' synthesize a proper wasm frame. But when raw column numbers are handed','line_number':1947,'multiline':False]['text':' out, we just fix them to 1 to avoid confusion.','line_number':1948,'multiline':False]['text':' XXX: Make the column 1-based as in other browsers, instead of 0-based','line_number':1953,'multiline':False]['text':' which is how SpiderMonkey stores it internally. This will be','line_number':1954,'multiline':False]['text':' unnecessary once bug 1144340 is fixed.','line_number':1955,'multiline':False]['text':' namespace js ','line_number':1959,'multiline':True]['text':' A `mozilla::Variant` matcher that converts the inner value of a','line_number':1981,'multiline':False]['text':' `JS::ubi::AtomOrTwoByteChars` string to a `JSAtom*`.','line_number':1982,'multiline':False]['text':' Convert the source and functionDisplayName strings to atoms.','line_number':2008,'multiline':False]['text':' asyncCause ','line_number':2034,'multiline':True]['text':' parent ','line_number':2035,'multiline':True]['text':' mutedErrors ','line_number':2036,'multiline':True]['text':' namespace ubi','line_number':2058,'multiline':False]['text':' namespace JS','line_number':2059,'multiline':False]