['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' for Some, Maybe','line_number':9,'multiline':False]['text':' for Span','line_number':10,'multiline':False]['text':' for Vector','line_number':11,'multiline':False]['text':' for ptrdiff_t','line_number':13,'multiline':False]['text':' for uint32_t, SIZE_MAX, int32_t','line_number':14,'multiline':False]['text':' for CallArgs, Rooted, CallArgsFromVp','line_number':16,'multiline':False]['text':' for ToNumber','line_number':17,'multiline':False]['text':' for CallArgs, RootedValue','line_number':18,'multiline':False]['text':' for NewDenseEmptyArray','line_number':20,'multiline':False]['text':' for DebuggerScriptReferent, Debugger','line_number':21,'multiline':False]['text':' for DebugScript','line_number':22,'multiline':False]['text':' for DebuggerSource','line_number':23,'multiline':False]['text':' for ImmutablePropertyNamePtr','line_number':24,'multiline':False]['text':' for MemoryUse, MemoryUse::Breakpoint','line_number':25,'multiline':False]['text':' for RootedDebuggerScript','line_number':26,'multiline':False]['text':' for TraceManuallyBarrieredCrossCompartmentEdge','line_number':27,'multiline':False]['text':' for Zone','line_number':28,'multiline':False]['text':' for AddCellMemory','line_number':29,'multiline':False]['text':' for GetErrorMessage, JSMSG_*','line_number':30,'multiline':False]['text':' for GCCellPtr','line_number':31,'multiline':False]['text':' for UncheckedUnwrap','line_number':32,'multiline':False]['text':' for ArrayObject','line_number':33,'multiline':False]['text':' for GET_JUMP_OFFSET','line_number':34,'multiline':False]['text':' for GlobalObject','line_number':35,'multiline':False]['text':' for JSContext, ReportValueError','line_number':36,'multiline':False]['text':' for JSFunction','line_number':37,'multiline':False]['text':' for RequireObject, JSObject','line_number':38,'multiline':False]['text':' for DefineDataProperty, HasOwnProperty','line_number':39,'multiline':False]['text':' for js::PlainObject','line_number':40,'multiline':False]['text':' for AutoRealm','line_number':41,'multiline':False]['text':' for JSAtomState, JSRuntime','line_number':42,'multiline':False]['text':' for NameToId, PropertyName, JSAtom','line_number':43,'multiline':False]['text':' for ExprLoc, DebugState','line_number':44,'multiline':False]['text':' for Instance','line_number':45,'multiline':False]['text':' for WasmInstanceObject','line_number':46,'multiline':False]['text':' for Bytes','line_number':47,'multiline':False]['text':' for BytecodeRangeWithPosition','line_number':49,'multiline':False]['text':' for ValueToId','line_number':50,'multiline':False]['text':' for NewBuiltinClassInstance, NewObjectWithGivenProto, NewTenuredObjectWithGivenProto','line_number':51,'multiline':False]['text':' for JSScript::global','line_number':52,'multiline':False]['text':' for GetProperty','line_number':53,'multiline':False]['text':' for AutoRealm::AutoRealm','line_number':54,'multiline':False]['text':' addProperty','line_number':62,'multiline':False]['text':' delProperty','line_number':63,'multiline':False]['text':' enumerate','line_number':64,'multiline':False]['text':' newEnumerate','line_number':65,'multiline':False]['text':' resolve','line_number':66,'multiline':False]['text':' mayResolve','line_number':67,'multiline':False]['text':' finalize','line_number':68,'multiline':False]['text':' call','line_number':69,'multiline':False]['text':' hasInstance','line_number':70,'multiline':False]['text':' construct','line_number':71,'multiline':False]['text':' trace','line_number':72,'multiline':False]['text':' This comes from a private pointer, so no barrier needed.','line_number':81,'multiline':False]['text':' static ','line_number':99,'multiline':True]['text':' static ','line_number':107,'multiline':True]['text':' JSFunction::getOrCreateScript requires an enclosing scope. This requires','line_number':131,'multiline':False]['text':' the enclosing script to be non-lazy.','line_number':132,'multiline':False]['text':' It didn't work! Delazifying the enclosing script still didn't','line_number':140,'multiline':False]['text':' delazify this script. This happens when the function','line_number':141,'multiline':False]['text':' corresponding to this script was removed by constant folding.','line_number':142,'multiline':False]['text':' static ','line_number':156,'multiline':True]['text':' Check for Debugger.Script.prototype, which is of class','line_number':171,'multiline':False]['text':' DebuggerScript::class.','line_number':172,'multiline':False]['text':' static ','line_number':257,'multiline':True]['text':' Ignore asm.js natives.','line_number':499,'multiline':False]['text':' If the function doesn't have script, ignore it.','line_number':507,'multiline':False]['text':' Ignore any delazification placeholder functions. These should not be','line_number':531,'multiline':False]['text':' exposed to debugger in any way.','line_number':532,'multiline':False]['text':' [minOffset, maxOffset) - Inclusive minimum and exclusive maximum.','line_number':608,'multiline':False]['text':' If no end column is given, we use the default of 0 and wrap to','line_number':784,'multiline':False]['text':' the next line.','line_number':785,'multiline':False]['text':' Second pass: build the result array.','line_number':852,'multiline':False]['text':'
 * FlowGraphSummary::populate(cx, script) computes a summary of script's
 * control flow graph used by DebuggerScript_{getAllOffsets,getLineOffsets}.
 *
 * An instruction on a given line is an entry point for that line if it can be
 * reached from (an instruction on) a different line. We distinguish between the
 * following cases:
 *   - hasNoEdges:
 *       The instruction cannot be reached, so the instruction is not an entry
 *       point for the line it is on.
 *   - hasSingleEdge:
 *       The instruction can be reached from a single line. If this line is
 *       different from the line the instruction is on, the instruction is an
 *       entry point for that line.
 *
 * Similarly, an instruction on a given position (line/column pair) is an
 * entry point for that position if it can be reached from (an instruction on) a
 * different position. Again, we distinguish between the following cases:
 *   - hasNoEdges:
 *       The instruction cannot be reached, so the instruction is not an entry
 *       point for the position it is on.
 *   - hasSingleEdge:
 *       The instruction can be reached from a single position. If this line is
 *       different from the position the instruction is on, the instruction is
 *       an entry point for that position.
 ','line_number':1053,'multiline':True]['text':' If we visit the branch target before we visit the','line_number':1139,'multiline':False]['text':' branch op itself, just reuse the previous location.','line_number':1140,'multiline':False]['text':' This is reasonable for the time being because this','line_number':1141,'multiline':False]['text':' situation can currently only arise from loop heads,','line_number':1142,'multiline':False]['text':' where this assumption holds.','line_number':1143,'multiline':False]['text':' As there is no literal incoming edge into the catch block, we','line_number':1175,'multiline':False]['text':' make a fake one by copying the JSOp::Try location, as-if this','line_number':1176,'multiline':False]['text':' was an incoming edge of the catch block. This is needed','line_number':1177,'multiline':False]['text':' because we only report offsets of entry points which have','line_number':1178,'multiline':False]['text':' valid incoming edges.','line_number':1179,'multiline':False]['text':' anonymous namespace ','line_number':1216,'multiline':True]['text':' Line numbers are only correctly defined on entry points. Thus looks','line_number':1256,'multiline':False]['text':' either for the next valid offset in the flowData, being the last entry','line_number':1257,'multiline':False]['text':' point flowing into the current offset, or for the next valid entry point.','line_number':1258,'multiline':False]['text':' If this is an entry point, take the line number associated with the entry','line_number':1265,'multiline':False]['text':' point, otherwise settle on the next instruction and take the incoming','line_number':1266,'multiline':False]['text':' edge position.','line_number':1267,'multiline':False]['text':' The same entry point test that is used by getAllColumnOffsets.','line_number':1289,'multiline':False]['text':' Return whether an opcode is considered effectful: it can have direct side','line_number':1359,'multiline':False]['text':' effects that can be observed outside of the current frame. Opcodes are not','line_number':1360,'multiline':False]['text':' effectful if they only modify the current frame's state, modify objects','line_number':1361,'multiline':False]['text':' created by the current frame, or can potentially call other scripts or','line_number':1362,'multiline':False]['text':' natives which could have side effects.','line_number':1363,'multiline':False]['text':' Treat async functions as effectful so that microtask checkpoints','line_number':1392,'multiline':False]['text':' won't run.','line_number':1393,'multiline':False]['text':' First pass: determine which offsets in this script are jump targets and','line_number':1630,'multiline':False]['text':' which line numbers jump to them.','line_number':1631,'multiline':False]['text':' Second pass: build the result array.','line_number':1637,'multiline':False]['text':' Make a note, if the current instruction is an entry point for the current','line_number':1650,'multiline':False]['text':' line.','line_number':1651,'multiline':False]['text':' Get the offsets array for this line.','line_number':1653,'multiline':False]['text':' Create an empty offsets array for this line.','line_number':1672,'multiline':False]['text':' Store it in the result array.','line_number':1673,'multiline':False]['text':' Append the current offset to the offsets array.','line_number':1687,'multiline':False]['text':' First pass: determine which offsets in this script are jump targets','line_number':1736,'multiline':False]['text':' and which positions jump to them.','line_number':1737,'multiline':False]['text':' Second pass: build the result array.','line_number':1743,'multiline':False]['text':' Make a note, if the current instruction is an entry point for','line_number':1754,'multiline':False]['text':' the current position.','line_number':1755,'multiline':False]['text':' First pass: determine which offsets in this script are jump targets and','line_number':1819,'multiline':False]['text':' which line numbers jump to them.','line_number':1820,'multiline':False]['text':' Second pass: build the result array.','line_number':1831,'multiline':False]['text':' If the op at offset is an entry point, append offset to result.','line_number':1839,'multiline':False]['text':' Parse lineno argument.','line_number':1878,'multiline':False]['text':' If the Debugger's compartment has killed incoming wrappers, we may not','line_number':1917,'multiline':False]['text':' have gotten usable results from the 'wrap' calls. Treat it as a','line_number':1918,'multiline':False]['text':' failure.','line_number':1919,'multiline':False]['text':' Ensure observability *before* setting the breakpoint. If the script is','line_number':1955,'multiline':False]['text':' not already a debuggee, trying to ensure observability after setting','line_number':1956,'multiline':False]['text':' the breakpoint (and thus marking the script as a debuggee) will skip','line_number':1957,'multiline':False]['text':' actually ensuring observability.','line_number':1958,'multiline':False]['text':' A Breakpoint belongs logically to its script's compartment, so its','line_number':1963,'multiline':False]['text':' references to its Debugger and handler must be properly wrapped.','line_number':1964,'multiline':False]['text':' A Breakpoint belongs logically to its Instance's compartment, so its','line_number':1994,'multiline':False]['text':' references to its Debugger and handler must be properly wrapped.','line_number':1995,'multiline':False]['text':' A Breakpoint belongs logically to its script's compartment, so it holds','line_number':2102,'multiline':False]['text':' its handler via a cross-compartment wrapper. But the handler passed to','line_number':2103,'multiline':False]['text':' `clearBreakpoint` is same-compartment with the Debugger. Wrap it here,','line_number':2104,'multiline':False]['text':' so that `DebugScript::clearBreakpointsIn` gets the right value to','line_number':2105,'multiline':False]['text':' search for.','line_number':2106,'multiline':False]['text':' A Breakpoint belongs logically to its instance's compartment, so it','line_number':2122,'multiline':False]['text':' holds its handler via a cross-compartment wrapper. But the handler','line_number':2123,'multiline':False]['text':' passed to `clearBreakpoint` is same-compartment with the Debugger. Wrap','line_number':2124,'multiline':False]['text':' it here, so that `DebugState::clearBreakpointsIn` gets the right value','line_number':2125,'multiline':False]['text':' to search for.','line_number':2126,'multiline':False]['text':' If the script has no coverage information, then skip this and return null','line_number':2230,'multiline':False]['text':' instead.','line_number':2231,'multiline':False]['text':' If the main ever got visited, then assume that any code before main got','line_number':2239,'multiline':False]['text':' visited once.','line_number':2240,'multiline':False]['text':' Build an array of objects which are composed of 4 properties:','line_number':2248,'multiline':False]['text':'  - offset          PC offset of the current opcode.','line_number':2249,'multiline':False]['text':'  - lineNumber      Line of the current opcode.','line_number':2250,'multiline':False]['text':'  - columnNumber    Column of the current opcode.','line_number':2251,'multiline':False]['text':'  - count           Number of times the instruction got executed.','line_number':2252,'multiline':False]['text':' Iterate linearly over the bytecode.','line_number':2269,'multiline':False]['text':' The beginning of each non-branching sequences of instruction set the','line_number':2273,'multiline':False]['text':' number of execution of the current instruction and any following','line_number':2274,'multiline':False]['text':' instruction.','line_number':2275,'multiline':False]['text':' Create a new object with the offset, line number, column number, the','line_number':2286,'multiline':False]['text':' number of hit counts, and append it to the array.','line_number':2287,'multiline':False]['text':' If the current instruction has thrown, then decrement the hit counts','line_number':2297,'multiline':False]['text':' with the number of throws.','line_number':2298,'multiline':False]['text':' static ','line_number':2309,'multiline':True]['text':' The following APIs are deprecated due to their reliance on the','line_number':2349,'multiline':False]['text':' under-defined 'entrypoint' concept. Make use of getPossibleBreakpoints,','line_number':2350,'multiline':False]['text':' getPossibleBreakpointOffsets, or getOffsetMetadata instead.','line_number':2351,'multiline':False]