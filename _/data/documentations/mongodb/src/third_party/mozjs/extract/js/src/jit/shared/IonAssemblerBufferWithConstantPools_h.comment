['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' [SMDOC] JIT AssemblerBuffer constant pooling (ARM/ARM64/MIPS)','line_number':18,'multiline':False]['text':'','line_number':19,'multiline':False]['text':' This code extends the AssemblerBuffer to support the pooling of values loaded','line_number':20,'multiline':False]['text':' using program-counter relative addressing modes. This is necessary with the','line_number':21,'multiline':False]['text':' ARM instruction set because it has a fixed instruction size that can not','line_number':22,'multiline':False]['text':' encode all values as immediate arguments in instructions. Pooling the values','line_number':23,'multiline':False]['text':' allows the values to be placed in large chunks which minimizes the number of','line_number':24,'multiline':False]['text':' forced branches around them in the code. This is used for loading floating','line_number':25,'multiline':False]['text':' point constants, for loading 32 bit constants on the ARMv6, for absolute','line_number':26,'multiline':False]['text':' branch targets, and in future will be needed for large branches on the ARMv6.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' For simplicity of the implementation, the constant pools are always placed','line_number':29,'multiline':False]['text':' after the loads referencing them. When a new constant pool load is added to','line_number':30,'multiline':False]['text':' the assembler buffer, a corresponding pool entry is added to the current','line_number':31,'multiline':False]['text':' pending pool. The finishPool() method copies the current pending pool entries','line_number':32,'multiline':False]['text':' into the assembler buffer at the current offset and patches the pending','line_number':33,'multiline':False]['text':' constant pool load instructions.','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' Before inserting instructions or pool entries, it is necessary to determine','line_number':36,'multiline':False]['text':' if doing so would place a pending pool entry out of reach of an instruction,','line_number':37,'multiline':False]['text':' and if so then the pool must firstly be dumped. With the allocation algorithm','line_number':38,'multiline':False]['text':' used below, the recalculation of all the distances between instructions and','line_number':39,'multiline':False]['text':' their pool entries can be avoided by noting that there will be a limiting','line_number':40,'multiline':False]['text':' instruction and pool entry pair that does not change when inserting more','line_number':41,'multiline':False]['text':' instructions. Adding more instructions makes the same increase to the','line_number':42,'multiline':False]['text':' distance, between instructions and their pool entries, for all such','line_number':43,'multiline':False]['text':' pairs. This pair is recorded as the limiter, and it is updated when new pool','line_number':44,'multiline':False]['text':' entries are added, see updateLimiter()','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' The pools consist of: a guard instruction that branches around the pool, a','line_number':47,'multiline':False]['text':' header word that helps identify a pool in the instruction stream, and then','line_number':48,'multiline':False]['text':' the pool entries allocated in units of words. The guard instruction could be','line_number':49,'multiline':False]['text':' omitted if control does not reach the pool, and this is referred to as a','line_number':50,'multiline':False]['text':' natural guard below, but for simplicity the guard branch is always','line_number':51,'multiline':False]['text':' emitted. The pool header is an identifiable word that in combination with the','line_number':52,'multiline':False]['text':' guard uniquely identifies a pool in the instruction stream. The header also','line_number':53,'multiline':False]['text':' encodes the pool size and a flag indicating if the guard is natural. It is','line_number':54,'multiline':False]['text':' possible to iterate through the code instructions skipping or examining the','line_number':55,'multiline':False]['text':' pools. E.g. it might be necessary to skip pools when search for, or patching,','line_number':56,'multiline':False]['text':' an instruction sequence.','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':' It is often required to keep a reference to a pool entry, to patch it after','line_number':59,'multiline':False]['text':' the buffer is finished. Each pool entry is assigned a unique index, counting','line_number':60,'multiline':False]['text':' up from zero (see the poolEntryCount slot below). These can be mapped back to','line_number':61,'multiline':False]['text':' the offset of the pool entry in the finished buffer, see poolEntryOffset().','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':' The code supports no-pool regions, and for these the size of the region, in','line_number':64,'multiline':False]['text':' instructions, must be supplied. This size is used to determine if inserting','line_number':65,'multiline':False]['text':' the instructions would place a pool entry out of range, and if so then a pool','line_number':66,'multiline':False]['text':' is firstly flushed. The DEBUG code checks that the emitted code is within the','line_number':67,'multiline':False]['text':' supplied size to detect programming errors. See enterNoPool() and','line_number':68,'multiline':False]['text':' leaveNoPool().','line_number':69,'multiline':False]['text':' The only planned instruction sets that require inline constant pools are the','line_number':71,'multiline':False]['text':' ARM, ARM64, and MIPS, and these all have fixed 32-bit sized instructions so','line_number':72,'multiline':False]['text':' for simplicity the code below is specialized for fixed 32-bit sized','line_number':73,'multiline':False]['text':' instructions and makes no attempt to support variable length','line_number':74,'multiline':False]['text':' instructions. The base assembler buffer which supports variable width','line_number':75,'multiline':False]['text':' instruction is used by the x86 and x64 backends.','line_number':76,'multiline':False]['text':' The AssemblerBufferWithConstantPools template class uses static callbacks to','line_number':78,'multiline':False]['text':' the provided Asm template argument class:','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' void Asm::InsertIndexIntoTag(uint8_t* load_, uint32_t index)','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':'   When allocEntry() is called to add a constant pool load with an associated','line_number':83,'multiline':False]['text':'   constant pool entry, this callback is called to encode the index of the','line_number':84,'multiline':False]['text':'   allocated constant pool entry into the load instruction.','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':'   After the constant pool has been placed, PatchConstantPoolLoad() is called','line_number':87,'multiline':False]['text':'   to update the load instruction with the right load offset.','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':' void Asm::WritePoolGuard(BufferOffset branch,','line_number':90,'multiline':False]['text':'                          Instruction* dest,','line_number':91,'multiline':False]['text':'                          BufferOffset afterPool)','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':'   Write out the constant pool guard branch before emitting the pool.','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':'   branch','line_number':96,'multiline':False]['text':'     Offset of the guard branch in the buffer.','line_number':97,'multiline':False]['text':'','line_number':98,'multiline':False]['text':'   dest','line_number':99,'multiline':False]['text':'     Pointer into the buffer where the guard branch should be emitted. (Same','line_number':100,'multiline':False]['text':'     as getInst(branch)). Space for guardSize_ instructions has been reserved.','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':'   afterPool','line_number':103,'multiline':False]['text':'     Offset of the first instruction after the constant pool. This includes','line_number':104,'multiline':False]['text':'     both pool entries and branch veneers added after the pool data.','line_number':105,'multiline':False]['text':'','line_number':106,'multiline':False]['text':' void Asm::WritePoolHeader(uint8_t* start, Pool* p, bool isNatural)','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':'   Write out the pool header which follows the guard branch.','line_number':109,'multiline':False]['text':'','line_number':110,'multiline':False]['text':' void Asm::PatchConstantPoolLoad(void* loadAddr, void* constPoolAddr)','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':'   Re-encode a load of a constant pool entry after the location of the','line_number':113,'multiline':False]['text':'   constant pool is known.','line_number':114,'multiline':False]['text':'','line_number':115,'multiline':False]['text':'   The load instruction at loadAddr was previously passed to','line_number':116,'multiline':False]['text':'   InsertIndexIntoTag(). The constPoolAddr is the final address of the','line_number':117,'multiline':False]['text':'   constant pool in the assembler buffer.','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' void Asm::PatchShortRangeBranchToVeneer(AssemblerBufferWithConstantPools*,','line_number':120,'multiline':False]['text':'                                         unsigned rangeIdx,','line_number':121,'multiline':False]['text':'                                         BufferOffset deadline,','line_number':122,'multiline':False]['text':'                                         BufferOffset veneer)','line_number':123,'multiline':False]['text':'','line_number':124,'multiline':False]['text':'   Patch a short-range branch to jump through a veneer before it goes out of','line_number':125,'multiline':False]['text':'   range.','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':'   rangeIdx, deadline','line_number':128,'multiline':False]['text':'     These arguments were previously passed to registerBranchDeadline(). It is','line_number':129,'multiline':False]['text':'     assumed that PatchShortRangeBranchToVeneer() knows how to compute the','line_number':130,'multiline':False]['text':'     offset of the short-range branch from this information.','line_number':131,'multiline':False]['text':'','line_number':132,'multiline':False]['text':'   veneer','line_number':133,'multiline':False]['text':'     Space for a branch veneer, guaranteed to be <= deadline. At this','line_number':134,'multiline':False]['text':'     position, guardSize_ * InstSize bytes are allocated. They should be','line_number':135,'multiline':False]['text':'     initialized to the proper unconditional branch instruction.','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':'   Unbound branches to the same unbound label are organized as a linked list:','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':'     Label::offset -> Branch1 -> Branch2 -> Branch3 -> nil','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':'   This callback should insert a new veneer branch into the list:','line_number':142,'multiline':False]['text':'','line_number':143,'multiline':False]['text':'     Label::offset -> Branch1 -> Branch2 -> Veneer -> Branch3 -> nil','line_number':144,'multiline':False]['text':'','line_number':145,'multiline':False]['text':'   When Assembler::bind() rewrites the branches with the real label offset, it','line_number':146,'multiline':False]['text':'   probably has to bind Branch2 to target the veneer branch instead of jumping','line_number':147,'multiline':False]['text':'   straight to the label.','line_number':148,'multiline':False]['text':' BranchDeadlineSet - Keep track of pending branch deadlines.','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' Some architectures like arm and arm64 have branch instructions with limited','line_number':155,'multiline':False]['text':' range. When assembling a forward branch, it is not always known if the final','line_number':156,'multiline':False]['text':' target label will be in range of the branch instruction.','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':' The BranchDeadlineSet data structure is used to keep track of the set of','line_number':159,'multiline':False]['text':' pending forward branches. It supports the following fast operations:','line_number':160,'multiline':False]['text':'','line_number':161,'multiline':False]['text':' 1. Get the earliest deadline in the set.','line_number':162,'multiline':False]['text':' 2. Add a new branch deadline.','line_number':163,'multiline':False]['text':' 3. Remove a branch deadline.','line_number':164,'multiline':False]['text':'','line_number':165,'multiline':False]['text':' Architectures may have different branch encodings with different ranges. Each','line_number':166,'multiline':False]['text':' supported range is assigned a small integer starting at 0. This data','line_number':167,'multiline':False]['text':' structure does not care about the actual range of branch instructions, just','line_number':168,'multiline':False]['text':' the latest buffer offset that can be reached - the deadline offset.','line_number':169,'multiline':False]['text':'','line_number':170,'multiline':False]['text':' Branched are stored as (rangeIdx, deadline) tuples. The target-specific code','line_number':171,'multiline':False]['text':' can compute the location of the branch itself from this information. This','line_number':172,'multiline':False]['text':' data structure does not need to know.','line_number':173,'multiline':False]['text':'','line_number':174,'multiline':False]['text':' Maintain a list of pending deadlines for each range separately.','line_number':177,'multiline':False]['text':'','line_number':178,'multiline':False]['text':' The offsets in each vector are always kept in ascending order.','line_number':179,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' Because we have a separate vector for different ranges, as forward','line_number':181,'multiline':False]['text':' branches are added to the assembler buffer, their deadlines will','line_number':182,'multiline':False]['text':' always be appended to the vector corresponding to their range.','line_number':183,'multiline':False]['text':'','line_number':184,'multiline':False]['text':' When binding labels, we expect a more-or-less LIFO order of branch','line_number':185,'multiline':False]['text':' resolutions. This would always hold if we had strictly structured control','line_number':186,'multiline':False]['text':' flow.','line_number':187,'multiline':False]['text':'','line_number':188,'multiline':False]['text':' We allow branch deadlines to be added and removed in any order, but','line_number':189,'multiline':False]['text':' performance is best in the expected case of near LIFO order.','line_number':190,'multiline':False]['text':'','line_number':191,'multiline':False]['text':' We really just want "RangeVector deadline_[NumRanges];", but each vector','line_number':194,'multiline':False]['text':' needs to be initialized with a LifoAlloc, and C++ doesn't bend that way.','line_number':195,'multiline':False]['text':'','line_number':196,'multiline':False]['text':' Use raw aligned storage instead and explicitly construct NumRanges','line_number':197,'multiline':False]['text':' vectors in our constructor.','line_number':198,'multiline':False]['text':' Always access the range vectors through this method.','line_number':201,'multiline':False]['text':' Maintain a precomputed earliest deadline at all times.','line_number':212,'multiline':False]['text':' This is unassigned only when all deadline vectors are empty.','line_number':213,'multiline':False]['text':' The range vector owning earliest_. Uninitialized when empty.','line_number':216,'multiline':False]['text':' Recompute the earliest deadline after it's been invalidated.','line_number':219,'multiline':False]['text':' Update the earliest deadline if needed after inserting (rangeIdx,','line_number':231,'multiline':False]['text':' deadline). Always return true for convenience:','line_number':232,'multiline':False]['text':' return insert() && updateEarliest().','line_number':233,'multiline':False]['text':' Manually construct vectors in the uninitialized aligned storage.','line_number':244,'multiline':False]['text':' This is because C++ arrays can otherwise only be constructed with','line_number':245,'multiline':False]['text':' the default constructor.','line_number':246,'multiline':False]['text':' Aligned storage doesn't destruct its contents automatically.','line_number':253,'multiline':False]['text':' Is this set completely empty?','line_number':259,'multiline':False]['text':' Get the total number of deadlines in the set.','line_number':262,'multiline':False]['text':' Get the number of deadlines for the range with the most elements.','line_number':271,'multiline':False]['text':' Get the first deadline that is still in the set.','line_number':280,'multiline':False]['text':' Get the range index corresponding to earliestDeadlineRange().','line_number':286,'multiline':False]['text':' Add a (rangeIdx, deadline) tuple to the set.','line_number':292,'multiline':False]['text':'','line_number':293,'multiline':False]['text':' It is assumed that this tuple is not already in the set.','line_number':294,'multiline':False]['text':' This function performs best id the added deadline is later than any','line_number':295,'multiline':False]['text':' existing deadline for the same range index.','line_number':296,'multiline':False]['text':'','line_number':297,'multiline':False]['text':' Return true if the tuple was added, false if the tuple could not be added','line_number':298,'multiline':False]['text':' because of an OOM error.','line_number':299,'multiline':False]['text':' This is the vector where deadline should be saved.','line_number':302,'multiline':False]['text':' Fast case: Simple append to the relevant array. This never affects','line_number':305,'multiline':False]['text':' the earliest deadline.','line_number':306,'multiline':False]['text':' Fast case: First entry to the vector. We need to update earliest_.','line_number':311,'multiline':False]['text':' General case of addDeadline. This is split into two functions such that','line_number':320,'multiline':False]['text':' the common case in addDeadline can be inlined while this part probably','line_number':321,'multiline':False]['text':' won't inline.','line_number':322,'multiline':False]['text':' Inserting into the middle of the vector. Use a log time binary search','line_number':326,'multiline':False]['text':' and a linear time insert().','line_number':327,'multiline':False]['text':' Is it worthwhile special-casing the empty vector?','line_number':328,'multiline':False]['text':' Remove a deadline from the set.','line_number':336,'multiline':False]['text':' If (rangeIdx, deadline) is not in the set, nothing happens.','line_number':337,'multiline':False]['text':' Expected fast case: Structured control flow causes forward','line_number':346,'multiline':False]['text':' branches to be bound in reverse order.','line_number':347,'multiline':False]['text':' Slow case: Binary search + linear erase.','line_number':350,'multiline':False]['text':' Specialization for architectures that don't need to track short-range','line_number':363,'multiline':False]['text':' branches.','line_number':364,'multiline':False]['text':' The allocation unit size for pools.','line_number':378,'multiline':False]['text':' Hysteresis given to short-range branches.','line_number':381,'multiline':False]['text':'','line_number':382,'multiline':False]['text':' If any short-range branches will go out of range in the next N bytes,','line_number':383,'multiline':False]['text':' generate a veneer for them in the current pool. The hysteresis prevents the','line_number':384,'multiline':False]['text':' creation of many tiny constant pools for branch veneers.','line_number':385,'multiline':False]['text':' The maximum program-counter relative offset below which the instruction','line_number':390,'multiline':False]['text':' set can encode. Different classes of intructions might support different','line_number':391,'multiline':False]['text':' ranges but for simplicity the minimum is used here, and for the ARM this','line_number':392,'multiline':False]['text':' is constrained to 1024 by the float load instructions.','line_number':393,'multiline':False]['text':' An offset to apply to program-counter relative offsets. The ARM has a','line_number':395,'multiline':False]['text':' bias of 8.','line_number':396,'multiline':False]['text':' The content of the pool entries.','line_number':399,'multiline':False]['text':' Flag that tracks OOM conditions. This is set after any append failed.','line_number':402,'multiline':False]['text':' The limiting instruction and pool-entry pair. The instruction program','line_number':405,'multiline':False]['text':' counter relative offset of this limiting instruction will go out of range','line_number':406,'multiline':False]['text':' first as the pool position moves forward. It is more efficient to track','line_number':407,'multiline':False]['text':' just this limiting pair than to recheck all offsets when testing if the','line_number':408,'multiline':False]['text':' pool needs to be dumped.','line_number':409,'multiline':False]['text':'','line_number':410,'multiline':False]['text':' 1. The actual offset of the limiting instruction referencing the limiting','line_number':411,'multiline':False]['text':' pool entry.','line_number':412,'multiline':False]['text':' 2. The pool entry index of the limiting pool entry.','line_number':414,'multiline':False]['text':' A record of the code offset of instructions that reference pool','line_number':418,'multiline':False]['text':' entries. These instructions need to be patched when the actual position','line_number':419,'multiline':False]['text':' of the instructions and pools are known, and for the code below this','line_number':420,'multiline':False]['text':' occurs when each pool is finished, see finishPool().','line_number':421,'multiline':False]['text':' Create a Pool. Don't allocate anything from lifoAloc, just capture its','line_number':424,'multiline':False]['text':' reference.','line_number':425,'multiline':False]['text':' If poolData() returns nullptr then oom_ will also be true.','line_number':435,'multiline':False]['text':' Update the instruction/pool-entry pair that limits the position of the','line_number':444,'multiline':False]['text':' pool. The nextInst is the actual offset of the new instruction being','line_number':445,'multiline':False]['text':' allocated.','line_number':446,'multiline':False]['text':'','line_number':447,'multiline':False]['text':' This is comparing the offsets, see checkFull() below for the equation,','line_number':448,'multiline':False]['text':' but common expressions on both sides have been canceled from the ranges','line_number':449,'multiline':False]['text':' being compared. Notably, the poolOffset cancels out, so the limiting pair','line_number':450,'multiline':False]['text':' does not depend on where the pool is placed.','line_number':451,'multiline':False]['text':' We have a new largest range!','line_number':457,'multiline':False]['text':' Check if inserting a pool at the actual offset poolOffset would place','line_number':463,'multiline':False]['text':' pool entries out of reach. This is called before inserting instructions','line_number':464,'multiline':False]['text':' to check that doing so would not push pool entries out of reach, and if','line_number':465,'multiline':False]['text':' so then the pool would need to be firstly dumped. The poolOffset is the','line_number':466,'multiline':False]['text':' first word of the pool, after the guard and header and alignment fill.','line_number':467,'multiline':False]['text':' Not full if there are no uses.','line_number':469,'multiline':False]['text':' Template arguments:','line_number':503,'multiline':False]['text':'','line_number':504,'multiline':False]['text':' SliceSize','line_number':505,'multiline':False]['text':'   Number of bytes in each allocated BufferSlice. See','line_number':506,'multiline':False]['text':'   AssemblerBuffer::SliceSize.','line_number':507,'multiline':False]['text':'','line_number':508,'multiline':False]['text':' InstSize','line_number':509,'multiline':False]['text':'   Size in bytes of the fixed-size instructions. This should be equal to','line_number':510,'multiline':False]['text':'   sizeof(Inst). This is only needed here because the buffer is defined before','line_number':511,'multiline':False]['text':'   the Instruction.','line_number':512,'multiline':False]['text':'','line_number':513,'multiline':False]['text':' Inst','line_number':514,'multiline':False]['text':'   The actual type used to represent instructions. This is only really used as','line_number':515,'multiline':False]['text':'   the return type of the getInst() method.','line_number':516,'multiline':False]['text':'','line_number':517,'multiline':False]['text':' Asm','line_number':518,'multiline':False]['text':'   Class defining the needed static callback functions. See documentation of','line_number':519,'multiline':False]['text':'   the Asm::* callbacks above.','line_number':520,'multiline':False]['text':'','line_number':521,'multiline':False]['text':' NumShortBranchRanges','line_number':522,'multiline':False]['text':'   The number of short branch ranges to support. This can be 0 if no support','line_number':523,'multiline':False]['text':'   for tracking short range branches is needed. The','line_number':524,'multiline':False]['text':'   AssemblerBufferWithConstantPools class does not need to know what the range','line_number':525,'multiline':False]['text':'   of branches is - it deals in branch 'deadlines' which is the last buffer','line_number':526,'multiline':False]['text':'   position that a short-range forward branch can reach. It is assumed that','line_number':527,'multiline':False]['text':'   the Asm class is able to find the actual branch instruction given a','line_number':528,'multiline':False]['text':'   (range-index, deadline) pair.','line_number':529,'multiline':False]['text':'','line_number':530,'multiline':False]['text':'','line_number':531,'multiline':False]['text':' The PoolEntry index counter. Each PoolEntry is given a unique index,','line_number':537,'multiline':False]['text':' counting up from zero, and these can be mapped back to the actual pool','line_number':538,'multiline':False]['text':' entry offset after finishing the buffer, see poolEntryOffset().','line_number':539,'multiline':False]['text':' The size of a pool guard, in instructions. A branch around the pool.','line_number':558,'multiline':False]['text':' The size of the header that is put at the beginning of a full pool, in','line_number':560,'multiline':False]['text':' instruction sized units.','line_number':561,'multiline':False]['text':' The maximum pc relative offset encoded in instructions that reference','line_number':564,'multiline':False]['text':' pool entries. This is generally set to the maximum offset that can be','line_number':565,'multiline':False]['text':' encoded by the instructions, but for testing can be lowered to affect the','line_number':566,'multiline':False]['text':' pool placement and frequency of pool placement.','line_number':567,'multiline':False]['text':' The bias on pc relative addressing mode offsets, in units of bytes. The','line_number':570,'multiline':False]['text':' ARM has a bias of 8 bytes.','line_number':571,'multiline':False]['text':' The current working pool. Copied out as needed before resetting.','line_number':574,'multiline':False]['text':' The buffer should be aligned to this address.','line_number':577,'multiline':False]['text':' The index of the first entry in this pool.','line_number':581,'multiline':False]['text':' Pool entries are numbered uniquely across all pools, starting from 0.','line_number':582,'multiline':False]['text':' The location of this pool's first entry in the main assembler buffer.','line_number':585,'multiline':False]['text':' Note that the pool guard and header come before this offset which','line_number':586,'multiline':False]['text':' points directly at the data.','line_number':587,'multiline':False]['text':' Info for each pool that has already been dumped. This does not include','line_number':594,'multiline':False]['text':' any entries in pool_.','line_number':595,'multiline':False]['text':' Set of short-range forward branches that have not yet been bound.','line_number':598,'multiline':False]['text':' We may need to insert veneers if the final label turns out to be out of','line_number':599,'multiline':False]['text':' range.','line_number':600,'multiline':False]['text':'','line_number':601,'multiline':False]['text':' This set stores (rangeIdx, deadline) pairs instead of the actual branch','line_number':602,'multiline':False]['text':' locations.','line_number':603,'multiline':False]['text':' When true dumping pools is inhibited.','line_number':606,'multiline':False]['text':' State for validating the 'maxInst' argument to enterNoPool().','line_number':610,'multiline':False]['text':' The buffer offset when entering the no-pool region.','line_number':611,'multiline':False]['text':' The maximum number of word sized instructions declared for the no-pool','line_number':613,'multiline':False]['text':' region.','line_number':614,'multiline':False]['text':' Instruction to use for alignment fill.','line_number':618,'multiline':False]['text':' Insert a number of NOP instructions between each requested instruction at','line_number':621,'multiline':False]['text':' all locations at which a pool can potentially spill. This is useful for','line_number':622,'multiline':False]['text':' checking that instruction locations are correctly referenced and/or','line_number':623,'multiline':False]['text':' followed.','line_number':624,'multiline':False]['text':' For inhibiting the insertion of fill NOPs in the dynamic context in which','line_number':628,'multiline':False]['text':' they are being inserted.','line_number':629,'multiline':False]['text':' A unique id within each JitContext, to identify pools in the debug','line_number':633,'multiline':False]['text':' spew. Set by the MacroAssembler, see getNextAssemblerId().','line_number':634,'multiline':False]['text':' The buffer slices are in a double linked list.','line_number':638,'multiline':False]['text':' Create an assembler buffer.','line_number':643,'multiline':False]['text':' Note that this constructor is not allowed to actually allocate memory from','line_number':644,'multiline':False]['text':' this->lifoAlloc_ because the MacroAssembler constructor has not yet created','line_number':645,'multiline':False]['text':' an AutoJitContextAlloc.','line_number':646,'multiline':False]['text':' We need to wait until an AutoJitContextAlloc is created by the','line_number':672,'multiline':False]['text':' MacroAssembler before allocating any space.','line_number':673,'multiline':False]['text':' We hand out references to lifoAlloc_ in the constructor.','line_number':675,'multiline':False]['text':' Check that no allocations were made then.','line_number':676,'multiline':False]['text':' Return the actual size of the buffer, excluding the current pending','line_number':683,'multiline':False]['text':' pool.','line_number':684,'multiline':False]['text':' Return the current actual size of the buffer. This is only accurate','line_number':690,'multiline':False]['text':' if there are no pending pool entries to dump, check.','line_number':691,'multiline':False]['text':' Insert fill for testing.','line_number':698,'multiline':False]['text':' Fill using a branch-nop rather than a NOP so this can be','line_number':702,'multiline':False]['text':' distinguished and skipped.','line_number':703,'multiline':False]['text':' Check if it is possible to add numInst instructions and numPoolEntries','line_number':715,'multiline':False]['text':' constant pool entries without needing to flush the current pool.','line_number':716,'multiline':False]['text':' Earliest starting offset for the current pool after adding numInsts.','line_number':719,'multiline':False]['text':' This is the beginning of the pool entries proper, after inserting a','line_number':720,'multiline':False]['text':' guard branch + pool header.','line_number':721,'multiline':False]['text':' Any constant pool loads that would go out of range?','line_number':725,'multiline':False]['text':' Any short-range branch that would go out of range?','line_number':730,'multiline':False]['text':' When NumShortBranchRanges > 1, is is possible for branch deadlines to','line_number':736,'multiline':False]['text':' expire faster than we can insert veneers. Suppose branches are 4 bytes','line_number':737,'multiline':False]['text':' each, we could have the following deadline set:','line_number':738,'multiline':False]['text':'','line_number':739,'multiline':False]['text':'   Range 0: 40, 44, 48','line_number':740,'multiline':False]['text':'   Range 1: 44, 48','line_number':741,'multiline':False]['text':'','line_number':742,'multiline':False]['text':' It is not good enough to start inserting veneers at the 40 deadline; we','line_number':743,'multiline':False]['text':' would not be able to create veneers for the second 44 deadline.','line_number':744,'multiline':False]['text':' Instead, we need to start at 32:','line_number':745,'multiline':False]['text':'','line_number':746,'multiline':False]['text':'   32: veneer(40)','line_number':747,'multiline':False]['text':'   36: veneer(44)','line_number':748,'multiline':False]['text':'   40: veneer(44)','line_number':749,'multiline':False]['text':'   44: veneer(48)','line_number':750,'multiline':False]['text':'   48: veneer(48)','line_number':751,'multiline':False]['text':'','line_number':752,'multiline':False]['text':' This is a pretty conservative solution to the problem: If we begin at','line_number':753,'multiline':False]['text':' the earliest deadline, we can always emit all veneers for the range','line_number':754,'multiline':False]['text':' that currently has the most pending deadlines. That may not leave room','line_number':755,'multiline':False]['text':' for veneers for the remaining ranges, so reserve space for those','line_number':756,'multiline':False]['text':' secondary range veneers assuming the worst case deadlines.','line_number':757,'multiline':False]['text':' Total pending secondary range veneer size.','line_number':759,'multiline':False]['text':' If inserting pool entries then find a new limiter before we do the','line_number':773,'multiline':False]['text':' range check.','line_number':774,'multiline':False]['text':' The pool entry index is returned above when allocating an entry, but','line_number':803,'multiline':False]['text':' when not allocating an entry a dummy value is returned - it is not','line_number':804,'multiline':False]['text':' expected to be used by the caller.','line_number':805,'multiline':False]['text':' Get the next buffer offset where an instruction would be inserted.','line_number':810,'multiline':False]['text':' This may flush the current constant pool before returning nextOffset().','line_number':811,'multiline':False]['text':' numInsts= ','line_number':813,'multiline':True]['text':' numPoolEntries= ','line_number':813,'multiline':True]['text':' The allocation of pool entries is not supported in a no-pool region,','line_number':826,'multiline':False]['text':' check.','line_number':827,'multiline':False]['text':' Insert the pool value.','line_number':852,'multiline':False]['text':' Now to get an instruction to write.','line_number':858,'multiline':False]['text':' Figure out the offset within the pool entries.','line_number':864,'multiline':False]['text':' Now inst is a valid thing to insert into the instruction stream.','line_number':868,'multiline':False]['text':' putInt is the workhorse for the assembler and higher-level buffer','line_number':875,'multiline':False]['text':' abstractions: it places one instruction into the instruction stream.','line_number':876,'multiline':False]['text':' Under normal circumstances putInt should just check that the constant','line_number':877,'multiline':False]['text':' pool does not need to be flushed, that there is space for the single word','line_number':878,'multiline':False]['text':' of the instruction, and write that word and update the buffer pointer.','line_number':879,'multiline':False]['text':'','line_number':880,'multiline':False]['text':' To do better here we need a status variable that handles both nopFill_','line_number':881,'multiline':False]['text':' and capacity, so that we can quickly know whether to go the slow path.','line_number':882,'multiline':False]['text':' That could be a variable that has the remaining number of simple','line_number':883,'multiline':False]['text':' instructions that can be inserted before a more expensive check,','line_number':884,'multiline':False]['text':' which is set to zero when nopFill_ is set.','line_number':885,'multiline':False]['text':'','line_number':886,'multiline':False]['text':' We assume that we don't have to check this->oom() if there is space to','line_number':887,'multiline':False]['text':' insert a plain instruction; there will always come a later time when it','line_number':888,'multiline':False]['text':' will be checked anyway.','line_number':889,'multiline':False]['text':' numInsts= ','line_number':894,'multiline':True]['text':' numPoolEntries= ','line_number':894,'multiline':True]['text':' Register a short-range branch deadline.','line_number':906,'multiline':False]['text':'','line_number':907,'multiline':False]['text':' After inserting a short-range forward branch, call this method to','line_number':908,'multiline':False]['text':' register the branch 'deadline' which is the last buffer offset that the','line_number':909,'multiline':False]['text':' branch instruction can reach.','line_number':910,'multiline':False]['text':'','line_number':911,'multiline':False]['text':' When the branch is bound to a destination label, call','line_number':912,'multiline':False]['text':' unregisterBranchDeadline() to stop tracking this branch,','line_number':913,'multiline':False]['text':'','line_number':914,'multiline':False]['text':' If the assembled code is about to exceed the registered branch deadline,','line_number':915,'multiline':False]['text':' and unregisterBranchDeadline() has not yet been called, an','line_number':916,'multiline':False]['text':' instruction-sized constant pool entry is allocated before the branch','line_number':917,'multiline':False]['text':' deadline.','line_number':918,'multiline':False]['text':'','line_number':919,'multiline':False]['text':' rangeIdx','line_number':920,'multiline':False]['text':'   A number < NumShortBranchRanges identifying the range of the branch.','line_number':921,'multiline':False]['text':'','line_number':922,'multiline':False]['text':' deadline','line_number':923,'multiline':False]['text':'   The highest buffer offset the the short-range branch can reach','line_number':924,'multiline':False]['text':'   directly.','line_number':925,'multiline':False]['text':'','line_number':926,'multiline':False]['text':' Un-register a short-range branch deadline.','line_number':933,'multiline':False]['text':'','line_number':934,'multiline':False]['text':' When a short-range branch has been successfully bound to its destination','line_number':935,'multiline':False]['text':' label, call this function to stop traching the branch.','line_number':936,'multiline':False]['text':'','line_number':937,'multiline':False]['text':' The (rangeIdx, deadline) pair must be previously registered.','line_number':938,'multiline':False]['text':'','line_number':939,'multiline':False]['text':' Are any short-range branches about to expire?','line_number':947,'multiline':False]['text':' Include branches that would expire in the next N bytes. The reservedBytes','line_number':953,'multiline':False]['text':' argument avoids the needless creation of many tiny constant pools.','line_number':954,'multiline':False]['text':'','line_number':955,'multiline':False]['text':' As the reservedBytes could be of any sizes such as SIZE_MAX, in the case','line_number':956,'multiline':False]['text':' of flushPool, we have to check for overflow when comparing the deadline','line_number':957,'multiline':False]['text':' with our expected reserved bytes.','line_number':958,'multiline':False]['text':' If there is no data in the pool being dumped, don't dump anything.','line_number':980,'multiline':False]['text':' Should not be placing a pool in a no-pool region, check.','line_number':985,'multiline':False]['text':' Dump the pool with a guard branch around the pool.','line_number':988,'multiline':False]['text':' Now generate branch veneers for any short-range branches that are','line_number':997,'multiline':False]['text':' about to expire.','line_number':998,'multiline':False]['text':' Stop tracking this branch. The Asm callback below may register','line_number':1003,'multiline':False]['text':' new branches to track.','line_number':1004,'multiline':False]['text':' Make room for the veneer. Same as a pool guard branch.','line_number':1007,'multiline':False]['text':' Fix the branch so it targets the veneer.','line_number':1013,'multiline':False]['text':' The Asm class knows how to find the original branch given the','line_number':1014,'multiline':False]['text':' (rangeIdx, deadline) pair.','line_number':1015,'multiline':False]['text':' We only reserved space for the guard branch and pool header.','line_number':1019,'multiline':False]['text':' Fill them in.','line_number':1020,'multiline':False]['text':' With the pool's final position determined it is now possible to patch','line_number':1025,'multiline':False]['text':' the instructions that reference entries in this pool, and this is','line_number':1026,'multiline':False]['text':' done incrementally as each pool is finished.','line_number':1027,'multiline':False]['text':' All entries should be before the pool.','line_number':1033,'multiline':False]['text':' Everything here is known so we can safely do the necessary','line_number':1036,'multiline':False]['text':' substitutions.','line_number':1037,'multiline':False]['text':' That is, PatchConstantPoolLoad wants to be handed the address of','line_number':1041,'multiline':False]['text':' the pool entry that is being loaded.  We need to do a non-trivial','line_number':1042,'multiline':False]['text':' amount of math here, since the pool that we've made does not','line_number':1043,'multiline':False]['text':' actually reside there in memory.','line_number':1044,'multiline':False]['text':' Record the pool info.','line_number':1050,'multiline':False]['text':' Reset everything to the state that it was in when we started.','line_number':1057,'multiline':False]['text':' Don't allow re-entry.','line_number':1074,'multiline':False]['text':' Check if the pool will spill by adding maxInst instructions, and if','line_number':1078,'multiline':False]['text':' so then finish the pool before entering the no-pool region. It is','line_number':1079,'multiline':False]['text':' assumed that no pool entries are allocated in a no-pool region and','line_number':1080,'multiline':False]['text':' this is asserted when allocating entries.','line_number':1081,'multiline':False]['text':' Record the buffer position to allow validating maxInst when leaving','line_number':1090,'multiline':False]['text':' the region.','line_number':1091,'multiline':False]['text':' Validate the maxInst argument supplied to enterNoPool().','line_number':1107,'multiline':False]['text':' A pool many need to be dumped at this point, so insert NOP fill here.','line_number':1131,'multiline':False]['text':' Check if the code position can be aligned without dumping a pool.','line_number':1134,'multiline':False]['text':' Add an InstSize because it is probably not useful for a pool to be','line_number':1141,'multiline':False]['text':' dumped at the aligned code position.','line_number':1142,'multiline':False]['text':' Alignment would cause a pool dump, so dump the pool now.','line_number':1144,'multiline':False]['text':' The pools should have all been flushed, check.','line_number':1163,'multiline':False]['text':' The pools should have all been flushed, check.','line_number':1175,'multiline':False]['text':' Find the pool containing pe.index().','line_number':1190,'multiline':False]['text':' The array is sorted, so we can use a binary search.','line_number':1191,'multiline':False]['text':' A note on asymmetric types in the upper_bound comparator:','line_number':1193,'multiline':False]['text':' http://permalink.gmane.org/gmane.comp.compilers.clang.devel/10101','line_number':1194,'multiline':False]['text':' Since upper_bound finds the first pool greater than pe,','line_number':1199,'multiline':False]['text':' we want the previous one which is the last one less than or equal.','line_number':1200,'multiline':False]['text':' The i iterator now points to the pool containing pe.index.','line_number':1203,'multiline':False]['text':' Compute the byte offset into the pool.','line_number':1206,'multiline':False]['text':' namespace jit','line_number':1212,'multiline':False]['text':' namespace js','line_number':1213,'multiline':False]['text':' jit_shared_IonAssemblerBufferWithConstantPools_h','line_number':1215,'multiline':False]