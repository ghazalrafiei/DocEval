['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
*******************************************************************************
*
*   Copyright (C) 1998-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*
* File uscnnf_p.c
*
* Modification History:
*
*   Date        Name        Description
*   12/02/98    stephen        Creation.
*   03/13/99    stephen     Modified for new C API.
*******************************************************************************
','line_number':3,'multiline':True]['text':' flag characters for u_scanf ','line_number':38,'multiline':True]['text':' special characters for u_scanf ','line_number':45,'multiline':True]['text':' unicode digits ','line_number':48,'multiline':True]['text':' u_scanf modifiers ','line_number':71,'multiline':True]['text':'*
 * Struct encapsulating a single uscanf format specification.
 ','line_number':80,'multiline':True]['text':' Width  ','line_number':84,'multiline':True]['text':' Format specification  ','line_number':86,'multiline':True]['text':' Padding character  ','line_number':88,'multiline':True]['text':' TRUE if arg should be skipped ','line_number':90,'multiline':True]['text':' L flag  ','line_number':91,'multiline':True]['text':' h flag  ','line_number':92,'multiline':True]['text':' l flag  ','line_number':93,'multiline':True]['text':' ll flag  ','line_number':94,'multiline':True]['text':' TRUE if this is a NULL-terminated string. ','line_number':95,'multiline':True]['text':'*
 * Struct encapsulating a single u_scanf format specification.
 ','line_number':99,'multiline':True]['text':' Information on this spec ','line_number':103,'multiline':True]['text':' Position of data in arg list ','line_number':104,'multiline':True]['text':'*
 * Parse a single u_scanf format specifier in Unicode.
 * @param fmt A pointer to a '%' character in a u_scanf format specification.
 * @param spec A pointer to a <TT>u_scanf_spec</TT> to receive the parsed
 * format specifier.
 * @return The number of characters contained in this specifier.
 ','line_number':107,'multiline':True]['text':' initialize spec to default values ','line_number':122,'multiline':True]['text':' skip over the initial '%' ','line_number':136,'multiline':True]['text':' Check for positional argument ','line_number':139,'multiline':True]['text':' Save the current position ','line_number':142,'multiline':True]['text':' handle positional parameters ','line_number':145,'multiline':True]['text':' if there is no '$', don't read anything ','line_number':155,'multiline':True]['text':' munge the '$' ','line_number':160,'multiline':True]['text':' Get any format flags ','line_number':165,'multiline':True]['text':' skip argument ','line_number':169,'multiline':True]['text':' pad character specified ','line_number':174,'multiline':True]['text':' first four characters are hex values for pad char ','line_number':177,'multiline':True]['text':' final character is ignored ','line_number':183,'multiline':True]['text':' Get the width ','line_number':190,'multiline':True]['text':' Get any modifiers ','line_number':200,'multiline':True]['text':' short ','line_number':204,'multiline':True]['text':' long or long long ','line_number':209,'multiline':True]['text':' skip over the next 'l' ','line_number':213,'multiline':True]['text':' long double ','line_number':220,'multiline':True]['text':' finally, get the specifier letter ','line_number':227,'multiline':True]['text':' return # of characters in this specifier ','line_number':230,'multiline':True]['text':' ANSI style formatting ','line_number':237,'multiline':True]['text':' Use US-ASCII characters only for formatting ','line_number':238,'multiline':True]['text':' % ','line_number':240,'multiline':True]['text':' s ','line_number':242,'multiline':True]['text':' c ','line_number':244,'multiline':True]['text':' d, i ','line_number':246,'multiline':True]['text':' u ','line_number':248,'multiline':True]['text':' o ','line_number':250,'multiline':True]['text':' x, X ','line_number':252,'multiline':True]['text':' f ','line_number':254,'multiline':True]['text':' e, E ','line_number':256,'multiline':True]['text':' g, G ','line_number':258,'multiline':True]['text':' n ','line_number':260,'multiline':True]['text':' [ ','line_number':262,'multiline':True]['text':' non-ANSI extensions ','line_number':265,'multiline':True]['text':' Use US-ASCII characters only for formatting ','line_number':266,'multiline':True]['text':' p ','line_number':268,'multiline':True]['text':' V ','line_number':270,'multiline':True]['text':' P ','line_number':272,'multiline':True]['text':' C  K is old format ','line_number':274,'multiline':True]['text':' S  U is old format ','line_number':276,'multiline':True]['text':'*
 * A u_scanf handler function.  
 * A u_scanf handler is responsible for handling a single u_scanf 
 * format specification, for example 'd' or 's'.
 * @param stream The UFILE to which to write output.
 * @param info A pointer to a <TT>u_scanf_spec_info</TT> struct containing
 * information on the format specification.
 * @param args A pointer to the argument data
 * @param fmt A pointer to the first character in the format string
 * following the spec.
 * @param fmtConsumed On output, set to the number of characters consumed
 * in <TT>fmt</TT>. Do nothing, if the argument isn't variable width.
 * @param argConverted The number of arguments converted and assigned, or -1 if an
 * error occurred.
 * @return The number of code points consumed during reading.
 ','line_number':282,'multiline':True]['text':' We do not use handlers for 0-0x1f ','line_number':313,'multiline':True]['text':' skip all leading ws in the input ','line_number':325,'multiline':True]['text':' put the final character back on the input ','line_number':331,'multiline':True]['text':' TODO: Is always skipping the prefix symbol as a positive sign a good idea in all locales? ','line_number':338,'multiline':True]['text':' skip all leading ws in the input ','line_number':359,'multiline':True]['text':' put the final character back on the input ','line_number':365,'multiline':True]['text':' make sure the next character in the input is a percent ','line_number':388,'multiline':True]['text':' in the special case of count, the u_scanf_spec_info's width ','line_number':408,'multiline':True]['text':' will contain the # of items converted thus far ','line_number':409,'multiline':True]['text':' we converted 0 args ','line_number':420,'multiline':True]['text':' skip all ws in the input ','line_number':443,'multiline':True]['text':' fill the input's internal buffer ','line_number':446,'multiline':True]['text':' determine the size of the input's buffer ','line_number':449,'multiline':True]['text':' truncate to the width, if specified ','line_number':452,'multiline':True]['text':' get the formatter ','line_number':456,'multiline':True]['text':' handle error ','line_number':459,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':463,'multiline':True]['text':' parse the number ','line_number':466,'multiline':True]['text':' mask off any necessary bits ','line_number':478,'multiline':True]['text':'  if(! info->fIsLong_double)
    num &= DBL_MAX;','line_number':479,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':482,'multiline':True]['text':' we converted 1 arg ','line_number':485,'multiline':True]['text':' skip all ws in the input ','line_number':514,'multiline':True]['text':' fill the input's internal buffer ','line_number':517,'multiline':True]['text':' determine the size of the input's buffer ','line_number':520,'multiline':True]['text':' truncate to the width, if specified ','line_number':523,'multiline':True]['text':' get the formatter ','line_number':527,'multiline':True]['text':' handle error ','line_number':530,'multiline':True]['text':' set the appropriate flags on the formatter ','line_number':534,'multiline':True]['text':' Upper/lower case the e ','line_number':542,'multiline':True]['text':' e ','line_number':543,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':565,'multiline':True]['text':' parse the number ','line_number':568,'multiline':True]['text':' mask off any necessary bits ','line_number':580,'multiline':True]['text':'  if(! info->fIsLong_double)
    num &= DBL_MAX;','line_number':581,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':584,'multiline':True]['text':' we converted 1 arg ','line_number':587,'multiline':True]['text':'int32_t       scientificResult, genericResult;','line_number':606,'multiline':True]['text':' since we can't determine by scanning the characters whether ','line_number':614,'multiline':True]['text':' a number was formatted in the 'f' or 'g' styles, parse the ','line_number':615,'multiline':True]['text':' string with both formatters, and assume whichever one ','line_number':616,'multiline':True]['text':' parsed the most is the correct formatter to use ','line_number':617,'multiline':True]['text':' skip all ws in the input ','line_number':620,'multiline':True]['text':' fill the input's internal buffer ','line_number':623,'multiline':True]['text':' determine the size of the input's buffer ','line_number':626,'multiline':True]['text':' truncate to the width, if specified ','line_number':629,'multiline':True]['text':' get the formatters ','line_number':633,'multiline':True]['text':' handle error ','line_number':637,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':641,'multiline':True]['text':' parse the number using each format','line_number':644,'multiline':True]['text':' determine which parse made it farther ','line_number':652,'multiline':True]['text':' stash the result in num ','line_number':654,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':656,'multiline':True]['text':' stash the result in num ','line_number':660,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':662,'multiline':True]['text':' mask off any necessary bits ','line_number':676,'multiline':True]['text':'  if(! info->fIsLong_double)
    num &= DBL_MAX;','line_number':677,'multiline':True]['text':' we converted 1 arg ','line_number':680,'multiline':True]['text':' skip all ws in the input ','line_number':706,'multiline':True]['text':' fill the input's internal buffer ','line_number':709,'multiline':True]['text':' determine the size of the input's buffer ','line_number':712,'multiline':True]['text':' truncate to the width, if specified ','line_number':715,'multiline':True]['text':' get the formatter ','line_number':719,'multiline':True]['text':' handle error ','line_number':722,'multiline':True]['text':' for integer types, do not attempt to parse fractions ','line_number':726,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':735,'multiline':True]['text':' parse the number ','line_number':738,'multiline':True]['text':' mask off any necessary bits ','line_number':741,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':751,'multiline':True]['text':' cleanup cloned formatter ','line_number':754,'multiline':True]['text':' we converted 1 arg ','line_number':757,'multiline':True]['text':' TODO Fix this when Numberformat handles uint64_t ','line_number':770,'multiline':True]['text':' skip all ws in the input ','line_number':792,'multiline':True]['text':' fill the input's internal buffer ','line_number':795,'multiline':True]['text':' determine the size of the input's buffer ','line_number':798,'multiline':True]['text':' truncate to the width, if specified ','line_number':801,'multiline':True]['text':' get the formatter ','line_number':805,'multiline':True]['text':' handle error ','line_number':808,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':812,'multiline':True]['text':' parse the number ','line_number':815,'multiline':True]['text':' mask off any necessary bits ','line_number':822,'multiline':True]['text':'  if(! info->fIsLong_double)
    num &= DBL_MAX;','line_number':823,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':826,'multiline':True]['text':' we converted 1 arg ','line_number':829,'multiline':True]['text':' skip all ws in the input ','line_number':856,'multiline':True]['text':' get the string one character at a time, truncating to the width ','line_number':861,'multiline':True]['text':' open the default converter ','line_number':864,'multiline':True]['text':' put the character from the input onto the target ','line_number':876,'multiline':True]['text':' Since we do this one character at a time, do it this way. ','line_number':878,'multiline':True]['text':' convert the character to the default codepage ','line_number':886,'multiline':True]['text':' clean up ','line_number':891,'multiline':True]['text':' increment the count ','line_number':897,'multiline':True]['text':' put the final character we read back on the input ','line_number':901,'multiline':True]['text':' add the terminator ','line_number':906,'multiline':True]['text':' clean up ','line_number':912,'multiline':True]['text':' we converted 1 arg ','line_number':915,'multiline':True]['text':' skip all ws in the input ','line_number':953,'multiline':True]['text':' get the string one character at a time, truncating to the width ','line_number':958,'multiline':True]['text':' put the character from the input onto the target ','line_number':966,'multiline':True]['text':' increment the count ','line_number':971,'multiline':True]['text':' put the final character we read back on the input ','line_number':975,'multiline':True]['text':' add the terminator ','line_number':981,'multiline':True]['text':' we converted 1 arg ','line_number':987,'multiline':True]['text':' skip all ws in the input ','line_number':1026,'multiline':True]['text':' fill the input's internal buffer ','line_number':1029,'multiline':True]['text':' determine the size of the input's buffer ','line_number':1032,'multiline':True]['text':' truncate to the width, if specified ','line_number':1035,'multiline':True]['text':' get the formatter ','line_number':1039,'multiline':True]['text':' handle error ','line_number':1042,'multiline':True]['text':' Skip the positive prefix. ICU normally can't handle this due to strict parsing. ','line_number':1046,'multiline':True]['text':' This is not applicable to RBNF. ','line_number':1047,'multiline':True]['text':'skipped += u_scanf_skip_leading_positive_sign(input, format, &status);','line_number':1048,'multiline':True]['text':' parse the number ','line_number':1050,'multiline':True]['text':' mask off any necessary bits ','line_number':1057,'multiline':True]['text':'  if(! info->fIsLong_double)
    num &= DBL_MAX;','line_number':1058,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':1061,'multiline':True]['text':' we converted 1 arg ','line_number':1064,'multiline':True]['text':' skip all ws in the input ','line_number':1085,'multiline':True]['text':' fill the input's internal buffer ','line_number':1088,'multiline':True]['text':' determine the size of the input's buffer ','line_number':1091,'multiline':True]['text':' truncate to the width, if specified ','line_number':1094,'multiline':True]['text':' check for alternate form ','line_number':1098,'multiline':True]['text':' skip the '0' and 'x' or 'X' if present ','line_number':1102,'multiline':True]['text':' parse the number ','line_number':1107,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':1110,'multiline':True]['text':' mask off any necessary bits ','line_number':1113,'multiline':True]['text':' we converted 1 arg ','line_number':1123,'multiline':True]['text':' skip all ws in the input ','line_number':1144,'multiline':True]['text':' fill the input's internal buffer ','line_number':1147,'multiline':True]['text':' determine the size of the input's buffer ','line_number':1150,'multiline':True]['text':' truncate to the width, if specified ','line_number':1153,'multiline':True]['text':' parse the number ','line_number':1157,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':1160,'multiline':True]['text':' mask off any necessary bits ','line_number':1163,'multiline':True]['text':' we converted 1 arg ','line_number':1173,'multiline':True]['text':' skip all ws in the input ','line_number':1195,'multiline':True]['text':' fill the input's internal buffer ','line_number':1198,'multiline':True]['text':' determine the size of the input's buffer ','line_number':1201,'multiline':True]['text':' truncate to the width, if specified ','line_number':1204,'multiline':True]['text':' Make sure that we don't consume too much ','line_number':1209,'multiline':True]['text':' parse the pointer - assign to temporary value ','line_number':1214,'multiline':True]['text':' update the input's position to reflect consumed data ','line_number':1221,'multiline':True]['text':' we converted 1 arg ','line_number':1224,'multiline':True]['text':' Create an empty set ','line_number':1245,'multiline':True]['text':' Back up one to get the [ ','line_number':1248,'multiline':True]['text':' truncate to the width, if specified and alias the target ','line_number':1251,'multiline':True]['text':' parse the scanset from the fmt string ','line_number':1256,'multiline':True]['text':' verify that the parse was successful ','line_number':1259,'multiline':True]['text':' grab characters one at a time and make sure they are in the scanset ','line_number':1263,'multiline':True]['text':' if the character's not in the scanset, break out ','line_number':1280,'multiline':True]['text':' put the final character we read back on the input ','line_number':1285,'multiline':True]['text':' if we didn't match at least 1 character, fail ','line_number':1293,'multiline':True]['text':' otherwise, add the terminator ','line_number':1296,'multiline':True]['text':' we converted 1 arg ','line_number':1301,'multiline':True]['text':' Use US-ASCII characters only for formatting. Most codepages have
 characters 20-7F from Unicode. Using any other codepage specific
 characters will make it very difficult to format the string on
 non-Unicode machines ','line_number':1306,'multiline':True]['text':' 0x20 ','line_number':1311,'multiline':True]['text':' 0x30 ','line_number':1317,'multiline':True]['text':' 0x40 ','line_number':1323,'multiline':True]['text':'deprecated','line_number':1327,'multiline':True]['text':' 0x50 ','line_number':1333,'multiline':True]['text':'deprecated','line_number':1336,'multiline':True]['text':' 0x60 ','line_number':1343,'multiline':True]['text':' 0x70 ','line_number':1349,'multiline':True]['text':' alias the pattern ','line_number':1370,'multiline':True]['text':' haven't converted anything yet ','line_number':1373,'multiline':True]['text':' iterate through the pattern ','line_number':1378,'multiline':True]['text':' match any characters up to the next '%' ','line_number':1381,'multiline':True]['text':' if we aren't at a '%', or if we're at end of string, break','line_number':1386,'multiline':True]['text':' parse the specifier ','line_number':1390,'multiline':True]['text':' update the pointer in pattern ','line_number':1393,'multiline':True]['text':' skip the argument, if necessary ','line_number':1398,'multiline':True]['text':' query the info function for argument information ','line_number':1399,'multiline':True]['text':' set the spec's width to the # of items converted ','line_number':1410,'multiline':True]['text':' else args is ignored ','line_number':1425,'multiline':True]['text':' call the handler function ','line_number':1431,'multiline':True]['text':' reset count to 1 so that += for alias works. ','line_number':1435,'multiline':True]['text':' if the handler encountered an error condition, break ','line_number':1440,'multiline':True]['text':' add to the # of items converted ','line_number':1446,'multiline':True]['text':' update the pointer in pattern ','line_number':1449,'multiline':True]['text':' else do nothing ','line_number':1452,'multiline':True]['text':' else do nothing ','line_number':1454,'multiline':True]['text':' just ignore unknown tags ','line_number':1456,'multiline':True]['text':' return # of items converted ','line_number':1459,'multiline':True]['text':' #if !UCONFIG_NO_FORMATTING ','line_number':1463,'multiline':True]