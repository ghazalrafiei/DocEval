['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':16,'multiline':False]['text':' Note: this function clobbers the input register.','line_number':23,'multiline':False]['text':' <= 0 or NaN --> 0','line_number':29,'multiline':False]['text':' Add 0.5 and truncate.','line_number':39,'multiline':False]['text':' Truncate to int32 and ensure the result <= 255. This relies on the','line_number':45,'multiline':False]['text':' processor setting output to a value > 255 for doubles outside the int32','line_number':46,'multiline':False]['text':' range (for instance 0x80000000).','line_number':47,'multiline':False]['text':' Check if we had a tie.','line_number':51,'multiline':False]['text':' It was a tie. Mask out the ones bit to get an even value.','line_number':55,'multiline':False]['text':' See also js_TypedArray_uint8_clamp_double.','line_number':56,'multiline':False]['text':' > 255 --> 255','line_number':61,'multiline':False]['text':' Determines whether the low double contained in the XMM register reg','line_number':79,'multiline':False]['text':' is equal to -0.0.','line_number':80,'multiline':False]['text':' if not already compared to zero','line_number':85,'multiline':False]['text':' Compare to zero. Lets through {0, -0}.','line_number':89,'multiline':False]['text':' If reg is non-zero, jump to nonZero.','line_number':92,'multiline':False]['text':' Input register is either zero or negative zero. Retrieve sign of input.','line_number':95,'multiline':False]['text':' If reg is 1 or 3, input is negative zero.','line_number':98,'multiline':False]['text':' If reg is 0 or 2, input is a normal zero.','line_number':99,'multiline':False]['text':' Do a vucomisd to catch equality and NaNs, which both require special','line_number':199,'multiline':False]['text':' handling. If the operands are ordered and inequal, we branch straight to','line_number':200,'multiline':False]['text':' the min/max instruction. If we wanted, we could also branch for less-than','line_number':201,'multiline':False]['text':' or greater-than here instead of using min/max, however these conditions','line_number':202,'multiline':False]['text':' will sometimes be hard on the branch predictor.','line_number':203,'multiline':False]['text':' Ordered and equal. The operands are bit-identical unless they are zero','line_number':210,'multiline':False]['text':' and negative zero. These instructions merge the sign bits in that','line_number':211,'multiline':False]['text':' case, and are no-ops otherwise.','line_number':212,'multiline':False]['text':' x86's min/max are not symmetric; if either operand is a NaN, they return','line_number':220,'multiline':False]['text':' the read-only operand. We need to return a NaN if either operand is a','line_number':221,'multiline':False]['text':' NaN, so we explicitly check for a NaN in the read-write operand.','line_number':222,'multiline':False]['text':' When the values are inequal, or second is NaN, x86's min and max will','line_number':229,'multiline':False]['text':' return the value we need.','line_number':230,'multiline':False]['text':' Do a vucomiss to catch equality and NaNs, which both require special','line_number':246,'multiline':False]['text':' handling. If the operands are ordered and inequal, we branch straight to','line_number':247,'multiline':False]['text':' the min/max instruction. If we wanted, we could also branch for less-than','line_number':248,'multiline':False]['text':' or greater-than here instead of using min/max, however these conditions','line_number':249,'multiline':False]['text':' will sometimes be hard on the branch predictor.','line_number':250,'multiline':False]['text':' Ordered and equal. The operands are bit-identical unless they are zero','line_number':257,'multiline':False]['text':' and negative zero. These instructions merge the sign bits in that','line_number':258,'multiline':False]['text':' case, and are no-ops otherwise.','line_number':259,'multiline':False]['text':' x86's min/max are not symmetric; if either operand is a NaN, they return','line_number':267,'multiline':False]['text':' the read-only operand. We need to return a NaN if either operand is a','line_number':268,'multiline':False]['text':' NaN, so we explicitly check for a NaN in the read-write operand.','line_number':269,'multiline':False]['text':' When the values are inequal, or second is NaN, x86's min and max will','line_number':276,'multiline':False]['text':' return the value we need.','line_number':277,'multiline':False]['text':'{{{ check_macroassembler_style','line_number':288,'multiline':False]['text':' ===============================================================','line_number':289,'multiline':False]['text':' MacroAssembler high-level usage.','line_number':290,'multiline':False]['text':' This operation really consists of five phases, in order to enforce the','line_number':296,'multiline':False]['text':' restriction that on x86_shared, srcDest must be eax and edx will be','line_number':297,'multiline':False]['text':' clobbered.','line_number':298,'multiline':False]['text':'','line_number':299,'multiline':False]['text':'     Input: { rhs, lhsOutput }','line_number':300,'multiline':False]['text':'','line_number':301,'multiline':False]['text':'  [PUSH] Preserve registers','line_number':302,'multiline':False]['text':'  [MOVE] Generate moves to specific registers','line_number':303,'multiline':False]['text':'','line_number':304,'multiline':False]['text':'  [DIV] Input: { regForRhs, EAX }','line_number':305,'multiline':False]['text':'  [DIV] extend EAX into EDX','line_number':306,'multiline':False]['text':'  [DIV] x86 Division operator','line_number':307,'multiline':False]['text':'  [DIV] Ouptut: { EAX, EDX }','line_number':308,'multiline':False]['text':'','line_number':309,'multiline':False]['text':'  [MOVE] Move specific registers to outputs','line_number':310,'multiline':False]['text':'  [POP] Restore registers','line_number':311,'multiline':False]['text':'','line_number':312,'multiline':False]['text':'    Output: { lhsOutput, remainderOutput }','line_number':313,'multiline':False]['text':' Currently this helper can't handle this situation.','line_number':317,'multiline':False]['text':' Choose a register that is not edx, or eax to hold the rhs;','line_number':321,'multiline':False]['text':' ebx is chosen arbitrarily, and will be preserved if necessary.','line_number':322,'multiline':False]['text':' Add registers we will be clobbering as live, but','line_number':325,'multiline':False]['text':' also remove the set we do not restore.','line_number':326,'multiline':False]['text':' Shuffle input into place.','line_number':337,'multiline':False]['text':' Sign extend eax into edx to make (edx:eax): idiv/udiv are 64-bit.','line_number':343,'multiline':False]['text':' Choose an arbitrary register that isn't eax, edx, rhs or srcDest;','line_number':363,'multiline':False]['text':' Choose an arbitrary register that isn't eax, edx, rhs or srcDest','line_number':379,'multiline':False]['text':' ===============================================================','line_number':393,'multiline':False]['text':' Stack manipulation functions.','line_number':394,'multiline':False]['text':' On x86, always use push to push the integer registers, as it's fast','line_number':408,'multiline':False]['text':' on modern hardware and it's a small instruction.','line_number':409,'multiline':False]['text':' x64 padding to keep the stack aligned on uintptr_t. Keep in sync with','line_number':434,'multiline':False]['text':' GetPushSizeInBytes.','line_number':435,'multiline':False]['text':' The macroassembler will keep the stack sizeof(uintptr_t)-aligned, so','line_number':442,'multiline':False]['text':' we don't need to take into account `alignExtra` here.','line_number':443,'multiline':False]['text':' x64 padding to keep the stack aligned on uintptr_t. Keep in sync with','line_number':483,'multiline':False]['text':' GetPushSizeInBytes.','line_number':484,'multiline':False]['text':' What this means is: if `alignExtra` is nonzero, then the save area size','line_number':491,'multiline':False]['text':' actually used is `alignExtra` bytes smaller than what','line_number':492,'multiline':False]['text':' PushRegsInMaskSizeInBytes claims.  Hence we need to compensate for that.','line_number':493,'multiline':False]['text':' x64 padding to keep the stack aligned on uintptr_t. Keep in sync with','line_number':530,'multiline':False]['text':' GetPushBytesInSize.','line_number':531,'multiline':False]['text':' On x86, use pop to pop the integer registers, if we're not going to','line_number':535,'multiline':False]['text':' ignore any slots, as it's fast on modern hardware and it's a small','line_number':536,'multiline':False]['text':' instruction.','line_number':537,'multiline':False]['text':' ===============================================================','line_number':625,'multiline':False]['text':' Simple call functions.','line_number':626,'multiline':False]['text':' ===============================================================','line_number':658,'multiline':False]['text':' Patchable near/far jumps.','line_number':659,'multiline':False]['text':' ===============================================================','line_number':682,'multiline':False]['text':' Jit Frames.','line_number':683,'multiline':False]['text':' ===============================================================','line_number':697,'multiline':False]['text':' WebAssembly','line_number':698,'multiline':False]['text':' RAII class that generates the jumps to traps when it's destructed, to','line_number':721,'multiline':False]['text':' prevent some code duplication in the outOfLineWasmTruncateXtoY methods.','line_number':722,'multiline':False]['text':' Handle errors.  These cases are not in arbitrary order: code will','line_number':734,'multiline':False]['text':' fall through to intOverflow.','line_number':735,'multiline':False]['text':' Negative overflow and NaN both are converted to 0, and the only','line_number':772,'multiline':False]['text':' other case is positive overflow which is converted to','line_number':773,'multiline':False]['text':' UINT32_MAX.','line_number':774,'multiline':False]['text':' Negative overflow is already saturated to INT32_MIN, so we only','line_number':786,'multiline':False]['text':' have to handle NaN and positive overflow here.','line_number':787,'multiline':False]['text':' Eagerly take care of NaNs.','line_number':805,'multiline':False]['text':' For unsigned, fall through to intOverflow failure case.','line_number':808,'multiline':False]['text':' Handle special values.','line_number':813,'multiline':False]['text':' We've used vcvttsd2si. The only valid double values that can','line_number':815,'multiline':False]['text':' truncate to INT32_MIN are in ]INT32_MIN - 1; INT32_MIN].','line_number':816,'multiline':False]['text':' Negative overflow and NaN both are converted to 0, and the only','line_number':838,'multiline':False]['text':' other case is positive overflow which is converted to','line_number':839,'multiline':False]['text':' UINT32_MAX.','line_number':840,'multiline':False]['text':' Negative overflow is already saturated to INT32_MIN, so we only','line_number':852,'multiline':False]['text':' have to handle NaN and positive overflow here.','line_number':853,'multiline':False]['text':' Eagerly take care of NaNs.','line_number':871,'multiline':False]['text':' For unsigned, fall through to intOverflow failure case.','line_number':874,'multiline':False]['text':' Handle special values.','line_number':879,'multiline':False]['text':' We've used vcvttss2si. Check that the input wasn't','line_number':881,'multiline':False]['text':' float(INT32_MIN), which is the only legimitate input that','line_number':882,'multiline':False]['text':' would truncate to INT32_MIN.','line_number':883,'multiline':False]['text':' Negative overflow and NaN both are converted to 0, and the only','line_number':900,'multiline':False]['text':' other case is positive overflow which is converted to','line_number':901,'multiline':False]['text':' UINT64_MAX.','line_number':902,'multiline':False]['text':' Negative overflow is already saturated to INT64_MIN, so we only','line_number':913,'multiline':False]['text':' have to handle NaN and positive overflow here.','line_number':914,'multiline':False]['text':' Eagerly take care of NaNs.','line_number':932,'multiline':False]['text':' Handle special values.','line_number':935,'multiline':False]['text':' We've used vcvtsd2sq. The only legit value whose i64','line_number':948,'multiline':False]['text':' truncation is INT64_MIN is double(INT64_MIN): exponent is so','line_number':949,'multiline':False]['text':' high that the highest resolution around is much more than 1.','line_number':950,'multiline':False]['text':' Negative overflow and NaN both are converted to 0, and the only','line_number':967,'multiline':False]['text':' other case is positive overflow which is converted to','line_number':968,'multiline':False]['text':' UINT64_MAX.','line_number':969,'multiline':False]['text':' Negative overflow is already saturated to INT64_MIN, so we only','line_number':980,'multiline':False]['text':' have to handle NaN and positive overflow here.','line_number':981,'multiline':False]['text':' Eagerly take care of NaNs.','line_number':999,'multiline':False]['text':' Handle special values.','line_number':1002,'multiline':False]['text':' We've used vcvtss2sq. See comment in outOfLineWasmTruncateDoubleToInt64.','line_number':1015,'multiline':False]['text':' ========================================================================','line_number':1027,'multiline':False]['text':' Primitive atomic operations.','line_number':1028,'multiline':False]['text':' Nothing','line_number':1059,'multiline':False]['text':' Note value can be an Imm or a Register.','line_number':1197,'multiline':False]['text':' But not for the bitwise ops','line_number':1222,'multiline':False]['text':' ========================================================================','line_number':1453,'multiline':False]['text':' JS atomic operations.','line_number':1454,'multiline':False]['text':' ========================================================================','line_number':1602,'multiline':False]['text':' Spectre Mitigations.','line_number':1603,'multiline':False]['text':' Spectre mitigation recommended by Intel and AMD suggest to use lfence as','line_number':1606,'multiline':False]['text':' a way to force all speculative execution of instructions to end.','line_number':1607,'multiline':False]['text':' Fail on negative-zero.','line_number':1615,'multiline':False]['text':' Round toward -Infinity.','line_number':1618,'multiline':False]['text':' Branch to a slow path for negative inputs. Doesn't catch NaN or -0.','line_number':1627,'multiline':False]['text':' Fail on negative-zero.','line_number':1634,'multiline':False]['text':' Input is non-negative, so truncation correctly rounds.','line_number':1637,'multiline':False]['text':' Input is negative, but isn't -0.','line_number':1641,'multiline':False]['text':' Negative values go on a comparatively expensive path, since no','line_number':1642,'multiline':False]['text':' native rounding mode matches JS semantics. Still better than callVM.','line_number':1643,'multiline':False]['text':' Truncate and round toward zero.','line_number':1646,'multiline':False]['text':' This is off-by-one for everything but integer-valued inputs.','line_number':1647,'multiline':False]['text':' Test whether the input double was integer-valued.','line_number':1650,'multiline':False]['text':' Input is not integer-valued, so we rounded off-by-one in the','line_number':1657,'multiline':False]['text':' wrong direction. Correct by subtraction.','line_number':1658,'multiline':False]['text':' Cannot overflow: output was already checked against INT_MIN.','line_number':1660,'multiline':False]['text':' Fail on negative-zero.','line_number':1670,'multiline':False]['text':' Round toward -Infinity.','line_number':1673,'multiline':False]['text':' Branch to a slow path for negative inputs. Doesn't catch NaN or -0.','line_number':1682,'multiline':False]['text':' Fail on negative-zero.','line_number':1689,'multiline':False]['text':' Input is non-negative, so truncation correctly rounds.','line_number':1692,'multiline':False]['text':' Input is negative, but isn't -0.','line_number':1696,'multiline':False]['text':' Negative values go on a comparatively expensive path, since no','line_number':1697,'multiline':False]['text':' native rounding mode matches JS semantics. Still better than callVM.','line_number':1698,'multiline':False]['text':' Truncate and round toward zero.','line_number':1701,'multiline':False]['text':' This is off-by-one for everything but integer-valued inputs.','line_number':1702,'multiline':False]['text':' Test whether the input double was integer-valued.','line_number':1705,'multiline':False]['text':' Input is not integer-valued, so we rounded off-by-one in the','line_number':1712,'multiline':False]['text':' wrong direction. Correct by subtraction.','line_number':1713,'multiline':False]['text':' Cannot overflow: output was already checked against INT_MIN.','line_number':1715,'multiline':False]['text':' If x is in ]-1,0], ceil(x) is -0, which cannot be represented as an int32.','line_number':1728,'multiline':False]['text':' Fail if x > -1 and the sign bit is set.','line_number':1729,'multiline':False]['text':' x <= -1 or x > -0','line_number':1737,'multiline':False]['text':' Round toward +Infinity.','line_number':1739,'multiline':False]['text':' No SSE4.1','line_number':1745,'multiline':False]['text':' x >= 0 and x is not -0.0. We can truncate integer values, and truncate and','line_number':1748,'multiline':False]['text':' add 1 to non-integer values. This will also work for values >= INT_MAX + 1,','line_number':1749,'multiline':False]['text':' as the truncate operation will return INT_MIN and we'll fail.','line_number':1750,'multiline':False]['text':' Input is not integer-valued, add 1 to obtain the ceiling value.','line_number':1755,'multiline':False]['text':' If input > INT_MAX, output == INT_MAX so adding 1 will overflow.','line_number':1756,'multiline':False]['text':' x <= -1, truncation is the way to go.','line_number':1760,'multiline':False]['text':' If x is in ]-1,0], ceil(x) is -0, which cannot be represented as an int32.','line_number':1773,'multiline':False]['text':' Fail if x > -1 and the sign bit is set.','line_number':1774,'multiline':False]['text':' x <= -1 or x > -0','line_number':1782,'multiline':False]['text':' Round toward +Infinity.','line_number':1784,'multiline':False]['text':' No SSE4.1','line_number':1790,'multiline':False]['text':' x >= 0 and x is not -0.0. We can truncate integer values, and truncate and','line_number':1793,'multiline':False]['text':' add 1 to non-integer values. This will also work for values >= INT_MAX + 1,','line_number':1794,'multiline':False]['text':' as the truncate operation will return INT_MIN and we'll fail.','line_number':1795,'multiline':False]['text':' Input is not integer-valued, add 1 to obtain the ceiling value.','line_number':1800,'multiline':False]['text':' If input > INT_MAX, output == INT_MAX so adding 1 will overflow.','line_number':1801,'multiline':False]['text':' x <= -1, truncation is the way to go.','line_number':1805,'multiline':False]['text':' Bail on ]-1; -0] range','line_number':1816,'multiline':False]['text':' Test for remaining values with the sign bit set, i.e. ]-1; -0]','line_number':1824,'multiline':False]['text':' x <= -1 or x >= +0, truncation is the way to go.','line_number':1828,'multiline':False]['text':' Bail on ]-1; -0] range','line_number':1837,'multiline':False]['text':' Test for remaining values with the sign bit set, i.e. ]-1; -0]','line_number':1845,'multiline':False]['text':' x <= -1 or x >= +0, truncation is the way to go.','line_number':1849,'multiline':False]['text':' Branch to a slow path for non-positive inputs. Doesn't catch NaN.','line_number':1860,'multiline':False]['text':' Input is non-negative. Add the biggest float less than 0.5 and truncate,','line_number':1865,'multiline':False]['text':' rounding down (because if the input is the biggest float less than 0.5,','line_number':1866,'multiline':False]['text':' adding 0.5 would undesirably round up to 1). Note that we have to add the','line_number':1867,'multiline':False]['text':' input to the temp register because we're not allowed to modify the input','line_number':1868,'multiline':False]['text':' register.','line_number':1869,'multiline':False]['text':' Input is negative, +0 or -0.','line_number':1875,'multiline':False]['text':' Branch on negative input.','line_number':1878,'multiline':False]['text':' Fail on negative-zero.','line_number':1881,'multiline':False]['text':' Input is +0.','line_number':1884,'multiline':False]['text':' Input is negative.','line_number':1889,'multiline':False]['text':' Inputs in ]-0.5; 0] need to be added 0.5, other negative inputs need to','line_number':1892,'multiline':False]['text':' be added the biggest double less than 0.5.','line_number':1893,'multiline':False]['text':' Add 0.5 and round toward -Infinity. The result is stored in the temp','line_number':1901,'multiline':False]['text':' register (currently contains 0.5).','line_number':1902,'multiline':False]['text':' Truncate.','line_number':1906,'multiline':False]['text':' If the result is positive zero, then the actual result is -0. Fail.','line_number':1909,'multiline':False]['text':' Otherwise, the truncation will have produced the correct negative','line_number':1910,'multiline':False]['text':' integer.','line_number':1911,'multiline':False]['text':' Round toward -Infinity without the benefit of ROUNDSS.','line_number':1915,'multiline':False]['text':' If input + 0.5 >= 0, input is a negative number >= -0.5 and the','line_number':1917,'multiline':False]['text':' result is -0.','line_number':1918,'multiline':False]['text':' Truncate and round toward zero.','line_number':1921,'multiline':False]['text':' This is off-by-one for everything but integer-valued inputs.','line_number':1922,'multiline':False]['text':' Test whether the truncated double was integer-valued.','line_number':1925,'multiline':False]['text':' Input is not integer-valued, so we rounded off-by-one in the','line_number':1929,'multiline':False]['text':' wrong direction. Correct by subtraction.','line_number':1930,'multiline':False]['text':' Cannot overflow: output was already checked against INT_MIN.','line_number':1932,'multiline':False]['text':' Branch to a slow path for non-positive inputs. Doesn't catch NaN.','line_number':1946,'multiline':False]['text':' Input is positive. Add the biggest double less than 0.5 and truncate,','line_number':1951,'multiline':False]['text':' rounding down (because if the input is the biggest double less than 0.5,','line_number':1952,'multiline':False]['text':' adding 0.5 would undesirably round up to 1). Note that we have to add the','line_number':1953,'multiline':False]['text':' input to the temp register because we're not allowed to modify the input','line_number':1954,'multiline':False]['text':' register.','line_number':1955,'multiline':False]['text':' Input is negative, +0 or -0.','line_number':1961,'multiline':False]['text':' Branch on negative input.','line_number':1964,'multiline':False]['text':' Fail on negative-zero.','line_number':1967,'multiline':False]['text':' maybeNonZero = ','line_number':1968,'multiline':True]['text':' Input is +0','line_number':1970,'multiline':False]['text':' Input is negative.','line_number':1975,'multiline':False]['text':' Inputs in ]-0.5; 0] need to be added 0.5, other negative inputs need to','line_number':1978,'multiline':False]['text':' be added the biggest double less than 0.5.','line_number':1979,'multiline':False]['text':' Add 0.5 and round toward -Infinity. The result is stored in the temp','line_number':1987,'multiline':False]['text':' register (currently contains 0.5).','line_number':1988,'multiline':False]['text':' Truncate.','line_number':1992,'multiline':False]['text':' If the result is positive zero, then the actual result is -0. Fail.','line_number':1995,'multiline':False]['text':' Otherwise, the truncation will have produced the correct negative','line_number':1996,'multiline':False]['text':' integer.','line_number':1997,'multiline':False]['text':' Round toward -Infinity without the benefit of ROUNDSD.','line_number':2001,'multiline':False]['text':' If input + 0.5 >= 0, input is a negative number >= -0.5 and the','line_number':2003,'multiline':False]['text':' result is -0.','line_number':2004,'multiline':False]['text':' Truncate and round toward zero.','line_number':2007,'multiline':False]['text':' This is off-by-one for everything but integer-valued inputs.','line_number':2008,'multiline':False]['text':' Test whether the truncated double was integer-valued.','line_number':2011,'multiline':False]['text':' Input is not integer-valued, so we rounded off-by-one in the','line_number':2015,'multiline':False]['text':' wrong direction. Correct by subtraction.','line_number':2016,'multiline':False]['text':' Cannot overflow: output was already checked against INT_MIN.','line_number':2018,'multiline':False]['text':'}}} check_macroassembler_style','line_number':2068,'multiline':False]