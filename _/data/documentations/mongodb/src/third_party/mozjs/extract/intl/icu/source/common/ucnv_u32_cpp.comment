['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'  
**********************************************************************
*   Copyright (C) 2002-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   file name:  ucnv_u32.c
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2002jul01
*   created by: Markus W. Scherer
*
*   UTF-32 converter implementation. Used to be in ucnv_utf.c.
','line_number':3,'multiline':True]['text':' -SURROGATE_LOW_START + HALF_BASE ','line_number':37,'multiline':True]['text':' UTF-32BE ----------------------------------------------------------------- ','line_number':44,'multiline':True]['text':' Restore state of current sequence ','line_number':57,'multiline':True]['text':' restore # of bytes consumed ','line_number':59,'multiline':True]['text':'Stores the previously calculated ch from a previous call','line_number':62,'multiline':True]['text':' stores a partially calculated target','line_number':77,'multiline':True]['text':' + 1 to make 0 a valid character ','line_number':78,'multiline':True]['text':' Normal valid byte when the loop has not prematurely terminated (i < inBytes) ','line_number':86,'multiline':True]['text':' fits in 16 bits ','line_number':89,'multiline':True]['text':' write out the surrogates ','line_number':93,'multiline':True]['text':' Put in overflow buffer (not handled here) ','line_number':100,'multiline':True]['text':' End of target buffer ','line_number':117,'multiline':True]['text':' Restore state of current sequence ','line_number':138,'multiline':True]['text':' restore # of bytes consumed ','line_number':140,'multiline':True]['text':'Stores the previously calculated ch from a previous call','line_number':143,'multiline':True]['text':' stores a partially calculated target','line_number':158,'multiline':True]['text':' + 1 to make 0 a valid character ','line_number':159,'multiline':True]['text':' Normal valid byte when the loop has not prematurely terminated (i < inBytes) ','line_number':167,'multiline':True]['text':' fits in 16 bits ','line_number':169,'multiline':True]['text':' write out the surrogates ','line_number':174,'multiline':True]['text':' Put in overflow buffer (not handled here) ','line_number':184,'multiline':True]['text':' End of target buffer ','line_number':203,'multiline':True]['text':' no input, nothing to do ','line_number':225,'multiline':True]['text':' write the BOM if necessary ','line_number':229,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':262,'multiline':True]['text':' callback(illegal) ','line_number':263,'multiline':True]['text':' ran out of source ','line_number':270,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':273,'multiline':True]['text':' callback(illegal) ','line_number':274,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':281,'multiline':True]['text':' callback(illegal) ','line_number':282,'multiline':True]['text':' We cannot get any larger than 10FFFF because we are coming from UTF-16 ','line_number':289,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':291,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':292,'multiline':True]['text':' no input, nothing to do ','line_number':328,'multiline':True]['text':' write the BOM if necessary ','line_number':332,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':366,'multiline':True]['text':' callback(illegal) ','line_number':367,'multiline':True]['text':' ran out of source ','line_number':374,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':377,'multiline':True]['text':' callback(illegal) ','line_number':378,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':385,'multiline':True]['text':' callback(illegal) ','line_number':386,'multiline':True]['text':' We cannot get any larger than 10FFFF because we are coming from UTF-16 ','line_number':393,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':395,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':396,'multiline':True]['text':' no input ','line_number':431,'multiline':True]['text':' got a partial character ','line_number':439,'multiline':True]['text':' Don't even try to do a direct cast because the value may be on an odd address. ','line_number':447,'multiline':True]['text':' The 1232 CCSID refers to any version of Unicode with any endianess of UTF-32 ','line_number':491,'multiline':True]['text':' reserved ','line_number':500,'multiline':True]['text':' UTF-32LE ---------------------------------------------------------- ','line_number':506,'multiline':True]['text':' Restore state of current sequence ','line_number':519,'multiline':True]['text':' restore # of bytes consumed ','line_number':522,'multiline':True]['text':' Stores the previously calculated ch from a previous call','line_number':525,'multiline':True]['text':' stores a partially calculated target','line_number':545,'multiline':True]['text':' + 1 to make 0 a valid character ','line_number':546,'multiline':True]['text':' Normal valid byte when the loop has not prematurely terminated (i < inBytes) ','line_number':554,'multiline':True]['text':' fits in 16 bits ','line_number':556,'multiline':True]['text':' write out the surrogates ','line_number':560,'multiline':True]['text':' Put in overflow buffer (not handled here) ','line_number':567,'multiline':True]['text':' End of target buffer ','line_number':585,'multiline':True]['text':' Restore state of current sequence ','line_number':606,'multiline':True]['text':' restore # of bytes consumed ','line_number':609,'multiline':True]['text':' Stores the previously calculated ch from a previous call','line_number':612,'multiline':True]['text':' stores a partially calculated target','line_number':632,'multiline':True]['text':' + 1 to make 0 a valid character ','line_number':633,'multiline':True]['text':' Normal valid byte when the loop has not prematurely terminated (i < inBytes) ','line_number':642,'multiline':True]['text':' fits in 16 bits ','line_number':645,'multiline':True]['text':' write out the surrogates ','line_number':650,'multiline':True]['text':' Put in overflow buffer (not handled here) ','line_number':661,'multiline':True]['text':' End of target buffer ','line_number':681,'multiline':True]['text':' no input, nothing to do ','line_number':703,'multiline':True]['text':' write the BOM if necessary ','line_number':707,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':744,'multiline':True]['text':' callback(illegal) ','line_number':745,'multiline':True]['text':' ran out of source ','line_number':752,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':755,'multiline':True]['text':' callback(illegal) ','line_number':756,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':763,'multiline':True]['text':' callback(illegal) ','line_number':764,'multiline':True]['text':' We cannot get any larger than 10FFFF because we are coming from UTF-16 ','line_number':771,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':773,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':774,'multiline':True]['text':' no input, nothing to do ','line_number':814,'multiline':True]['text':' write the BOM if necessary ','line_number':818,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':857,'multiline':True]['text':' callback(illegal) ','line_number':858,'multiline':True]['text':' ran out of source ','line_number':865,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':868,'multiline':True]['text':' callback(illegal) ','line_number':869,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':876,'multiline':True]['text':' callback(illegal) ','line_number':877,'multiline':True]['text':' We cannot get any larger than 10FFFF because we are coming from UTF-16 ','line_number':884,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':886,'multiline':True]['text':' unsigned cast implicitly does (ch & FF) ','line_number':887,'multiline':True]['text':' no input ','line_number':926,'multiline':True]['text':' got a partial character ','line_number':934,'multiline':True]['text':' Don't even try to do a direct cast because the value may be on an odd address. ','line_number':942,'multiline':True]['text':' The 1232 CCSID refers to any version of Unicode with any endianess of UTF-32 ','line_number':986,'multiline':True]['text':' reserved ','line_number':995,'multiline':True]['text':' UTF-32 (Detect BOM) ------------------------------------------------------ ','line_number':1002,'multiline':True]['text':'
 * Detect a BOM at the beginning of the stream and select UTF-32BE or UTF-32LE
 * accordingly.
 *
 * State values:
 * 0    initial state
 * 1    saw 00
 * 2    saw 00 00
 * 3    saw 00 00 FE
 * 4    -
 * 5    saw FF
 * 6    saw FF FE
 * 7    saw FF FE 00
 * 8    UTF-32BE mode
 * 9    UTF-32LE mode
 *
 * During detection: state&3==number of matching bytes so far.
 *
 * On output, emit U+FEFF as the first code point.
 ','line_number':1004,'multiline':True]['text':' reset toUnicode: state=0 ','line_number':1028,'multiline':True]['text':' reset fromUnicode: prepare to output the UTF-32PE BOM ','line_number':1032,'multiline':True]['text':'
     * If we detect a BOM in this buffer, then we must add the BOM size to the
     * offsets because the actual converter function will not see and count the BOM.
     * offsetDelta will have the number of the BOM bytes that are in the current buffer.
     ','line_number':1061,'multiline':True]['text':' could be 00 00 FE FF ','line_number':1073,'multiline':True]['text':' could be FF FE 00 00 ','line_number':1075,'multiline':True]['text':' default to UTF-32BE ','line_number':1077,'multiline':True]['text':' detect UTF-32BE ','line_number':1092,'multiline':True]['text':' detect UTF-32LE ','line_number':1095,'multiline':True]['text':' switch to UTF-32BE and pass the previous bytes ','line_number':1099,'multiline':True]['text':' number of bytes from this buffer ','line_number':1100,'multiline':True]['text':' reset the source ','line_number':1102,'multiline':True]['text':' simple: all in the same buffer, just reset source ','line_number':1106,'multiline':True]['text':' some of the bytes are from a previous buffer, replay those first ','line_number':1110,'multiline':True]['text':' select the correct BOM ','line_number':1111,'multiline':True]['text':' replay previous bytes ','line_number':1112,'multiline':True]['text':' this sourceLimit is not the real source stream limit ','line_number':1113,'multiline':True]['text':' no offsets: bytes from previous buffer, and not enough for output ','line_number':1115,'multiline':True]['text':' restore real pointers; pArgs->source will be set in case 8/9 ','line_number':1118,'multiline':True]['text':' call UTF-32BE ','line_number':1127,'multiline':True]['text':' call UTF-32LE ','line_number':1137,'multiline':True]['text':' does not occur ','line_number':1147,'multiline':True]['text':' add BOM size to offsets - see comment at offsetDelta declaration ','line_number':1151,'multiline':True]['text':' handle truncated input ','line_number':1162,'multiline':True]['text':' no input at all, nothing to do ','line_number':1165,'multiline':True]['text':' handle 0<state<8: call UTF-32BE with too-short input ','line_number':1173,'multiline':True]['text':' select the correct BOM ','line_number':1174,'multiline':True]['text':' replay bytes ','line_number':1175,'multiline':True]['text':' no offsets: not enough for output ','line_number':1177,'multiline':True]['text':' ### TODO implement getStarters for all Unicode encodings?! ','line_number':1223,'multiline':True]['text':' The 1236 CCSID refers to any version of Unicode with a BOM sensitive endianess of UTF-32 ','line_number':1233,'multiline':True]['text':' reserved ','line_number':1247,'multiline':True]