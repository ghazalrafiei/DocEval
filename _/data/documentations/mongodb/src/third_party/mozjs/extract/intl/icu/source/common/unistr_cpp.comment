['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
******************************************************************************
* Copyright (C) 1999-2016, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*
* File unistr.cpp
*
* Modification History:
*
*   Date        Name        Description
*   09/25/98    stephen     Creation.
*   04/20/99    stephen     Overhauled per 4/16 code review.
*   07/09/99    stephen     Renamed {hi,lo},{byte,word} to icu_X for HP/UX
*   11/18/99    aliu        Added handleReplaceBetween() to make inherit from
*                           Replaceable.
*   06/25/01    grhoten     Removed the dependency on iostream
******************************************************************************
','line_number':3,'multiline':True]['text':'DEBUGGING','line_number':42,'multiline':False]['text':' END DEBUGGING','line_number':75,'multiline':False]['text':' Local function definitions for now','line_number':78,'multiline':False]['text':' need to copy areas that may overlap','line_number':80,'multiline':False]['text':' u_unescapeAt() callback to get a UChar from a UnicodeString','line_number':91,'multiline':False]['text':' The Replaceable virtual destructor can't be defined in the header
   due to how AIX works with multiple definitions of virtual functions.
','line_number':101,'multiline':True]['text':'========================================','line_number':116,'multiline':False]['text':' Reference Counting functions, put at top of file so that optimizing compilers','line_number':117,'multiline':False]['text':'                               have a chance to automatically inline.','line_number':118,'multiline':False]['text':'========================================','line_number':119,'multiline':False]['text':'========================================','line_number':145,'multiline':False]['text':' Constructors','line_number':146,'multiline':False]['text':'========================================','line_number':147,'multiline':False]['text':' The default constructor is inline in unistr.h.','line_number':149,'multiline':False]['text':' just allocate and do not do anything else','line_number':154,'multiline':False]['text':' supplementary code point, write surrogate pairs','line_number':169,'multiline':False]['text':' We would get more than 2G UChars.','line_number':171,'multiline':False]['text':' We test isError so that the compiler does not complain that we don't.','line_number':202,'multiline':False]['text':' If isError then i==0 which is what we want anyway.','line_number':203,'multiline':False]['text':' treat as an empty string, do not alias','line_number':226,'multiline':False]['text':' text is terminated, or else it would have failed the above test','line_number':235,'multiline':False]['text':' treat as an empty string, do not alias','line_number':248,'multiline':False]['text':' fLength = u_strlen(buff); but do not look beyond buffCapacity','line_number':254,'multiline':False]['text':' treat as an empty string','line_number':268,'multiline':False]['text':' if there's nothing to convert, do nothing','line_number':293,'multiline':False]['text':' else see unistr_cnv.cpp','line_number':303,'multiline':False]['text':' Replaceable base class clone() default implementation, does not clone','line_number':328,'multiline':False]['text':' UnicodeString overrides clone() with a real implementation','line_number':334,'multiline':False]['text':'========================================','line_number':340,'multiline':False]['text':' array allocation','line_number':341,'multiline':False]['text':'========================================','line_number':342,'multiline':False]['text':' The number of bytes for one int32_t reference counter and capacity UChars','line_number':348,'multiline':False]['text':' must fit into a 32-bit size_t (at least when on a 32-bit platform).','line_number':349,'multiline':False]['text':' We also add one for the NUL terminator, to avoid reallocation in getTerminatedBuffer(),','line_number':350,'multiline':False]['text':' and round up to a multiple of 16 bytes.','line_number':351,'multiline':False]['text':' This means that capacity must be at most (0xfffffff0 - 4) / 2 - 1 = 0x7ffffff5.','line_number':352,'multiline':False]['text':' (With more complicated checks we could go up to 0x7ffffffd without rounding up,','line_number':353,'multiline':False]['text':' but that does not seem worth it.)','line_number':354,'multiline':False]['text':' namespace','line_number':366,'multiline':False]['text':' for the NUL','line_number':375,'multiline':False]['text':' Switch to size_t which is unsigned so that we can allocate up to 4GB.','line_number':376,'multiline':False]['text':' Reference counter + UChars.','line_number':377,'multiline':False]['text':' Round up to a multiple of 16.','line_number':379,'multiline':False]['text':' set initial refCount and point behind the refCount','line_number':383,'multiline':False]['text':' have fArray point to the first UChar','line_number':387,'multiline':False]['text':'========================================','line_number':400,'multiline':False]['text':' Destructor','line_number':401,'multiline':False]['text':'========================================','line_number':402,'multiline':False]['text':' UnicodeString::kMaxShortLength+1','line_number':405,'multiline':False]['text':' Count lengths of strings at the end of their lifetime.','line_number':424,'multiline':False]['text':' Useful for discussion of a desirable stack buffer size.','line_number':425,'multiline':False]['text':' Count the contents length, not the optional NUL terminator nor further capacity.','line_number':426,'multiline':False]['text':' Ignore open-buffer strings and strings which alias external storage.','line_number':427,'multiline':False]['text':'========================================','line_number':440,'multiline':False]['text':' Factory methods','line_number':441,'multiline':False]['text':'========================================','line_number':442,'multiline':False]['text':' Most UTF-32 strings will be BMP-only and result in a same-length','line_number':453,'multiline':False]['text':' UTF-16 string. We overestimate the capacity just slightly,','line_number':454,'multiline':False]['text':' just in case there are a few supplementary characters.','line_number':455,'multiline':False]['text':' Substitution character.','line_number':467,'multiline':False]['text':' Don't care about number of substitutions.','line_number':468,'multiline':False]['text':' +1 for the terminating NUL.','line_number':472,'multiline':False]['text':'========================================','line_number':482,'multiline':False]['text':' Assignment','line_number':483,'multiline':False]['text':'========================================','line_number':484,'multiline':False]['text':' if assigning to ourselves, do nothing','line_number':498,'multiline':False]['text':' is the right side bogus?','line_number':503,'multiline':False]['text':' delete the current contents','line_number':509,'multiline':False]['text':' empty string - use the stack buffer','line_number':513,'multiline':False]['text':' fLength>0 and not an "open" src.getBuffer(minCapacity)','line_number':518,'multiline':False]['text':' short string using the stack buffer, do the same','line_number':522,'multiline':False]['text':' src uses a refCounted string buffer, use that buffer with refCount','line_number':527,'multiline':False]['text':' src is const, use a cast - we don't actually change it','line_number':528,'multiline':False]['text':' copy all fields, share the reference-counted buffer','line_number':530,'multiline':False]['text':' src is a readonly alias, do the same','line_number':539,'multiline':False]['text':' -> maintain the readonly alias as such','line_number':540,'multiline':False]['text':' else if(!fastCopy) fall through to case kWritableAlias','line_number':548,'multiline':False]['text':' -> allocate a new buffer and copy the contents','line_number':549,'multiline':False]['text':' src is a writable alias; we make a copy of that instead','line_number':552,'multiline':False]['text':' if there is not enough memory, then fall through to setting to bogus','line_number':559,'multiline':False]['text':' if src is bogus, set ourselves to bogus','line_number':563,'multiline':False]['text':' do not call setToBogus() here because fArray and flags are not consistent here','line_number':564,'multiline':False]['text':' No explicit check for self move assignment, consistent with standard library.','line_number':575,'multiline':False]['text':' Self move assignment causes no crash nor leak but might make the object bogus.','line_number':576,'multiline':False]['text':' Same as move assignment except without memory management.','line_number':582,'multiline':False]['text':' Short string using the stack buffer, copy the contents.','line_number':586,'multiline':False]['text':' Check for self assignment to prevent "overlap in memcpy" warnings,','line_number':587,'multiline':False]['text':' although it should be harmless to copy a buffer to itself exactly.','line_number':588,'multiline':False]['text':' In all other cases, copy all fields.','line_number':594,'multiline':False]['text':' Set src to bogus without releasing any memory.','line_number':601,'multiline':False]['text':' Empty short string: Known not to need releaseArray().','line_number':610,'multiline':False]['text':' Copy fields without resetting source values in between.','line_number':611,'multiline':False]['text':' Set temp to an empty string so that other's memory is not released twice.','line_number':615,'multiline':False]['text':'========================================','line_number':619,'multiline':False]['text':' Miscellaneous operations','line_number':620,'multiline':False]['text':'========================================','line_number':621,'multiline':False]['text':' construct with capacity','line_number':624,'multiline':False]['text':''\\'','line_number':636,'multiline':True]['text':' advances i','line_number':638,'multiline':False]['text':' return empty string','line_number':640,'multiline':False]['text':' invalid escape sequence','line_number':641,'multiline':False]['text':'========================================','line_number':654,'multiline':False]['text':' Read-only implementation','line_number':655,'multiline':False]['text':'========================================','line_number':656,'multiline':False]['text':' Requires: this & text not bogus and have same lengths.','line_number':659,'multiline':False]['text':' Byte-wise comparison works for equality regardless of endianness.','line_number':660,'multiline':False]['text':' compare illegal string values','line_number':671,'multiline':False]['text':' pin indices to legal values','line_number':676,'multiline':False]['text':' treat const UChar *srcChars==NULL as an empty string','line_number':680,'multiline':False]['text':' get the correct pointer','line_number':684,'multiline':False]['text':' get the srcLength if necessary','line_number':693,'multiline':False]['text':' are we comparing different lengths?','line_number':698,'multiline':False]['text':'
   * note that uprv_memcmp() returns an int but we return an int8_t;
   * we need to take care not to truncate the result -
   * one way to do this is to right-shift the value to
   * move the sign bit into the lower 8 bits and making sure that this
   * does not become 0 itself
   ','line_number':712,'multiline':True]['text':' big-endian: byte comparison works','line_number':724,'multiline':False]['text':' little-endian: compare UChar units','line_number':730,'multiline':False]['text':' String compare in code point order - doCompare() compares in code unit order. ','line_number':742,'multiline':True]['text':' compare illegal string values','line_number':750,'multiline':False]['text':' treat const UChar *srcChars==NULL as an empty string','line_number':751,'multiline':False]['text':' pin indices to legal values','line_number':756,'multiline':False]['text':' translate the 32-bit result into an 8-bit one ','line_number':764,'multiline':True]['text':' if(isBogus()) then fArray==0 and start==0 - u_countChar32() checks for NULL','line_number':827,'multiline':False]['text':' if(isBogus()) then fArray==0 and start==0 - u_strHasMoreChar32Than() checks for NULL','line_number':834,'multiline':False]['text':' pin index','line_number':840,'multiline':False]['text':' pin indices to legal values','line_number':864,'multiline':False]['text':' do not copy anything if we alias dst itself','line_number':867,'multiline':False]['text':' if the arguments are illegal, then do nothing','line_number':900,'multiline':False]['text':' pin the indices to legal values','line_number':905,'multiline':False]['text':' not getArrayStart() to check kIsBogus & kOpenGetBuffer','line_number':918,'multiline':False]['text':' anything not NULL because that would make an empty string','line_number':920,'multiline':False]['text':' bogus result string','line_number':921,'multiline':False]['text':' Standard substitution character.','line_number':934,'multiline':False]['text':' Don't care about number of substitutions.','line_number':935,'multiline':False]['text':' if the arguments are illegal, then do nothing','line_number':945,'multiline':False]['text':'dstSize < 0 || ','line_number':946,'multiline':True]['text':' else see unistr_cnv.cpp','line_number':952,'multiline':False]['text':' When converting from UTF-16 to UTF-8, the result will have at most 3 times','line_number':964,'multiline':False]['text':' as many bytes as the source has UChars.','line_number':965,'multiline':False]['text':' The "worst cases" are writing systems like Indic, Thai and CJK with','line_number':966,'multiline':False]['text':' 3:1 bytes:UChars.','line_number':967,'multiline':False]['text':' Standard substitution character.','line_number':983,'multiline':False]['text':' Don't care about number of substitutions.','line_number':984,'multiline':False]['text':' Standard substitution character.','line_number':993,'multiline':False]['text':' Don't care about number of substitutions.','line_number':994,'multiline':False]['text':' getBuffer() and u_strToUTF32WithSub() check for illegal arguments.','line_number':1014,'multiline':False]['text':' Substitution character.','line_number':1017,'multiline':False]['text':' Don't care about number of substitutions.','line_number':1018,'multiline':False]['text':' UnicodeString does not find empty substrings','line_number':1035,'multiline':False]['text':' get the indices within bounds','line_number':1040,'multiline':False]['text':' find the first occurrence of the substring','line_number':1043,'multiline':False]['text':' pin indices','line_number':1058,'multiline':False]['text':' find the first occurrence of c','line_number':1061,'multiline':False]['text':' pin indices','line_number':1075,'multiline':False]['text':' find the first occurrence of c','line_number':1078,'multiline':False]['text':' UnicodeString does not find empty substrings','line_number':1099,'multiline':False]['text':' get the indices within bounds','line_number':1104,'multiline':False]['text':' find the last occurrence of the substring','line_number':1107,'multiline':False]['text':' pin indices','line_number':1126,'multiline':False]['text':' find the last occurrence of c','line_number':1129,'multiline':False]['text':' pin indices','line_number':1143,'multiline':False]['text':' find the last occurrence of c','line_number':1146,'multiline':False]['text':'========================================','line_number':1156,'multiline':False]['text':' Write implementation','line_number':1157,'multiline':False]['text':'========================================','line_number':1158,'multiline':False]['text':' no more oldText's here: done','line_number':1185,'multiline':False]['text':' we found oldText, replace it by newText and go beyond it','line_number':1188,'multiline':False]['text':' turn a bogus string into an empty one','line_number':1209,'multiline':False]['text':' If len<capacity on a read-only alias, then array[len] is','line_number':1226,'multiline':False]['text':' either the original NUL (if constructed with (TRUE, s, length))','line_number':1227,'multiline':False]['text':' or one of the original string contents characters (if later truncated),','line_number':1228,'multiline':False]['text':' therefore we can assume that array[len] is initialized memory.','line_number':1229,'multiline':False]['text':' kRefCounted: Do not write the NUL if the buffer is shared.','line_number':1234,'multiline':False]['text':' That is mostly safe, except when the length of one copy was modified','line_number':1235,'multiline':False]['text':' without copy-on-write, e.g., via truncate(newLength) or remove(void).','line_number':1236,'multiline':False]['text':' Then the NUL would be written into the middle of another copy's string.','line_number':1237,'multiline':False]['text':' Otherwise, the buffer is fully writable and it is anyway safe to write the NUL.','line_number':1239,'multiline':False]['text':' Do not test if there is a NUL already because it might be uninitialized memory.','line_number':1240,'multiline':False]['text':' (That would be safe, but tools like valgrind & Purify would complain.)','line_number':1241,'multiline':False]['text':' setTo() analogous to the readonly-aliasing constructor with the same signature','line_number':1255,'multiline':False]['text':' do not modify a string that has an "open" getBuffer(minCapacity)','line_number':1262,'multiline':False]['text':' treat as an empty string, do not alias','line_number':1268,'multiline':False]['text':' text is terminated, or else it would have failed the above test','line_number':1285,'multiline':False]['text':' setTo() analogous to the writable-aliasing constructor with the same signature','line_number':1293,'multiline':False]['text':' do not modify a string that has an "open" getBuffer(minCapacity)','line_number':1299,'multiline':False]['text':' treat as an empty string, do not alias','line_number':1304,'multiline':False]['text':' buffLength = u_strlen(buff); but do not look beyond buffCapacity','line_number':1314,'multiline':False]['text':' The UTF-16 string will be at most as long as the UTF-8 string.','line_number':1333,'multiline':False]['text':' +1 for the terminating NUL.','line_number':1337,'multiline':False]['text':' Substitution character.','line_number':1344,'multiline':False]['text':' Don't care about number of substitutions.','line_number':1345,'multiline':False]['text':' We test isError so that the compiler does not complain that we don't.','line_number':1379,'multiline':False]['text':' If isError (srcChar is not a valid code point) then count==0 which means','line_number':1380,'multiline':False]['text':' we remove the source segment rather than replacing it with srcChar.','line_number':1381,'multiline':False]['text':' We test isError so that the compiler does not complain that we don't.','line_number':1391,'multiline':False]['text':' If isError then _length==0 which turns the doAppend() into a no-op anyway.','line_number':1392,'multiline':False]['text':' pin the indices to legal values','line_number':1403,'multiline':False]['text':' get the characters from src','line_number':1406,'multiline':False]['text':' and replace the range in ourselves with them','line_number':1407,'multiline':False]['text':' optimize (read-only alias).remove(0, start) and .remove(start, end)','line_number':1424,'multiline':False]['text':' remove prefix by adjusting the array pointer','line_number':1427,'multiline':False]['text':' remove suffix by reducing the length (like truncate())','line_number':1436,'multiline':False]['text':' not NUL-terminated any more','line_number':1438,'multiline':False]['text':' Perform all remaining operations relative to srcChars + srcStart.','line_number':1451,'multiline':False]['text':' From this point forward, do not use srcStart.','line_number':1452,'multiline':False]['text':' get the srcLength if necessary','line_number':1455,'multiline':False]['text':' pin the indices to legal values','line_number':1460,'multiline':False]['text':' Calculate the size of the string after the replace.','line_number':1463,'multiline':False]['text':' Avoid int32_t overflow.','line_number':1464,'multiline':False]['text':' Check for insertion into ourself','line_number':1472,'multiline':False]['text':' Copy into a new UnicodeString and start over','line_number':1477,'multiline':False]['text':' cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;','line_number':1486,'multiline':False]['text':' therefore we need to keep the current fArray','line_number':1487,'multiline':False]['text':' copy the stack buffer contents because it will be overwritten with','line_number':1490,'multiline':False]['text':' fUnion.fFields values','line_number':1491,'multiline':False]['text':' clone our array and allocate a bigger array if needed','line_number':1496,'multiline':False]['text':' now do the replace','line_number':1504,'multiline':False]['text':' if fArray changed, then we need to copy everything except what will change','line_number':1508,'multiline':False]['text':' fArray did not change; copy only the portion that isn't changing, leaving a hole','line_number':1514,'multiline':False]['text':' now fill in the hole with the new string','line_number':1520,'multiline':False]['text':' delayed delete in case srcChars == fArray when we started, and','line_number':1525,'multiline':False]['text':' to keep oldArray alive for the above operations','line_number':1526,'multiline':False]['text':' Versions of doReplace() only for append() variants.','line_number':1534,'multiline':False]['text':' doReplace() and doAppend() optimize for different cases.','line_number':1535,'multiline':False]['text':' pin the indices to legal values','line_number':1543,'multiline':False]['text':' Perform all remaining operations relative to srcChars + srcStart.','line_number':1554,'multiline':False]['text':' From this point forward, do not use srcStart.','line_number':1555,'multiline':False]['text':' get the srcLength if necessary','line_number':1559,'multiline':False]['text':' Check for append onto ourself','line_number':1572,'multiline':False]['text':' Copy into a new UnicodeString and start over','line_number':1577,'multiline':False]['text':' optimize append() onto a large-enough, owned string','line_number':1586,'multiline':False]['text':' Do not copy characters when','line_number':1590,'multiline':False]['text':'   UChar *buffer=str.getAppendBuffer(...);','line_number':1591,'multiline':False]['text':' is followed by','line_number':1592,'multiline':False]['text':'   str.append(buffer, length);','line_number':1593,'multiline':False]['text':' or','line_number':1594,'multiline':False]['text':'   str.appendString(buffer, length)','line_number':1595,'multiline':False]['text':' or similar.','line_number':1596,'multiline':False]['text':'*
 * Replaceable API
 ','line_number':1605,'multiline':True]['text':'*
 * Replaceable API
 ','line_number':1615,'multiline':True]['text':' Nothing to do; avoid bogus malloc call','line_number':1621,'multiline':False]['text':' Check to make sure text is not null.','line_number':1624,'multiline':False]['text':'*
 * Replaceable API
 *
 * NOTE: This is for the Replaceable class.  There is no rep.cpp,
 * so we implement this function here.
 ','line_number':1632,'multiline':True]['text':'*
 * Replaceable API
 ','line_number':1642,'multiline':True]['text':' pin the indices to legal values','line_number':1655,'multiline':False]['text':' pinIndices() might have shrunk the length','line_number':1657,'multiline':False]['text':' -1 for inclusive boundary (length>=2)','line_number':1662,'multiline':False]['text':' Before the loop we know left<right because length>=2.','line_number':1666,'multiline':False]['text':' Make sure to test the middle code unit of an odd-length string.','line_number':1672,'multiline':False]['text':' Redundant if the length is even.','line_number':1673,'multiline':False]['text':' if there are supplementary code points in the reversed range, then re-swap their surrogates ','line_number':1676,'multiline':True]['text':' -1 so that we can look at *(left+1) if left<right','line_number':1681,'multiline':False]['text':' move contents up by padding width','line_number':1703,'multiline':False]['text':' fill in padding character','line_number':1708,'multiline':False]['text':' fill in padding character','line_number':1725,'multiline':False]['text':'========================================','line_number':1736,'multiline':False]['text':' Hashing','line_number':1737,'multiline':False]['text':'========================================','line_number':1738,'multiline':False]['text':' Delegate hash computation to uhash.  This makes UnicodeString
     * hashing consistent with UChar* hashing.  ','line_number':1742,'multiline':True]['text':'========================================','line_number':1751,'multiline':False]['text':' External Buffer','line_number':1752,'multiline':False]['text':'========================================','line_number':1753,'multiline':False]['text':' set the new fLength','line_number':1769,'multiline':False]['text':' the new length is the string length, capped by fCapacity','line_number':1772,'multiline':False]['text':'========================================','line_number':1786,'multiline':False]['text':' Miscellaneous','line_number':1787,'multiline':False]['text':'========================================','line_number':1788,'multiline':False]['text':' default parameters need to be static, therefore','line_number':1795,'multiline':False]['text':' the defaults are -1 to have convenience defaults','line_number':1796,'multiline':False]['text':' while a getBuffer(minCapacity) is "open",','line_number':1801,'multiline':False]['text':' prevent any modifications of the string by returning FALSE here','line_number':1802,'multiline':False]['text':' if the string is bogus, then only an assignment or similar can revive it','line_number':1803,'multiline':False]['text':'
   * We need to make a copy of the array if
   * the buffer is read-only, or
   * the buffer is refCounted (shared), and refCount>1, or
   * the buffer is too small.
   * Return FALSE if memory could not be allocated.
   ','line_number':1808,'multiline':True]['text':' check growCapacity for default value and use of the stack buffer','line_number':1820,'multiline':False]['text':' save old values','line_number':1827,'multiline':False]['text':' kRefCounted and kUsingStackBuffer are mutally exclusive ','line_number':1834,'multiline':True]['text':' copy the stack buffer contents because it will be overwritten with','line_number':1836,'multiline':False]['text':' fUnion.fFields values','line_number':1837,'multiline':False]['text':' no need to copy from the stack buffer to itself','line_number':1841,'multiline':False]['text':' when stack buffer is not used, oldArray must have a non-NULL reference ','line_number':1845,'multiline':True]['text':' allocate a new array','line_number':1848,'multiline':False]['text':' copy the contents','line_number':1853,'multiline':False]['text':' do not copy more than what fits - it may be smaller than before','line_number':1854,'multiline':False]['text':' release the old array','line_number':1868,'multiline':False]['text':' the array is refCounted; decrement and release if 0','line_number':1870,'multiline':False]['text':' Note: cast to (void *) is needed with MSVC, where u_atomic_int32_t','line_number':1874,'multiline':False]['text':' is defined as volatile. (Volatile has useful non-standard behavior','line_number':1875,'multiline':False]['text':'   with this compiler.)','line_number':1876,'multiline':False]['text':' the caller requested to delete it himself','line_number':1879,'multiline':False]['text':' not enough memory for growCapacity and not even for the smaller newCapacity','line_number':1885,'multiline':False]['text':' reset the old values for setToBogus() to release the array','line_number':1886,'multiline':False]['text':' UnicodeStringAppendable ------------------------------------------------- ***','line_number':1898,'multiline':False]['text':' Moved here from uhash_us.cpp so that using a UVector of UnicodeString*','line_number':1956,'multiline':False]['text':' does not depend on hashtable code.','line_number':1957,'multiline':False]['text':'
This should never be called. It is defined here to make sure that the
virtual vector deleting destructor is defined within unistr.cpp.
The vector deleting destructor is already a part of UObject,
but defining it here makes sure that it is included with this object file.
This makes sure that static library dependencies are kept to a minimum.
','line_number':1972,'multiline':True]