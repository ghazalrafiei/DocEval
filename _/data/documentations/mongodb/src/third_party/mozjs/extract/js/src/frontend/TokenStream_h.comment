['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'
 * Streaming access to the raw tokens of JavaScript source.
 *
 * Because JS tokenization is context-sensitive -- a '/' could be either a
 * regular expression *or* a division operator depending on context -- the
 * various token stream classes are mostly not useful outside of the Parser
 * where they reside.  We should probably eventually merge the two concepts.
 ','line_number':7,'multiline':True]['text':'
 * [SMDOC] Parser Token Stream
 *
 * A token stream exposes the raw tokens -- operators, names, numbers,
 * keywords, and so on -- of JavaScript source code.
 *
 * These are the components of the overall token stream concept:
 * TokenStreamShared, TokenStreamAnyChars, TokenStreamCharsBase<Unit>,
 * TokenStreamChars<Unit>, and TokenStreamSpecific<Unit, AnyCharsAccess>.
 *
 * == TokenStreamShared → ∅ ==
 *
 * Certain aspects of tokenizing are used everywhere:
 *
 *   * modifiers (used to select which context-sensitive interpretation of a
 *     character should be used to decide what token it is) and modifier
 *     assertion handling;
 *   * flags on the overall stream (have we encountered any characters on this
 *     line?  have we hit a syntax error?  and so on);
 *   * and certain token-count constants.
 *
 * These are all defined in TokenStreamShared.  (They could be namespace-
 * scoped, but it seems tentatively better not to clutter the namespace.)
 *
 * == TokenStreamAnyChars → TokenStreamShared ==
 *
 * Certain aspects of tokenizing have meaning independent of the character type
 * of the source text being tokenized: line/column number information, tokens
 * in lookahead from determining the meaning of a prior token, compilation
 * options, the filename, flags, source map URL, access to details of the
 * current and next tokens (is the token of the given type?  what name or
 * number is contained in the token?  and other queries), and others.
 *
 * All this data/functionality *could* be duplicated for both single-byte and
 * double-byte tokenizing, but there are two problems.  First, it's potentially
 * wasteful if the compiler doesnt recognize it can unify the concepts.  (And
 * if any-character concepts are intermixed with character-specific concepts,
 * potentially the compiler *can't* unify them because offsets into the
 * hypothetical TokenStream<Unit>s would differ.)  Second, some of this stuff
 * needs to be accessible in ParserBase, the aspects of JS language parsing
 * that have meaning independent of the character type of the source text being
 * parsed.  So we need a separate data structure that ParserBase can hold on to
 * for it.  (ParserBase isn't the only instance of this, but it's certainly the
 * biggest case of it.)  Ergo, TokenStreamAnyChars.
 *
 * == TokenStreamCharsShared → ∅ ==
 *
 * Some functionality has meaning independent of character type, yet has no use
 * *unless* you know the character type in actual use.  It *could* live in
 * TokenStreamAnyChars, but it makes more sense to live in a separate class
 * that character-aware token information can simply inherit.
 *
 * This class currently exists only to contain a char16_t buffer, transiently
 * used to accumulate strings in tricky cases that can't just be read directly
 * from source text.  It's not used outside character-aware tokenizing, so it
 * doesn't make sense in TokenStreamAnyChars.
 *
 * == TokenStreamCharsBase<Unit> → TokenStreamCharsShared ==
 *
 * Certain data structures in tokenizing are character-type-specific: namely,
 * the various pointers identifying the source text (including current offset
 * and end).
 *
 * Additionally, some functions operating on this data are defined the same way
 * no matter what character type you have (e.g. current offset in code units
 * into the source text) or share a common interface regardless of character
 * type (e.g. consume the next code unit if it has a given value).
 *
 * All such functionality lives in TokenStreamCharsBase<Unit>.
 *
 * == SpecializedTokenStreamCharsBase<Unit> → TokenStreamCharsBase<Unit> ==
 *
 * Certain tokenizing functionality is specific to a single character type.
 * For example, JS's UTF-16 encoding recognizes no coding errors, because lone
 * surrogates are not an error; but a UTF-8 encoding must recognize a variety
 * of validation errors.  Such functionality is defined only in the appropriate
 * SpecializedTokenStreamCharsBase specialization.
 *
 * == GeneralTokenStreamChars<Unit, AnyCharsAccess> →
 *    SpecializedTokenStreamCharsBase<Unit> ==
 *
 * Some functionality operates differently on different character types, just
 * as for TokenStreamCharsBase, but additionally requires access to character-
 * type-agnostic information in TokenStreamAnyChars.  For example, getting the
 * next character performs different steps for different character types and
 * must access TokenStreamAnyChars to update line break information.
 *
 * Such functionality, if it can be defined using the same algorithm for all
 * character types, lives in GeneralTokenStreamChars<Unit, AnyCharsAccess>.
 * The AnyCharsAccess parameter provides a way for a GeneralTokenStreamChars
 * instance to access its corresponding TokenStreamAnyChars, without inheriting
 * from it.
 *
 * GeneralTokenStreamChars<Unit, AnyCharsAccess> is just functionality, no
 * actual member data.
 *
 * Such functionality all lives in TokenStreamChars<Unit, AnyCharsAccess>, a
 * declared-but-not-defined template class whose specializations have a common
 * public interface (plus whatever private helper functions are desirable).
 *
 * == TokenStreamChars<Unit, AnyCharsAccess> →
 *    GeneralTokenStreamChars<Unit, AnyCharsAccess> ==
 *
 * Some functionality is like that in GeneralTokenStreamChars, *but* it's
 * defined entirely differently for different character types.
 *
 * For example, consider "match a multi-code unit code point" (hypothetically:
 * we've only implemented two-byte tokenizing right now):
 *
 *   * For two-byte text, there must be two code units to get, the leading code
 *     unit must be a UTF-16 lead surrogate, and the trailing code unit must be
 *     a UTF-16 trailing surrogate.  (If any of these fail to hold, a next code
 *     unit encodes that code point and is not multi-code unit.)
 *   * For single-byte Latin-1 text, there are no multi-code unit code points.
 *   * For single-byte UTF-8 text, the first code unit must have N > 1 of its
 *     highest bits set (and the next unset), and |N - 1| successive code units
 *     must have their high bit set and next-highest bit unset, *and*
 *     concatenating all unconstrained bits together must not produce a code
 *     point value that could have been encoded in fewer code units.
 *
 * This functionality can't be implemented as member functions in
 * GeneralTokenStreamChars because we'd need to *partially specialize* those
 * functions -- hold Unit constant while letting AnyCharsAccess vary.  But
 * C++ forbids function template partial specialization like this: either you
 * fix *all* parameters or you fix none of them.
 *
 * Fortunately, C++ *does* allow *class* template partial specialization.  So
 * TokenStreamChars is a template class with one specialization per Unit.
 * Functions can be defined differently in the different specializations,
 * because AnyCharsAccess as the only template parameter on member functions
 * *can* vary.
 *
 * All TokenStreamChars<Unit, AnyCharsAccess> specializations, one per Unit,
 * are just functionality, no actual member data.
 *
 * == TokenStreamSpecific<Unit, AnyCharsAccess> →
 *    TokenStreamChars<Unit, AnyCharsAccess>, TokenStreamShared,
 *    ErrorReporter ==
 *
 * TokenStreamSpecific is operations that are parametrized on character type
 * but implement the *general* idea of tokenizing, without being intrinsically
 * tied to character type.  Notably, this includes all operations that can
 * report warnings or errors at particular offsets, because we include a line
 * of context with such errors -- and that necessarily accesses the raw
 * characters of their specific type.
 *
 * Much TokenStreamSpecific operation depends on functionality in
 * TokenStreamAnyChars.  The obvious solution is to inherit it -- but this
 * doesn't work in Parser: its ParserBase base class needs some
 * TokenStreamAnyChars functionality without knowing character type.
 *
 * The AnyCharsAccess type parameter is a class that statically converts from a
 * TokenStreamSpecific* to its corresponding TokenStreamAnyChars.  The
 * TokenStreamSpecific in Parser<ParseHandler, Unit> can then specify a class
 * that properly converts from TokenStreamSpecific Parser::tokenStream to
 * TokenStreamAnyChars ParserBase::anyChars.
 *
 * Could we hardcode one set of offset calculations for this and eliminate
 * AnyCharsAccess?  No.  Offset calculations possibly could be hardcoded if
 * TokenStreamSpecific were present in Parser before Parser::handler, assuring
 * the same offsets in all Parser-related cases.  But there's still a separate
 * TokenStream class, that requires different offset calculations.  So even if
 * we wanted to hardcode this (it's not clear we would, because forcing the
 * TokenStreamSpecific declarer to specify this is more explicit), we couldn't.
 ','line_number':18,'multiline':True]['text':' ParserAtom, ParserAtomsTable, TaggedParserAtomIndex','line_number':206,'multiline':False]['text':' JSMSG_*','line_number':210,'multiline':False]['text':' js::HashMap','line_number':211,'multiline':False]['text':' JS::RegExpFlags','line_number':212,'multiline':False]['text':' Saturate column number at a limit that can be represented in various parts of','line_number':228,'multiline':False]['text':' the engine. Source locations beyond this point will report at the limit','line_number':229,'multiline':False]['text':' column instead.','line_number':230,'multiline':False]['text':'','line_number':231,'multiline':False]['text':' See:','line_number':232,'multiline':False]['text':'  - TokenStreamAnyChars::checkOptions','line_number':233,'multiline':False]['text':'  - ColSpan::isRepresentable','line_number':234,'multiline':False]['text':'  - WasmFrameIter::computeLine','line_number':235,'multiline':False]['text':' If `name` is reserved word, returns the TokenKind of it.','line_number':238,'multiline':False]['text':' TokenKind::Limit otherwise.','line_number':239,'multiline':False]['text':' If `name` is reserved word, returns string representation of it.','line_number':242,'multiline':False]['text':' nullptr otherwise.','line_number':243,'multiline':False]['text':' If `tt` is reserved word, returns string representation of it.','line_number':246,'multiline':False]['text':' nullptr otherwise.','line_number':247,'multiline':False]['text':' No deprecated content was present.','line_number':251,'multiline':False]['text':' Octal literal not prefixed by "0o" but rather by just "0", e.g. 0755.','line_number':253,'multiline':False]['text':' Octal character escape, e.g. "hell\157 world".','line_number':255,'multiline':False]['text':' NonOctalDecimalEscape, i.e. "\8" or "\9".','line_number':257,'multiline':False]['text':' Hit end of file.','line_number':262,'multiline':False]['text':' Non-whitespace since start of line.','line_number':264,'multiline':False]['text':' Hit a syntax error, at start or during a token.','line_number':266,'multiline':False]['text':' The nature of any deprecated content seen since last reset.','line_number':269,'multiline':False]['text':' We have to uint8_t instead DeprecatedContent to work around a GCC 7 bug.','line_number':270,'multiline':False]['text':' https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414','line_number':271,'multiline':False]['text':'*
 * TokenStream types and constants that are used in both TokenStreamAnyChars
 * and TokenStreamSpecific.  Do not add any non-static data members to this
 * class!
 ','line_number':284,'multiline':True]['text':' 1 current + 2 lookahead, rounded','line_number':291,'multiline':False]['text':' to power of 2 to avoid divmod by 3','line_number':292,'multiline':False]['text':' Technically only TokenStreamSpecific<Unit, AnyCharsAccess>::seek with','line_number':333,'multiline':False]['text':' Unit constant and AnyCharsAccess varying must be friended, but 1) it's','line_number':334,'multiline':False]['text':' hard to friend one function in template classes, and 2) C++ doesn't','line_number':335,'multiline':False]['text':' allow partial friend specialization to target just that single class.','line_number':336,'multiline':False]['text':'*
 * This class maps:
 *
 *   * a sourceUnits offset (a 0-indexed count of code units)
 *
 * to
 *
 *   * a (1-indexed) line number and
 *   * a (0-indexed) offset in code *units* (not code points, not bytes) into
 *     that line,
 *
 * for either |Unit = Utf8Unit| or |Unit = char16_t|.
 *
 * Note that the latter quantity is *not* the same as a column number, which is
 * a count of code *points*.  Computing a column number requires the offset
 * within the line and the source units of that line (including what type |Unit|
 * is, to know how to decode them).  If you need a column number, functions in
 * |GeneralTokenStreamChars<Unit>| will consult this and source units to compute
 * it.
 ','line_number':353,'multiline':True]['text':' For a given buffer holding source code, |lineStartOffsets_| has one','line_number':374,'multiline':False]['text':' element per line of source code, plus one sentinel element.  Each','line_number':375,'multiline':False]['text':' non-sentinel element holds the buffer offset for the start of the','line_number':376,'multiline':False]['text':' corresponding line of source code.  For this example script,','line_number':377,'multiline':False]['text':' assuming an initialLineOffset of 0:','line_number':378,'multiline':False]['text':'','line_number':379,'multiline':False]['text':' 1  // xyz            [line starts at offset 0]','line_number':380,'multiline':False]['text':' 2  var x;            [line starts at offset 7]','line_number':381,'multiline':False]['text':' 3                    [line starts at offset 14]','line_number':382,'multiline':False]['text':' 4  var y;            [line starts at offset 15]','line_number':383,'multiline':False]['text':'','line_number':384,'multiline':False]['text':' |lineStartOffsets_| is:','line_number':385,'multiline':False]['text':'','line_number':386,'multiline':False]['text':'   [0, 7, 14, 15, MAX_PTR]','line_number':387,'multiline':False]['text':'','line_number':388,'multiline':False]['text':' To convert a "line number" to an "index" into |lineStartOffsets_|,','line_number':389,'multiline':False]['text':' subtract |initialLineNum_|.  E.g. line 3's index is','line_number':390,'multiline':False]['text':' (3 - initialLineNum_), which is 2.  Therefore lineStartOffsets_[2]','line_number':391,'multiline':False]['text':' holds the buffer offset for the start of line 3, which is 14.  (Note','line_number':392,'multiline':False]['text':' that |initialLineNum_| is often 1, but not always.','line_number':393,'multiline':False]['text':'','line_number':394,'multiline':False]['text':' The first element is always initialLineOffset, passed to the','line_number':395,'multiline':False]['text':' constructor, and the last element is always the MAX_PTR sentinel.','line_number':396,'multiline':False]['text':'','line_number':397,'multiline':False]['text':' Offset-to-{line,offset-into-line} lookups are O(log n) in the worst','line_number':398,'multiline':False]['text':' case (binary search), but in practice they're heavily clustered and','line_number':399,'multiline':False]['text':' we do better than that by using the previous lookup's result','line_number':400,'multiline':False]['text':' (lastIndex_) as a starting point.','line_number':401,'multiline':False]['text':'','line_number':402,'multiline':False]['text':' Checking if an offset lies within a particular line number','line_number':403,'multiline':False]['text':' (isOnThisLine()) is O(1).','line_number':404,'multiline':False]['text':'','line_number':405,'multiline':False]['text':'* The line number on which the source text begins. ','line_number':408,'multiline':True]['text':'*
   * The index corresponding to the last offset lookup -- used so that if
   * offset lookups proceed in increasing order, and and the offset appears
   * in the next couple lines from the last offset, we can avoid a full
   * binary-search.
   *
   * This is mutable because it's modified on every search, but that fact
   * isn't visible outside this class.
   ','line_number':411,'multiline':True]['text':' +1 due to sentinel','line_number':443,'multiline':False]['text':'*
   * A token, computed for an offset in source text, that can be used to
   * access line number and line-offset information for that offset.
   *
   * LineToken *alone* exposes whether the corresponding offset is in the
   * the first line of source (which may not be 1, depending on
   * |initialLineNumber|), and whether it's in the same line as
   * another LineToken.
   ','line_number':451,'multiline':True]['text':' stored for consistency-of-use assertions','line_number':463,'multiline':False]['text':'*
   * Compute a token usable to access information about the line at the
   * given offset.
   *
   * The only information directly accessible in a token is whether it
   * corresponds to the first line of source text (which may not be line
   * 1, depending on the |initialLineNumber| value used to construct
   * this).  Use |lineNumber(LineToken)| to compute the actual line
   * number (incorporating the contribution of |initialLineNumber|).
   ','line_number':487,'multiline':True]['text':'* Compute the line number for the given token. ','line_number':499,'multiline':True]['text':'* Return the offset of the start of the line for |lineToken|. ','line_number':504,'multiline':True]['text':' Store everything in |unsigned char|s so everything packs.','line_number':519,'multiline':False]['text':' No invalid character escapes.','line_number':549,'multiline':False]['text':' A malformed \x escape.','line_number':551,'multiline':False]['text':' A malformed \u escape.','line_number':553,'multiline':False]['text':' An otherwise well-formed \u escape which represents a','line_number':555,'multiline':False]['text':' codepoint > 10FFFF.','line_number':556,'multiline':False]['text':' An octal escape in a template token.','line_number':558,'multiline':False]['text':' NonOctalDecimalEscape - \8 or \9.','line_number':560,'multiline':False]['text':' Constant-at-construction fields.','line_number':566,'multiline':False]['text':'* Options used for parsing/tokenizing. ','line_number':570,'multiline':True]['text':'*
   * Pointer used internally to test whether in strict mode.  Use |strictMode()|
   * instead of this field.
   ','line_number':573,'multiline':True]['text':'* Input filename or null. ','line_number':579,'multiline':True]['text':' Column number computation fields.','line_number':582,'multiline':False]['text':'*
   * A map of (line number => sequence of the column numbers at
   * |ColumnChunkLength|-unit boundaries rewound [if needed] to the nearest code
   * point boundary).  (|TokenStreamAnyChars::computePartialColumn| is the sole
   * user of |ColumnChunkLength| and therefore contains its definition.)
   *
   * Entries appear in this map only when a column computation of sufficient
   * distance is performed on a line -- and only when the column is beyond the
   * first |ColumnChunkLength| units.  Each line's vector is lazily filled as
   * greater offsets require column computations.
   ','line_number':584,'multiline':True]['text':' Computing accurate column numbers requires at *some* point linearly','line_number':597,'multiline':False]['text':' iterating through prior source units in the line, to properly account for','line_number':598,'multiline':False]['text':' multi-unit code points.  This is quadratic if counting happens repeatedly.','line_number':599,'multiline':False]['text':'','line_number':600,'multiline':False]['text':' But usually we need columns for advancing offsets through scripts.  By','line_number':601,'multiline':False]['text':' caching the last ((line number, offset) => relative column) mapping (in','line_number':602,'multiline':False]['text':' similar manner to how |SourceCoords::lastIndex_| is used to cache','line_number':603,'multiline':False]['text':' (offset => line number) mappings) we can usually avoid re-iterating through','line_number':604,'multiline':False]['text':' the common line prefix.','line_number':605,'multiline':False]['text':'','line_number':606,'multiline':False]['text':' Additionally, we avoid hash table lookup costs by caching the','line_number':607,'multiline':False]['text':' |Vector<ChunkInfo>*| for the line of the last lookup.  (|nullptr| means we','line_number':608,'multiline':False]['text':' must look it up -- or it hasn't been created yet.)  This pointer is nulled','line_number':609,'multiline':False]['text':' when a lookup on a new line occurs, but as it's not a pointer at literal,','line_number':610,'multiline':False]['text':' reallocatable element data, it's *not* invalidated when new entries are','line_number':611,'multiline':False]['text':' added to such a vector.','line_number':612,'multiline':False]['text':'*
   * The line in which the last column computation occurred, or UINT32_MAX if
   * no prior computation has yet happened.
   ','line_number':614,'multiline':True]['text':'*
   * The chunk vector of the line for that last column computation.  This is
   * null if the chunk vector needs to be recalculated or initially created.
   ','line_number':620,'multiline':True]['text':'*
   * The offset (in code units) of the last column computation performed,
   * relative to source start.
   ','line_number':626,'multiline':True]['text':'*
   * The column number for the offset (in code units) of the last column
   * computation performed, relative to source start.
   ','line_number':632,'multiline':True]['text':' Intra-token fields.','line_number':638,'multiline':False]['text':'*
   * The offset of the first invalid escape in a template literal.  (If there is
   * one -- if not, the value of this field is meaningless.)
   *
   * See also |invalidTemplateEscapeType|.
   ','line_number':640,'multiline':True]['text':'*
   * The type of the first invalid escape in a template literal.  (If there
   * isn't one, this will be |None|.)
   *
   * See also |invalidTemplateEscapeOffset|.
   ','line_number':648,'multiline':True]['text':' Fields with values relevant across tokens (and therefore potentially across','line_number':656,'multiline':False]['text':' function boundaries, such that lazy function parsing and stream-seeking','line_number':657,'multiline':False]['text':' must take care in saving and restoring them).','line_number':658,'multiline':False]['text':'* Line number and offset-to-line mapping information. ','line_number':660,'multiline':True]['text':'* Circular token buffer of gotten tokens that have been ungotten. ','line_number':663,'multiline':True]['text':'* The index in |tokens| of the last parsed token. ','line_number':666,'multiline':True]['text':'* The number of tokens in |tokens| available to be gotten. ','line_number':669,'multiline':True]['text':'* The current line number. ','line_number':672,'multiline':True]['text':'* Various flag bits (see above). ','line_number':675,'multiline':True]['text':'* The offset of the start of the current line. ','line_number':678,'multiline':True]['text':'* The start of the previous line, or |size_t(-1)| on the first line. ','line_number':681,'multiline':True]['text':'* The user's requested source URL.  Null if none has been set. ','line_number':684,'multiline':True]['text':'* The URL of the source map for this script.  Null if none has been set. ','line_number':687,'multiline':True]['text':' Assorted boolean fields, none of which require maintenance across tokens,','line_number':690,'multiline':False]['text':' stored at class end to minimize padding.','line_number':691,'multiline':False]['text':'*
   * Whether syntax errors should or should not contain details about the
   * precise nature of the error.  (This is intended for use in suppressing
   * content-revealing details about syntax errors in cross-origin scripts on
   * the web.)
   ','line_number':693,'multiline':True]['text':'*
   * An array storing whether a TokenKind observed while attempting to extend
   * a valid AssignmentExpression into an even longer AssignmentExpression
   * (e.g., extending '3' to '3 + 5') will terminate it without error.
   *
   * For example, ';' always ends an AssignmentExpression because it ends a
   * Statement or declaration.  '}' always ends an AssignmentExpression
   * because it terminates BlockStatement, FunctionBody, and embedded
   * expressions in TemplateLiterals.  Therefore both entries are set to true
   * in TokenStreamAnyChars construction.
   *
   * But e.g. '+' *could* extend an AssignmentExpression, so its entry here
   * is false.  Meanwhile 'this' can't extend an AssignmentExpression, but
   * it's only valid after a line break, so its entry here must be false.
   *
   * NOTE: This array could be static, but without C99's designated
   *       initializers it's easier zeroing here and setting the true entries
   *       in the constructor body.  (Having this per-instance might also aid
   *       locality.)  Don't worry!  Initialization time for each TokenStream
   *       is trivial.  See bug 639420.
   ','line_number':701,'multiline':True]['text':' all-false initially','line_number':722,'multiline':False]['text':' End of fields.','line_number':724,'multiline':False]['text':' Accessors.','line_number':740,'multiline':False]['text':' Flag methods.','line_number':783,'multiline':False]['text':' Workaround GCC 7 sadness.','line_number':792,'multiline':False]['text':' This is private because it should only be called by the tokenizer while','line_number':819,'multiline':False]['text':' tokenizing not by, for example, BytecodeEmitter.','line_number':820,'multiline':False]['text':' Call this immediately after parsing an OrExpression to allow scanning the','line_number':835,'multiline':False]['text':' next token with SlashIsRegExp without asserting (even though we just','line_number':836,'multiline':False]['text':' peeked at it in SlashIsDiv mode).','line_number':837,'multiline':False]['text':'','line_number':838,'multiline':False]['text':' It's OK to disable the assertion because the places where this is called','line_number':839,'multiline':False]['text':' have peeked at the next token in SlashIsDiv mode, and checked that it is','line_number':840,'multiline':False]['text':' *not* a Div token.','line_number':841,'multiline':False]['text':'','line_number':842,'multiline':False]['text':' To see why it is necessary to disable the assertion, consider these two','line_number':843,'multiline':False]['text':' programs:','line_number':844,'multiline':False]['text':'','line_number':845,'multiline':False]['text':'     x = arg => q       // per spec, this is all one statement, and the','line_number':846,'multiline':False]['text':'     /a/g;              // slashes are division operators','line_number':847,'multiline':False]['text':'','line_number':848,'multiline':False]['text':'     x = arg => {}      // per spec, ASI at the end of this line','line_number':849,'multiline':False]['text':'     /a/g;              // and that's a regexp literal','line_number':850,'multiline':False]['text':'','line_number':851,'multiline':False]['text':' The first program shows why orExpr() has use SlashIsDiv mode when peeking','line_number':852,'multiline':False]['text':' ahead for the next operator after parsing `q`. The second program shows','line_number':853,'multiline':False]['text':' why matchOrInsertSemicolon() must use SlashIsRegExp mode when scanning','line_number':854,'multiline':False]['text':' ahead for a semicolon.','line_number':855,'multiline':False]['text':' Check the precondition: Caller already peeked ahead at the next token,','line_number':858,'multiline':False]['text':' in SlashIsDiv mode, and it is *not* a Div token.','line_number':859,'multiline':False]['text':'*
   * Fill in |err|.
   *
   * If the token stream doesn't have location info for this error, use the
   * caller's location (including line/column number) and return false.  (No
   * line of context is set.)
   *
   * Otherwise fill in everything in |err| except 1) line/column numbers and
   * 2) line-of-context-related fields and return true.  The caller *must*
   * fill in the line/column number; filling the line of context is optional.
   ','line_number':896,'multiline':True]['text':'*
   * Compute the "partial" column number in Unicode code points of the absolute
   * |offset| within source text on the line of |lineToken| (which must have
   * been computed from |offset|).
   *
   * A partial column number on a line that isn't the first line is just the
   * actual column number.  But a partial column number on the first line is the
   * column number *ignoring the initial line/column of the script*.  For
   * example, consider this HTML with line/column number keys:
   *
   *                 1         2            3
   *       0123456789012345678901234   567890
   *     ------------------------------------
   *   1 | <html>
   *   2 | <head>
   *   3 |   <script>var x = 3;  x &lt; 4;
   *   4 | const y = 7;</script>
   *   5 | </head>
   *   6 | <body></body>
   *   7 | </html>
   *
   * The script would be compiled specifying initial (line, column) of (3, 10)
   * using |JS::ReadOnlyCompileOptions::{lineno,column}|.  And the column
   * reported by |computeColumn| for the "v" of |var| would be 10.  But the
   * partial column number of the "v" in |var|, that this function returns,
   * would be 0.  On the other hand, the column reported by |computeColumn| and
   * the partial column number returned by this function for the "c" in |const|
   * would both be 0, because it's not in the first line of source text.
   *
   * The partial column is with respect *only* to the JavaScript source text as
   * SpiderMonkey sees it.  In the example, the "&lt;" is converted to "<" by
   * the browser before SpiderMonkey would see it.  So the partial column of the
   * "4" in the inequality would be 16, not 19.
   *
   * Code points are not all equal length, so counting requires *some* kind of
   * linear-time counting from the start of the line.  This function attempts
   * various tricks to reduce this cost.  If these optimizations succeed,
   * repeated calls to this function on a line will pay a one-time cost linear
   * in the length of the line, then each call pays a separate constant-time
   * cost.  If the optimizations do not succeed, this function works in time
   * linear in the length of the line.
   *
   * It's unusual for a function in *this* class to be |Unit|-templated, but
   * while this operation manages |Unit|-agnostic fields in this class and in
   * |srcCoords|, it must *perform* |Unit|-sensitive computations to fill them.
   * And this is the best place to do that.
   ','line_number':912,'multiline':True]['text':'*
   * Update line/column information for the start of a new line at
   * |lineStartOffset|.
   ','line_number':964,'multiline':True]['text':' Push the last scanned token back into the stream.','line_number':992,'multiline':False]['text':' If |other| has fresh information from directives, overwrite any','line_number':1001,'multiline':False]['text':' previously recorded directives.  (There is no specification directing','line_number':1002,'multiline':False]['text':' that last-in-source-order directive controls, sadly.  We behave this way','line_number':1003,'multiline':False]['text':' in the ordinary case, so we ought do so here too.)','line_number':1004,'multiline':False]['text':' Compute error metadata for an error at no offset.','line_number':1013,'multiline':False]['text':' ErrorReporter API Helpers','line_number':1016,'multiline':False]['text':' Provide minimal set of error reporting API given we cannot use','line_number':1018,'multiline':False]['text':' ErrorReportMixin here. "report" prefix is added to avoid conflict with','line_number':1019,'multiline':False]['text':' ErrorReportMixin methods in TokenStream class.','line_number':1020,'multiline':False]['text':' Every LineTerminator fits in char16_t, so this is exact.','line_number':1048,'multiline':False]['text':'*
 * PeekedCodePoint represents the result of peeking ahead in some source text
 * to determine the next validly-encoded code point.
 *
 * If there isn't a valid code point, then |isNone()|.
 *
 * But if there *is* a valid code point, then |!isNone()|, the code point has
 * value |codePoint()| and its length in code units is |lengthInUnits()|.
 *
 * Conceptually, this class is |Maybe<struct { char32_t v; uint8_t len; }>|.
 ','line_number':1078,'multiline':True]['text':'*
   * Create a peeked code point with the given value and length in code
   * units.
   *
   * While the latter value is computable from the former for both UTF-8 and
   * JS's version of UTF-16, the caller likely computed a length in units in
   * the course of determining the peeked value.  Passing both here avoids
   * recomputation and lets us do a consistency-checking assertion.
   ','line_number':1100,'multiline':True]['text':'* Create a PeekedCodeUnit that represents no valid code point. ','line_number':1116,'multiline':True]['text':'* True if no code point was found, false otherwise. ','line_number':1119,'multiline':True]['text':'* If a code point was found, its value. ','line_number':1122,'multiline':True]['text':'* If a code point was found, its length in code units. ','line_number':1128,'multiline':True]['text':' BEWARE: The Unicode line/paragraph separators don't fit in a single','line_number':1183,'multiline':False]['text':'         UTF-8 code unit, so this test is exact for Utf8Unit but inexact','line_number':1184,'multiline':False]['text':'         for UTF-8 as a whole.  Users must handle |unit| as start of a','line_number':1185,'multiline':False]['text':'         Unicode LineTerminator themselves!','line_number':1186,'multiline':False]['text':' This is the low-level interface to the JS source code buffer.  It just gets','line_number':1190,'multiline':False]['text':' raw Unicode code units -- 16-bit char16_t units of source text that are not','line_number':1191,'multiline':False]['text':' (always) full code points, and 8-bit units of UTF-8 source text soon.','line_number':1192,'multiline':False]['text':' TokenStreams functions are layered on top and do some extra stuff like','line_number':1193,'multiline':False]['text':' converting all EOL sequences to '\n', tracking the line number, and setting','line_number':1194,'multiline':False]['text':' |flags.isEOF|.  (The "raw" in "raw Unicode code units" refers to the lack of','line_number':1195,'multiline':False]['text':' EOL sequence normalization.)','line_number':1196,'multiline':False]['text':'','line_number':1197,'multiline':False]['text':' buf[0..length-1] often represents a substring of some larger source,','line_number':1198,'multiline':False]['text':' where we have only the substring in memory. The |startOffset| argument','line_number':1199,'multiline':False]['text':' indicates the offset within this larger string at which our string','line_number':1200,'multiline':False]['text':' begins, the offset of |buf[0]|.','line_number':1201,'multiline':False]['text':'* Base of buffer. ','line_number':1205,'multiline':True]['text':'* Offset of base_[0]. ','line_number':1208,'multiline':True]['text':'* Limit for quick bounds check. ','line_number':1211,'multiline':True]['text':'* Next char to get. ','line_number':1214,'multiline':True]['text':' this will nullptr-crash if poisoned','line_number':1266,'multiline':False]['text':' this will nullptr-crash if poisoned','line_number':1270,'multiline':False]['text':'*
   * Determine the next code point in source text.  The code point is not
   * normalized: '\r', '\n', '\u2028', and '\u2029' are returned literally.
   * If there is no next code point because |atEnd()|, or if an encoding
   * error is encountered, return a |PeekedCodePoint| that |isNone()|.
   *
   * This function does not report errors: code that attempts to get the next
   * code point must report any error.
   *
   * If a next code point is found, it may be consumed by passing it to
   * |consumeKnownCodePoint|.
   ','line_number':1273,'multiline':True]['text':'*
   * Consume a peeked code point that |!isNone()|.
   *
   * This call DOES NOT UPDATE LINE-STATUS.  You may need to call
   * |updateLineInfoForEOL()| and |updateFlagsForEOL()| if this consumes a
   * LineTerminator.  Note that if this consumes '\r', you also must consume
   * an optional '\n' (i.e. a full LineTerminatorSequence) before doing so.
   ','line_number':1295,'multiline':True]['text':'* Match |n| hexadecimal digits and store their value in |*out|. ','line_number':1314,'multiline':True]['text':'* Unget U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR. ','line_number':1387,'multiline':True]['text':' Use this with caution!','line_number':1401,'multiline':False]['text':' Poison the SourceUnits so they can't be accessed again.','line_number':1407,'multiline':False]['text':' |ptr| can be null for unpoisoned SourceUnits if this was initialized with','line_number':1417,'multiline':False]['text':' |units == nullptr| and |length == 0|.  In that case, for lack of any','line_number':1418,'multiline':False]['text':' better options, consider this to not be poisoned.','line_number':1419,'multiline':False]['text':'*
   * Consume the rest of a single-line comment (but not the EOL/EOF that
   * terminates it).
   *
   * If an encoding error is encountered -- possible only for UTF-8 because
   * JavaScript's conception of UTF-16 encompasses any sequence of 16-bit
   * code units -- valid code points prior to the encoding error are consumed
   * and subsequent invalid code units are not consumed.  For example, given
   * these UTF-8 code units:
   *
   *   'B'   'A'  'D'  ':'   <bad code unit sequence>
   *   0x42  0x41 0x44 0x3A  0xD0 0x00 ...
   *
   * the first four code units are consumed, but 0xD0 and 0x00 are not
   * consumed because 0xD0 encodes a two-byte lead unit but 0x00 is not a
   * valid trailing code unit.
   *
   * It is expected that the caller will report such an encoding error when
   * it attempts to consume the next code point.
   ','line_number':1427,'multiline':True]['text':'*
   * The maximum radius of code around the location of an error that should
   * be included in a syntax error message -- this many code units to either
   * side.  The resulting window of data is then accordinngly trimmed so that
   * the window contains only validly-encoded data.
   *
   * Because this number is the same for both UTF-8 and UTF-16, windows in
   * UTF-8 may contain fewer code points than windows in UTF-16.  As we only
   * use this for error messages, we don't particularly care.
   ','line_number':1449,'multiline':True]['text':'*
   * From absolute offset |offset|, search backward to find an absolute
   * offset within source text, no further than |WindowRadius| code units
   * away from |offset|, such that all code points from that offset to
   * |offset| are valid, non-LineTerminator code points.
   ','line_number':1461,'multiline':True]['text':'*
   * From absolute offset |offset|, find an absolute offset within source
   * text, no further than |WindowRadius| code units away from |offset|, such
   * that all code units from |offset| to that offset are valid,
   * non-LineTerminator code points.
   ','line_number':1469,'multiline':True]['text':'*
   * Given a |window| of |encodingSpecificWindowLength| units encoding valid
   * Unicode text, with index |encodingSpecificTokenOffset| indicating a
   * particular code point boundary in |window|, compute the corresponding
   * token offset and length if |window| were encoded in UTF-16.  For
   * example:
   *
   *   // U+03C0 GREEK SMALL LETTER PI is encoded as 0xCF 0x80.
   *   const Utf8Unit* encodedWindow =
   *     reinterpret_cast<const Utf8Unit*>(u8"ππππ = @ FAIL");
   *   size_t encodedTokenOffset = 11; // 2 * 4 + ' = '.length
   *   size_t encodedWindowLength = 17; // 2 * 4 + ' = @ FAIL'.length
   *   size_t utf16Offset, utf16Length;
   *   computeWindowOffsetAndLength(encodedWindow,
   *                                encodedTokenOffset, &utf16Offset,
   *                                encodedWindowLength, &utf16Length);
   *   MOZ_ASSERT(utf16Offset == 7);
   *   MOZ_ASSERT(utf16Length = 13);
   *
   * This function asserts if called for UTF-16: the sole caller can avoid
   * computing UTF-16 offsets when they're definitely the same as the encoded
   * offsets.
   ','line_number':1477,'multiline':True]['text':'*
 * An all-purpose buffer type for accumulating text during tokenizing.
 *
 * In principle we could make this buffer contain |char16_t|, |Utf8Unit|, or
 * |Unit|.  We use |char16_t| because:
 *
 *   * we don't have a UTF-8 regular expression parser, so in general regular
 *     expression text must be copied to a separate UTF-16 buffer to parse it,
 *     and
 *   * |TokenStreamCharsShared::copyCharBufferTo|, which copies a shared
 *     |CharBuffer| to a |char16_t*|, is simpler if it doesn't have to convert.
 ','line_number':1531,'multiline':True]['text':'*
 * Append the provided code point (in the range [U+0000, U+10FFFF], surrogate
 * code points included) to the buffer.
 ','line_number':1545,'multiline':True]['text':'*
 * Accumulate the range of UTF-16 text (lone surrogates permitted, because JS
 * allows them in source text) into |charBuffer|.  Normalize '\r', '\n', and
 * "\r\n" into '\n'.
 ','line_number':1552,'multiline':True]['text':'*
 * Accumulate the range of previously-validated UTF-8 text into |charBuffer|.
 * Normalize '\r', '\n', and "\r\n" into '\n'.
 ','line_number':1560,'multiline':True]['text':'*
   * Buffer transiently used to store sequences of identifier or string code
   * points when such can't be directly processed from the original source
   * text (e.g. because it contains escapes).
   ','line_number':1572,'multiline':True]['text':'* Information for parsing with a lifetime longer than the parser itself. ','line_number':1579,'multiline':True]['text':'*
   * Determine whether a code unit constitutes a complete ASCII code point.
   * (The code point's exact value might not be used, however, if subsequent
   * code observes that |unit| is part of a LineTerminatorSequence.)
   ','line_number':1589,'multiline':True]['text':' Add to parser atoms table.','line_number':1600,'multiline':False]['text':' The other stream's buffer may contain information for a','line_number':1609,'multiline':False]['text':' gotten-then-ungotten token, that we must transfer into this stream so','line_number':1610,'multiline':False]['text':' that token's final get behaves as desired.','line_number':1611,'multiline':False]['text':'* Code units in the source code being tokenized. ','line_number':1624,'multiline':True]['text':' End of fields.','line_number':1627,'multiline':False]['text':'*
   * Convert a non-EOF code unit returned by |getCodeUnit()| or
   * |peekCodeUnit()| to a Unit code unit.
   ','line_number':1633,'multiline':True]['text':'*
   * Try to match a non-LineTerminator ASCII code point.  Return true iff it
   * was matched.
   ','line_number':1650,'multiline':True]['text':'*
   * Try to match an ASCII LineTerminator code point.  Return true iff it was
   * matched.
   ','line_number':1661,'multiline':True]['text':'* Consume a known, non-EOF code unit. ','line_number':1681,'multiline':True]['text':' Forbid accidental calls to consumeKnownCodeUnit *not* with the single','line_number':1684,'multiline':False]['text':' unit-or-EOF type.  Unit should use SourceUnits::consumeKnownCodeUnit;','line_number':1685,'multiline':False]['text':' CodeUnitValue() results should go through toUnit(), or better yet just','line_number':1686,'multiline':False]['text':' use the original Unit.','line_number':1687,'multiline':False]['text':'*
   * Add a null-terminated line of context to error information, for the line
   * in |sourceUnits| that contains |offset|.  Also record the window's
   * length and the offset of the error in the window.  (Don't bother adding
   * a line of context if it would be empty.)
   *
   * The window will contain no LineTerminators of any kind, and it will not
   * extend more than |SourceUnits::WindowRadius| to either side of |offset|,
   * nor into the previous or next lines.
   *
   * This function is quite internal, and you probably should be calling one
   * of its existing callers instead.
   ','line_number':1691,'multiline':True]['text':' static ','line_number':1733,'multiline':True]['text':' Deliberately don't |using| |sourceUnits| because of bug 1472569.  :-(','line_number':1749,'multiline':False]['text':' These APIs are only usable by UTF-16-specific code.','line_number':1754,'multiline':False]['text':'*
   * Given |lead| already consumed, consume and return the code point encoded
   * starting from it.  Infallible because lone surrogates in JS encode a
   * "code point" of the same value.
   ','line_number':1756,'multiline':True]['text':' Handle single-unit code points and lone trailing surrogates.','line_number':1765,'multiline':False]['text':' Or handle lead surrogates not paired with trailing surrogates.','line_number':1767,'multiline':False]['text':' Otherwise it's a multi-unit code point.','line_number':1774,'multiline':False]['text':' These APIs are in both SpecializedTokenStreamCharsBase specializations','line_number':1779,'multiline':False]['text':' and so are usable in subclasses no matter what Unit is.','line_number':1780,'multiline':False]['text':' Deliberately don't |using| |sourceUnits| because of bug 1472569.  :-(','line_number':1791,'multiline':False]['text':' These APIs are only usable by UTF-8-specific code.','line_number':1794,'multiline':False]['text':'*
   * A mutable iterator-wrapper around |SourceUnits| that translates
   * operators to calls to |SourceUnits::getCodeUnit()| and similar.
   *
   * This class is expected to be used in concert with |SourceUnitsEnd|.
   ','line_number':1798,'multiline':True]['text':' In iterator copies created by the post-increment operator, a pointer','line_number':1807,'multiline':False]['text':' at the next source text code unit when the post-increment operator','line_number':1808,'multiline':False]['text':' was called, cleared when the iterator is dereferenced.','line_number':1809,'multiline':False]['text':' operator* is expected to get the *next* value from an iterator','line_number':1819,'multiline':False]['text':' not pointing at the end of the underlying range.  However, the','line_number':1820,'multiline':False]['text':' sole use of this is in the context of an expression of the form','line_number':1821,'multiline':False]['text':' |*iter++|, that performed the |sourceUnits_.getCodeUnit()| in','line_number':1822,'multiline':False]['text':' the |operator++(int)| below -- so dereferencing acts on a','line_number':1823,'multiline':False]['text':' |sourceUnits_| already advanced.  Therefore the correct unit to','line_number':1824,'multiline':False]['text':' return is the previous one.','line_number':1825,'multiline':False]['text':'* A sentinel representing the end of |SourceUnits| data. ','line_number':1873,'multiline':True]['text':' These APIs are in both SpecializedTokenStreamCharsBase specializations','line_number':1880,'multiline':False]['text':' and so are usable in subclasses no matter what Unit is.','line_number':1881,'multiline':False]['text':'* A small class encapsulating computation of the start-offset of a Token. ','line_number':1893,'multiline':True]['text':'*
   * Compute a starting offset that is the current offset of |sourceUnits|,
   * offset by |adjust|.  (For example, |adjust| of -1 indicates the code
   * unit one backwards from |sourceUnits|'s current offset.)
   ','line_number':1898,'multiline':True]['text':'*
   * Allocates a new Token from the given offset to the current offset,
   * ascribes it the given kind, and sets |*out| to that kind.
   ','line_number':1922,'multiline':True]['text':' Save the modifier used to get this token, so that if an ungetToken()','line_number':1931,'multiline':False]['text':' occurs and then the token is re-gotten (or peeked, etc.), we can','line_number':1932,'multiline':False]['text':' assert both gets used compatible modifiers.','line_number':1933,'multiline':False]['text':' Deliberately don't |using CharsBase::sourceUnits| because of bug 1472569.','line_number':1949,'multiline':False]['text':' :-(','line_number':1950,'multiline':False]['text':'*
   * Compute the column number in Unicode code points of the absolute |offset|
   * within source text on the line corresponding to |lineToken|.
   *
   * |offset| must be a code point boundary, preceded only by validly-encoded
   * source units.  (It doesn't have to be *followed* by valid source units.)
   ','line_number':1978,'multiline':True]['text':'*
   * Fill in |err| completely, except for line-of-context information.
   *
   * Return true if the caller can compute a line of context from the token
   * stream.  Otherwise return false.
   ','line_number':1989,'multiline':True]['text':'*
   * Get the next code unit -- the next numeric sub-unit of source text,
   * possibly smaller than a full code point -- without updating line/column
   * counters or consuming LineTerminatorSequences.
   *
   * Because of these limitations, only use this if (a) the resulting code
   * unit is guaranteed to be ungotten (by ungetCodeUnit()) if it's an EOL,
   * and (b) the line-related state (lineno, linebase) is not used before
   * it's ungotten.
   ','line_number':2051,'multiline':True]['text':'*
   * Given a just-consumed ASCII code unit/point |lead|, consume a full code
   * point or LineTerminatorSequence (normalizing it to '\n') and store it in
   * |*codePoint|.  Return true on success, otherwise return false and leave
   * |*codePoint| undefined on failure.
   *
   * If a LineTerminatorSequence was consumed, also update line/column info.
   *
   * This may change the current |sourceUnits| offset.
   ','line_number':2076,'multiline':True]['text':' sentinel value to hopefully cause errors','line_number':2103,'multiline':False]['text':'*
   * If possible, compute a line of context for an otherwise-filled-in |err|
   * at the given offset in this token stream.
   *
   * This function is very-internal: almost certainly you should use one of
   * its callers instead.  It basically exists only to make those callers
   * more readable.
   ','line_number':2119,'multiline':True]['text':' We only have line-start information for the current line.  If the error','line_number':2129,'multiline':False]['text':' is on a different line, we can't easily provide context.  (This means','line_number':2130,'multiline':False]['text':' any error in a multi-line token, e.g. an unterminated multiline string','line_number':2131,'multiline':False]['text':' literal, won't have context.)','line_number':2132,'multiline':False]['text':'*
   * Consume any hashbang comment at the start of a Script or Module, if one is
   * present.  Stops consuming just before any terminating LineTerminator or
   * before an encoding error is encountered.
   ','line_number':2141,'multiline':True]['text':' Of the form    |`...${|   or   |}...${|','line_number':2157,'multiline':False]['text':' NO_SUBS_TEMPLATE is of the form   |`...`|   or   |}...`|','line_number':2161,'multiline':False]['text':' |charBuffer| should be empty here, but we may as well code defensively.','line_number':2166,'multiline':False]['text':' Template literals normalize only '\r' and "\r\n" to '\n'; Unicode','line_number':2170,'multiline':False]['text':' separators don't need special handling.','line_number':2171,'multiline':False]['text':' https://tc39.github.io/ecma262/#sec-static-semantics-tv-and-trv','line_number':2172,'multiline':False]['text':' Deliberately don't |using| |sourceUnits| because of bug 1472569.  :-(','line_number':2203,'multiline':False]['text':'*
   * Given the non-ASCII |lead| code unit just consumed, consume and return a
   * complete non-ASCII code point.  Line/column updates are not performed,
   * and line breaks are returned as-is without normalization.
   ','line_number':2210,'multiline':True]['text':' There are no encoding errors in 16-bit JS, so implement this so that','line_number':2217,'multiline':False]['text':' the compiler knows it, too.','line_number':2218,'multiline':False]['text':'*
   * Given a just-consumed non-ASCII code unit |lead| (which may also be a
   * full code point, for UTF-16), consume a full code point or
   * LineTerminatorSequence (normalizing it to '\n') and store it in
   * |*codePoint|.  Return true on success, otherwise return false and leave
   * |*codePoint| undefined on failure.
   *
   * If a LineTerminatorSequence was consumed, also update line/column info.
   *
   * This may change the current |sourceUnits| offset.
   ','line_number':2223,'multiline':True]['text':' Deliberately don't |using| |sourceUnits| because of bug 1472569.  :-(','line_number':2256,'multiline':False]['text':'*
   * Report a UTF-8 encoding-related error for a code point starting AT THE
   * CURRENT OFFSET.
   *
   * |relevantUnits| indicates how many code units from the current offset
   * are potentially relevant to the reported error, such that they may be
   * included in the error message.  For example, if at the current offset we
   * have
   *
   *   0b1111'1111 ...
   *
   * a code unit never allowed in UTF-8, then |relevantUnits| might be 1
   * because only that unit is relevant.  Or if we have
   *
   *   0b1111'0111 0b1011'0101 0b0000'0000 ...
   *
   * where the first two code units are a valid prefix to a four-unit code
   * point but the third unit *isn't* a valid trailing code unit, then
   * |relevantUnits| might be 3.
   ','line_number':2277,'multiline':True]['text':' Don't use |internalEncodingError|!  Use one of the elaborated functions','line_number':2300,'multiline':False]['text':' that calls it, below -- all of which should be used to indicate an error','line_number':2301,'multiline':False]['text':' in a code point starting AT THE CURRENT OFFSET as with','line_number':2302,'multiline':False]['text':' |internalEncodingError|.','line_number':2303,'multiline':False]['text':'* Report an error for an invalid lead code unit |lead|. ','line_number':2305,'multiline':True]['text':'*
   * Report an error when there aren't enough code units remaining to
   * constitute a full code point after |lead|: only |remaining| code units
   * were available for a code point starting with |lead|, when at least
   * |required| code units were required.
   ','line_number':2308,'multiline':True]['text':'*
   * Report an error for a bad trailing UTF-8 code unit, where the bad
   * trailing unit was the last of |unitsObserved| units examined from the
   * current offset.
   ','line_number':2317,'multiline':True]['text':' Helper used for both |badCodePoint| and |notShortestForm| for code units','line_number':2324,'multiline':False]['text':' that have all the requisite high bits set/unset in a manner that *could*','line_number':2325,'multiline':False]['text':' encode a valid code point, but the remaining bits encoding its actual','line_number':2326,'multiline':False]['text':' value do not define a permitted value.','line_number':2327,'multiline':False]['text':'*
   * Report an error for UTF-8 that encodes a UTF-16 surrogate or a number
   * outside the Unicode range.
   ','line_number':2332,'multiline':True]['text':'*
   * Report an error for UTF-8 that encodes a code point not in its shortest
   * form.
   ','line_number':2346,'multiline':True]['text':'*
   * Given the non-ASCII |lead| code unit just consumed, consume the rest of
   * a non-ASCII code point.  The code point is not normalized: on success
   * |*codePoint| may be U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR.
   *
   * Report an error if an invalid code point is encountered.
   ','line_number':2362,'multiline':True]['text':'*
   * Given a just-consumed non-ASCII code unit |lead|, consume a full code
   * point or LineTerminatorSequence (normalizing it to '\n') and store it in
   * |*codePoint|.  Return true on success, otherwise return false and leave
   * |*codePoint| undefined on failure.
   *
   * If a LineTerminatorSequence was consumed, also update line/column info.
   *
   * This function will change the current |sourceUnits| offset.
   ','line_number':2372,'multiline':True]['text':' TokenStream is the lexical scanner for JavaScript source text.','line_number':2385,'multiline':False]['text':'','line_number':2386,'multiline':False]['text':' It takes a buffer of Unit code units (currently only char16_t encoding','line_number':2387,'multiline':False]['text':' UTF-16, but we're adding either UTF-8 or Latin-1 single-byte text soon) and','line_number':2388,'multiline':False]['text':' linearly scans it into |Token|s.','line_number':2389,'multiline':False]['text':'','line_number':2390,'multiline':False]['text':' Internally the class uses a four element circular buffer |tokens| of','line_number':2391,'multiline':False]['text':' |Token|s. As an index for |tokens|, the member |cursor_| points to the','line_number':2392,'multiline':False]['text':' current token. Calls to getToken() increase |cursor_| by one and return the','line_number':2393,'multiline':False]['text':' new current token. If a TokenStream was just created, the current token is','line_number':2394,'multiline':False]['text':' uninitialized. It's therefore important that one of the first four member','line_number':2395,'multiline':False]['text':' functions listed below is called first. The circular buffer lets us go back','line_number':2396,'multiline':False]['text':' up to two tokens from the last scanned token. Internally, the relative','line_number':2397,'multiline':False]['text':' number of backward steps that were taken (via ungetToken()) after the last','line_number':2398,'multiline':False]['text':' token was scanned is stored in |lookahead|.','line_number':2399,'multiline':False]['text':'','line_number':2400,'multiline':False]['text':' The following table lists in which situations it is safe to call each listed','line_number':2401,'multiline':False]['text':' function. No checks are made by the functions in non-debug builds.','line_number':2402,'multiline':False]['text':'','line_number':2403,'multiline':False]['text':' Function Name     | Precondition; changes to |lookahead|','line_number':2404,'multiline':False]['text':' ------------------+---------------------------------------------------------','line_number':2405,'multiline':False]['text':' getToken          | none; if |lookahead > 0| then |lookahead--|','line_number':2406,'multiline':False]['text':' peekToken         | none; if |lookahead == 0| then |lookahead == 1|','line_number':2407,'multiline':False]['text':' peekTokenSameLine | none; if |lookahead == 0| then |lookahead == 1|','line_number':2408,'multiline':False]['text':' matchToken        | none; if |lookahead > 0| and the match succeeds then','line_number':2409,'multiline':False]['text':'                   |       |lookahead--|','line_number':2410,'multiline':False]['text':' consumeKnownToken | none; if |lookahead > 0| then |lookahead--|','line_number':2411,'multiline':False]['text':' ungetToken        | 0 <= |lookahead| <= |maxLookahead - 1|; |lookahead++|','line_number':2412,'multiline':False]['text':'','line_number':2413,'multiline':False]['text':' The behavior of the token scanning process (see getTokenInternal()) can be','line_number':2414,'multiline':False]['text':' modified by calling one of the first four above listed member functions with','line_number':2415,'multiline':False]['text':' an optional argument of type Modifier.  However, the modifier will be','line_number':2416,'multiline':False]['text':' ignored unless |lookahead == 0| holds.  Due to constraints of the grammar,','line_number':2417,'multiline':False]['text':' this turns out not to be a problem in practice. See the','line_number':2418,'multiline':False]['text':' mozilla.dev.tech.js-engine.internals thread entitled 'Bug in the scanner?'','line_number':2419,'multiline':False]['text':' for more details:','line_number':2420,'multiline':False]['text':' https://groups.google.com/forum/?fromgroups=#!topic/mozilla.dev.tech.js-engine.internals/2JLH5jRcr7E).','line_number':2421,'multiline':False]['text':'','line_number':2422,'multiline':False]['text':' The method seek() allows rescanning from a previously visited location of','line_number':2423,'multiline':False]['text':' the buffer, initially computed by constructing a Position local variable.','line_number':2424,'multiline':False]['text':'','line_number':2425,'multiline':False]['text':' Anything inherited through a base class whose type depends upon this','line_number':2439,'multiline':False]['text':' class's template parameters can only be accessed through a dependent','line_number':2440,'multiline':False]['text':' name: prefixed with |this|, by explicit qualification, and so on.  (This','line_number':2441,'multiline':False]['text':' is so that references to inherited fields are statically distinguishable','line_number':2442,'multiline':False]['text':' from references to names outside of the class.)  This is tedious and','line_number':2443,'multiline':False]['text':' onerous.','line_number':2444,'multiline':False]['text':'','line_number':2445,'multiline':False]['text':' As an alternative, we directly add every one of these functions to this','line_number':2446,'multiline':False]['text':' class, using explicit qualification to address the dependent-name','line_number':2447,'multiline':False]['text':' problem.  |this| or other qualification is no longer necessary -- at','line_number':2448,'multiline':False]['text':' cost of this ever-changing laundry list of |using|s.  So it goes.','line_number':2449,'multiline':False]['text':' Deliberately don't |using| |charBuffer| because of bug 1472569.  :-(','line_number':2461,'multiline':False]['text':' Deliberately don't |using| |sourceUnits| because of bug 1472569.  :-(','line_number':2485,'multiline':False]['text':'*
   * Get the next code point, converting LineTerminatorSequences to '\n' and
   * updating internal line-counter state if needed.  Return true on success
   * and store the code point in |*cp|.  Return false and leave |*cp|
   * undefined on failure.
   ','line_number':2498,'multiline':True]['text':' If there is an invalid escape in a template, report it and return false,','line_number':2506,'multiline':False]['text':' otherwise return true.','line_number':2507,'multiline':False]['text':' Implement ErrorReporter.','line_number':2519,'multiline':False]['text':' Implement ErrorReportMixin.','line_number':2553,'multiline':False]['text':' Implement ErrorReportMixin.','line_number':2562,'multiline':False]['text':'*
   * Tokenize a decimal number that begins at |numStart| into the provided
   * token.
   *
   * |unit| must be one of these values:
   *
   *   1. The first decimal digit in the integral part of a decimal number
   *      not starting with '0' or '.', e.g. '1' for "17", '3' for "3.14", or
   *      '8' for "8.675309e6".
   *
   *   In this case, the next |getCodeUnit()| must return the code unit after
   *   |unit| in the overall number.
   *
   *   2. The '.' in a "."/"0."-prefixed decimal number or the 'e'/'E' in a
   *      "0e"/"0E"-prefixed decimal number, e.g. ".17", "0.42", or "0.1e3".
   *
   *   In this case, the next |getCodeUnit()| must return the code unit
   *   *after* the first decimal digit *after* the '.'.  So the next code
   *   unit would be '7' in ".17", '2' in "0.42", 'e' in "0.4e+8", or '/' in
   *   "0.5/2" (three separate tokens).
   *
   *   3. The code unit after the '0' where "0" is the entire number token.
   *
   *   In this case, the next |getCodeUnit()| would return the code unit
   *   after |unit|, but this function will never perform such call.
   *
   *   4. (Non-strict mode code only)  The first '8' or '9' in a "noctal"
   *      number that begins with a '0' but contains a non-octal digit in its
   *      integer part so is interpreted as decimal, e.g. '9' in "09.28" or
   *      '8' in "0386" or '9' in "09+7" (three separate tokens").
   *
   *   In this case, the next |getCodeUnit()| returns the code unit after
   *   |unit|: '.', '6', or '+' in the examples above.
   *
   * This interface is super-hairy and horribly stateful.  Unfortunately, its
   * hair merely reflects the intricacy of ECMAScript numeric literal syntax.
   * And incredibly, it *improves* on the goto-based horror that predated it.
   ','line_number':2605,'multiline':True]['text':'* Tokenize a regular expression literal beginning at |start|. ','line_number':2647,'multiline':True]['text':'*
   * Slurp characters between |start| and sourceUnits.current() into
   * charBuffer, to later parse into a bigint.
   ','line_number':2650,'multiline':True]['text':' Advance to the next token.  If the token stream encountered an error,','line_number':2658,'multiline':False]['text':' return false.  Otherwise return true and store the token kind in |*ttp|.','line_number':2659,'multiline':False]['text':' Check for a pushed-back token resulting from mismatching lookahead.','line_number':2661,'multiline':False]['text':' This is like peekToken(), with one exception:  if there is an EOL','line_number':2720,'multiline':False]['text':' between the end of the current token and the start of the next token, it','line_number':2721,'multiline':False]['text':' return true and store Eol in |*ttp|.  In that case, no token with','line_number':2722,'multiline':False]['text':' Eol is actually created, just a Eol TokenKind is returned, and','line_number':2723,'multiline':False]['text':' currentToken() shouldn't be consulted.  (This is the only place Eol','line_number':2724,'multiline':False]['text':' is produced.)','line_number':2725,'multiline':False]['text':' If lookahead != 0, we have scanned ahead at least one token, and','line_number':2731,'multiline':False]['text':' |lineno| is the line that the furthest-scanned token ends on.  If','line_number':2732,'multiline':False]['text':' it's the same as the line that the current token ends on, that's a','line_number':2733,'multiline':False]['text':' stronger condition than what we are looking for, and we don't need','line_number':2734,'multiline':False]['text':' to return Eol.','line_number':2735,'multiline':False]['text':' The above check misses two cases where we don't have to return','line_number':2752,'multiline':False]['text':' Eol.','line_number':2753,'multiline':False]['text':' - The next token starts on the same line, but is a multi-line token.','line_number':2754,'multiline':False]['text':' - The next token starts on the same line, but lookahead==2 and there','line_number':2755,'multiline':False]['text':'   is a newline between the next token and the one after that.','line_number':2756,'multiline':False]['text':' The following test is somewhat expensive but gets these cases (and','line_number':2757,'multiline':False]['text':' all others) right.','line_number':2758,'multiline':False]['text':' Careful, |next| points to an initialized-but-not-allocated Token!','line_number':2767,'multiline':False]['text':' This is safe because we don't modify token data below.','line_number':2768,'multiline':False]['text':' Get the next token from the stream if its kind is |tt|.','line_number':2778,'multiline':False]['text':' If the next token ends an overall Expression, we'll parse this','line_number':2809,'multiline':False]['text':' Expression without ever invoking Parser::orExpr().  But we need that','line_number':2810,'multiline':False]['text':' function's DEBUG-only side effect of marking this token as safe to get','line_number':2811,'multiline':False]['text':' with SlashIsRegExp, so we have to do it manually here.','line_number':2812,'multiline':False]['text':' Parse a TemplateMiddle or TemplateTail token (one of the string-like parts','line_number':2869,'multiline':False]['text':' of a template string) after already consuming the leading `RightCurly`.','line_number':2870,'multiline':False]['text':' (The spec says the `}` is the first character of the TemplateMiddle/','line_number':2871,'multiline':False]['text':' TemplateTail, but we treat it as a separate token because that's much','line_number':2872,'multiline':False]['text':' easier to implement in both TokenStream and the parser.)','line_number':2873,'multiline':False]['text':'','line_number':2874,'multiline':False]['text':' This consumes a token and sets the current token, like `getToken()`.  It','line_number':2875,'multiline':False]['text':' doesn't take a Modifier because there's no risk of encountering a division','line_number':2876,'multiline':False]['text':' operator or RegExp literal.','line_number':2877,'multiline':False]['text':'','line_number':2878,'multiline':False]['text':' On success, `*ttp` is either `TokenKind::TemplateHead` (if we got a','line_number':2879,'multiline':False]['text':' TemplateMiddle token) or `TokenKind::NoSubsTemplate` (if we got a','line_number':2880,'multiline':False]['text':' TemplateTail). That may seem strange; there are four different template','line_number':2881,'multiline':False]['text':' token types in the spec, but we only use two. We use `TemplateHead` for','line_number':2882,'multiline':False]['text':' TemplateMiddle because both end with `...${`, and `NoSubsTemplate` for','line_number':2883,'multiline':False]['text':' TemplateTail because both contain the end of the template, including the','line_number':2884,'multiline':False]['text':' closing quote mark. They're not treated differently, either in the parser','line_number':2885,'multiline':False]['text':' or in the tokenizer.','line_number':2886,'multiline':False]['text':' It's preferable to define this in TokenStream.cpp, but its template-ness','line_number':2902,'multiline':False]['text':' means we'd then have to *instantiate* this constructor for all possible','line_number':2903,'multiline':False]['text':' (Unit, AnyCharsAccess) pairs -- and that gets super-messy as AnyCharsAccess','line_number':2904,'multiline':False]['text':' *itself* is templated.  This symbol really isn't that huge compared to some','line_number':2905,'multiline':False]['text':' defined inline in TokenStreamSpecific, so just rely on the linker commoning','line_number':2906,'multiline':False]['text':' stuff up.','line_number':2907,'multiline':False]['text':' allowPoisoned = ','line_number':2916,'multiline':True]['text':' static ','line_number':2959,'multiline':True]['text':' static ','line_number':2966,'multiline':True]['text':' namespace frontend','line_number':2974,'multiline':False]['text':' namespace js','line_number':2975,'multiline':False]['text':' frontend_TokenStream_h ','line_number':2981,'multiline':True]