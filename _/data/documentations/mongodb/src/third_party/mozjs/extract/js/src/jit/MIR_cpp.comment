['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JSJitInfo, JSTypedMethodJitInfo','line_number':29,'multiline':False]['text':' js::Scalar::Type','line_number':30,'multiline':False]['text':' js::PlainObject','line_number':33,'multiline':False]['text':' Division by zero will trap at runtime.','line_number':146,'multiline':False]['text':' Overflow will trap at runtime.','line_number':152,'multiline':False]['text':' Division by zero will trap at runtime.','line_number':160,'multiline':False]['text':' Handle all negative values at runtime, for simplicity.','line_number':164,'multiline':False]['text':' If this was an int32 operation but the result isn't an int32 (for','line_number':263,'multiline':False]['text':' example, a division where the numerator isn't evenly divisible by the','line_number':264,'multiline':False]['text':' denominator), decline folding.','line_number':265,'multiline':False]['text':' we should fold only when it is a floating point operation','line_number':278,'multiline':False]['text':' check if rhs is a power of two','line_number':295,'multiline':False]['text':' In the default case, there are no constants to fold.','line_number':420,'multiline':False]['text':' Only support specialized, non-magic types.','line_number':438,'multiline':False]['text':' If the type are matching then we return the value which is used as','line_number':483,'multiline':False]['text':' argument of the store.','line_number':484,'multiline':False]['text':' If we expect to read a type which is more generic than the type seen','line_number':486,'multiline':False]['text':' by the store, then we box the value used by the store.','line_number':487,'multiline':False]['text':' If the operand of the Not is itself a Not, they cancel out.','line_number':536,'multiline':False]['text':' We already have a definition use. So 1+','line_number':750,'multiline':False]['text':' We saw one definition. Loop to test if there is another.','line_number':755,'multiline':False]['text':' No def-uses.','line_number':793,'multiline':False]['text':' More than one def-use.','line_number':801,'multiline':False]['text':' No def-uses.','line_number':811,'multiline':False]['text':' This function relies on addUse adding new uses to the front of the list.','line_number':818,'multiline':False]['text':' Check this invariant by asserting the next few uses are 'older'. Skip this','line_number':819,'multiline':False]['text':' for phis because setBackedge can add a new use for a loop phi even if the','line_number':820,'multiline':False]['text':' loop body has a use with an id greater than the loop phi's id.','line_number':821,'multiline':False]['text':' Carry over the fact the value has uses which are no longer inspectable','line_number':846,'multiline':False]['text':' with the graph.','line_number':847,'multiline':False]['text':' Update the resume point operand to use the optimized-out constant.','line_number':866,'multiline':False]['text':' Remove dangling pointers.','line_number':871,'multiline':False]['text':' Update the operand to use the dominating definition.','line_number':888,'multiline':False]['text':' valueHash() and equals() expect the unused payload bits to be','line_number':1010,'multiline':False]['text':' initialized to zero. Assert this in debug builds.','line_number':1011,'multiline':False]['text':' Build a 64-bit value holding both the payload and the type.','line_number':1053,'multiline':False]['text':' Fold all 64 bits into the 32-bit result. It's tempting to just discard','line_number':1059,'multiline':False]['text':' half of the bits, as this is just a hash, however there are many common','line_number':1060,'multiline':False]['text':' patterns of values where only the low or the high bits vary, so','line_number':1061,'multiline':False]['text':' discarding either side would lead to excessive hash collisions.','line_number':1062,'multiline':False]['text':' Wasm has types like int64 that cannot be stored as js::Value. It also','line_number':1175,'multiline':False]['text':' doesn't want the NaN canonicalization enforced by js::Value.','line_number':1176,'multiline':False]['text':' TODO(Warp): Lazy groups have been removed.','line_number':1246,'multiline':False]['text':' We have to call EmulatesUndefined but that reads obj->group->clasp','line_number':1247,'multiline':False]['text':' and so it's racy when the object has a lazy group. The main callers','line_number':1248,'multiline':False]['text':' of this (MTest, MNot) already know how to fold the object case, so','line_number':1249,'multiline':False]['text':' just give up.','line_number':1250,'multiline':False]['text':' Decline folding if this is an int32 operation, but the result type','line_number':1343,'multiline':False]['text':' isn't an int32.','line_number':1344,'multiline':False]['text':' The function pointer call can't GC.','line_number':1378,'multiline':False]['text':' Define |THIS_SLOT| as part of this translation unit, as it is used to','line_number':1398,'multiline':False]['text':' specialized the parameterized |New| function calls introduced by','line_number':1399,'multiline':False]['text':' TRIVIAL_NEW_WRAPPERS.','line_number':1400,'multiline':False]['text':' If we are not running off-main thread we can assert that the','line_number':1434,'multiline':False]['text':' metadata is consistent.','line_number':1435,'multiline':False]['text':' If we don't know anything about the types of our arguments, we have to','line_number':1469,'multiline':False]['text':' assume that type-coercions can have side-effects, so we need to alias','line_number':1470,'multiline':False]['text':' everything.','line_number':1471,'multiline':False]['text':' Passing through undefined can't have side-effects','line_number':1483,'multiline':False]['text':' getArg(0) is "this", so skip it','line_number':1486,'multiline':False]['text':' The only way to reliably avoid side-effects given the information we','line_number':1489,'multiline':False]['text':' have here is if we're passing in a known primitive value to an','line_number':1490,'multiline':False]['text':' argument that expects a primitive value.','line_number':1491,'multiline':False]['text':'','line_number':1492,'multiline':False]['text':' XXXbz maybe we need to communicate better information.  For example,','line_number':1493,'multiline':False]['text':' a sequence argument will sort of unavoidably have side effects, while','line_number':1494,'multiline':False]['text':' a typed array argument won't have any, but both are claimed to be','line_number':1495,'multiline':False]['text':' JSJitInfo::Object.  But if we do that, we need to watch out for our','line_number':1496,'multiline':False]['text':' movability/DCE-ability bits: if we have an arg type that can reliably','line_number':1497,'multiline':False]['text':' throw an exception on conversion, that might not affect our alias set','line_number':1498,'multiline':False]['text':' per se, but it should prevent us being moved or DCE-ed, unless we','line_number':1499,'multiline':False]['text':' know the incoming things match that arg type and won't throw.','line_number':1500,'multiline':False]['text':'','line_number':1501,'multiline':False]['text':' We checked all the args, and they check out.  So we only alias DOM','line_number':1508,'multiline':False]['text':' mutations or alias nothing, depending on the alias set in the jitinfo.','line_number':1509,'multiline':False]['text':' We are movable if the jitinfo says we can be and if we're also not','line_number':1519,'multiline':False]['text':' effectful.  The jitinfo can't check for the latter, since it depends on','line_number':1520,'multiline':False]['text':' the types of our arguments.','line_number':1521,'multiline':False]['text':' The other call had better be movable at this point!','line_number':1563,'multiline':False]['text':' Fold MUnbox(MBox(x)) => x if types match.','line_number':1727,'multiline':False]['text':' Fold MUnbox(MBox(x)) => MToDouble(x) if possible.','line_number':1735,'multiline':False]['text':' MUnbox<Int32>(MBox<Double>(x)) will always fail, even if x can be','line_number':1746,'multiline':False]['text':' represented as an Int32. Fold to avoid unnecessary bailouts.','line_number':1747,'multiline':False]['text':' getLoopPredecessorOperand and getLoopBackedgeOperand rely on these','line_number':1761,'multiline':False]['text':' predecessors being at indices 0 and 1.','line_number':1762,'multiline':False]['text':' If we have phi(..., a, b, c, d, ..., z) and we plan','line_number':1779,'multiline':False]['text':' on removing a, then first shift downward so that we have','line_number':1780,'multiline':False]['text':' phi(..., b, c, d, ..., z, z):','line_number':1781,'multiline':False]['text':' truncate the inputs_ list:','line_number':1791,'multiline':False]['text':' Look if this MPhi is a ternary construct.
   * This is a very loose term as it actually only checks for
   *
   *      MTest X
   *       /  \
   *    ...    ...
   *       \  /
   *     MPhi X Y
   *
   * Which we will simply call:
   * x ? x : y or x ? y : x
   ','line_number':1803,'multiline':True]['text':' True branch may only dominate one edge of MPhi.','line_number':1829,'multiline':False]['text':' False branch may only dominate one edge of MPhi.','line_number':1835,'multiline':False]['text':' True and false branch must dominate different edges of MPhi.','line_number':1841,'multiline':False]['text':' We found a ternary construct.','line_number':1847,'multiline':False]['text':' Accept either','line_number':1853,'multiline':False]['text':' testArg ? testArg : constant or','line_number':1854,'multiline':False]['text':' testArg ? constant : testArg','line_number':1855,'multiline':False]['text':' This check should be a tautology, except that the constant might be the','line_number':1867,'multiline':False]['text':' result of the removal of a branch.  In such case the domination scope of','line_number':1868,'multiline':False]['text':' the block which is holding the constant might be incomplete. This','line_number':1869,'multiline':False]['text':' condition is used to prevent doing this optimization based on incomplete','line_number':1870,'multiline':False]['text':' information.','line_number':1871,'multiline':False]['text':'','line_number':1872,'multiline':False]['text':' As GVN removed a branch, it will update the dominations rules before','line_number':1873,'multiline':False]['text':' trying to fold this MPhi again. Thus, this condition does not inhibit','line_number':1874,'multiline':False]['text':' this optimization.','line_number':1875,'multiline':False]['text':' If testArg is an int32 type we can:','line_number':1883,'multiline':False]['text':' - fold testArg ? testArg : 0 to testArg','line_number':1884,'multiline':False]['text':' - fold testArg ? 0 : testArg to 0','line_number':1885,'multiline':False]['text':' When folding to the constant we need to hoist it.','line_number':1889,'multiline':False]['text':' If testArg is an double type we can:','line_number':1896,'multiline':False]['text':' - fold testArg ? testArg : 0.0 to MNaNToZero(testArg)','line_number':1897,'multiline':False]['text':' If testArg is a string type we can:','line_number':1905,'multiline':False]['text':' - fold testArg ? testArg : "" to testArg','line_number':1906,'multiline':False]['text':' - fold testArg ? "" : testArg to ""','line_number':1907,'multiline':False]['text':' When folding to the constant we need to hoist it.','line_number':1910,'multiline':False]['text':' If this phi is redundant (e.g., phi(a,a) or b=phi(a,this)),','line_number':1925,'multiline':False]['text':' returns the operand that it will always be equal to (a, in','line_number':1926,'multiline':False]['text':' those two cases).','line_number':1927,'multiline':False]['text':' Phis in different blocks may have different control conditions.','line_number':1955,'multiline':False]['text':' For example, these phis:','line_number':1956,'multiline':False]['text':'','line_number':1957,'multiline':False]['text':'   if (p)','line_number':1958,'multiline':False]['text':'     goto a','line_number':1959,'multiline':False]['text':'   a:','line_number':1960,'multiline':False]['text':'     t = phi(x, y)','line_number':1961,'multiline':False]['text':'','line_number':1962,'multiline':False]['text':'   if (q)','line_number':1963,'multiline':False]['text':'     goto b','line_number':1964,'multiline':False]['text':'   b:','line_number':1965,'multiline':False]['text':'     s = phi(x, y)','line_number':1966,'multiline':False]['text':'','line_number':1967,'multiline':False]['text':' have identical operands, but they are not equvalent because t is','line_number':1968,'multiline':False]['text':' effectively p?x:y and s is effectively q?x:y.','line_number':1969,'multiline':False]['text':'','line_number':1970,'multiline':False]['text':' For now, consider phis in different blocks incongruent.','line_number':1971,'multiline':False]['text':' This function is called to fix the current Phi flags using it as a','line_number':1980,'multiline':False]['text':' replacement of the other Phi instruction |def|.','line_number':1981,'multiline':False]['text':'','line_number':1982,'multiline':False]['text':' When dealing with usage analysis, any Use will replace all other values,','line_number':1983,'multiline':False]['text':' such as Unused and Unknown. Unless both are Unused, the merge would be','line_number':1984,'multiline':False]['text':' Unknown.','line_number':1985,'multiline':False]['text':'    this == unused && other == unknown','line_number':1991,'multiline':False]['text':' or this == unknown && other == unused','line_number':1992,'multiline':False]['text':'    this == unused && other == unused','line_number':1995,'multiline':False]['text':' or this == unknown && other = unknown','line_number':1996,'multiline':False]['text':' static ','line_number':2004,'multiline':True]['text':' Find and mark phis that must transitively hold an iterator live.','line_number':2006,'multiline':False]['text':' This phi must be able to be any value.','line_number':2048,'multiline':False]['text':' The operand vector is initialized in reverse order by WarpBuilder.','line_number':2056,'multiline':False]['text':' It cannot be checked for consistency until all arguments are added.','line_number':2057,'multiline':False]['text':' FixedList doesn't initialize its elements, so do an unchecked init.','line_number':2058,'multiline':False]['text':' Identity operations are removed (for int32 only) in foldUnnecessaryBitop.','line_number':2071,'multiline':False]['text':' It's probably OK to perform this optimization only for int32, as it will','line_number':2087,'multiline':False]['text':' have the greatest effect for asm.js code that is compiled with the JS','line_number':2088,'multiline':False]['text':' pipeline, and that code will not see int64 values.','line_number':2089,'multiline':False]['text':' Fold unsigned shift right operator when the second operand is zero and','line_number':2095,'multiline':False]['text':' the only use is an unsigned modulo. Thus, the expression','line_number':2096,'multiline':False]['text':' |(x >>> 0) % y| becomes |x % y|.','line_number':2097,'multiline':False]['text':' Eliminate bitwise operations that are no-ops when used on integer','line_number':2105,'multiline':False]['text':' inputs, such as (x | 0).','line_number':2106,'multiline':False]['text':' Test if this instruction can produce negative zero even when bailing out','line_number':2147,'multiline':False]['text':' and changing types.','line_number':2148,'multiline':False]['text':' Test if all uses have the same semantics for -0 and 0','line_number':2173,'multiline':False]['text':' If add is truncating -0 and 0 are observed as the same.','line_number':2182,'multiline':False]['text':' x + y gives -0, when both x and y are -0','line_number':2187,'multiline':False]['text':' Figure out the order in which the addition's operands will','line_number':2189,'multiline':False]['text':' execute. EdgeCaseAnalysis::analyzeLate has renumbered the MIR','line_number':2190,'multiline':False]['text':' definitions for us so that this just requires comparing ids.','line_number':2191,'multiline':False]['text':' Negative zero checks can be removed on the first executed','line_number':2197,'multiline':False]['text':' operand only if it is guaranteed the second executed operand','line_number':2198,'multiline':False]['text':' will produce a value other than -0. While the second is','line_number':2199,'multiline':False]['text':' typed as an int32, a bailout taken between execution of the','line_number':2200,'multiline':False]['text':' operands may change that type and cause a -0 to flow to the','line_number':2201,'multiline':False]['text':' second.','line_number':2202,'multiline':False]['text':'','line_number':2203,'multiline':False]['text':' There is no way to test whether there are any bailouts','line_number':2204,'multiline':False]['text':' between execution of the operands, so remove negative','line_number':2205,'multiline':False]['text':' zero checks from the first only if the second's type is','line_number':2206,'multiline':False]['text':' independent from type changes that may occur after bailing.','line_number':2207,'multiline':False]['text':' The negative zero check can always be removed on the second','line_number':2212,'multiline':False]['text':' executed operand; by the time this executes the first will have','line_number':2213,'multiline':False]['text':' been evaluated as int32 and the addition's result cannot be -0.','line_number':2214,'multiline':False]['text':' If sub is truncating -0 and 0 are observed as the same','line_number':2218,'multiline':False]['text':' x + y gives -0, when x is -0 and y is 0','line_number':2223,'multiline':False]['text':' We can remove the negative zero check on the rhs, only if we','line_number':2225,'multiline':False]['text':' are sure the lhs isn't negative zero.','line_number':2226,'multiline':False]['text':' The lhs is typed as integer (i.e. not -0.0), but it can bailout','line_number':2228,'multiline':False]['text':' and change type. This should be fine if the lhs is executed','line_number':2229,'multiline':False]['text':' first. However if the rhs is executed first, the lhs can bail,','line_number':2230,'multiline':False]['text':' change type and become -0.0 while the rhs has already been','line_number':2231,'multiline':False]['text':' optimized to not make a difference between zero and negative zero.','line_number':2232,'multiline':False]['text':' Only allowed to remove check when definition is the second operand','line_number':2251,'multiline':False]['text':' Only allowed to remove check when definition is the first operand','line_number':2262,'multiline':False]['text':' Always allowed to remove check. No matter which operand.','line_number':2277,'multiline':False]['text':' Only allowed to remove check when definition is the third operand.','line_number':2282,'multiline':False]['text':' It's probably OK to perform this optimization only for int32, as it will','line_number':2344,'multiline':False]['text':' have the greatest effect for asm.js code that is compiled with the JS','line_number':2345,'multiline':False]['text':' pipeline, and that code will not see int64 values.','line_number':2346,'multiline':False]['text':' 0 + -0 = 0. So we can't remove addition','line_number':2420,'multiline':False]['text':' subtraction isn't commutative. So we can't remove subtraction when lhs','line_number':2432,'multiline':False]['text':' equals 0','line_number':2433,'multiline':False]['text':' id op x => x','line_number':2442,'multiline':False]['text':' Do not use Float32 if we can use int32.','line_number':2451,'multiline':False]['text':' Directly apply math utility to compare the rhs() and lhs() when','line_number':2505,'multiline':False]['text':' they are both constants.','line_number':2506,'multiline':False]['text':' The folded MConstant should maintain the same MIRType with','line_number':2523,'multiline':False]['text':' the original MMinMax.','line_number':2524,'multiline':False]['text':' min(int32, cte >= INT32_MAX) = int32','line_number':2544,'multiline':False]['text':' max(int32, cte <= INT32_MIN) = int32','line_number':2554,'multiline':False]['text':' (Typed)ArrayLength is always >= 0.','line_number':2569,'multiline':False]['text':' max(array.length, cte <= 0) = array.length','line_number':2570,'multiline':False]['text':' min(array.length, cte <= 0) = cte','line_number':2571,'multiline':False]['text':' Both `x` and `p` in `x^p` must be constants in order to precompute.','line_number':2581,'multiline':False]['text':' Reject folding if the result isn't an int32, because we'll bail anyway.','line_number':2598,'multiline':False]['text':' If `p` in `x^p` isn't constant, we can't apply these folds.','line_number':2607,'multiline':False]['text':' Math.pow(x, 0.5) is a sqrt with edge-case detection.','line_number':2619,'multiline':False]['text':' Math.pow(x, -0.5) == 1 / Math.pow(x, 0.5), even for edge cases.','line_number':2625,'multiline':False]['text':' Math.pow(x, 1) == x.','line_number':2635,'multiline':False]['text':' Multiplying the same number can't yield negative zero.','line_number':2644,'multiline':False]['text':' Math.pow(x, 2) == x*x.','line_number':2649,'multiline':False]['text':' Math.pow(x, 3) == x*x*x.','line_number':2654,'multiline':False]['text':' Math.pow(x, 4) == y*y, where y = x*x.','line_number':2661,'multiline':False]['text':' No optimization','line_number':2668,'multiline':False]['text':' Do not use Float32 if we can use int32.','line_number':2701,'multiline':False]['text':' This is only meaningful when doing integer division.','line_number':2738,'multiline':False]['text':' Try removing divide by zero check','line_number':2746,'multiline':False]['text':' If lhs is a constant int != INT32_MIN, then','line_number':2751,'multiline':False]['text':' negative overflow check can be skipped.','line_number':2752,'multiline':False]['text':' If rhs is a constant int != -1, likewise.','line_number':2757,'multiline':False]['text':' If lhs is != 0, then negative zero check can be skipped.','line_number':2762,'multiline':False]['text':' If rhs is >= 0, likewise.','line_number':2767,'multiline':False]['text':' These optimizations make sense only for integer division','line_number':2799,'multiline':False]['text':' the add is fallible if range analysis does not say that it is finite, AND','line_number':2873,'multiline':False]['text':' either the truncation analysis shows that there are non-truncated uses.','line_number':2874,'multiline':False]['text':' see comment in MAdd::fallible()','line_number':2885,'multiline':False]['text':' Optimize X - X to 0. This optimization is only valid for Int32','line_number':2905,'multiline':False]['text':' values. Subtracting a floating point value from itself returns','line_number':2906,'multiline':False]['text':' NaN when the operand is either Infinity or NaN.','line_number':2907,'multiline':False]['text':' Ensure that any bailouts that we depend on to guarantee that X','line_number':2909,'multiline':False]['text':' is Int32 are not removed.','line_number':2910,'multiline':False]['text':' Try to remove the check for negative zero','line_number':2936,'multiline':False]['text':' This only makes sense when using the integer multiplication','line_number':2937,'multiline':False]['text':' If lhs is > 0, no need for negative zero check.','line_number':2942,'multiline':False]['text':' If rhs is > 0, likewise.','line_number':2949,'multiline':False]['text':' Remove the imul annotation when merging imul and normal multiplication.','line_number':2967,'multiline':False]['text':' silence GCC warning','line_number':3032,'multiline':False]['text':' static ','line_number':3036,'multiline':True]['text':' ~~x => x | 0','line_number':3088,'multiline':False]['text':' The flags are packed with the length in a fixed private slot.','line_number':3136,'multiline':False]['text':' Since Ion has no UInt32 type, we use Int32 and we have a special','line_number':3214,'multiline':False]['text':' exception to the type rules: we can return values in','line_number':3215,'multiline':False]['text':' (INT32_MIN,UINT32_MAX] and still claim that we have an Int32 type','line_number':3216,'multiline':False]['text':' without bailing out. This is necessary because Ion has no UInt32','line_number':3217,'multiline':False]['text':' type and we can't have bailouts in wasm code.','line_number':3218,'multiline':False]['text':' FixedList doesn't initialize its elements, so do unchecked inits.','line_number':3252,'multiline':False]['text':' If the last resume point had the same side-effect stack, then we can','line_number':3264,'multiline':False]['text':' reuse the current side effect without cloning it. This is a simple','line_number':3265,'multiline':False]['text':' way to share common context by making a spaghetti stack.','line_number':3266,'multiline':False]['text':' Ensure that the store would not be deleted by DCE.','line_number':3273,'multiline':False]['text':' If the operand converts an I64 to BigInt, drop both conversions.','line_number':3341,'multiline':False]['text':' Fold this operation if the input operand is constant.','line_number':3346,'multiline':False]['text':' Unwrap MInt64ToBigInt: MToInt64(MInt64ToBigInt(int64)) = int64.','line_number':3362,'multiline':False]['text':' When the input is an Int64 already, just return it.','line_number':3367,'multiline':False]['text':' Fold this operation if the input operand is constant.','line_number':3372,'multiline':False]['text':' Fold this operation if the input operand is constant.','line_number':3386,'multiline':False]['text':' Only the value within the range of Int32 can be substituted as','line_number':3405,'multiline':False]['text':' constant.','line_number':3406,'multiline':False]['text':' Do not fold the TruncateToInt32 node when the input is uint32 (e.g. ursh','line_number':3421,'multiline':False]['text':' with a zero constant. Consider the test jit-test/tests/ion/bug1247880.js,','line_number':3422,'multiline':False]['text':' where the relevant code is: |(imul(1, x >>> 0) % 2)|. The imul operator','line_number':3423,'multiline':False]['text':' is folded to a MTruncateToInt32 node, which will result in this MIR:','line_number':3424,'multiline':False]['text':' MMod(MTruncateToInt32(MUrsh(x, MConstant(0))), MConstant(2)). Note that','line_number':3425,'multiline':False]['text':' the MUrsh node's type is int32 (since uint32 is not implemented), and','line_number':3426,'multiline':False]['text':' that would fold the MTruncateToInt32 node. This will make the modulo','line_number':3427,'multiline':False]['text':' unsigned, while is should have been signed.','line_number':3428,'multiline':False]['text':' Fold this operation if the input operand is constant.','line_number':3439,'multiline':False]['text':' Only the value within the range of Int32 can be substituted as','line_number':3455,'multiline':False]['text':' constant.','line_number':3456,'multiline':False]['text':' See the comment in |MToNumberInt32::foldsTo|.','line_number':3467,'multiline':False]['text':' Do not fold the TruncateToInt32 node when the input is uint32 (e.g. ursh','line_number':3487,'multiline':False]['text':' with a zero constant. Consider the test jit-test/tests/ion/bug1247880.js,','line_number':3488,'multiline':False]['text':' where the relevant code is: |(imul(1, x >>> 0) % 2)|. The imul operator','line_number':3489,'multiline':False]['text':' is folded to a MTruncateToInt32 node, which will result in this MIR:','line_number':3490,'multiline':False]['text':' MMod(MTruncateToInt32(MUrsh(x, MConstant(0))), MConstant(2)). Note that','line_number':3491,'multiline':False]['text':' the MUrsh node's type is int32 (since uint32 is not implemented), and','line_number':3492,'multiline':False]['text':' that would fold the MTruncateToInt32 node. This will make the modulo','line_number':3493,'multiline':False]['text':' unsigned, while is should have been signed.','line_number':3494,'multiline':False]['text':' If x is a Float32, Float32(Double(x)) == x','line_number':3638,'multiline':False]['text':' Fold ToFloat32(ToDouble(int32)) to ToFloat32(int32).','line_number':3650,'multiline':False]['text':' Intuitively somebody would think that if lhs === rhs,','line_number':3686,'multiline':False]['text':' then we can just return true. (Or false for !==)','line_number':3687,'multiline':False]['text':' However NaN !== NaN is true! So we spend some time trying','line_number':3688,'multiline':False]['text':' to eliminate this case.','line_number':3689,'multiline':False]['text':' The LHS is the value we want to test against null or undefined.','line_number':3788,'multiline':False]['text':' Optimize "MCompare MConstant (MToDouble SomethingInInt32Range).','line_number':3848,'multiline':False]['text':' In most cases the MToDouble was added, because the constant is','line_number':3849,'multiline':False]['text':' a double.','line_number':3850,'multiline':False]['text':' e.g. v < 9007199254740991, where v is an int32 is always true.','line_number':3851,'multiline':False]['text':' Fall through.','line_number':3904,'multiline':False]['text':' Fall through.','line_number':3911,'multiline':False]['text':' Fold away some String equality comparisons.','line_number':3938,'multiline':False]['text':' Default to equal.','line_number':3940,'multiline':False]['text':' |str[i]| is compiled as |MFromCharCode(MCharCodeAt(str, i))|.','line_number':3987,'multiline':False]['text':' Try to optimize |MConstant(string) <compare> (MFromCharCode MCharCodeAt)|','line_number':3994,'multiline':False]['text':' as |MConstant(charcode) <compare> MCharCodeAt|.','line_number':3995,'multiline':False]['text':' Try to optimize |(MFromCharCode MCharCodeAt) <compare> (MFromCharCode','line_number':4024,'multiline':False]['text':' MCharCodeAt)| as |MCharCodeAt <compare> MCharCodeAt|.','line_number':4025,'multiline':False]['text':' Fold if the input is constant','line_number':4073,'multiline':False]['text':' If the operand of the Not is itself a Not, they cancel out. But we can't','line_number':4084,'multiline':False]['text':' always convert Not(Not(x)) to x because that may loose the conversion to','line_number':4085,'multiline':False]['text':' boolean. We can simplify Not(Not(Not(x))) to Not(x) though.','line_number':4086,'multiline':False]['text':' Not of an undefined or null value is always true','line_number':4095,'multiline':False]['text':' Not of a symbol is always false.','line_number':4101,'multiline':False]['text':' This instruction is only used as a summary for bailout paths.','line_number':4156,'multiline':False]['text':' This instruction is only used as a summary for bailout paths.','line_number':4166,'multiline':False]['text':' static ','line_number':4174,'multiline':True]['text':' MNewPlainObject uses a shape constant, not an object.','line_number':4176,'multiline':False]['text':' +1, for the Object.','line_number':4196,'multiline':False]['text':' Initialize all the slots of the object state with the value contained in','line_number':4214,'multiline':False]['text':' the template object. This is needed to account values which are baked in','line_number':4215,'multiline':False]['text':' the template objects and not visible in IonMonkey, such as the','line_number':4216,'multiline':False]['text':' uninitialized-lexical magic value of call objects.','line_number':4217,'multiline':False]['text':' This instruction is only used as a summary for bailout paths.','line_number':4266,'multiline':False]['text':' +1, for the Array object.','line_number':4281,'multiline':False]['text':' +1, for the length value of the array.','line_number':4283,'multiline':False]['text':' No globals of different type can alias.  See bug 1467415 comment 3.','line_number':4440,'multiline':False]['text':' We could do better here.  We're dealing with two indirect globals.','line_number':4445,'multiline':False]['text':' If at at least one of them is created in this module, then they','line_number':4446,'multiline':False]['text':' can't alias -- in other words they can only alias if they are both','line_number':4447,'multiline':False]['text':' imported.  That would require having a flag on globals to indicate','line_number':4448,'multiline':False]['text':' which are imported.  See bug 1467415 comment 3, 4th rule.','line_number':4449,'multiline':False]['text':' Same comment as in MWasmLoadGlobalVar::congruentTo() applies here.','line_number':4456,'multiline':False]['text':' We don't need to consider the isConstant_ markings here, because','line_number':4469,'multiline':False]['text':' equivalence of offsets implies equivalence of constness.','line_number':4470,'multiline':False]['text':' We omit checking congruence of the operands.  There is only one','line_number':4474,'multiline':False]['text':' operand, the TLS pointer, and it only ever has one value within the','line_number':4475,'multiline':False]['text':' domain of optimization.  If that should ever change then operand','line_number':4476,'multiline':False]['text':' congruence checking should be reinstated.','line_number':4477,'multiline':False]['text':' && congruentIfOperandsEqual(other) ','line_number':4478,'multiline':True]['text':' Specialize swizzle(v, constant) as shuffle(mask, v, zero) to trigger all','line_number':4524,'multiline':False]['text':' our shuffle optimizations.  We don't report this rewriting as the report','line_number':4525,'multiline':False]['text':' will be overwritten by the subsequent shuffle analysis.','line_number':4526,'multiline':False]['text':' Out-of-bounds lanes reference the zero vector; in many cases, the zero','line_number':4530,'multiline':False]['text':' vector is removed by subsequent optimizations.','line_number':4531,'multiline':False]['text':' Specialize var OP const / const OP var when possible.','line_number':4546,'multiline':False]['text':'','line_number':4547,'multiline':False]['text':' As the LIR layer can't directly handle v128 constants as part of its normal','line_number':4548,'multiline':False]['text':' machinery we specialize some nodes here if they have single-use v128','line_number':4549,'multiline':False]['text':' constant arguments.  The purpose is to generate code that inlines the','line_number':4550,'multiline':False]['text':' constant in the instruction stream, using either a rip-relative load+op or','line_number':4551,'multiline':False]['text':' quickly-synthesized constant in a scratch on x64.  There is a general','line_number':4552,'multiline':False]['text':' assumption here that that is better than generating the constant into an','line_number':4553,'multiline':False]['text':' allocatable register, since that register value could not be reused. (This','line_number':4554,'multiline':False]['text':' ignores the possibility that the constant load could be hoisted).','line_number':4555,'multiline':False]['text':' ENABLE_WASM_SIMD','line_number':4738,'multiline':False]['text':' Skip over instructions that usually appear between the actual index','line_number':4828,'multiline':False]['text':' value being used and the MLoadElement.','line_number':4829,'multiline':False]['text':' They don't modify the index value in a meaningful way.','line_number':4830,'multiline':False]['text':' Drop the MToNumberInt32 added by the TypePolicy for double and float','line_number':4832,'multiline':False]['text':' values.','line_number':4833,'multiline':False]['text':' Ignore the bounds check, which don't modify the index.','line_number':4838,'multiline':False]['text':' Masking the index for Spectre-mitigation is not observable.','line_number':4843,'multiline':False]['text':' For constants check they are not equal.','line_number':4859,'multiline':False]['text':' Be conservative and only allow values that fit into int32.','line_number':4869,'multiline':False]['text':' Check if "ins1 = ins2 + cte", which would make both instructions','line_number':4879,'multiline':False]['text':' have different values.','line_number':4880,'multiline':False]['text':' FixedList doesn't initialize its elements, so do an unchecked init.','line_number':4960,'multiline':False]['text':' If we only have one successor, convert to a plain goto to the only','line_number':5075,'multiline':False]['text':' successor. TableSwitch indices are numeric; other types will always go to','line_number':5076,'multiline':False]['text':' the only successor.','line_number':5077,'multiline':False]['text':' The MStringSplit won't generate any code.','line_number':5113,'multiline':False]['text':' We're replacing foo.split(bar).join(baz) by','line_number':5116,'multiline':False]['text':' foo.replace(bar, baz).  MStringSplit could be recovered by','line_number':5117,'multiline':False]['text':' a bailout.  As we are removing its last use, and its result','line_number':5118,'multiline':False]['text':' could be captured by a resume point, this MStringSplit will','line_number':5119,'multiline':False]['text':' be executed on the bailout path.','line_number':5120,'multiline':False]['text':' Fold constant double representable as intptr to intptr.','line_number':5215,'multiline':False]['text':' If not representable as an int64, this access is equal to an OOB access.','line_number':5218,'multiline':False]['text':' So replace it with a known int64/intptr value which also produces an OOB','line_number':5219,'multiline':False]['text':' access. If we don't support OOB accesses we have to bail out.','line_number':5220,'multiline':False]['text':' These instructions don't modify the object and just guard specific','line_number':5270,'multiline':False]['text':' properties.','line_number':5271,'multiline':False]['text':' The guard doesn't depend on any other instruction that is modifying','line_number':5335,'multiline':False]['text':' the object operand, so check it directly.','line_number':5336,'multiline':False]['text':' A JSFunction's BaseScript pointer is immutable. Relazification of','line_number':5570,'multiline':False]['text':' self-hosted functions is an exception to this, but we don't use this','line_number':5571,'multiline':False]['text':' guard for self-hosted functions.','line_number':5572,'multiline':False]['text':' At the JS boundary some wasm types must be represented as a Value, and in','line_number':5872,'multiline':False]['text':' addition a void return requires an Undefined value.','line_number':5873,'multiline':False]