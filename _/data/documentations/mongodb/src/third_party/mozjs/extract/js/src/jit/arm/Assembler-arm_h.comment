['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' NOTE: there are duplicates in this list! Sometimes we want to specifically','line_number':33,'multiline':False]['text':' refer to the link register as a link register (bl lr is much clearer than bl','line_number':34,'multiline':False]['text':' r14). HOWEVER, this register can easily be a gpr when it is not busy holding','line_number':35,'multiline':False]['text':' the return address.','line_number':36,'multiline':False]['text':' Helper class for ScratchRegister usage. Asserts that only one piece','line_number':58,'multiline':False]['text':' of code thinks it has exclusive ownership of the scratch register.','line_number':59,'multiline':False]['text':' These register assignments for the 64-bit atomic ops are frequently too','line_number':85,'multiline':False]['text':' constraining, but we have no way of expressing looser constraints to the','line_number':86,'multiline':False]['text':' register allocator.','line_number':87,'multiline':False]['text':' CompareExchange: Any two odd/even pairs would do for `new` and `out`, and any','line_number':89,'multiline':False]['text':' pair would do for `old`, so long as none of them overlap.','line_number':90,'multiline':False]['text':' Exchange: Any two non-equal odd/even pairs would do for `new` and `out`.','line_number':105,'multiline':False]['text':' Atomic rmw operations: Any two odd/even pairs would do for `tmp` and `out`,','line_number':113,'multiline':False]['text':' and any pair would do for `val`, so long as none of them overlap.','line_number':114,'multiline':False]['text':' ARM can either use HardFp (use float registers for float arguments), or','line_number':135,'multiline':False]['text':' SoftFp (use general registers for float arguments) ABI.  We keep this','line_number':136,'multiline':False]['text':' switch as a runtime switch because wasm always use the HardFp back-end','line_number':137,'multiline':False]['text':' while the calls to native functions have to use the one provided by the','line_number':138,'multiline':False]['text':' system.','line_number':139,'multiline':False]['text':' These registers may be volatile or nonvolatile.','line_number':160,'multiline':False]['text':' This register may be volatile or nonvolatile. Avoid d15 which is the','line_number':166,'multiline':False]['text':' ScratchDoubleReg_.','line_number':167,'multiline':False]['text':' These registers may be volatile or nonvolatile.','line_number':171,'multiline':False]['text':' Note: these three registers are all guaranteed to be different','line_number':172,'multiline':False]['text':' This register is guaranteed to be clobberable during the prologue and','line_number':177,'multiline':False]['text':' epilogue of an ABI call which must preserve both ABI argument, return','line_number':178,'multiline':False]['text':' and non-volatile registers.','line_number':179,'multiline':False]['text':' TLS pointer argument register for WebAssembly functions. This must not alias','line_number':182,'multiline':False]['text':' any other register used for passing function arguments or return values.','line_number':183,'multiline':False]['text':' Preserved by WebAssembly functions.','line_number':184,'multiline':False]['text':' Registers used for wasm table calls. These registers must be disjoint','line_number':187,'multiline':False]['text':' from the ABI argument registers, WasmTlsReg and each other.','line_number':188,'multiline':False]['text':' Register used as a scratch along the return path in the fast js -> wasm stub','line_number':194,'multiline':False]['text':' code.  This must not overlap ReturnReg, JSReturnOperand, or WasmTlsReg.  It','line_number':195,'multiline':False]['text':' must be a volatile register.','line_number':196,'multiline':False]['text':' Register used to store a reference to an exception thrown by Wasm to an','line_number':199,'multiline':False]['text':' exception handling block. Should not overlap with WasmTlsReg.','line_number':200,'multiline':False]['text':' The attribute '__value_in_regs' alters the calling convention of a function','line_number':217,'multiline':False]['text':' so that a structure of up to four elements can be returned via the argument','line_number':218,'multiline':False]['text':' registers rather than being written to memory.','line_number':219,'multiline':False]['text':' Do not reference ScratchFloat32Reg_ directly, use ScratchFloat32Scope','line_number':240,'multiline':False]['text':' instead.','line_number':241,'multiline':False]['text':' Do not reference ScratchDoubleReg_ directly, use ScratchDoubleScope instead.','line_number':247,'multiline':False]['text':' Registerd used in RegExpMatcher instruction (do not use JSReturnOperand).','line_number':253,'multiline':False]['text':' Registerd used in RegExpTester instruction (do not use ReturnReg).','line_number':258,'multiline':False]['text':' For maximal awesomeness, 8 should be sufficent. ldrd/strd (dual-register','line_number':280,'multiline':False]['text':' load/store) operate in a single cycle when the address they are dealing with','line_number':281,'multiline':False]['text':' is 8 byte aligned. Also, the ARM abi wants the stack to be 8 byte aligned at','line_number':282,'multiline':False]['text':' function boundaries. I'm trying to make sure this is always true.','line_number':283,'multiline':False]['text':' See comments in wasm::GenerateFunctionPrologue.  The difference between these','line_number':312,'multiline':False]['text':' is the size of the largest callable prologue on the platform.','line_number':313,'multiline':False]['text':' For being passed into the generic vfp instruction generator when there is an','line_number':341,'multiline':False]['text':' instruction that only takes two registers.','line_number':342,'multiline':False]['text':' The docs were rather unclear on this. It sounds like','line_number':357,'multiline':False]['text':' 1 << 21 | 0 << 24 encodes dtrt.','line_number':358,'multiline':False]['text':' For the extra memory operations, ldrd, ldrsb, ldrh.','line_number':363,'multiline':False]['text':' << 5','line_number':367,'multiline':False]['text':' << 5','line_number':368,'multiline':False]['text':' << 5','line_number':369,'multiline':False]['text':' << 5','line_number':370,'multiline':False]['text':' RRX is encoded as ROR with a 0 offset.','line_number':371,'multiline':False]['text':' Modes for STM/LDM. Names are the suffixes applied to the instruction.','line_number':374,'multiline':False]['text':' empty / after','line_number':376,'multiline':False]['text':' full / before','line_number':377,'multiline':False]['text':' decrement','line_number':378,'multiline':False]['text':' increment','line_number':379,'multiline':False]['text':' Condition code updating mode.','line_number':388,'multiline':False]['text':' Set condition code.','line_number':390,'multiline':False]['text':' Leave condition code unchanged.','line_number':391,'multiline':False]['text':' You almost never want to use this directly. Instead, you wantto pass in a','line_number':396,'multiline':False]['text':' signed constant, and let this bit be implicitly set for you. This is however,','line_number':397,'multiline':False]['text':' necessary if we want a negative index.','line_number':398,'multiline':False]['text':' Just like ALUOp, but for the vfp instruction set.','line_number':439,'multiline':False]['text':' Negate the operation, AND negate the immediate that we were passed in.','line_number':453,'multiline':False]['text':' If there is a variant of op that has a dest (think cmp/sub) return that','line_number':459,'multiline':False]['text':' variant of it.','line_number':460,'multiline':False]['text':' All of these classes exist solely to shuffle data into the various operands.','line_number':467,'multiline':False]['text':' For example Operand2 can be an imm8, a register-shifted-by-a-constant or a','line_number':468,'multiline':False]['text':' register-shifted-by-a-register. We represent this in C++ by having a base','line_number':469,'multiline':False]['text':' class Operand2, which just stores the 32 bits of data as they will be encoded','line_number':470,'multiline':False]['text':' in the instruction. You cannot directly create an Operand2 since it is','line_number':471,'multiline':False]['text':' tricky, and not entirely sane to do so. Instead, you create one of its child','line_number':472,'multiline':False]['text':' classes, e.g. Imm8. Imm8's constructor takes a single integer argument. Imm8','line_number':473,'multiline':False]['text':' will verify that its argument can be encoded as an ARM 12 bit imm8, encode it','line_number':474,'multiline':False]['text':' using an Imm8data, and finally call its parent's (Operand2) constructor with','line_number':475,'multiline':False]['text':' the Imm8data. The Operand2 constructor will then call the Imm8data's encode()','line_number':476,'multiline':False]['text':' function to extract the raw bits from it.','line_number':477,'multiline':False]['text':'','line_number':478,'multiline':False]['text':' In the future, we should be able to extract data from the Operand2 by asking','line_number':479,'multiline':False]['text':' it for its component Imm8data structures. The reason this is so horribly','line_number':480,'multiline':False]['text':' round-about is we wanted to have Imm8 and RegisterShiftedRegister inherit','line_number':481,'multiline':False]['text':' directly from Operand2 but have all of them take up only a single word of','line_number':482,'multiline':False]['text':' storage. We also wanted to avoid passing around raw integers at all since','line_number':483,'multiline':False]['text':' they are error prone.','line_number':484,'multiline':False]['text':' The "second register".','line_number':492,'multiline':False]['text':' Do we get another register for shifting.','line_number':494,'multiline':False]['text':' We'd like this to be a more sensible encoding, but that would need to be','line_number':497,'multiline':False]['text':' a struct and that would not pack :(','line_number':498,'multiline':False]['text':' Mark as a protected field to avoid unused private field warnings.','line_number':502,'multiline':False]['text':' Op2 has a mode labelled "<imm8m>", which is arm's magical immediate encoding.','line_number':517,'multiline':False]['text':' Some instructions actually get 8 bits of data, which is called Imm8Data','line_number':518,'multiline':False]['text':' below. These should have edit distance > 1, but this is how it is for now.','line_number':519,'multiline':False]['text':' Mark as a protected field to avoid unused private field warnings.','line_number':525,'multiline':False]['text':' Throw in an extra bit that will be 1 if we can't encode this properly.','line_number':529,'multiline':False]['text':' if we can encode it properly, a simple "|" will still suffice to meld it','line_number':530,'multiline':False]['text':' into the instruction.','line_number':531,'multiline':False]['text':' Default constructor makes an invalid immediate.','line_number':535,'multiline':False]['text':' Mark as a protected field to avoid unused private field warnings.','line_number':556,'multiline':False]['text':' VLDR/VSTR take an 8 bit offset, which is implicitly left shifted by 2.','line_number':570,'multiline':False]['text':' ARM can magically encode 256 very special immediates to be moved into a','line_number':581,'multiline':False]['text':' register.','line_number':582,'multiline':False]['text':' This structure's members are public and it has no constructor to','line_number':584,'multiline':False]['text':' initialize them, for a very special reason. Were this structure to','line_number':585,'multiline':False]['text':' have a constructor, the initialization for DoubleEncoder's internal','line_number':586,'multiline':False]['text':' table (see below) would require a rather large static constructor on','line_number':587,'multiline':False]['text':' some of our supported compilers. The known solution to this is to mark','line_number':588,'multiline':False]['text':' the constructor constexpr, but, again, some of our supported','line_number':589,'multiline':False]['text':' compilers don't support constexpr! So we are reduced to public','line_number':590,'multiline':False]['text':' members and eschewing a constructor in hopes that the initialization','line_number':591,'multiline':False]['text':' of DoubleEncoder's table is correct.','line_number':592,'multiline':False]['text':' This assert is an attempting at ensuring that we don't create random','line_number':598,'multiline':False]['text':' instances of this structure and then asking to encode() it.','line_number':599,'multiline':False]['text':' Mark as a protected field to avoid unused private field warnings.','line_number':629,'multiline':False]['text':' The register that holds the shift amount.','line_number':633,'multiline':False]['text':' namespace datastore','line_number':642,'multiline':False]['text':' RotateLeft below may not be called with a shift of zero.','line_number':683,'multiline':False]['text':' An encodable integer has a maximum of 8 contiguous set bits,','line_number':688,'multiline':False]['text':' with an optional wrapped left rotation to even bit positions.','line_number':689,'multiline':False]['text':' Pair template?','line_number':699,'multiline':False]['text':' An offset from a register to be used for ldr/str. This should include the','line_number':752,'multiline':False]['text':' sign bit, since ARM has "signed-magnitude" offsets. That is it encodes an','line_number':753,'multiline':False]['text':' unsigned offset, then the instruction specifies if the offset is positive or','line_number':754,'multiline':False]['text':' negative. The +/- bit is necessary if the instruction set wants to be able to','line_number':755,'multiline':False]['text':' have a negative register offset e.g. ldr pc, [r1,-r2];','line_number':756,'multiline':False]['text':' These are designed to be called by a constructor of a subclass.','line_number':781,'multiline':False]['text':' Constructing the necessary RIS/RRS structures is annoying.','line_number':782,'multiline':False]['text':' We will frequently want to bundle a register with its offset so that we have','line_number':808,'multiline':False]['text':' an "operand" to a load instruction.','line_number':809,'multiline':False]['text':' Offsets for the extended data transfer instructions:','line_number':824,'multiline':False]['text':' ldrsh, ldrd, ldrsb, etc.','line_number':825,'multiline':False]['text':' This is the most-derived class, since the extended data transfer instructions','line_number':849,'multiline':False]['text':' don't support any sort of modifying the "index" operand.','line_number':850,'multiline':False]['text':' A BOffImm is an immediate that is used for branches. Namely, it is the offset','line_number':917,'multiline':False]['text':' that will be encoded in the branch instruction. This is the only sane way of','line_number':918,'multiline':False]['text':' constructing a branch.','line_number':919,'multiline':False]['text':' Mark as a protected field to avoid unused private field warnings.','line_number':962,'multiline':False]['text':' I would preffer that these do not exist, since there are essentially no','line_number':980,'multiline':False]['text':' instructions that would ever take more than one of these, however, the MIR','line_number':981,'multiline':False]['text':' wants to only have one type of arguments to functions, so bugger.','line_number':982,'multiline':False]['text':' The encoding of registers is the same for OP2, DTR and EDTR yet the type','line_number':984,'multiline':False]['text':' system doesn't let us express this, so choices must be made.','line_number':985,'multiline':False]['text':' Advances to the next intentionally-inserted instruction.','line_number':1065,'multiline':False]['text':' Advances past any automatically-inserted instructions.','line_number':1068,'multiline':False]['text':' Advances past the given number of instruction-length bytes.','line_number':1074,'multiline':False]['text':' ARM conditional constants:','line_number':1085,'multiline':False]['text':' Zero','line_number':1087,'multiline':False]['text':' Non-zero','line_number':1088,'multiline':False]['text':' MI is valid too.','line_number':1135,'multiline':False]['text':' Bit set when a DoubleCondition does not map to a single ARM condition.','line_number':1138,'multiline':False]['text':' The macro assembler has to special-case these conditions, or else','line_number':1139,'multiline':False]['text':' ConditionFromDoubleCondition will complain.','line_number':1140,'multiline':False]['text':' These conditions will only evaluate to true if the comparison is','line_number':1144,'multiline':False]['text':' ordered - i.e. neither operand is NaN.','line_number':1145,'multiline':False]['text':' If either operand is NaN, these conditions always evaluate to true.','line_number':1153,'multiline':False]['text':' Full system barrier','line_number':1172,'multiline':False]['text':' StoreStore barrier','line_number':1173,'multiline':False]['text':' This should be protected, but since CodeGenerator wants to use it, it','line_number':1176,'multiline':False]['text':' needs to go out here :(','line_number':1177,'multiline':False]['text':' Shim around AssemblerBufferWithConstantPools::allocEntry.','line_number':1182,'multiline':False]['text':' Structure for fixing up pc-relative loads/jumps when a the machine code','line_number':1214,'multiline':False]['text':' gets moved (executable copy, gc, etc.).','line_number':1215,'multiline':False]['text':' TODO: this should actually be a pool-like object. It is currently a big','line_number':1227,'multiline':False]['text':' hack, and probably shouldn't exist.','line_number':1228,'multiline':False]['text':' For the alignment fill use NOP: 0x0320f000 or (Always | InstNOP::NopInst).','line_number':1241,'multiline':False]['text':' For the nopFill use a branch to the next instruction: 0xeaffffff.','line_number':1242,'multiline':False]['text':' We need to wait until an AutoJitContextAlloc is created by the','line_number':1260,'multiline':False]['text':' MacroAssembler, before allocating any space.','line_number':1261,'multiline':False]['text':' Raw GC pointer relocations and Value relocations both end up in','line_number':1273,'multiline':False]['text':' Assembler::TraceDataRelocations.','line_number':1274,'multiline':False]['text':' Given the start of a Control Flow sequence, grab the value that is','line_number':1288,'multiline':False]['text':' finally branched to given the start of a function that loads an address','line_number':1289,'multiline':False]['text':' into a register get the address that ends up in the register.','line_number':1290,'multiline':False]['text':' Size of the instruction stream, in bytes, after pools are flushed.','line_number':1329,'multiline':False]['text':' Size of the jump relocation table, in bytes.','line_number':1331,'multiline':False]['text':' Size of the data table, in bytes.','line_number':1335,'multiline':False]['text':' Write a single instruction into the instruction stream.  Very hot,','line_number':1338,'multiline':False]['text':' inlined for performance','line_number':1339,'multiline':False]['text':' As above, but also mark the instruction as a branch.  Very hot, inlined','line_number':1348,'multiline':False]['text':' for performance','line_number':1349,'multiline':False]['text':' Write a placeholder NOP for a branch into the instruction stream','line_number':1359,'multiline':False]['text':' (in order to adjust assembler addresses and mark it as a branch), it will','line_number':1360,'multiline':False]['text':' be overwritten subsequently.','line_number':1361,'multiline':False]['text':' A static variant for the cases where we don't want to have an assembler','line_number':1364,'multiline':False]['text':' object.','line_number':1365,'multiline':False]['text':' Logical operations:','line_number':1386,'multiline':False]['text':' Reverse byte operations:','line_number':1395,'multiline':False]['text':' Mathematical operations:','line_number':1399,'multiline':False]['text':' Test operations:','line_number':1412,'multiline':False]['text':' Sign extension operations:','line_number':1418,'multiline':False]['text':' Not quite ALU worthy, but useful none the less: These also have the issue','line_number':1428,'multiline':False]['text':' of these being formatted completly differently from the standard ALU','line_number':1429,'multiline':False]['text':' operations.','line_number':1430,'multiline':False]['text':' Data transfer instructions: ldr, str, ldrb, strb.','line_number':1464,'multiline':False]['text':' Using an int to differentiate between 8 bits and 32 bits is overkill.','line_number':1465,'multiline':False]['text':' Handles all of the other integral data transferring functions:','line_number':1472,'multiline':False]['text':' ldrsb, ldrsh, ldrd, etc. The size is given in bits.','line_number':1473,'multiline':False]['text':' Overwrite a pool entry with new data.','line_number':1480,'multiline':False]['text':' Load a 32 bit immediate from a pool into a register.','line_number':1483,'multiline':False]['text':' Load a 64 bit floating point immediate from a pool into a register.','line_number':1487,'multiline':False]['text':' Load a 32 bit floating point immediate from a pool into a register.','line_number':1490,'multiline':False]['text':' Atomic instructions: ldrexd, ldrex, ldrexh, ldrexb, strexd, strex, strexh,','line_number':1494,'multiline':False]['text':' strexb.','line_number':1495,'multiline':False]['text':'','line_number':1496,'multiline':False]['text':' The doubleword, halfword, and byte versions are available from ARMv6K','line_number':1497,'multiline':False]['text':' forward.','line_number':1498,'multiline':False]['text':'','line_number':1499,'multiline':False]['text':' The word versions are available from ARMv6 forward and can be used to','line_number':1500,'multiline':False]['text':' implement the halfword and byte versions on older systems.','line_number':1501,'multiline':False]['text':' LDREXD rt, rt2, [rn].  Constraint: rt even register, rt2=rt+1.','line_number':1503,'multiline':False]['text':' LDREX rt, [rn]','line_number':1507,'multiline':False]['text':' STREXD rd, rt, rt2, [rn].  Constraint: rt even register, rt2=rt+1.','line_number':1512,'multiline':False]['text':' STREX rd, rt, [rn].  Constraint: rd != rn, rd != rt.','line_number':1516,'multiline':False]['text':' CLREX','line_number':1524,'multiline':False]['text':' Memory synchronization.','line_number':1527,'multiline':False]['text':' These are available from ARMv7 forward.','line_number':1528,'multiline':False]['text':' Memory synchronization for architectures before ARMv7.','line_number':1533,'multiline':False]['text':' Speculation barrier','line_number':1538,'multiline':False]['text':' Control flow stuff:','line_number':1541,'multiline':False]['text':' bx can *only* branch to a register never to an immediate.','line_number':1543,'multiline':False]['text':' Branch can branch to an immediate *or* to a register. Branches to','line_number':1546,'multiline':False]['text':' immediates are pc relative, branches to registers are absolute.','line_number':1547,'multiline':False]['text':' blx can go to either an immediate or a register. When blx'ing to a','line_number':1553,'multiline':False]['text':' register, we change processor mode depending on the low bit of the','line_number':1554,'multiline':False]['text':' register when blx'ing to an immediate, we *always* change processor','line_number':1555,'multiline':False]['text':' state.','line_number':1556,'multiline':False]['text':' bl can only branch+link to an immediate, never to a register it never','line_number':1561,'multiline':False]['text':' changes processor state.','line_number':1562,'multiline':False]['text':' bl #imm can have a condition code, blx #imm cannot.','line_number':1564,'multiline':False]['text':' blx reg can be conditional.','line_number':1565,'multiline':False]['text':' VFP instructions!','line_number':1572,'multiline':False]['text':' Unityped variants: all registers hold the same (ieee754 single/double)','line_number':1580,'multiline':False]['text':' notably not included are vcvt; vmov vd, #imm; vmov rt, vn.','line_number':1581,'multiline':False]['text':' Specifically, a move between two same sized-registers.','line_number':1606,'multiline':False]['text':' Transfer between Core and VFP.','line_number':1609,'multiline':False]['text':' Unlike the next function, moving between the core registers and vfp','line_number':1616,'multiline':False]['text':' registers can't be *that* properly typed. Namely, since I don't want to','line_number':1617,'multiline':False]['text':' munge the type VFPRegister to also include core registers. Thus, the core','line_number':1618,'multiline':False]['text':' and vfp registers are passed in based on their type, and src/dest is','line_number':1619,'multiline':False]['text':' determined by the float2core.','line_number':1620,'multiline':False]['text':' Our encoding actually allows just the src and the dest (and their types)','line_number':1625,'multiline':False]['text':' to uniquely specify the encoding that we are going to use.','line_number':1626,'multiline':False]['text':' Hard coded to a 32 bit fixed width result for now.','line_number':1630,'multiline':False]['text':' Transfer between VFP and memory.','line_number':1634,'multiline':False]['text':' vfp doesn't have a wb option','line_number':1636,'multiline':True]['text':' vfp doesn't have a wb option ','line_number':1639,'multiline':True]['text':' VFP's ldm/stm work differently from the standard arm ones. You can only','line_number':1642,'multiline':False]['text':' transfer a range.','line_number':1643,'multiline':False]['text':' also has update conditions ','line_number':1646,'multiline':True]['text':' vldr/vstr variants that handle unaligned accesses.  These encode as NEON','line_number':1648,'multiline':False]['text':' single-element instructions and can only be used if NEON is available.','line_number':1649,'multiline':False]['text':' Here, vd must be tagged as a float or double register.','line_number':1650,'multiline':False]['text':' Label operations.','line_number':1659,'multiline':False]['text':' I'm going to pretend this doesn't exist for now.','line_number':1664,'multiline':False]['text':' The buffer is about to be linked, make sure any constant pools or excess','line_number':1702,'multiline':False]['text':' bookkeeping has been flushed to the instruction stream.','line_number':1703,'multiline':False]['text':' Copy the assembly code to the given buffer, and perform any pending','line_number':1716,'multiline':False]['text':' relocations relying on the target address.','line_number':1717,'multiline':False]['text':' Actual assembly emitting functions.','line_number':1720,'multiline':False]['text':' Since I can't think of a reasonable default for the mode, I'm going to','line_number':1722,'multiline':False]['text':' leave it as a required argument.','line_number':1723,'multiline':False]['text':' The operand for the vstr/vldr instruction is the lowest register in the','line_number':1783,'multiline':False]['text':' range.','line_number':1784,'multiline':False]['text':' Fencepost problem.','line_number':1787,'multiline':False]['text':' vdtm can only transfer 16 registers at once.  If we need to transfer','line_number':1789,'multiline':False]['text':' more, then either hoops are necessary, or we need to be updating the','line_number':1790,'multiline':False]['text':' register.','line_number':1791,'multiline':False]['text':' Limit the instruction to 16 registers.','line_number':1797,'multiline':False]['text':' If it is a store, we want to start at the high end and move down','line_number':1799,'multiline':False]['text':' (e.g. vpush d16-d31; vpush d0-d15).','line_number':1800,'multiline':False]['text':' Update the bounds.','line_number':1804,'multiline':False]['text':' Update the length parameter.','line_number':1807,'multiline':False]['text':' 'bkpt 0xffff'','line_number':1828,'multiline':False]['text':' API for speaking with the IonAssemblerBufferWithConstantPools generate an','line_number':1831,'multiline':False]['text':' initial placeholder instruction that we want to later fix up.','line_number':1832,'multiline':False]['text':' Take the stub value that was written in before, and write in an actual','line_number':1835,'multiline':False]['text':' load using the index we'd computed previously as well as the address of','line_number':1836,'multiline':False]['text':' the pool start.','line_number':1837,'multiline':False]['text':' We're not tracking short-range branches for ARM for now.','line_number':1840,'multiline':False]['text':' END API','line_number':1846,'multiline':False]['text':' Move our entire pool into the instruction stream. This is to force an','line_number':1848,'multiline':False]['text':' opportunistic dump of the pool, prefferably when it is more convenient to','line_number':1849,'multiline':False]['text':' do a dump.','line_number':1850,'multiline':False]['text':' Toggle a jmp or cmp emitted by toggledJump().','line_number':1876,'multiline':False]['text':' Implement this if we implement a disassembler.','line_number':1889,'multiline':False]['text':' Assembler','line_number':1891,'multiline':False]['text':' An Instruction is a structure for both encoding and decoding any and all ARM','line_number':1893,'multiline':False]['text':' instructions. Many classes have not been implemented thus far.','line_number':1894,'multiline':False]['text':' This is not for defaulting to always, this is for instructions that','line_number':1899,'multiline':False]['text':' cannot be made conditional, and have the usually invalid 4b1111 cond','line_number':1900,'multiline':False]['text':' field.','line_number':1901,'multiline':False]['text':' Standard constructor.','line_number':1906,'multiline':False]['text':' You should never create an instruction directly. You should create a more','line_number':1911,'multiline':False]['text':' specific instruction which will eventually call one of these constructors','line_number':1912,'multiline':False]['text':' for you.','line_number':1913,'multiline':False]['text':' Check if this instruction is really a particular case.','line_number':1916,'multiline':False]['text':' Safely get a more specific variant of this pointer.','line_number':1922,'multiline':False]['text':' Since almost all instructions have condition codes, the condition code','line_number':1932,'multiline':False]['text':' extractor resides in the base class.','line_number':1933,'multiline':False]['text':' Sometimes, an api wants a uint32_t (or a pointer to it) rather than an','line_number':1940,'multiline':False]['text':' instruction. raw() just coerces this into a pointer to a uint32_t.','line_number':1941,'multiline':False]['text':' Instruction','line_number':1944,'multiline':False]['text':' Make sure that it is the right size.','line_number':1946,'multiline':False]['text':' Data Transfer Instructions.','line_number':1953,'multiline':False]['text':' TODO: Replace the initialization with something that is safer.','line_number':1960,'multiline':False]['text':' When patching the load in PatchConstantPoolLoad, we ensure that the','line_number':1987,'multiline':False]['text':' offset is a multiple of 4, offset by 8 bytes from the actual','line_number':1988,'multiline':False]['text':' location.  Indeed, when the base register is PC, ARM's 3 stages','line_number':1989,'multiline':False]['text':' pipeline design makes it that PC is off by 8 bytes (= 2 *','line_number':1990,'multiline':False]['text':' sizeof(uint32*)) when we actually executed it.','line_number':1991,'multiline':False]['text':' Branching to a register, or calling a register','line_number':2009,'multiline':False]['text':' Don't use BranchTag yourself, use a derived instruction.','line_number':2012,'multiline':False]['text':' Get the register that is being branched to','line_number':2024,'multiline':False]['text':' Make sure we are branching to a pre-known register','line_number':2026,'multiline':False]['text':' Branching to an immediate offset, or calling an immediate offset','line_number':2031,'multiline':False]['text':' Very specific branching instructions.','line_number':2049,'multiline':False]['text':' Both movw and movt. The layout of both the immediate and the destination','line_number':2082,'multiline':False]['text':' register is the same so the code is being shared.','line_number':2083,'multiline':False]['text':' Compile-time iterator over instructions, with a safe interface that','line_number':2153,'multiline':False]['text':' references not-necessarily-linear Instructions by linear BufferOffset.','line_number':2154,'multiline':False]['text':' Advances the buffer to the next intentionally-inserted instruction.','line_number':2161,'multiline':False]['text':' Advances the BufferOffset past any automatically-inserted instructions.','line_number':2168,'multiline':False]['text':' There are 16 *float* registers available for arguments','line_number':2174,'multiline':False]['text':' If doubles are used, only half the number of registers are available.','line_number':2175,'multiline':False]['text':' Get a register in which we plan to put a quantity that will be used as an','line_number':2188,'multiline':False]['text':' integer argument. This differs from GetIntArgReg in that if we have no more','line_number':2189,'multiline':False]['text':' actual argument registers to use we will fall back on using whatever','line_number':2190,'multiline':False]['text':' CallTempReg* don't overlap the argument registers, and only fail once those','line_number':2191,'multiline':False]['text':' run out too.','line_number':2192,'multiline':False]['text':' Unfortunately, we have to assume things about the point at which','line_number':2199,'multiline':False]['text':' GetIntArgReg returns false, because we need to know how many registers it','line_number':2200,'multiline':False]['text':' can allocate.','line_number':2201,'multiline':False]['text':' Forbids nop filling for testing purposes. Not nestable.','line_number':2256,'multiline':False]['text':' The maxInst argument is the maximum number of word sized instructions','line_number':2270,'multiline':False]['text':' that will be allocated within this context. It is used to determine if','line_number':2271,'multiline':False]['text':' the pool needs to be dumped before entering this content. The debug code','line_number':2272,'multiline':False]['text':' checks that no more than maxInst instructions are actually allocated.','line_number':2273,'multiline':False]['text':'','line_number':2274,'multiline':False]['text':' Allocation of pool entries is not supported within this content so the','line_number':2275,'multiline':False]['text':' code can not use large integers or float constants etc.','line_number':2276,'multiline':False]['text':' namespace jit','line_number':2285,'multiline':False]['text':' namespace js','line_number':2286,'multiline':False]['text':' jit_arm_Assembler_arm_h ','line_number':2288,'multiline':True]