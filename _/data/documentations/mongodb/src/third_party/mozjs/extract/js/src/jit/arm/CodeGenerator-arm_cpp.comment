['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::Scalar::Type','line_number':23,'multiline':False]['text':' shared','line_number':42,'multiline':False]['text':' Test the operand','line_number':71,'multiline':False]['text':' All non-table-based bailouts will go here.','line_number':130,'multiline':False]['text':' Push the frame size, so the handler can recover the IonScript.','line_number':133,'multiline':False]['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':147,'multiline':False]['text':' the known value makes sense. We can't use bailout tables if the stack','line_number':148,'multiline':False]['text':' isn't properly aligned to the static frame size.','line_number':149,'multiline':False]['text':' We could not use a jump table, either because all bailout IDs were','line_number':161,'multiline':False]['text':' reserved, or a jump table is not optimal for this frame size or','line_number':162,'multiline':False]['text':' platform. Whatever, we will generate a lazy bailout.','line_number':163,'multiline':False]['text':' All bailout code is associated with the bytecodeSite of the block we are','line_number':168,'multiline':False]['text':' bailing out from.','line_number':169,'multiline':False]['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':182,'multiline':False]['text':' the known value makes sense. We can't use bailout tables if the stack','line_number':183,'multiline':False]['text':' isn't properly aligned to the static frame size.','line_number':184,'multiline':False]['text':' On ARM we don't use a bailout table.','line_number':188,'multiline':False]['text':' All bailout code is associated with the bytecodeSite of the block we are','line_number':193,'multiline':False]['text':' bailing out from.','line_number':194,'multiline':False]['text':' BailoutStack::padding_','line_number':210,'multiline':False]['text':' BailoutStack::snapshotOffset_','line_number':211,'multiline':False]['text':' Bailout when this condition is met.','line_number':322,'multiline':False]['text':' Bailout on -0.0','line_number':324,'multiline':False]['text':' TODO: move these to ma_mul.','line_number':332,'multiline':False]['text':' Escape overflow check;','line_number':339,'multiline':False]['text':' Nop','line_number':341,'multiline':False]['text':' Escape overflow check;','line_number':343,'multiline':False]['text':' Overflow is handled later.','line_number':346,'multiline':False]['text':' Try shift and add sequences for a positive constant.','line_number':351,'multiline':False]['text':' If it cannot overflow, we can do lots of optimizations.','line_number':353,'multiline':False]['text':' See if the constant has one bit set, meaning it can be','line_number':357,'multiline':False]['text':' encoded as a bitshift.','line_number':358,'multiline':False]['text':' If the constant cannot be encoded as (1 << C1), see','line_number':363,'multiline':False]['text':' if it can be encoded as (1 << C1) | (1 << C2), which','line_number':364,'multiline':False]['text':' can be computed using an add and a shift.','line_number':365,'multiline':False]['text':' To stay on the safe side, only optimize things that are a','line_number':378,'multiline':False]['text':' power of 2.','line_number':379,'multiline':False]['text':' dest = lhs * pow(2,shift)','line_number':383,'multiline':False]['text':' At runtime, check (lhs == dest >> shift), if this','line_number':385,'multiline':False]['text':' does not hold, some bits were lost due to overflow,','line_number':386,'multiline':False]['text':' and the computation should be resumed as a double.','line_number':387,'multiline':False]['text':' Bailout on overflow.','line_number':407,'multiline':False]['text':' Bailout on overflow.','line_number':422,'multiline':False]['text':' Result is -0 if lhs or rhs is negative.','line_number':432,'multiline':False]['text':' nop','line_number':457,'multiline':False]['text':' Use shift if constant is power of 2.','line_number':464,'multiline':False]['text':' Handle INT32_MIN / -1;','line_number':486,'multiline':False]['text':' The integer division will give INT32_MIN, but we want -(double)INT32_MIN.','line_number':487,'multiline':False]['text':' Sets EQ if lhs == INT32_MIN.','line_number':489,'multiline':False]['text':' If EQ (LHS == INT32_MIN), sets EQ if rhs == -1.','line_number':491,'multiline':False]['text':' (-INT32_MIN)|0 = INT32_MIN','line_number':500,'multiline':False]['text':' Handle divide by zero.','line_number':513,'multiline':False]['text':' Infinity|0 == 0','line_number':523,'multiline':False]['text':' Handle negative 0.','line_number':536,'multiline':False]['text':' idivmod returns the quotient in r0, and the remainder in r1.','line_number':608,'multiline':False]['text':' If the remainder is != 0, bailout since this must be a double.','line_number':630,'multiline':False]['text':' The bailout code also needs the scratch register.','line_number':632,'multiline':False]['text':' Here it is only used as a dummy target to set CC flags.','line_number':633,'multiline':False]['text':' Numerator is unsigned, so needs no adjusting. Do the shift.','line_number':641,'multiline':False]['text':' Adjust the value so that shifting produces a correctly rounded result','line_number':646,'multiline':False]['text':' when the numerator is negative. See 10-1 "Signed Division by a Known','line_number':647,'multiline':False]['text':' Power of 2" in Henry S. Warren, Jr.'s Hacker's Delight.','line_number':648,'multiline':False]['text':' Do the shift.','line_number':658,'multiline':False]['text':' X % 0 is bad because it will give garbage (or abort), when it should give','line_number':665,'multiline':False]['text':' NaN.','line_number':666,'multiline':False]['text':' NaN|0 == 0','line_number':676,'multiline':False]['text':' Contrary to other architectures (notably x86) INT_MIN % -1 doesn't need to','line_number':694,'multiline':False]['text':' be handled separately. |ma_smod| computes the remainder using the |SDIV|','line_number':695,'multiline':False]['text':' and the |MLS| instructions. On overflow, |SDIV| truncates the result to','line_number':696,'multiline':False]['text':' 32-bit and returns INT_MIN, see ARM Architecture Reference Manual, SDIV','line_number':697,'multiline':False]['text':' instruction.','line_number':698,'multiline':False]['text':'','line_number':699,'multiline':False]['text':'   mls(INT_MIN, sdiv(INT_MIN, -1), -1)','line_number':700,'multiline':False]['text':' = INT_MIN - (sdiv(INT_MIN, -1) * -1)','line_number':701,'multiline':False]['text':' = INT_MIN - (INT_MIN * -1)','line_number':702,'multiline':False]['text':' = INT_MIN - INT_MIN','line_number':703,'multiline':False]['text':' = 0','line_number':704,'multiline':False]['text':'','line_number':705,'multiline':False]['text':' And a zero remainder with a negative dividend is already handled below.','line_number':706,'multiline':False]['text':' If X%Y == 0 and X < 0, then we *actually* wanted to return -0.0.','line_number':716,'multiline':False]['text':' -0.0|0 == 0','line_number':719,'multiline':False]['text':' See if X < 0','line_number':722,'multiline':False]['text':' Extract the registers from this instruction.','line_number':734,'multiline':False]['text':' Save the lhs in case we end up with a 0 that should be a -0.0 because lhs <','line_number':742,'multiline':False]['text':' 0.','line_number':743,'multiline':False]['text':' Prevent INT_MIN % -1.','line_number':748,'multiline':False]['text':'','line_number':749,'multiline':False]['text':' |aeabi_idivmod| is allowed to return any arbitrary value when called with','line_number':750,'multiline':False]['text':' |(INT_MIN, -1)|, see "Run-time ABI for the ARM architecture manual". Most','line_number':751,'multiline':False]['text':' implementations perform a non-trapping signed integer division and','line_number':752,'multiline':False]['text':' return the expected result, i.e. INT_MIN. But since we can't rely on this','line_number':753,'multiline':False]['text':' behavior, handle this case separately here.','line_number':754,'multiline':False]['text':' Sets EQ if lhs == INT_MIN','line_number':758,'multiline':False]['text':' If EQ (LHS == INT_MIN), sets EQ if rhs == -1','line_number':760,'multiline':False]['text':' (INT_MIN % -1)|0 == 0','line_number':764,'multiline':False]['text':' If X%Y == 0 and X < 0, then we *actually* wanted to return -0.0','line_number':801,'multiline':False]['text':' -0.0|0 == 0','line_number':804,'multiline':False]['text':' See if X < 0','line_number':807,'multiline':False]['text':' bug 739870, jbramley has a different sequence that may help with speed','line_number':823,'multiline':False]['text':' here.','line_number':824,'multiline':False]['text':' -0|0 == 0','line_number':839,'multiline':False]['text':' -0|0 == 0','line_number':862,'multiline':False]['text':' Callers handle division by zero and integer overflow.','line_number':870,'multiline':False]['text':' result= ','line_number':873,'multiline':True]['text':' Create and return the result.','line_number':875,'multiline':False]['text':' idivmod returns the quotient in r0, and the remainder in r1.','line_number':882,'multiline':False]['text':' Create and return the result.','line_number':902,'multiline':False]['text':' Callers handle division by zero and integer overflow.','line_number':910,'multiline':False]['text':' result= ','line_number':915,'multiline':True]['text':' Create and return the result.','line_number':918,'multiline':False]['text':' idivmod returns the quotient in r0, and the remainder in r1.','line_number':925,'multiline':False]['text':' Create and return the result.','line_number':945,'multiline':False]['text':' This will not actually be true on arm. We can not an imm8m in order to','line_number':953,'multiline':False]['text':' get a wider range of numbers','line_number':954,'multiline':False]['text':' All of these bitops should be either imm32's, or integer registers.','line_number':967,'multiline':False]['text':' x >>> 0 can overflow.','line_number':1024,'multiline':False]['text':' The shift amounts should be AND'ed into the 0-31 range since arm','line_number':1036,'multiline':False]['text':' shifts by the lower byte of the register (it will attempt to shift by','line_number':1037,'multiline':False]['text':' 250 if you ask it to).','line_number':1038,'multiline':False]['text':' x >>> 0 can overflow.','line_number':1051,'multiline':False]['text':' knownNotZero = ','line_number':1088,'multiline':True]['text':' knownNotZero = ','line_number':1095,'multiline':True]['text':' Masm.pow(-Infinity, 0.5) == Infinity.','line_number':1114,'multiline':False]['text':' Math.pow(-0, 0.5) == 0 == Math.pow(0, 0.5).','line_number':1120,'multiline':False]['text':' Adding 0 converts any -0 to 0.','line_number':1121,'multiline':False]['text':' The entries of the jump table need to be absolute addresses and thus','line_number':1172,'multiline':False]['text':' must be patched after codegen is finished.','line_number':1173,'multiline':False]['text':' The code generated by this is utter hax.','line_number':1182,'multiline':False]['text':' The end result looks something like:','line_number':1183,'multiline':False]['text':' SUBS index, input, #base','line_number':1184,'multiline':False]['text':' RSBSPL index, index, #max','line_number':1185,'multiline':False]['text':' LDRPL pc, pc, index lsl 2','line_number':1186,'multiline':False]['text':' B default','line_number':1187,'multiline':False]['text':' If the range of targets in N through M, we first subtract off the lowest','line_number':1189,'multiline':False]['text':' case (N), which both shifts the arguments into the range 0 to (M - N)','line_number':1190,'multiline':False]['text':' with and sets the MInus flag if the argument was out of range on the low','line_number':1191,'multiline':False]['text':' end.','line_number':1192,'multiline':False]['text':' Then we a reverse subtract with the size of the jump table, which will','line_number':1194,'multiline':False]['text':' reverse the order of range (It is size through 0, rather than 0 through','line_number':1195,'multiline':False]['text':' size). The main purpose of this is that we set the same flag as the lower','line_number':1196,'multiline':False]['text':' bound check for the upper bound check. Lastly, we do this conditionally','line_number':1197,'multiline':False]['text':' on the previous check succeeding.','line_number':1198,'multiline':False]['text':' Then we conditionally load the pc offset by the (reversed) index (times','line_number':1200,'multiline':False]['text':' the address size) into the pc, which branches to the correct case. NOTE:','line_number':1201,'multiline':False]['text':' when we go to read the pc, the value that we get back is the pc of the','line_number':1202,'multiline':False]['text':' current instruction *PLUS 8*. This means that ldr foo, [pc, +0] reads','line_number':1203,'multiline':False]['text':' $pc+8. In other words, there is an empty word after the branch into the','line_number':1204,'multiline':False]['text':' switch table before the table actually starts. Since the only other','line_number':1205,'multiline':False]['text':' unhandled case is the default case (both out of range high and out of','line_number':1206,'multiline':False]['text':' range low) I then insert a branch to default case into the extra slot,','line_number':1207,'multiline':False]['text':' which ensures we don't attempt to execute the address table.','line_number':1208,'multiline':False]['text':' Lower value with low value.','line_number':1214,'multiline':False]['text':' Inhibit pools within the following sequence because we are indexing into','line_number':1218,'multiline':False]['text':' a pc relative table. The region will have one instruction for ma_ldr, one','line_number':1219,'multiline':False]['text':' for ma_b, and each table case takes one word.','line_number':1220,'multiline':False]['text':' To fill in the CodeLabels for the case entries, we need to first generate','line_number':1226,'multiline':False]['text':' the case entries (we don't yet know their offsets in the instruction','line_number':1227,'multiline':False]['text':' stream).','line_number':1228,'multiline':False]['text':' On arm, the input operand and the output payload have the same virtual','line_number':1352,'multiline':False]['text':' register. All that needs to be written is the type tag for the type','line_number':1353,'multiline':False]['text':' definition.','line_number':1354,'multiline':False]['text':' Note that for unbox, the type and payload indexes are switched on the','line_number':1366,'multiline':False]['text':' inputs.','line_number':1367,'multiline':False]['text':' Note: If spectreValueMasking is disabled, then this instruction will','line_number':1391,'multiline':False]['text':' default to a no-op as long as the lowering allocate the same register for','line_number':1392,'multiline':False]['text':' the output and the payload.','line_number':1393,'multiline':False]['text':' If the compare set the 0 bit, then the result is definitely false.','line_number':1420,'multiline':False]['text':' It is also false if one of the operands is NAN, which is shown as','line_number':1422,'multiline':False]['text':' Overflow.','line_number':1423,'multiline':False]['text':' If the compare set the 0 bit, then the result is definitely false.','line_number':1435,'multiline':False]['text':' It is also false if one of the operands is NAN, which is shown as','line_number':1437,'multiline':False]['text':' Overflow.','line_number':1438,'multiline':False]['text':' See ../CodeGenerator.cpp for more information.','line_number':1496,'multiline':False]['text':' It is hard to optimize !x, so just do it the basic way for now.','line_number':1510,'multiline':False]['text':' Since this operation is not, we want to set a bit if the double is','line_number':1525,'multiline':False]['text':' falsey, which means 0.0, -0.0 or NaN. When comparing with 0, an input of','line_number':1526,'multiline':False]['text':' 0 will set the Z bit (30) and NaN will set the V bit (28) of the APSR.','line_number':1527,'multiline':False]['text':' Do the compare.','line_number':1531,'multiline':False]['text':' TODO There are three variations here to compare performance-wise.','line_number':1533,'multiline':False]['text':' Load the value into the dest register.','line_number':1536,'multiline':False]['text':' 28 + 2 = 30','line_number':1539,'multiline':False]['text':' Since this operation is not, we want to set a bit if the double is','line_number':1551,'multiline':False]['text':' falsey, which means 0.0, -0.0 or NaN. When comparing with 0, an input of','line_number':1552,'multiline':False]['text':' 0 will set the Z bit (30) and NaN will set the V bit (28) of the APSR.','line_number':1553,'multiline':False]['text':' Do the compare.','line_number':1557,'multiline':False]['text':' TODO There are three variations here to compare performance-wise.','line_number':1559,'multiline':False]['text':' Load the value into the dest register.','line_number':1562,'multiline':False]['text':' 28 + 2 = 30','line_number':1565,'multiline':False]['text':' Ensure that there is enough space in the buffer for the OsiPoint patching','line_number':1577,'multiline':False]['text':' to occur. Otherwise, we could overwrite the invalidation epilogue.','line_number':1578,'multiline':False]['text':' Push the return address of the point that we bailed out at onto the stack.','line_number':1585,'multiline':False]['text':' Push the Ion script onto the stack (when we determine what that pointer','line_number':1588,'multiline':False]['text':' is).','line_number':1589,'multiline':False]['text':' Jump to the invalidator which will replace the current frame.','line_number':1592,'multiline':False]['text':' Maybe add the offset.','line_number':2053,'multiline':False]['text':' Check for large unsigned result - represent as double.','line_number':2249,'multiline':False]['text':' Check for non-zero remainder if not truncating to int.','line_number':2256,'multiline':False]['text':' Check for large unsigned result - represent as double.','line_number':2285,'multiline':False]['text':' Infinity|0 == 0','line_number':2315,'multiline':False]['text':' Bailout for divide by zero','line_number':2321,'multiline':False]['text':' uidivmod returns the quotient in r0, and the remainder in r1.','line_number':2370,'multiline':False]['text':' Bailout for big unsigned results','line_number':2377,'multiline':False]['text':' TruncateDoubleTo{UI,I}nt64 returns 0x8000000000000000 to indicate','line_number':2507,'multiline':False]['text':' exceptional results, so check for that and produce the appropriate','line_number':2508,'multiline':False]['text':' traps. The Saturating form always returns a normal value and never','line_number':2509,'multiline':False]['text':' needs traps.','line_number':2510,'multiline':False]['text':' On ARM, saturating truncation codegen handles saturating itself rather than','line_number':2525,'multiline':False]['text':' relying on out-of-line fixup code.','line_number':2526,'multiline':False]['text':' Clear lhs's sign.','line_number':2587,'multiline':False]['text':' Keep rhs's sign.','line_number':2590,'multiline':False]['text':' Combine.','line_number':2593,'multiline':False]['text':' Manipulate high words of double inputs.','line_number':2607,'multiline':False]['text':' Clear lhs's sign.','line_number':2615,'multiline':False]['text':' Keep rhs's sign.','line_number':2618,'multiline':False]['text':' Combine.','line_number':2621,'multiline':False]['text':' Reconstruct the output.','line_number':2624,'multiline':False]['text':' Handle divide by zero.','line_number':2691,'multiline':False]['text':' We can use WasmTlsReg as temp register because we preserved it before.','line_number':2694,'multiline':False]['text':' Handle an integer overflow exception from INT64_MIN / -1.','line_number':2702,'multiline':False]['text':' Prevent divide by zero.','line_number':2748,'multiline':False]['text':' We can use WasmTlsReg as temp register because we preserved it before.','line_number':2751,'multiline':False]