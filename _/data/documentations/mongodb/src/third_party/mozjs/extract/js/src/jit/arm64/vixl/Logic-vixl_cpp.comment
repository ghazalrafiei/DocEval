['text':' Copyright 2015, ARM Limited','line_number':1,'multiline':False]['text':' All rights reserved.','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':4,'multiline':False]['text':' modification, are permitted provided that the following conditions are met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'   * Redistributions of source code must retain the above copyright notice,','line_number':7,'multiline':False]['text':'     this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'   * Redistributions in binary form must reproduce the above copyright notice,','line_number':9,'multiline':False]['text':'     this list of conditions and the following disclaimer in the documentation','line_number':10,'multiline':False]['text':'     and/or other materials provided with the distribution.','line_number':11,'multiline':False]['text':'   * Neither the name of ARM Limited nor the names of its contributors may be','line_number':12,'multiline':False]['text':'     used to endorse or promote products derived from this software without','line_number':13,'multiline':False]['text':'     specific prior written permission.','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS CONTRIBUTORS "AS IS" AND','line_number':16,'multiline':False]['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED','line_number':17,'multiline':False]['text':' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE','line_number':18,'multiline':False]['text':' DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE','line_number':19,'multiline':False]['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':20,'multiline':False]['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR','line_number':21,'multiline':False]['text':' SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER','line_number':22,'multiline':False]['text':' CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,','line_number':23,'multiline':False]['text':' OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':24,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':25,'multiline':False]['text':' This works for all negative values, including INT64_MIN.','line_number':49,'multiline':False]['text':' An input of 0 is a special case because the result is effectively','line_number':56,'multiline':False]['text':' subnormal: The exponent is encoded as 0 and there is no implicit 1 bit.','line_number':57,'multiline':False]['text':' Calculate the exponent. The highest significant bit will have the value','line_number':62,'multiline':False]['text':' 2^exponent.','line_number':63,'multiline':False]['text':' This works for all negative values, including INT64_MIN.','line_number':75,'multiline':False]['text':' An input of 0 is a special case because the result is effectively','line_number':82,'multiline':False]['text':' subnormal: The exponent is encoded as 0 and there is no implicit 1 bit.','line_number':83,'multiline':False]['text':' Calculate the exponent. The highest significant bit will have the value','line_number':88,'multiline':False]['text':' 2^exponent.','line_number':89,'multiline':False]['text':' TODO(all): consider assigning the result of LaneCountFromFormat to a local.','line_number':509,'multiline':False]['text':' Test for unsigned saturation.','line_number':511,'multiline':False]['text':' Test for signed saturation.','line_number':519,'multiline':False]['text':' If the signs of the operands are the same, but different from the result,','line_number':523,'multiline':False]['text':' there was an overflow.','line_number':524,'multiline':False]['text':' Test for unsigned saturation.','line_number':912,'multiline':False]['text':' Test for signed saturation.','line_number':917,'multiline':False]['text':' If the signs of the operands are different, and the sign of the first','line_number':921,'multiline':False]['text':' operand doesn't match the result, there was an overflow.','line_number':922,'multiline':False]['text':' Set signed saturation state.','line_number':1637,'multiline':False]['text':' Set unsigned saturation state.','line_number':1643,'multiline':False]['text':' Set rounding state. Rounding only needed on right shifts.','line_number':1659,'multiline':False]['text':' Set saturation state.','line_number':1683,'multiline':False]['text':' Set rounding state. Rounding only needed on right shifts.','line_number':1693,'multiline':False]['text':' Test for signed saturation.','line_number':1718,'multiline':False]['text':' Test for signed positive saturation.','line_number':1738,'multiline':False]['text':' Positive saturation.','line_number':1758,'multiline':False]['text':' Negative saturation.','line_number':1760,'multiline':False]['text':' Test for signed saturation.','line_number':1774,'multiline':False]['text':' Test for signed saturation','line_number':1826,'multiline':False]['text':' Test for unsigned saturation','line_number':1833,'multiline':False]['text':' 2 * INT_32_MIN * INT_32_MIN causes int64_t to overflow.','line_number':3044,'multiline':False]['text':' To avoid this, we use (src1 * src2 + 1 << (esize - 2)) >> (esize - 1)','line_number':3045,'multiline':False]['text':' which is same as (2 * src1 * src2 + 1 << (esize - 1)) >> esize.','line_number':3046,'multiline':False]['text':' inf + -inf returns the default NaN.','line_number':3289,'multiline':False]['text':' Other cases should be handled by standard arithmetic.','line_number':3293,'multiline':False]['text':' NaNs should be handled elsewhere.','line_number':3301,'multiline':False]['text':' inf - inf returns the default NaN.','line_number':3305,'multiline':False]['text':' Other cases should be handled by standard arithmetic.','line_number':3309,'multiline':False]['text':' NaNs should be handled elsewhere.','line_number':3317,'multiline':False]['text':' inf * 0.0 returns the default NaN.','line_number':3321,'multiline':False]['text':' Other cases should be handled by standard arithmetic.','line_number':3325,'multiline':False]['text':' inf * 0.0 returns +/-2.0.','line_number':3334,'multiline':False]['text':' inf * 0.0','line_number':3350,'multiline':False]['text':' 0.0 * inf','line_number':3351,'multiline':False]['text':' inf - inf','line_number':3352,'multiline':False]['text':' Generated NaNs override quiet NaNs propagated from a.','line_number':3355,'multiline':False]['text':' If the operation would produce a NaN, return the default NaN.','line_number':3364,'multiline':False]['text':' Work around broken fma implementations for exact zero results: The sign of','line_number':3370,'multiline':False]['text':' exact 0.0 results is positive unless both a and op1 * op2 are negative.','line_number':3371,'multiline':False]['text':' Work around broken fma implementations for rounded zero results: If a is','line_number':3379,'multiline':False]['text':' 0.0, the sign of the result is the sign of op1 * op2 before rounding.','line_number':3380,'multiline':False]['text':' NaNs should be handled elsewhere.','line_number':3391,'multiline':False]['text':' inf / inf and 0.0 / 0.0 return the default NaN.','line_number':3395,'multiline':False]['text':' Other cases should be handled by standard arithmetic.','line_number':3401,'multiline':False]['text':' a and b are zero, and the sign differs: return +0.0.','line_number':3427,'multiline':False]['text':' a and b are zero, and the sign differs: return -0.0.','line_number':3455,'multiline':False]['text':' Return +inf if signs match, otherwise -inf.','line_number':3483,'multiline':False]['text':' Return +inf if signs match, otherwise -inf.','line_number':3501,'multiline':False]['text':' The multiply-add-halve operation must be fully fused, so avoid interim','line_number':3505,'multiline':False]['text':' rounding by checking which operand can be losslessly divided by two','line_number':3506,'multiline':False]['text':' before doing the multiply-add.','line_number':3507,'multiline':False]['text':' Neither operand is normal after halving: the result is dominated by','line_number':3513,'multiline':False]['text':' the addition term, so just return that.','line_number':3514,'multiline':False]['text':' The Z-flag is set when the conversion from double precision floating-point','line_number':3521,'multiline':False]['text':' to 32-bit integer is exact. If the source value is +/-Infinity, -0.0, NaN,','line_number':3522,'multiline':False]['text':' outside the bounds of a 32-bit integer, or isn't an exact integer then the','line_number':3523,'multiline':False]['text':' Z-flag is unset.','line_number':3524,'multiline':False]['text':' +/- zero and infinity all return zero, however -0 and +/- Infinity also','line_number':3530,'multiline':False]['text':' unset the Z-flag.','line_number':3531,'multiline':False]['text':' NaN values unset the Z-flag and set the result to 0.','line_number':3537,'multiline':False]['text':' All other values are converted to an integer representation, rounded','line_number':3542,'multiline':False]['text':' toward zero.','line_number':3543,'multiline':False]['text':' Constrain the value into the range [INT32_MIN, INT32_MAX]. We can almost','line_number':3551,'multiline':False]['text':' write a one-liner with std::round, but the behaviour on ties is incorrect','line_number':3552,'multiline':False]['text':' for our purposes.','line_number':3553,'multiline':False]['text':' Take the bottom 32 bits of the result as a 32-bit integer.','line_number':3568,'multiline':False]['text':' If the integer result is out of range or the conversion isn't exact,','line_number':3573,'multiline':False]['text':' take exception and unset the Z-flag.','line_number':3574,'multiline':False]['text':' Take care of correctly handling the range ]-0.5, -0.0], which must','line_number':3601,'multiline':False]['text':' yield -0.0.','line_number':3602,'multiline':False]['text':' If the error is greater than 0.5, or is equal to 0.5 and the integer','line_number':3607,'multiline':False]['text':' result is positive, round up.','line_number':3608,'multiline':False]['text':' Take care of correctly handling the range [-0.5, -0.0], which must','line_number':3614,'multiline':False]['text':' yield -0.0.','line_number':3615,'multiline':False]['text':' If the error is greater than 0.5, or is equal to 0.5 and the integer','line_number':3619,'multiline':False]['text':' result is odd, round up.','line_number':3620,'multiline':False]['text':' If value>0 then we take floor(value)','line_number':3628,'multiline':False]['text':' otherwise, ceil(value).','line_number':3629,'multiline':False]['text':' We always use floor(value).','line_number':3636,'multiline':False]['text':' Take care of correctly handling the range ]-1.0, -0.0], which must','line_number':3640,'multiline':False]['text':' yield -0.0.','line_number':3641,'multiline':False]['text':' If the error is non-zero, round up.','line_number':3645,'multiline':False]['text':' The compiler would have to round kXMaxInt, triggering a warning. Compare','line_number':3670,'multiline':False]['text':' against the largest int64_t that is exactly representable as a double.','line_number':3671,'multiline':False]['text':' The compiler would have to round kXMaxUInt, triggering a warning. Compare','line_number':3694,'multiline':False]['text':' against the largest uint64_t that is exactly representable as a double.','line_number':3695,'multiline':False]['text':' TODO: Full support for SimFloat16 in SimRegister(s).','line_number':4277,'multiline':False]['text':' TODO: Full support for SimFloat16 in SimRegister(s).','line_number':4298,'multiline':False]['text':' Based on reference C function recip_sqrt_estimate from ARM ARM.','line_number':4385,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4425,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4449,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4457,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4491,'multiline':False]['text':' FPExc_DivideByZero exception.','line_number':4502,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4504,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4506,'multiline':False]['text':' FPExc_Overflow and FPExc_Inexact.','line_number':4516,'multiline':False]['text':' Return FPMaxNormal(sign).','line_number':4520,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4521,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4532,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4554,'multiline':False]['text':' In range 253-254 = -1 to 253+1 = 254.','line_number':4555,'multiline':False]['text':' In range 2045-2046 = -1 to 2045+1 = 2046.','line_number':4557,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4569,'multiline':False]['text':' Based on reference C function recip_estimate from ARM ARM.','line_number':4623,'multiline':False]['text':' NOLINT(runtime/sizeof)','line_number':4668,'multiline':False]['text':' namespace vixl','line_number':4736,'multiline':False]['text':' JS_SIMULATOR_ARM64','line_number':4738,'multiline':False]