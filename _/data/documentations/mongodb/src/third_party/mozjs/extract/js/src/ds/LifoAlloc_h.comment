['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' size_t','line_number':19,'multiline':False]['text':' [SMDOC] LifoAlloc bump allocator','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' This file defines an allocator named LifoAlloc which is a Bump allocator,','line_number':25,'multiline':False]['text':' which has the property of making fast allocation but is not able to reclaim','line_number':26,'multiline':False]['text':' individual allocations.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' * Allocation principle','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' In practice a LifoAlloc is implemented using a list of BumpChunks, which are','line_number':31,'multiline':False]['text':' contiguous memory areas which are chained in a single linked list.','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':' When an allocation is performed, we check if there is space in the last','line_number':34,'multiline':False]['text':' chunk. If there is we bump the pointer of the last chunk and return the','line_number':35,'multiline':False]['text':' previous value of the pointer. Otherwise we allocate a new chunk which is','line_number':36,'multiline':False]['text':' large enough and perform the allocation the same way.','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' Each allocation is made with 2 main functions, called','line_number':39,'multiline':False]['text':' BumpChunk::nextAllocBase and BumpChunk::nextAllocEnd. These functions are','line_number':40,'multiline':False]['text':' made to avoid duplicating logic, such as allocating, checking if we can','line_number':41,'multiline':False]['text':' allocate or reserving a given buffer space. They are made to align the','line_number':42,'multiline':False]['text':' pointer for the next allocation (8-byte aligned), and also to reserve some','line_number':43,'multiline':False]['text':' red-zones to improve reports of our security instrumentation. (see Security','line_number':44,'multiline':False]['text':' features below)','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' The Chunks sizes are following the heuristics implemented in NextSize','line_number':47,'multiline':False]['text':' (LifoAlloc.cpp), which doubles the size until we reach 1 MB and then','line_number':48,'multiline':False]['text':' continues with a smaller geometric series. This heuristic is meant to reduce','line_number':49,'multiline':False]['text':' the number of allocations, such that we spend less time allocating/freeing','line_number':50,'multiline':False]['text':' chunks of a few KB at a time.','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' ** Oversize allocations','line_number':53,'multiline':False]['text':'','line_number':54,'multiline':False]['text':' When allocating with a LifoAlloc, we distinguish 2 different kinds of','line_number':55,'multiline':False]['text':' allocations, the small allocations and the large allocations. The reason for','line_number':56,'multiline':False]['text':' splitting in 2 sets is to avoid wasting memory.','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':' If you had a single linked list of chunks, then making oversized allocations','line_number':59,'multiline':False]['text':' can cause chunks to contain a lot of wasted space as new chunks would have to','line_number':60,'multiline':False]['text':' be allocated to fit these allocations, and the space of the previous chunk','line_number':61,'multiline':False]['text':' would remain unused.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':' Oversize allocation size can be disabled or customized with disableOversize','line_number':64,'multiline':False]['text':' and setOversizeThreshold, which must be smaller than the default chunk size','line_number':65,'multiline':False]['text':' with which the LifoAlloc was initialized.','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':' ** LifoAllocScope (mark & release)','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' As the memory cannot be reclaimed except when the LifoAlloc structure is','line_number':70,'multiline':False]['text':' deleted, the LifoAllocScope structure is used to create scopes, related to a','line_number':71,'multiline':False]['text':' stacked task. When going out of a LifoAllocScope the memory associated to the','line_number':72,'multiline':False]['text':' scope is marked as unused but not reclaimed. This implies that the memory','line_number':73,'multiline':False]['text':' allocated for one task can be reused for a similar task later on. (see','line_number':74,'multiline':False]['text':' Safety)','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' LifoAllocScope is based on mark and release functions. The mark function is','line_number':77,'multiline':False]['text':' used to recall the offsets at which a LifoAllocScope got created. The release','line_number':78,'multiline':False]['text':' function takes the Mark as input and will flag all memory allocated after the','line_number':79,'multiline':False]['text':' mark creation as unused.','line_number':80,'multiline':False]['text':'','line_number':81,'multiline':False]['text':' When releasing all the memory of BumpChunks, these are moved to a list of','line_number':82,'multiline':False]['text':' unused chunks which will later be reused by new allocations.','line_number':83,'multiline':False]['text':'','line_number':84,'multiline':False]['text':' A bump chunk allocator normally has a single bump pointers, whereas we have','line_number':85,'multiline':False]['text':' 2. (see Oversize allocations) By doing so, we lose the ordering of allocation','line_number':86,'multiline':False]['text':' coming from a single linked list of allocation.','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' However, we rely on the ordering of allocation with LifoAllocScope, i-e when','line_number':89,'multiline':False]['text':' mark and release functions are used. Thus the LifoAlloc::Mark is composed of','line_number':90,'multiline':False]['text':' 2 marks, One for each singled linked list of allocations, to keep both lists','line_number':91,'multiline':False]['text':' of allocations ordered.','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':' ** Infallible Allocator','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' LifoAlloc can also be used as an infallible allocator. This requires the user','line_number':96,'multiline':False]['text':' to periodically ensure that enough space has been reserved to satisfy the','line_number':97,'multiline':False]['text':' upcoming set of allocations by calling LifoAlloc::ensureUnusedApproximate or','line_number':98,'multiline':False]['text':' LifoAlloc::allocEnsureUnused functions. Between 2 calls of these functions,','line_number':99,'multiline':False]['text':' functions such as allocInfallible can be used without checking against','line_number':100,'multiline':False]['text':' nullptr, as long as there is a bounded number of such calls and that all','line_number':101,'multiline':False]['text':' allocations including their red-zone fit in the reserved space.','line_number':102,'multiline':False]['text':'','line_number':103,'multiline':False]['text':' The infallible allocator mode can be toggle as being the default by calling','line_number':104,'multiline':False]['text':' setAsInfallibleByDefault, in which case an AutoFallibleScope should be used','line_number':105,'multiline':False]['text':' to make any large allocations. Failing to do so will raise an issue when','line_number':106,'multiline':False]['text':' running the LifoAlloc with the OOM Simulator. (see Security features)','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':' * LifoAlloc::Enum Iterator','line_number':109,'multiline':False]['text':'','line_number':110,'multiline':False]['text':' A LifoAlloc is used for backing the store-buffer of the Garbage Collector','line_number':111,'multiline':False]['text':' (GC). The store-buffer is appending data as it is being reported during','line_number':112,'multiline':False]['text':' incremental GC. The LifoAlloc::Enum class is used for iterating over the set','line_number':113,'multiline':False]['text':' of allocations made within the LifoAlloc.','line_number':114,'multiline':False]['text':'','line_number':115,'multiline':False]['text':' However, one must take extra care into having the proper associated types for','line_number':116,'multiline':False]['text':' the data which are being written and read out of the LifoAlloc. The iterator','line_number':117,'multiline':False]['text':' is reusing the same logic as the allocator in order to skip red-zones.','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' At the moment, the iterator will cause a hard failure if any oversize','line_number':120,'multiline':False]['text':' allocation are made.','line_number':121,'multiline':False]['text':'','line_number':122,'multiline':False]['text':' * Safety','line_number':123,'multiline':False]['text':'','line_number':124,'multiline':False]['text':' A LifoAlloc is neither thread-safe nor interrupt-safe. It should only be','line_number':125,'multiline':False]['text':' manipulated in one thread of execution at a time. It can be transferred from','line_number':126,'multiline':False]['text':' one thread to another but should not be used concurrently.','line_number':127,'multiline':False]['text':'','line_number':128,'multiline':False]['text':' When using LifoAllocScope, no pointer to the data allocated within a','line_number':129,'multiline':False]['text':' LifoAllocScope should be stored in data allocated before the latest','line_number':130,'multiline':False]['text':' LifoAllocScope. This kind of issue can hide in different forms, such as','line_number':131,'multiline':False]['text':' appending to a Vector backed by a LifoAlloc, which can resize and move the','line_number':132,'multiline':False]['text':' data below the LifoAllocScope. Thus causing a use-after-free once leaving a','line_number':133,'multiline':False]['text':' LifoAllocScope.','line_number':134,'multiline':False]['text':'','line_number':135,'multiline':False]['text':' * Security features','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':' ** Single Linked List','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' For sanity reasons this LifoAlloc implementation makes use of its own single','line_number':140,'multiline':False]['text':' linked list implementation based on unique pointers (UniquePtr). The reason','line_number':141,'multiline':False]['text':' for this is to ensure that a BumpChunk is owned only once, thus preventing','line_number':142,'multiline':False]['text':' use-after-free issues.','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' ** OOM Simulator','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' The OOM simulator is controlled by the JS_OOM_BREAKPOINT macro, and used to','line_number':147,'multiline':False]['text':' check any fallible allocation for potential OOM. Fallible functions are','line_number':148,'multiline':False]['text':' instrumented with JS_OOM_POSSIBLY_FAIL(); function calls, and are expected to','line_number':149,'multiline':False]['text':' return null on failures.','line_number':150,'multiline':False]['text':'','line_number':151,'multiline':False]['text':' Except for simulating OOMs, LifoAlloc is instrumented in DEBUG and OOM','line_number':152,'multiline':False]['text':' Simulator builds to checks for the correctness of the Infallible Allocator','line_number':153,'multiline':False]['text':' state. When using a LifoAlloc as an infallible allocator, enough space should','line_number':154,'multiline':False]['text':' always be reserved for the next allocations. Therefore, to check this','line_number':155,'multiline':False]['text':' invariant LifoAlloc::newChunkWithCapacity checks that any new chunks are','line_number':156,'multiline':False]['text':' allocated within a fallible scope, under AutoFallibleScope.','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':' ** Address Sanitizers & Valgrind','line_number':159,'multiline':False]['text':'','line_number':160,'multiline':False]['text':' When manipulating memory in a LifoAlloc, the memory remains contiguous and','line_number':161,'multiline':False]['text':' therefore subject to potential buffer overflow/underflow. To check for these','line_number':162,'multiline':False]['text':' memory corruptions, the macro LIFO_HAVE_MEM_CHECK is used to add red-zones','line_number':163,'multiline':False]['text':' with LIFO_MAKE_MEM_NOACCESS and LIFO_MAKE_MEM_UNDEFINED.','line_number':164,'multiline':False]['text':'','line_number':165,'multiline':False]['text':' The red-zone is a minimum space left in between 2 allocations. Any access to','line_number':166,'multiline':False]['text':' these red-zones should warn in both valgrind / ASan builds.','line_number':167,'multiline':False]['text':'','line_number':168,'multiline':False]['text':' The red-zone size is defined in BumpChunk::RedZoneSize and default to 0 if','line_number':169,'multiline':False]['text':' not instrumentation is expected, and 16 otherwise.','line_number':170,'multiline':False]['text':'','line_number':171,'multiline':False]['text':' ** Magic Number','line_number':172,'multiline':False]['text':'','line_number':173,'multiline':False]['text':' A simple sanity check is present in all BumpChunk under the form of a','line_number':174,'multiline':False]['text':' constant field which is never mutated. the BumpChunk::magic_ is initalized to','line_number':175,'multiline':False]['text':' the "Lif" string. Any mutation of this value indicate a memory corruption.','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':' This magic number is enabled in all MOZ_DIAGNOSTIC_ASSERT_ENABLED builds,','line_number':178,'multiline':False]['text':' which implies that all Nightly and dev-edition versions of','line_number':179,'multiline':False]['text':' Firefox/SpiderMonkey contain this instrumentation.','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':' ** Memory protection','line_number':182,'multiline':False]['text':'','line_number':183,'multiline':False]['text':' LifoAlloc chunks are holding a lot of memory. When the memory is known to be','line_number':184,'multiline':False]['text':' unused, unchanged for some period of time, such as moving from one thread to','line_number':185,'multiline':False]['text':' another. Then the memory can be set as read-only with LifoAlloc::setReadOnly','line_number':186,'multiline':False]['text':' and reset as read-write with LifoAlloc::setReadWrite.','line_number':187,'multiline':False]['text':'','line_number':188,'multiline':False]['text':' This code is guarded by LIFO_CHUNK_PROTECT and at the moment only enabled in','line_number':189,'multiline':False]['text':' DEBUG builds in order to avoid the fragmentation of the TLB which might run','line_number':190,'multiline':False]['text':' out-of-memory when calling mprotect.','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' Single linked list which is using UniquePtr to hold the next pointers.','line_number':217,'multiline':False]['text':' UniquePtr are used to ensure that none of the elements are used','line_number':218,'multiline':False]['text':' silmutaneously in 2 different list.','line_number':219,'multiline':False]['text':' First element of the list which owns the next element, and ensure that','line_number':223,'multiline':False]['text':' that this list is the only owner of the element.','line_number':224,'multiline':False]['text':' Weak pointer to the last element of the list.','line_number':227,'multiline':False]['text':' Move the elements of the |other| list in the current one, and implicitly','line_number':250,'multiline':False]['text':' remove all the elements of the current list.','line_number':251,'multiline':False]['text':' Iterates over the elements of the list, this is used to avoid raw','line_number':263,'multiline':False]['text':' manipulation of pointers as much as possible.','line_number':264,'multiline':False]['text':' Split the list in 2 single linked lists after the element given as','line_number':292,'multiline':False]['text':' argument.  The front of the list remains in the current list, while the','line_number':293,'multiline':False]['text':' back goes in the newly create linked list.','line_number':294,'multiline':False]['text':'','line_number':295,'multiline':False]['text':' This is used for example to extract one element from a list. (see','line_number':296,'multiline':False]['text':' LifoAlloc::getOrCreateChunk)','line_number':297,'multiline':False]['text':' A Chunk represent a single memory allocation made with the system','line_number':379,'multiline':False]['text':' allocator. As the owner of the memory, it is responsible for the allocation','line_number':380,'multiline':False]['text':' and the deallocation.','line_number':381,'multiline':False]['text':'','line_number':382,'multiline':False]['text':' This structure is only move-able, but not copyable.','line_number':383,'multiline':False]['text':' Pointer to the last byte allocated in this chunk.','line_number':386,'multiline':False]['text':' Pointer to the first byte after this chunk.','line_number':388,'multiline':False]['text':' Magic number used to check against poisoned values.','line_number':392,'multiline':False]['text':' Poison the memory with memset, in order to catch errors due to','line_number':401,'multiline':False]['text':' use-after-free, with JS_LIFO_UNDEFINED_PATTERN pattern, or to catch','line_number':402,'multiline':False]['text':' use-before-init with JS_LIFO_UNINITIALIZED_PATTERN.','line_number':403,'multiline':False]['text':' Red zone reserved after each allocation.','line_number':433,'multiline':False]['text':' The memory is freshly allocated and marked as undefined by the','line_number':458,'multiline':False]['text':' allocator of the BumpChunk. Instead, we mark this memory as','line_number':459,'multiline':False]['text':' no-access, as it has not been allocated within the BumpChunk.','line_number':460,'multiline':False]['text':' Cast |this| into a uint8_t* pointer.','line_number':465,'multiline':False]['text':'','line_number':466,'multiline':False]['text':' Warning: Are you sure you do not want to use begin() instead?','line_number':467,'multiline':False]['text':' Update the bump pointer to any value contained in this chunk, which is','line_number':471,'multiline':False]['text':' above the private fields of this chunk.','line_number':472,'multiline':False]['text':'','line_number':473,'multiline':False]['text':' The memory is poisoned and flagged as no-access when the bump pointer is','line_number':474,'multiline':False]['text':' moving backward, such as when memory is released, or when a Mark is used','line_number':475,'multiline':False]['text':' to unwind previous allocations.','line_number':476,'multiline':False]['text':'','line_number':477,'multiline':False]['text':' The memory is flagged as undefined when the bump pointer is moving','line_number':478,'multiline':False]['text':' forward.','line_number':479,'multiline':False]['text':' Poison/Unpoison memory that we just free'd/allocated.','line_number':485,'multiline':False]['text':' The area [newBump - RedZoneSize .. newBump[ is already flagged as','line_number':491,'multiline':False]['text':' no-access either with the previous if-branch or with the','line_number':492,'multiline':False]['text':' BumpChunk constructor. No need to mark it twice.','line_number':493,'multiline':False]['text':' Returns true if this chunk contains no allocated content.','line_number':502,'multiline':False]['text':' Returns the size in bytes of the number of allocated space. This includes','line_number':505,'multiline':False]['text':' the size consumed by the alignment of the allocations.','line_number':506,'multiline':False]['text':' These are used for manipulating a chunk as if it was a vector of bytes,','line_number':509,'multiline':False]['text':' and used for iterating over the content of the buffer (see','line_number':510,'multiline':False]['text':' LifoAlloc::Enum)','line_number':511,'multiline':False]['text':' This function is the only way to allocate and construct a chunk. It','line_number':516,'multiline':False]['text':' returns a UniquePtr to the newly allocated chunk.  The size given as','line_number':517,'multiline':False]['text':' argument includes the space needed for the header of the chunk.','line_number':518,'multiline':False]['text':' Report allocation.','line_number':521,'multiline':False]['text':' Report allocation size.','line_number':526,'multiline':False]['text':' Opaque type used to carry a pointer to the current location of the bump_','line_number':529,'multiline':False]['text':' pointer, within a BumpChunk.','line_number':530,'multiline':False]['text':' Chunk which owns the pointer.','line_number':532,'multiline':False]['text':' Recorded of the bump_ pointer of the BumpChunk.','line_number':534,'multiline':False]['text':' Return a mark to be able to unwind future allocations with the release','line_number':546,'multiline':False]['text':' function. (see LifoAllocScope)','line_number':547,'multiline':False]['text':' Check if a pointer is part of the allocated data of this chunk.','line_number':550,'multiline':False]['text':' Note: We cannot check "ptr < end()" because the mark have a 0-size','line_number':552,'multiline':False]['text':' length.','line_number':553,'multiline':False]['text':' Check if a mark is part of the allocated data of this chunk.','line_number':557,'multiline':False]['text':' Release the memory allocated in this chunk. This function does not call','line_number':563,'multiline':False]['text':' any of the destructors.','line_number':564,'multiline':False]['text':' Release the memory allocated in this chunk since the corresponding mark','line_number':567,'multiline':False]['text':' got created. This function does not call any of the destructors.','line_number':568,'multiline':False]['text':' Given an amount, compute the total size of a chunk for it: reserved','line_number':574,'multiline':False]['text':' space before |begin()|, space for |amount| bytes, and red-zone space','line_number':575,'multiline':False]['text':' after those bytes that will ultimately end at |capacity_|.','line_number':576,'multiline':False]['text':' Given a bump chunk pointer, find the next base/end pointers. This is','line_number':580,'multiline':False]['text':' useful for having consistent allocations, and iterating over known size','line_number':581,'multiline':False]['text':' allocations.','line_number':582,'multiline':False]['text':' Returns true, if the unused space is large enough for an allocation of','line_number':588,'multiline':False]['text':' |n| bytes.','line_number':589,'multiline':False]['text':' bump_ <= newBump, is necessary to catch overflow.','line_number':592,'multiline':False]['text':' Space remaining in the current chunk.','line_number':596,'multiline':False]['text':' Try to perform an allocation of size |n|, returns nullptr if not possible.','line_number':605,'multiline':False]['text':' Check for overflow.','line_number':615,'multiline':False]['text':' Ensure consistency between "can" and "try".','line_number':620,'multiline':False]['text':' Space reserved for the BumpChunk internal data, and the alignment of the','line_number':634,'multiline':False]['text':' first allocation content. This can be used to ensure there is enough space','line_number':635,'multiline':False]['text':' for the next allocation (see LifoAlloc::newChunkWithCapacity).','line_number':636,'multiline':False]['text':' static ','line_number':640,'multiline':True]['text':' may be zero','line_number':646,'multiline':False]['text':' namespace detail','line_number':662,'multiline':False]['text':' LIFO bump allocator: used for phase-oriented and fast LIFO allocations.','line_number':664,'multiline':False]['text':'','line_number':665,'multiline':False]['text':' Note: We leave BumpChunks latent in the set of unused chunks after they've','line_number':666,'multiline':False]['text':' been released to avoid thrashing before a GC.','line_number':667,'multiline':False]['text':' List of chunks containing allocated data of size smaller than the default','line_number':672,'multiline':False]['text':' chunk size. In the common case, the last chunk of this list is always','line_number':673,'multiline':False]['text':' used to perform the allocations. When the allocation cannot be performed,','line_number':674,'multiline':False]['text':' we move a Chunk from the unused set to the list of used chunks.','line_number':675,'multiline':False]['text':' List of chunks containing allocated data where each allocation is larger','line_number':678,'multiline':False]['text':' than the oversize threshold. Each chunk contains exactly one allocation.','line_number':679,'multiline':False]['text':' This reduces wasted space in the chunk list.','line_number':680,'multiline':False]['text':'','line_number':681,'multiline':False]['text':' Oversize chunks are allocated on demand and freed as soon as they are','line_number':682,'multiline':False]['text':' released, instead of being pushed to the unused list.','line_number':683,'multiline':False]['text':' Set of unused chunks, which can be reused for future allocations.','line_number':686,'multiline':False]['text':' Size of all chunks in chunks_, oversize_, unused_ lists.','line_number':693,'multiline':False]['text':' Size of all chunks containing small bump allocations. This heuristic is','line_number':697,'multiline':False]['text':' used to compute growth rate while ignoring chunks such as oversized,','line_number':698,'multiline':False]['text':' now-unused, or transferred (which followed their own growth patterns).','line_number':699,'multiline':False]['text':' Return a BumpChunk that can perform an allocation of at least size |n|.','line_number':709,'multiline':False]['text':' Reuse or allocate a BumpChunk that can perform an allocation of at least','line_number':712,'multiline':False]['text':' size |n|, if successful it is placed at the end the list of |chunks_|.','line_number':713,'multiline':False]['text':' Append unused chunks to the end of this LifoAlloc.','line_number':718,'multiline':False]['text':' Append used chunks to the end of this LifoAlloc. We act as if all the','line_number':728,'multiline':False]['text':' chunks in |this| are used, even if they're not, so memory may be wasted.','line_number':729,'multiline':False]['text':' Track the amount of space allocated in used and unused chunks.','line_number':734,'multiline':False]['text':' Give oversized allocations their own chunk instead of wasting space','line_number':753,'multiline':False]['text':' due to fragmentation at the end of normal chunk.','line_number':754,'multiline':False]['text':' Check for space in unused chunks or allocate a new unused chunk.','line_number':765,'multiline':False]['text':' Set the threshold to allocate data in its own chunk outside the space for','line_number':779,'multiline':False]['text':' small allocations.','line_number':780,'multiline':False]['text':' Steal allocated chunks from |other|.','line_number':787,'multiline':False]['text':' Append all chunks from |other|. They are removed from |other|.','line_number':790,'multiline':False]['text':' Append unused chunks from |other|. They are removed from |other|.','line_number':793,'multiline':False]['text':' Frees all held memory.','line_number':800,'multiline':False]['text':' Only simulate OOMs when we are not using the LifoAlloc as an','line_number':813,'multiline':False]['text':' infallible allocator.','line_number':814,'multiline':False]['text':' Allocates |n| bytes if we can guarantee that we will have','line_number':822,'multiline':False]['text':' |needed| unused bytes remaining. Returns nullptr if we can't.','line_number':823,'multiline':False]['text':' This is useful for maintaining our ballast invariants while','line_number':824,'multiline':False]['text':' attempting fallible allocations.','line_number':825,'multiline':False]['text':' Ensures that enough space exists to satisfy N bytes worth of','line_number':864,'multiline':False]['text':' allocation requests, not necessarily contiguous. Note that this does','line_number':865,'multiline':False]['text':' not guarantee a successful single allocation of N bytes.','line_number':866,'multiline':False]['text':' Create an array with uninitialized elements of type |T|.','line_number':917,'multiline':False]['text':' The caller is responsible for initialization.','line_number':918,'multiline':False]['text':' Note: MOZ_NEVER_INLINE is a work around for a Clang 9 (PGO) miscompilation.','line_number':934,'multiline':False]['text':' See bug 1583907.','line_number':935,'multiline':False]['text':' When releasing all chunks, we can no longer determine which chunks were','line_number':947,'multiline':False]['text':' transferred and which were not, so simply clear the heuristic to zero','line_number':948,'multiline':False]['text':' right away.','line_number':949,'multiline':False]['text':' On release, we free any oversize allocations instead of keeping them','line_number':957,'multiline':False]['text':' in unused chunks.','line_number':958,'multiline':False]['text':' Protect the content of the LifoAlloc chunks.','line_number':965,'multiline':False]['text':' Get the total "used" (occupied bytes) count for the arena chunks.','line_number':974,'multiline':False]['text':' Return true if the LifoAlloc does not currently contain any allocations.','line_number':983,'multiline':False]['text':' Return the number of bytes remaining to allocate in the current chunk.','line_number':991,'multiline':False]['text':' e.g. How many bytes we can allocate before needing a new block.','line_number':992,'multiline':False]['text':' Get the total size of the arena chunks (including unused space).','line_number':1000,'multiline':False]['text':' Like sizeOfExcludingThis(), but includes the size of the LifoAlloc itself.','line_number':1015,'multiline':False]['text':' Get the current size of the arena chunks (including unused space and','line_number':1020,'multiline':False]['text':' bookkeeping space).','line_number':1021,'multiline':False]['text':' Get the peak size of the arena chunks (including unused space and','line_number':1024,'multiline':False]['text':' bookkeeping space).','line_number':1025,'multiline':False]['text':' Doesn't perform construction; useful for lazily-initialized POD types.','line_number':1028,'multiline':False]['text':' Iterate over the data allocated in a LifoAlloc, and interpret it.','line_number':1053,'multiline':False]['text':' Iterator over the list of bump chunks.','line_number':1058,'multiline':False]['text':' Read head (must be within chunk_).','line_number':1061,'multiline':False]['text':' If there is not enough room in the remaining block for |size|,','line_number':1064,'multiline':False]['text':' advance to the next block and update the position.','line_number':1065,'multiline':False]['text':' The current code assumes that if we have a chunk, then we','line_number':1073,'multiline':False]['text':' have allocated something it in.','line_number':1074,'multiline':False]['text':' Return true if there are no more bytes to enumerate.','line_number':1093,'multiline':False]['text':' Move the read position forward by the size of one T.','line_number':1099,'multiline':False]['text':' Return a pointer to the item at the current position. This returns a','line_number':1105,'multiline':False]['text':' pointer to the inline storage, not a copy, and moves the read-head by','line_number':1106,'multiline':False]['text':' the requested |size|.','line_number':1107,'multiline':False]['text':'
     * The parser can allocate enormous amounts of memory for large functions.
     * Eagerly free the memory now (which otherwise won't be freed until the
     * next GC) to avoid unnecessary OOMs.
     ','line_number':1126,'multiline':True]['text':' namespace js','line_number':1194,'multiline':False]['text':' ds_LifoAlloc_h ','line_number':1196,'multiline':True]