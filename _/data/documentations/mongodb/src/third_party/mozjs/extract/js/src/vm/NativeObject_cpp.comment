['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::GetErrorMessage, JSMSG_*','line_number':22,'multiline':False]['text':' js::AutoCheckRecursionLimit','line_number':23,'multiline':False]['text':' js::SameValue','line_number':27,'multiline':False]['text':' js::GetterSetter','line_number':28,'multiline':False]['text':' js::PlainObject','line_number':29,'multiline':False]['text':' Add an extra (unused) Value to make sure an out-of-bounds index when','line_number':51,'multiline':False]['text':' masked (resulting in index 0) accesses valid memory.','line_number':52,'multiline':False]['text':' Objects with no elements share one empty set of elements. ','line_number':64,'multiline':True]['text':' Objects with no elements share one empty set of elements. ','line_number':71,'multiline':True]['text':' DEBUG','line_number':113,'multiline':False]['text':' static ','line_number':115,'multiline':True]['text':' shrinkCapacityToInitializedLength ensures there are no shifted elements.','line_number':122,'multiline':False]['text':' static ','line_number':126,'multiline':True]['text':' static ','line_number':137,'multiline':True]['text':' static ','line_number':170,'multiline':True]['text':'
   * No bounds check, as this is used when the object's shape does not
   * reflect its allocated slots (updateSlotsForSpan).
   ','line_number':191,'multiline':True]['text':' We call numFixedSlotsMaybeForwarded() to allow reading slots of','line_number':240,'multiline':False]['text':' associated objects in trace hooks that may be called during a moving GC.','line_number':241,'multiline':False]['text':' We call numFixedSlotsMaybeForwarded() to allow reading slots of','line_number':246,'multiline':False]['text':' associated objects in trace hooks that may be called during a moving GC.','line_number':247,'multiline':False]['text':' DEBUG ','line_number':251,'multiline':True]['text':'
   * Slot capacities are determined by the span of allocated objects. Due to
   * the limited number of bits to store shape slots, object growth is
   * throttled well before the slot capacity can overflow.
   ','line_number':293,'multiline':True]['text':' Leave slots at its old size. ','line_number':318,'multiline':True]['text':' static ','line_number':362,'multiline':True]['text':' IC code calls this directly.','line_number':365,'multiline':False]['text':' static ','line_number':376,'multiline':True]['text':' IC code calls this directly.','line_number':378,'multiline':False]['text':' growElements will report OOM also if the number of dense elements will','line_number':388,'multiline':False]['text':' exceed MAX_DENSE_ELEMENTS_COUNT. See goodElementsAllocationAmount.','line_number':389,'multiline':False]['text':' It's possible for realloc to fail when shrinking an allocation. In this','line_number':441,'multiline':False]['text':' case we continue using the original allocation but still update the','line_number':442,'multiline':False]['text':' capacity to the new requested capacity, which is smaller than the actual','line_number':443,'multiline':False]['text':' capacity.','line_number':444,'multiline':False]['text':' static ','line_number':491,'multiline':True]['text':'
   * Wait until after the object goes into dictionary mode, which must happen
   * when sparsely packing any array with more than MIN_SPARSE_INDEX elements
   * (see PropertyTree::MAX_HEIGHT).
   ','line_number':494,'multiline':True]['text':'
   * Only measure the number of indexed properties every log(n) times when
   * populating the object.
   ','line_number':503,'multiline':True]['text':' Watch for conditions under which an object's elements cannot be dense. ','line_number':512,'multiline':True]['text':'
   * The indexes in the object need to be sufficiently dense before they can
   * be converted to dense mode.
   ','line_number':517,'multiline':True]['text':' For simplicity, only densify the object if all indexed properties can','line_number':530,'multiline':False]['text':' be converted to dense elements.','line_number':531,'multiline':False]['text':'
   * This object meets all necessary restrictions, convert all indexed
   * properties into dense elements.
   ','line_number':547,'multiline':True]['text':' Mark the densified elements as maybe-in-iteration. See also the comment','line_number':561,'multiline':False]['text':' in GetIterator.','line_number':562,'multiline':False]['text':' To move the elements, temporarily update initializedLength to include','line_number':590,'multiline':False]['text':' the shifted elements.','line_number':591,'multiline':False]['text':' Move the elements. Initialize to |undefined| to ensure pre-barriers','line_number':594,'multiline':False]['text':' don't see garbage.','line_number':595,'multiline':False]['text':' Restore the initialized length. We use setDenseInitializedLength to','line_number':601,'multiline':False]['text':' make sure prepareElementRangeForOverwrite is called on the shifted','line_number':602,'multiline':False]['text':' elements.','line_number':603,'multiline':False]['text':' Move the elements if less than a third of the allocated space is in use.','line_number':613,'multiline':False]['text':' We need more elements than are easily available. Try to make space','line_number':627,'multiline':False]['text':' for more elements than we need (and shift the remaining ones) so','line_number':628,'multiline':False]['text':' that unshifting more elements later will be fast.','line_number':629,'multiline':False]['text':' Don't bother reserving elements if the number of elements is small.','line_number':631,'multiline':False]['text':' Note that there's no technical reason for using this particular','line_number':632,'multiline':False]['text':' limit.','line_number':633,'multiline':False]['text':' Determine toShift, the number of extra elements we want to make','line_number':643,'multiline':False]['text':' available.','line_number':644,'multiline':False]['text':' Give up if we need to allocate more elements.','line_number':649,'multiline':False]['text':' Move more elements than we need, so that other unshift calls will be','line_number':654,'multiline':False]['text':' fast. We just have to make sure we don't exceed unusedCapacity.','line_number':655,'multiline':False]['text':' Ensure |numShifted + toShift| does not exceed MaxShiftedElements.','line_number':658,'multiline':False]['text':' Now move/unshift the elements.','line_number':667,'multiline':False]['text':' Shift the elements we just prepended.','line_number':675,'multiline':False]['text':' We can now fall-through to the fast path below.','line_number':678,'multiline':False]['text':' Initialize to |undefined| to ensure pre-barriers don't see garbage.','line_number':692,'multiline':False]['text':' Given a requested capacity (in elements) and (potentially) the length of an','line_number':700,'multiline':False]['text':' array for which elements are being allocated, compute an actual allocation','line_number':701,'multiline':False]['text':' amount (in elements).  (Allocation amounts include space for an','line_number':702,'multiline':False]['text':' ObjectElements instance, so a return value of |N| implies','line_number':703,'multiline':False]['text':' |N - ObjectElements::VALUES_PER_HEADER| usable elements.)','line_number':704,'multiline':False]['text':'','line_number':705,'multiline':False]['text':' The requested/actual allocation distinction is meant to:','line_number':706,'multiline':False]['text':'','line_number':707,'multiline':False]['text':'   * preserve amortized O(N) time to add N elements;','line_number':708,'multiline':False]['text':'   * minimize the number of unused elements beyond an array's length, and','line_number':709,'multiline':False]['text':'   * provide at least SLOT_CAPACITY_MIN elements no matter what (so adding','line_number':710,'multiline':False]['text':'     the first several elements to small arrays only needs one allocation).','line_number':711,'multiline':False]['text':'','line_number':712,'multiline':False]['text':' Note: the structure and behavior of this method follow along with','line_number':713,'multiline':False]['text':' UnboxedArrayObject::chooseCapacityIndex. Changes to the allocation strategy','line_number':714,'multiline':False]['text':' in one should generally be matched by the other.','line_number':715,'multiline':False]['text':' static ','line_number':716,'multiline':True]['text':' Handle "small" requests primarily by doubling.','line_number':728,'multiline':False]['text':' If |amount| would be 2/3 or more of the array's length, adjust','line_number':734,'multiline':False]['text':' it (up or down) to be equal to the array's length.  This avoids','line_number':735,'multiline':False]['text':' allocating excess elements that aren't likely to be needed, either','line_number':736,'multiline':False]['text':' in this resizing or a subsequent one.  The 2/3 factor is chosen so','line_number':737,'multiline':False]['text':' that exceptional resizings will at most triple the capacity, as','line_number':738,'multiline':False]['text':' opposed to the usual doubling.','line_number':739,'multiline':False]['text':' The almost-doubling above wastes a lot of space for larger bucket sizes.','line_number':754,'multiline':False]['text':' For large amounts, switch to bucket sizes that obey this formula:','line_number':755,'multiline':False]['text':'','line_number':756,'multiline':False]['text':'   count(n+1) = Math.ceil(count(n) * 1.125)','line_number':757,'multiline':False]['text':'','line_number':758,'multiline':False]['text':' where |count(n)| is the size of the nth bucket, measured in 2**20 slots.','line_number':759,'multiline':False]['text':' These bucket sizes still preserve amortized O(N) time to add N elements,','line_number':760,'multiline':False]['text':' just with a larger constant factor.','line_number':761,'multiline':False]['text':'','line_number':762,'multiline':False]['text':' The bucket size table below was generated with this JavaScript (and','line_number':763,'multiline':False]['text':' manual reformatting):','line_number':764,'multiline':False]['text':'','line_number':765,'multiline':False]['text':'   for (let n = 1, i = 0; i < 34; i++) {','line_number':766,'multiline':False]['text':'     print('0x' + (n * (1 << 20)).toString(16) + ', ');','line_number':767,'multiline':False]['text':'     n = Math.ceil(n * 1.125);','line_number':768,'multiline':False]['text':'   }','line_number':769,'multiline':False]['text':' Pick the first bucket that'll fit |reqAllocated|.','line_number':780,'multiline':False]['text':' Otherwise, return the maximum bucket size.','line_number':788,'multiline':False]['text':' If there are shifted elements, consider moving them first. If we don't','line_number':797,'multiline':False]['text':' move them here, the code below will include the shifted elements in the','line_number':798,'multiline':False]['text':' resize.','line_number':799,'multiline':False]['text':' If the number of elements is small, it's cheaper to just move them as','line_number':802,'multiline':False]['text':' it may avoid a malloc/realloc. Note that there's no technical reason','line_number':803,'multiline':False]['text':' for using this particular value, but it works well in real-world use','line_number':804,'multiline':False]['text':' cases.','line_number':805,'multiline':False]['text':' If |reqCapacity + numShifted| overflows, we just move all shifted','line_number':818,'multiline':False]['text':' elements to avoid the problem.','line_number':819,'multiline':False]['text':' Preserve the |capacity <= length| invariant for arrays with','line_number':835,'multiline':False]['text':' non-writable length.  See also js::ArraySetLength which initially','line_number':836,'multiline':False]['text':' enforces this requirement.','line_number':837,'multiline':False]['text':' If newCapacity exceeds MAX_DENSE_ELEMENTS_COUNT, the array should become','line_number':851,'multiline':False]['text':' sparse.','line_number':852,'multiline':False]['text':' Leave elements at its old size.','line_number':868,'multiline':False]['text':' Leave elements at its old size.','line_number':873,'multiline':False]['text':' If we have shifted elements, consider moving them.','line_number':904,'multiline':False]['text':' Leave elements at its old size.','line_number':922,'multiline':False]['text':' Leave elements at its old size.','line_number':936,'multiline':False]['text':' When an array's length becomes non-writable, writes to indexes greater','line_number':951,'multiline':False]['text':' greater than or equal to the length don't change the array.  We handle this','line_number':952,'multiline':False]['text':' with a check for non-writable length in most places. But in JIT code every','line_number':953,'multiline':False]['text':' check counts -- so we piggyback the check on the already-required range','line_number':954,'multiline':False]['text':' check for |index < capacity| by making capacity of arrays with non-writable','line_number':955,'multiline':False]['text':' length never exceed the length. This mechanism is also used when an object','line_number':956,'multiline':False]['text':' becomes non-extensible.','line_number':957,'multiline':False]['text':' The size of the memory allocation hasn't changed but we lose the actual','line_number':976,'multiline':False]['text':' capacity information. Make the associated size match the updated capacity.','line_number':977,'multiline':False]['text':' static ','line_number':987,'multiline':True]['text':' Try to pull a free slot from the slot-number free list.','line_number':995,'multiline':False]['text':' Can't afford to check the whole free list, but let's check the head.','line_number':1028,'multiline':False]['text':' Place all freed slots other than reserved slots (bug 595230) on the','line_number':1031,'multiline':False]['text':' dictionary's free list.','line_number':1032,'multiline':False]['text':'** [[DefineOwnProperty]] *************************************************','line_number':1059,'multiline':True]['text':' Inline addProperty for array objects.','line_number':1092,'multiline':False]['text':'*
 * Determines whether a write to the given element on |arr| should fail
 * because |arr| has a non-writable length, and writing that element would
 * increase the length of the array.
 ','line_number':1115,'multiline':True]['text':' Lookups on integer ids cannot be cached through prototypes.','line_number':1128,'multiline':False]['text':' Lookups will not be cached through non-native protos.','line_number':1135,'multiline':False]['text':' If |obj| is a prototype of another object, check if we're shadowing a','line_number':1153,'multiline':False]['text':' property on its proto chain. In this case we need to reshape that object','line_number':1154,'multiline':False]['text':' for shape teleporting to work correctly.','line_number':1155,'multiline':False]['text':'','line_number':1156,'multiline':False]['text':' See also the 'Shape Teleporting Optimization' comment in jit/CacheIR.cpp.','line_number':1157,'multiline':False]['text':' Inlined fast path for non-prototype/non-native objects.','line_number':1159,'multiline':False]['text':' static ','line_number':1167,'multiline':True]['text':' If we're redefining a getter/setter property but the getter and setter','line_number':1183,'multiline':False]['text':' objects are still the same, use the existing GetterSetter.','line_number':1184,'multiline':False]['text':' Whether we're adding a new property or changing an existing property (this','line_number':1234,'multiline':False]['text':' can be either a property stored in the shape tree or a dense element).','line_number':1235,'multiline':False]['text':' Use dense storage for indexed properties where possible: when we have an','line_number':1259,'multiline':False]['text':' integer key with default property attributes and are either adding a new','line_number':1260,'multiline':False]['text':' property or changing a dense element.','line_number':1261,'multiline':False]['text':' Clear any existing dense index after adding a sparse indexed property,','line_number':1321,'multiline':False]['text':' and investigate converting the object to dense indexes.','line_number':1322,'multiline':False]['text':' Versions of AddOrChangeProperty optimized for adding a plain data property.','line_number':1348,'multiline':False]['text':' These function doesn't handle integer ids as we may have to store them in','line_number':1349,'multiline':False]['text':' dense elements.','line_number':1350,'multiline':False]['text':'
 * If desc is redundant with an existing own property obj[id], then set
 * |*redundant = true| and return true.
 ','line_number':1410,'multiline':True]['text':' Get the current value of the existing property.','line_number':1435,'multiline':False]['text':' Don't call SameValue here to ensure we properly update distinct','line_number':1441,'multiline':False]['text':' NaN values.','line_number':1442,'multiline':False]['text':' Check for custom data properties for ArrayObject/ArgumentsObject.','line_number':1448,'multiline':False]['text':' PropertyDescriptor can't represent these properties so they're never','line_number':1449,'multiline':False]['text':' redundant.','line_number':1450,'multiline':False]['text':' Section numbers and step numbers below refer to ES2018, draft rev','line_number':1478,'multiline':False]['text':' 540b827fccf6122a984be99ab9af7be20e3b5562.','line_number':1479,'multiline':False]['text':'','line_number':1480,'multiline':False]['text':' This function aims to implement 9.1.6 [[DefineOwnProperty]] as well as','line_number':1481,'multiline':False]['text':' the [[DefineOwnProperty]] methods described in 9.4.2.1 (arrays), 9.4.4.2','line_number':1482,'multiline':False]['text':' (arguments), and 9.4.5.3 (typed array views).','line_number':1483,'multiline':False]['text':' Dispense with custom behavior of exotic native objects first.','line_number':1485,'multiline':False]['text':' 9.4.2.1 step 2. Redefining an array's length is very special.','line_number':1487,'multiline':False]['text':' 9.1.6.3 ValidateAndApplyPropertyDescriptor, step 7.a.','line_number':1490,'multiline':False]['text':' 9.4.2.1 step 3. Don't extend a fixed-length array.','line_number':1499,'multiline':False]['text':' 9.4.5.3 step 3. Indexed properties of typed arrays are special.','line_number':1507,'multiline':False]['text':' Either we are resolving the .length property on this object,','line_number':1521,'multiline':False]['text':' or redefining it. In the latter case only, we must reify the','line_number':1522,'multiline':False]['text':' property.','line_number':1523,'multiline':False]['text':' Do same thing as .length for [@@iterator].','line_number':1530,'multiline':False]['text':' 9.1.6.1 OrdinaryDefineOwnProperty step 1.','line_number':1543,'multiline':False]['text':' We are being called from a resolve or enumerate hook to reify a','line_number':1546,'multiline':False]['text':' lazily-resolved property. To avoid reentering the resolve hook and','line_number':1547,'multiline':False]['text':' recursing forever, skip the resolve hook when doing this lookup.','line_number':1548,'multiline':False]['text':' From this point, the step numbers refer to','line_number':1558,'multiline':False]['text':' 9.1.6.3, ValidateAndApplyPropertyDescriptor.','line_number':1559,'multiline':False]['text':' Step 1 is a redundant assertion.','line_number':1560,'multiline':False]['text':' Filling in desc: Here we make a copy of the desc_ argument. We will turn','line_number':1562,'multiline':False]['text':' it into a complete descriptor before updating obj. The spec algorithm','line_number':1563,'multiline':False]['text':' does not explicitly do this, but the end result is the same. Search for','line_number':1564,'multiline':False]['text':' "fill in" below for places where the filling-in actually occurs.','line_number':1565,'multiline':False]['text':' Step 2.','line_number':1568,'multiline':False]['text':' Note: We are sharing the property definition machinery with private','line_number':1570,'multiline':False]['text':'       fields. Private fields may be added to non-extensible objects.','line_number':1571,'multiline':False]['text':' Fill in missing desc fields with defaults.','line_number':1576,'multiline':False]['text':' Step 3 and 7.a.i.3, 8.a.iii, 10 (partially). Prop might not actually','line_number':1585,'multiline':False]['text':' have a real shape, e.g. in the case of typed array elements,','line_number':1586,'multiline':False]['text':' GetPropertyAttributes is used to paper-over that difference.','line_number':1587,'multiline':False]['text':' Step 4.','line_number':1597,'multiline':False]['text':' Fill in desc.[[Configurable]] and desc.[[Enumerable]] if missing.','line_number':1607,'multiline':False]['text':' Steps 5-8.','line_number':1615,'multiline':False]['text':' Step 5. No further validation is required.','line_number':1617,'multiline':False]['text':' Fill in desc. A generic descriptor has none of these fields, so copy','line_number':1619,'multiline':False]['text':' everything from shape.','line_number':1620,'multiline':False]['text':' Step 6.','line_number':1638,'multiline':False]['text':' Fill in desc fields with default values (steps 6.b.i and 6.c.i).','line_number':1643,'multiline':False]['text':' Step 7.','line_number':1646,'multiline':False]['text':' Step 7.a.i.1.','line_number':1649,'multiline':False]['text':' Fill in desc.[[Value]].','line_number':1661,'multiline':False]['text':' Step 7.a.i.2.','line_number':1664,'multiline':False]['text':' Step 7.a.i.3.','line_number':1676,'multiline':False]['text':' Fill in desc.[[Writable]].','line_number':1681,'multiline':False]['text':' Step 8.','line_number':1686,'multiline':False]['text':' The spec says to use SameValue, but since the values in','line_number':1691,'multiline':False]['text':' question are objects, we can just compare pointers.','line_number':1692,'multiline':False]['text':' Step 8.a.i.','line_number':1694,'multiline':False]['text':' Fill in desc.[[Set]] from shape.','line_number':1699,'multiline':False]['text':' Step 8.a.ii.','line_number':1703,'multiline':False]['text':' Fill in desc.[[Get]] from shape.','line_number':1708,'multiline':False]['text':' Step 8.a.iii (Omitted).','line_number':1712,'multiline':False]['text':' Step 9.','line_number':1715,'multiline':False]['text':' Step 10.','line_number':1720,'multiline':False]['text':' Off-thread callers should not get here: they must call this','line_number':1745,'multiline':False]['text':' function only with known-valid arguments. Populating a new','line_number':1746,'multiline':False]['text':' PlainObject with configurable properties is fine.','line_number':1747,'multiline':False]['text':' Off-thread callers should not get here: they must call this','line_number':1764,'multiline':False]['text':' function only with known-valid arguments. Populating a new','line_number':1765,'multiline':False]['text':' PlainObject with configurable properties is fine.','line_number':1766,'multiline':False]['text':' Optimized NativeDefineProperty() version for known absent properties.','line_number':1784,'multiline':False]['text':' Dispense with custom behavior of exotic native objects first.','line_number':1786,'multiline':False]['text':' Array's length property is non-configurable, so we shouldn't','line_number':1788,'multiline':False]['text':' encounter it in this function.','line_number':1789,'multiline':False]['text':' 9.4.2.1 step 3. Don't extend a fixed-length array.','line_number':1792,'multiline':False]['text':' 9.4.5.5 step 2. Indexed properties of typed arrays are special.','line_number':1800,'multiline':False]['text':' This method is only called for non-existent properties, which','line_number':1807,'multiline':False]['text':' means any absent indexed property must be out of range.','line_number':1808,'multiline':False]['text':' The following steps refer to 9.4.5.11 IntegerIndexedElementSet.','line_number':1811,'multiline':False]['text':' Step 1 is enforced by the caller.','line_number':1813,'multiline':False]['text':' Steps 2-3.','line_number':1815,'multiline':False]['text':' We still need to call ToNumber or ToBigInt, because of its','line_number':1816,'multiline':False]['text':' possible side effects.','line_number':1817,'multiline':False]['text':' Step 4 (nothing to do, the index is out of range).','line_number':1822,'multiline':False]['text':' Step 5.','line_number':1824,'multiline':False]['text':' If this method is called with either |length| or |@@iterator|, the','line_number':1828,'multiline':False]['text':' property was previously deleted and hence should already be marked','line_number':1829,'multiline':False]['text':' as overridden.','line_number':1830,'multiline':False]['text':' We still need to mark any element properties as overridden.','line_number':1836,'multiline':False]['text':' 9.1.6.3, ValidateAndApplyPropertyDescriptor.','line_number':1850,'multiline':False]['text':' Step 1 is a redundant assertion, step 3 and later don't apply here.','line_number':1851,'multiline':False]['text':' Step 2.','line_number':1853,'multiline':False]['text':' This might be a dense element. Use AddOrChangeProperty as it knows','line_number':1859,'multiline':False]['text':' how to deal with that.','line_number':1860,'multiline':False]['text':' This helper doesn't handle the case where the index may be in the dense','line_number':1883,'multiline':False]['text':' elements','line_number':1884,'multiline':False]['text':' First decide if this is an add or an update. Because the IC guards have','line_number':1888,'multiline':False]['text':' already ensured this exists exterior to the dense array range, and the','line_number':1889,'multiline':False]['text':' prototype checks have ensured there are no indexes on the prototype, we','line_number':1890,'multiline':False]['text':' can use the shape lineage to find the element if it exists:','line_number':1891,'multiline':False]['text':' If we didn't find the property, we're on the add path: delegate to','line_number':1895,'multiline':False]['text':' AddOrChangeProperty.','line_number':1896,'multiline':False]['text':' At this point we're updating a property: See SetExistingProperty.','line_number':1905,'multiline':False]['text':' We don't know exactly what this object looks like, hit the slowpath.','line_number':1912,'multiline':False]['text':'** [[HasProperty]] *******************************************************','line_number':1919,'multiline':True]['text':' ES6 draft rev31 9.1.7.1 OrdinaryHasProperty','line_number':1921,'multiline':False]['text':' This loop isn't explicit in the spec algorithm. See the comment on step','line_number':1927,'multiline':False]['text':' 7.a. below.','line_number':1928,'multiline':False]['text':' Steps 2-3.','line_number':1930,'multiline':False]['text':' Step 4.','line_number':1935,'multiline':False]['text':' Step 5-6.','line_number':1941,'multiline':False]['text':' Step 8.','line_number':1944,'multiline':False]['text':' As a side-effect of NativeLookupOwnPropertyInline, we may determine that','line_number':1945,'multiline':False]['text':' a property is not found and the proto chain should not be searched. This','line_number':1946,'multiline':False]['text':' can occur for:','line_number':1947,'multiline':False]['text':'  - Out-of-range numeric properties of a TypedArrayObject','line_number':1948,'multiline':False]['text':'  - Recursive resolve hooks (which is expected when they try to set the','line_number':1949,'multiline':False]['text':'    property being resolved).','line_number':1950,'multiline':False]['text':' Step 7.a. If the prototype is also native, this step is a','line_number':1956,'multiline':False]['text':' recursive tail call, and we don't need to go through all the','line_number':1957,'multiline':False]['text':' plumbing of HasProperty; the top of the loop is where','line_number':1958,'multiline':False]['text':' we're going to end up anyway. But if pobj is non-native,','line_number':1959,'multiline':False]['text':' that optimization would be incorrect.','line_number':1960,'multiline':False]['text':'** [[GetOwnPropertyDescriptor]] ******************************************','line_number':1970,'multiline':True]['text':'** [[Get]] ***************************************************************','line_number':2002,'multiline':True]['text':'
 * Finish getting the property `receiver[id]` after looking at every object on
 * the prototype chain and not finding any such property.
 *
 * Per the spec, this should just set the result to `undefined` and call it a
 * day. However this function also runs when we're evaluating an
 * expression that's an Identifier (that is, an unqualified name lookup),
 * so we need to figure out if that's what's happening and throw
 * a ReferenceError if so.
 ','line_number':2081,'multiline':True]['text':' If we are doing a name lookup, this is a ReferenceError.','line_number':2096,'multiline':False]['text':' Otherwise, just return |undefined|.','line_number':2102,'multiline':False]['text':' The NoGC version of GetNonexistentProperty, present only to make types line','line_number':2106,'multiline':False]['text':' up.','line_number':2107,'multiline':False]['text':' When nameLookup is true, GetProperty implements ES6 rev 34 (2015 Feb','line_number':2123,'multiline':False]['text':' 20) 8.1.1.2.6 GetBindingValue, with step 3 (the call to HasProperty)','line_number':2124,'multiline':False]['text':' and step 6 (the call to Get) fused so that only a single lookup is','line_number':2125,'multiline':False]['text':' needed.','line_number':2126,'multiline':False]['text':'','line_number':2127,'multiline':False]['text':' If we get here, we've reached a non-native object. Fall back on the','line_number':2128,'multiline':False]['text':' algorithm as specified, with two separate lookups. (Note that we','line_number':2129,'multiline':False]['text':' throw ReferenceErrors regardless of strictness, technically a bug.)','line_number':2130,'multiline':False]['text':' Callers should have ensured that this object has a static prototype.','line_number':2161,'multiline':False]['text':' Indexed properties can not exist on the prototype chain.','line_number':2164,'multiline':False]['text':' Property not found, return directly.','line_number':2174,'multiline':False]['text':' This loop isn't explicit in the spec algorithm. See the comment on step','line_number':2193,'multiline':False]['text':' 4.d below.','line_number':2194,'multiline':False]['text':' Steps 2-3.','line_number':2196,'multiline':False]['text':' Steps 5-8. Special case for dense elements because','line_number':2202,'multiline':False]['text':' GetExistingProperty doesn't support those.','line_number':2203,'multiline':False]['text':' Steps 4.a-b.','line_number':2218,'multiline':False]['text':' Step 4.c. The spec algorithm simply returns undefined if proto is','line_number':2221,'multiline':False]['text':' null, but see the comment on GetNonexistentProperty.','line_number':2222,'multiline':False]['text':' Step 4.d. If the prototype is also native, this step is a','line_number':2227,'multiline':False]['text':' recursive tail call, and we don't need to go through all the','line_number':2228,'multiline':False]['text':' plumbing of JSObject::getGeneric; the top of the loop is where','line_number':2229,'multiline':False]['text':' we're going to end up anyway. But if pobj is non-native,','line_number':2230,'multiline':False]['text':' that optimization would be incorrect.','line_number':2231,'multiline':False]['text':' Manually unwrap 'with' environments to prevent looking up @@unscopables','line_number':2276,'multiline':False]['text':' twice.','line_number':2277,'multiline':False]['text':'','line_number':2278,'multiline':False]['text':' This is unfortunate because internally, the engine does not distinguish','line_number':2279,'multiline':False]['text':' HasProperty from HasBinding: both are implemented as a HasPropertyOp','line_number':2280,'multiline':False]['text':' hook on a WithEnvironmentObject.','line_number':2281,'multiline':False]['text':'','line_number':2282,'multiline':False]['text':' In the case of attempting to get the value of a binding already looked up','line_number':2283,'multiline':False]['text':' via JSOp::BindName, calling HasProperty on the WithEnvironmentObject is','line_number':2284,'multiline':False]['text':' equivalent to calling HasBinding a second time. This results in the','line_number':2285,'multiline':False]['text':' incorrect behavior of performing the @@unscopables check again.','line_number':2286,'multiline':False]['text':'** [[Set]] ***************************************************************','line_number':2296,'multiline':True]['text':'
 * Finish assignment to a shapeful data property of a native object obj. This
 * conforms to no standard and there is a lot of legacy baggage here.
 ','line_number':2342,'multiline':True]['text':' The common path. Standard data property.','line_number':2354,'multiline':False]['text':' See bug 1128681.','line_number':2360,'multiline':False]['text':'
 * When a [[Set]] operation finds no existing property with the given id
 * or finds a writable data property on the prototype chain, we end up here.
 * Finish the [[Set]] by defining a new property on receiver.
 *
 * This implements ES6 draft rev 28, 9.1.9 [[Set]] steps 5.b-f, but it
 * is really old code and there are a few barnacles.
 ','line_number':2365,'multiline':True]['text':' Step 5.b.','line_number':2376,'multiline':False]['text':' Steps 5.c-d.','line_number':2384,'multiline':False]['text':' Step 5.e.','line_number':2392,'multiline':False]['text':' Step 5.e.i.','line_number':2394,'multiline':False]['text':' Step 5.e.ii.','line_number':2399,'multiline':False]['text':' Purge the property cache of now-shadowed id in receiver's environment','line_number':2406,'multiline':False]['text':' chain.','line_number':2407,'multiline':False]['text':' Steps 5.e.iii-iv. and 5.f.i. Define the new data property.','line_number':2412,'multiline':False]['text':' When setting |id| for |receiver| and |obj| has no property for id, continue','line_number':2425,'multiline':False]['text':' the search up the prototype chain.','line_number':2426,'multiline':False]['text':'
 * Implement "the rest of" assignment to a property when no property
 * receiver[id] was found anywhere on the prototype chain.
 *
 * FIXME: This should be updated to follow ES6 draft rev 28, section 9.1.9,
 * steps 4.d.i and 5.
 ','line_number':2440,'multiline':True]['text':' Pure optimization for the common case. There's no point performing the','line_number':2459,'multiline':False]['text':' lookup in step 5.c again, as our caller just did it for us.','line_number':2460,'multiline':False]['text':' Ensure that a custom GetOwnPropertyOp, if present, doesn't','line_number':2462,'multiline':False]['text':' introduce additional properties which weren't previously found by','line_number':2463,'multiline':False]['text':' LookupOwnProperty.','line_number':2464,'multiline':False]['text':' Step 5.e. Define the new data property.','line_number':2475,'multiline':False]['text':' Purge the property cache of now-shadowed id in receiver's environment','line_number':2477,'multiline':False]['text':' chain.','line_number':2478,'multiline':False]['text':' Set an existing own property obj[index] that's a dense element.','line_number':2498,'multiline':False]['text':'
 * Finish the assignment `receiver[id] = v` when an existing property (shape)
 * has been found on a native object (pobj). This implements ES6 draft rev 32
 * (2015 Feb 2) 9.1.9 steps 5 and 6.
 *
 * It is necessary to pass both id and shape because shape could be an implicit
 * dense or typed array element (i.e. not actually a pointer to a Shape).
 ','line_number':2509,'multiline':True]['text':' Step 5 for dense elements.','line_number':2521,'multiline':False]['text':' Step 5.a.','line_number':2523,'multiline':False]['text':' Pure optimization for the common case:','line_number':2528,'multiline':False]['text':' Steps 5.b-f.','line_number':2539,'multiline':False]['text':' Step 5 for all other properties.','line_number':2543,'multiline':False]['text':' Step 5.a.','line_number':2546,'multiline':False]['text':' steps 5.c-f.','line_number':2551,'multiline':False]['text':' Pure optimization for the common case. There's no point performing','line_number':2553,'multiline':False]['text':' the lookup in step 5.c again, as our caller just did it for us. The','line_number':2554,'multiline':False]['text':' result is |shapeProp|.','line_number':2555,'multiline':False]['text':' Steps 5.e.i-ii.','line_number':2557,'multiline':False]['text':' Shadow pobj[id] by defining a new data property receiver[id].','line_number':2561,'multiline':False]['text':' Delegate everything to SetPropertyByDefining.','line_number':2562,'multiline':False]['text':' Steps 6-11.','line_number':2566,'multiline':False]['text':' Step numbers below reference ES6 rev 27 9.1.9, the [[Set]] internal','line_number':2586,'multiline':False]['text':' method for ordinary objects. We substitute our own names for these names','line_number':2587,'multiline':False]['text':' used in the spec: O -> pobj, P -> id, ownDesc -> shape.','line_number':2588,'multiline':False]['text':' This loop isn't explicit in the spec algorithm. See the comment on step','line_number':2592,'multiline':False]['text':' 4.c.i below. (There's a very similar loop in the NativeGetProperty','line_number':2593,'multiline':False]['text':' implementation, but unfortunately not similar enough to common up.)','line_number':2594,'multiline':False]['text':'','line_number':2595,'multiline':False]['text':' We're intentionally not spec-compliant for TypedArrays:','line_number':2596,'multiline':False]['text':' When |pobj| is a TypedArray and |id| is a TypedArray index, we should','line_number':2597,'multiline':False]['text':' ignore |receiver| and instead always try to set the property on |pobj|.','line_number':2598,'multiline':False]['text':' Bug 1502889 showed that this behavior isn't web-compatible. This issue is','line_number':2599,'multiline':False]['text':' also reported at <https://github.com/tc39/ecma262/issues/1541>.','line_number':2600,'multiline':False]['text':' Steps 2-3.','line_number':2602,'multiline':False]['text':' Steps 5-6.','line_number':2608,'multiline':False]['text':' Steps 4.a-b.','line_number':2612,'multiline':False]['text':' As a side-effect of NativeLookupOwnPropertyInline, we may determine that','line_number':2613,'multiline':False]['text':' a property is not found and the proto chain should not be searched. This','line_number':2614,'multiline':False]['text':' can occur for:','line_number':2615,'multiline':False]['text':'  - Out-of-range numeric properties of a TypedArrayObject','line_number':2616,'multiline':False]['text':'  - Recursive resolve hooks (which is expected when they try to set the','line_number':2617,'multiline':False]['text':'    property being resolved).','line_number':2618,'multiline':False]['text':' Step 4.d.i (and step 5).','line_number':2621,'multiline':False]['text':' Step 4.c.i. If the prototype is also native, this step is a','line_number':2626,'multiline':False]['text':' recursive tail call, and we don't need to go through all the','line_number':2627,'multiline':False]['text':' plumbing of SetProperty; the top of the loop is where we're going to','line_number':2628,'multiline':False]['text':' end up anyway. But if pobj is non-native, that optimization would be','line_number':2629,'multiline':False]['text':' incorrect.','line_number':2630,'multiline':False]['text':' Unqualified assignments are not specified to go through [[Set]]','line_number':2632,'multiline':False]['text':' at all, but they do go through this function. So check for','line_number':2633,'multiline':False]['text':' unqualified assignment to a nonexistent global (a strict error).','line_number':2634,'multiline':False]['text':'** [[Delete]] ************************************************************','line_number':2675,'multiline':True]['text':' ES6 draft rev31 9.1.10 [[Delete]]','line_number':2692,'multiline':False]['text':' Steps 2-3.','line_number':2695,'multiline':False]['text':' Step 4.','line_number':2701,'multiline':False]['text':' If no property call the class's delProperty hook, passing succeeded','line_number':2703,'multiline':False]['text':' as the result parameter. This always succeeds when there is no hook.','line_number':2704,'multiline':False]['text':' Step 6. Non-configurable property.','line_number':2709,'multiline':False]['text':' Typed array elements are configurable, but can't be deleted.','line_number':2714,'multiline':False]['text':' Step 5.','line_number':2727,'multiline':False]['text':' Don't use the fast path if |from| may have extra indexed or lazy','line_number':2751,'multiline':False]['text':' properties.','line_number':2752,'multiline':False]['text':' Collect all enumerable data properties.','line_number':2759,'multiline':False]['text':' Don't use the fast path if |from| contains non-data properties.','line_number':2774,'multiline':False]['text':'','line_number':2775,'multiline':False]['text':' This enables two optimizations:','line_number':2776,'multiline':False]['text':' 1. We don't need to handle the case when accessors modify |from|.','line_number':2777,'multiline':False]['text':' 2. String and symbol properties can be added in one go.','line_number':2778,'multiline':False]['text':' If |target| contains no own properties, we can directly call','line_number':2790,'multiline':False]['text':' AddDataPropertyNonPrototype.','line_number':2791,'multiline':False]