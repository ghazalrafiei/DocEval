['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' GCC versions 4.6 and above define __ARM_PCS_VFP to denote a hard-float','line_number':19,'multiline':False]['text':' ABI target. The iOS toolchain doesn't define anything specific here,','line_number':20,'multiline':False]['text':' but iOS always supports VFP.','line_number':21,'multiline':False]['text':' These offsets are specific to nunboxing, and capture offsets into the','line_number':29,'multiline':False]['text':' components of a js::Value.','line_number':30,'multiline':False]['text':' How far forward/back can a jump go? Provide a generous buffer for thunks.','line_number':36,'multiline':False]['text':'//','line_number':39,'multiline':False]['text':' These offsets are related to bailouts.','line_number':40,'multiline':False]['text':'//','line_number':41,'multiline':False]['text':' Size of each bailout table entry. On arm, this is presently a single call','line_number':43,'multiline':False]['text':' (which is wrong!). The call clobbers lr.','line_number':44,'multiline':False]['text':' For now, I've dealt with this by ensuring that we never allocate to lr. It','line_number':45,'multiline':False]['text':' should probably be 8 bytes, a mov of an immediate into r12 (not allocated','line_number':46,'multiline':False]['text':' presently, or ever) followed by a branch to the apropriate code.','line_number':47,'multiline':False]['text':' Content spilled during bailouts.','line_number':80,'multiline':False]['text':' per','line_number':112,'multiline':False]['text':' https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html#//apple_ref/doc/uid/TP40009021-SW4','line_number':113,'multiline':False]['text':' = arguments','line_number':127,'multiline':False]['text':' = outReg','line_number':128,'multiline':False]['text':' = argBase','line_number':129,'multiline':False]['text':' r12 = ip = scratch','line_number':134,'multiline':False]['text':' Registers returned from a JS -> JS call.','line_number':137,'multiline':False]['text':' Registers returned from a JS -> C call.','line_number':140,'multiline':False]['text':' Used for double-size returns.','line_number':143,'multiline':False]['text':' Smallest integer type that can hold a register bitmask.','line_number':159,'multiline':False]['text':' Content spilled during bailouts.','line_number':235,'multiline':False]['text':' There are only 32 places that we can put values.','line_number':264,'multiline':False]['text':' clang-format off ','line_number':268,'multiline':True]['text':' ARM float registers overlap in a way that for 1 double registers, in the','line_number':269,'multiline':False]['text':' range d0-d15, we have 2 singles register in the range s0-s31. d16-d31','line_number':270,'multiline':False]['text':' have no single register aliases.  The aliasing rule state that d{n}','line_number':271,'multiline':False]['text':' aliases s{2n} and s{2n+1}, for n in [0 .. 15].','line_number':272,'multiline':False]['text':'','line_number':273,'multiline':False]['text':' The register set is used to represent either allocatable register or live','line_number':274,'multiline':False]['text':' registers. The register maps d0-d15 and s0-s31 to a single bit each. The','line_number':275,'multiline':False]['text':' registers d16-d31 are not used at the moment.','line_number':276,'multiline':False]['text':'','line_number':277,'multiline':False]['text':' uuuu uuuu uuuu uuuu dddd dddd dddd dddd ssss ssss ssss ssss ssss ssss ssss ssss','line_number':278,'multiline':False]['text':'                     ^                 ^ ^                                     ^','line_number':279,'multiline':False]['text':'                     '-- d15      d0 --' '-- s31                          s0 --'','line_number':280,'multiline':False]['text':'','line_number':281,'multiline':False]['text':' LiveSet are handled by adding the bit of each register without','line_number':282,'multiline':False]['text':' considering the aliases.','line_number':283,'multiline':False]['text':'','line_number':284,'multiline':False]['text':' AllocatableSet are handled by adding and removing the bit of each','line_number':285,'multiline':False]['text':' aligned-or-dominated-aliased registers.','line_number':286,'multiline':False]['text':'','line_number':287,'multiline':False]['text':'     ...0...00... : s{2n}, s{2n+1} and d{n} are not available','line_number':288,'multiline':False]['text':'     ...1...01... : s{2n} is available (*)','line_number':289,'multiline':False]['text':'     ...0...10... : s{2n+1} is available','line_number':290,'multiline':False]['text':'     ...1...11... : s{2n}, s{2n+1} and d{n} are available','line_number':291,'multiline':False]['text':'','line_number':292,'multiline':False]['text':' (*) Note that d{n} bit is set, but is not available because s{2n+1} bit','line_number':293,'multiline':False]['text':' is not set, which is required as d{n} dominates s{2n+1}. The d{n} bit is','line_number':294,'multiline':False]['text':' set, because s{2n} is aligned.','line_number':295,'multiline':False]['text':'','line_number':296,'multiline':False]['text':'        |        d{n}       |','line_number':297,'multiline':False]['text':'        | s{2n+1} |  s{2n}  |','line_number':298,'multiline':False]['text':'','line_number':299,'multiline':False]['text':' clang-format on ','line_number':300,'multiline':True]['text':' d15 is the ScratchFloatReg.','line_number':307,'multiline':False]['text':' s30 and s31 alias d15.','line_number':311,'multiline':False]['text':' d15 is the ARM scratch float register.','line_number':324,'multiline':False]['text':' s30 and s31 alias d15.','line_number':325,'multiline':False]['text':' What type of data is being stored in this register? UInt / Int are','line_number':337,'multiline':False]['text':' specifically for vcvt, where we need to know how the data is supposed to','line_number':338,'multiline':False]['text':' be converted.','line_number':339,'multiline':False]['text':' Bitfields below are all uint32_t to make sure MSVC packs them correctly.','line_number':346,'multiline':False]['text':' ARM doesn't have more than 32 registers of each type, so 5 bits should','line_number':348,'multiline':False]['text':' suffice.','line_number':349,'multiline':False]['text':' For serializing values.','line_number':401,'multiline':False]['text':' This should only be used in areas where we only have doubles and','line_number':418,'multiline':False]['text':' singles.','line_number':419,'multiline':False]['text':' s1 has 0 other aligned aliases, 1 total.','line_number':481,'multiline':False]['text':' s0 has 1 other aligned aliase, 2 total.','line_number':482,'multiline':False]['text':' |   d0    |','line_number':485,'multiline':False]['text':' | s0 | s1 |','line_number':486,'multiline':False]['text':' If we've stored s0 and s1 in memory, we also want to say that d0 is','line_number':487,'multiline':False]['text':' stored there, but it is only stored at the location where it is aligned','line_number':488,'multiline':False]['text':' e.g. at s0, not s1.','line_number':489,'multiline':False]['text':' This function is used to ensure that Register set can take all Single','line_number':505,'multiline':False]['text':' registers, even if we are taking a mix of either double or single','line_number':506,'multiline':False]['text':' registers.','line_number':507,'multiline':False]['text':'','line_number':508,'multiline':False]['text':'   s0.alignedOrDominatedAliasedSet() == s0 | d0.','line_number':509,'multiline':False]['text':'   s1.alignedOrDominatedAliasedSet() == s1.','line_number':510,'multiline':False]['text':'   d0.alignedOrDominatedAliasedSet() == s0 | s1 | d0.','line_number':511,'multiline':False]['text':'','line_number':512,'multiline':False]['text':' This way the Allocatable register set does not have to do any arithmetics','line_number':513,'multiline':False]['text':' to know if a register is available or not, as we have the following','line_number':514,'multiline':False]['text':' relations:','line_number':515,'multiline':False]['text':'','line_number':516,'multiline':False]['text':'  d0.alignedOrDominatedAliasedSet() ==','line_number':517,'multiline':False]['text':'      s0.alignedOrDominatedAliasedSet() | s1.alignedOrDominatedAliasedSet()','line_number':518,'multiline':False]['text':'','line_number':519,'multiline':False]['text':'  s0.alignedOrDominatedAliasedSet() & s1.alignedOrDominatedAliasedSet() == 0','line_number':520,'multiline':False]['text':'','line_number':521,'multiline':False]['text':' Single registers are not dominating any smaller registers, thus masking','line_number':587,'multiline':False]['text':' is enough to convert an allocatable set into a set of register list all','line_number':588,'multiline':False]['text':' single register available.','line_number':589,'multiline':False]['text':' clang-format off ','line_number':596,'multiline':True]['text':' An allocatable float register set is represented as follow:','line_number':597,'multiline':False]['text':'','line_number':598,'multiline':False]['text':' uuuu uuuu uuuu uuuu dddd dddd dddd dddd ssss ssss ssss ssss ssss ssss ssss ssss','line_number':599,'multiline':False]['text':'                     ^                 ^ ^                                     ^','line_number':600,'multiline':False]['text':'                     '-- d15      d0 --' '-- s31                          s0 --'','line_number':601,'multiline':False]['text':'','line_number':602,'multiline':False]['text':'     ...0...00... : s{2n}, s{2n+1} and d{n} are not available','line_number':603,'multiline':False]['text':'     ...1...01... : s{2n} is available','line_number':604,'multiline':False]['text':'     ...0...10... : s{2n+1} is available','line_number':605,'multiline':False]['text':'     ...1...11... : s{2n}, s{2n+1} and d{n} are available','line_number':606,'multiline':False]['text':'','line_number':607,'multiline':False]['text':' The goal of this function is to return the set of double registers which','line_number':608,'multiline':False]['text':' are available as an indexable bit set. This implies that iff a double bit','line_number':609,'multiline':False]['text':' is set in the returned set, then the register is available.','line_number':610,'multiline':False]['text':'','line_number':611,'multiline':False]['text':' To do so, this functions converts the 32 bits set of single registers','line_number':612,'multiline':False]['text':' into a 16 bits set of equivalent double registers. Then, we mask out','line_number':613,'multiline':False]['text':' double registers which do not have all the single register that compose','line_number':614,'multiline':False]['text':' them. As d{n} bit is set when s{2n} is available, we only need to take','line_number':615,'multiline':False]['text':' s{2n+1} into account.','line_number':616,'multiline':False]['text':' clang-format on ','line_number':617,'multiline':True]['text':' Convert  s7s6s5s4 s3s2s1s0  into  s7s5s3s1, for all s0-s31.','line_number':619,'multiline':False]['text':' Filter s{2n+1} registers.','line_number':622,'multiline':False]['text':' Group adjacent bits as follow:','line_number':623,'multiline':False]['text':'     0.0.s3.s1 == ((0.s3.0.s1) >> 1 | (0.s3.0.s1)) & 0b0011;','line_number':624,'multiline':False]['text':' 0a0b --> 00ab','line_number':625,'multiline':False]['text':' 00ab00cd --> 0000abcd','line_number':626,'multiline':False]['text':' Move the s7s5s3s1 to the aliased double positions.','line_number':629,'multiline':False]['text':' Note: We currently do not use any representation for d16-d31.','line_number':632,'multiline':False]['text':' Filter out any double register which are not allocatable due to','line_number':636,'multiline':False]['text':' non-aligned dominated single registers.','line_number':637,'multiline':False]['text':' The only floating point register set that we work with are the VFP Registers.','line_number':641,'multiline':False]['text':' {LD,ST}REX{B,H,D}','line_number':647,'multiline':False]['text':' DMB, DSB, and ISB','line_number':648,'multiline':False]['text':' Not part of the HWCAP flag, but we need to know these and these bits are not','line_number':657,'multiline':False]['text':' used. Define these here so that their use can be inlined by the simulator.','line_number':658,'multiline':False]['text':' A bit to flag when signaled alignment faults are to be fixed up.','line_number':660,'multiline':False]['text':' A bit to flag when the flags are uninitialized, so they can be atomically','line_number':663,'multiline':False]['text':' set.','line_number':664,'multiline':False]['text':' A bit to flag when alignment faults are enabled and signal.','line_number':667,'multiline':False]['text':' A bit to flag the use of the hardfp ABI.','line_number':670,'multiline':False]['text':' A bit to flag the use of the ARMv7 arch, otherwise ARMv6.','line_number':673,'multiline':False]['text':' Top three bits are reserved, do not use them.','line_number':676,'multiline':False]['text':' Returns true when cpu alignment faults are enabled and signaled, and thus we','line_number':678,'multiline':False]['text':' should ensure loads and stores are aligned.','line_number':679,'multiline':False]['text':' Returns true when cpu alignment faults will be fixed up by the','line_number':686,'multiline':False]['text':' "operating system", which functionality we will emulate.','line_number':687,'multiline':False]['text':' Arm/D32 has double registers that can NOT be treated as float32 and this','line_number':694,'multiline':False]['text':' requires some dances in lowering.','line_number':695,'multiline':False]['text':' On ARM, Dn aliases both S2n and S2n+1, so if you need to convert a float32 to','line_number':698,'multiline':False]['text':' a double as a temporary, you need a temporary double register.','line_number':699,'multiline':False]['text':' InitARMFlags is called from the JitContext constructor to read the hardware','line_number':702,'multiline':False]['text':' flags.  The call is a no-op after the first call, or if the JS shell has','line_number':703,'multiline':False]['text':' already set the flags (it has a command line switch for this, see','line_number':704,'multiline':False]['text':' ParseARMHwCapFlags).','line_number':705,'multiline':False]['text':'','line_number':706,'multiline':False]['text':' If the environment variable ARMHWCAP is set then the flags are read from it','line_number':707,'multiline':False]['text':' instead; see ParseARMHwCapFlags.','line_number':708,'multiline':False]['text':' Parse a string denoting ARM hardware flags and unconditionally set the flags.','line_number':711,'multiline':False]['text':' Doing this after the flags have been observed is likely to cause problems, as','line_number':712,'multiline':False]['text':' code is allowed to assume that the flags are stable.','line_number':713,'multiline':False]['text':' Retrive the ARM hardware flags at a bitmask.  They must have been set.','line_number':716,'multiline':False]['text':' If the simulator is used then the ABI choice is dynamic. Otherwise the ABI is','line_number':719,'multiline':False]['text':' static and useHardFpABI is inlined so that unused branches can be optimized','line_number':720,'multiline':False]['text':' away.','line_number':721,'multiline':False]['text':' In order to handle SoftFp ABI calls, we need to be able to express that we','line_number':734,'multiline':False]['text':' have ABIArg which are represented by pair of general purpose registers.','line_number':735,'multiline':False]['text':' namespace jit','line_number':738,'multiline':False]['text':' namespace js','line_number':739,'multiline':False]['text':' jit_arm_Architecture_arm_h ','line_number':741,'multiline':True]