['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' The ABIArgGenerator is used for making system ABI calls and for inter-wasm','line_number':33,'multiline':False]['text':' calls. The system ABI can either be SoftFp or HardFp, and inter-wasm calls','line_number':34,'multiline':False]['text':' are always HardFp calls. The initialization defaults to HardFp, and the ABI','line_number':35,'multiline':False]['text':' choice is made before any system ABI calls with the method "setUseHardFp".','line_number':36,'multiline':False]['text':' See the "Parameter Passing" section of the "Procedure Call Standard for the','line_number':44,'multiline':False]['text':' ARM Architecture" documentation.','line_number':45,'multiline':False]['text':' Make sure to use an even register index. Increase to next even number','line_number':61,'multiline':False]['text':' when odd.','line_number':62,'multiline':False]['text':' Align the stack on 8 bytes.','line_number':65,'multiline':False]['text':' Make sure to use an even register index. Increase to next even number','line_number':86,'multiline':False]['text':' when odd.','line_number':87,'multiline':False]['text':' Align the stack on 8 bytes.','line_number':90,'multiline':False]['text':' Make sure to use an even register index. Increase to next even number','line_number':123,'multiline':False]['text':' when odd.','line_number':124,'multiline':False]['text':' Align the stack on 8 bytes.','line_number':127,'multiline':False]['text':' Double register are composed of 2 float registers, thus we have to','line_number':148,'multiline':False]['text':' skip any float register which cannot be used in a pair of float','line_number':149,'multiline':False]['text':' registers in which a double value can be stored.','line_number':150,'multiline':False]['text':' Encode a standard register when it is being used as src1, the dest, and an','line_number':188,'multiline':False]['text':' extra register. These should never be called with an InvalidReg.','line_number':189,'multiline':False]['text':' Encode a standard register when it is being used as src1, the dest, and an','line_number':210,'multiline':False]['text':' extra register. For these, an InvalidReg is used to indicate a optional','line_number':211,'multiline':False]['text':' register that has been omitted.','line_number':212,'multiline':False]['text':' Bits 15,14,13,12, 22.','line_number':260,'multiline':False]['text':' Bits 19,18,17,16, 7.','line_number':269,'multiline':False]['text':' Bits 5, 3,2,1,0.','line_number':278,'multiline':False]['text':' VFP register treated as an integer, NOT a gpr.','line_number':292,'multiline':False]['text':' This buffer uses fixed-size chunks so there's no point in reserving','line_number':507,'multiline':False]['text':' now vs. on-demand.','line_number':508,'multiline':False]['text':' For now, specialize to the one use case. As long as wasm::Bytes is a','line_number':513,'multiline':False]['text':' Vector, not a linked-list of chunks, there's not much we can do other','line_number':514,'multiline':False]['text':' than copy.','line_number':515,'multiline':False]['text':' Offset in bytes.','line_number':531,'multiline':False]['text':' See if we have a simple case, b #offset.','line_number':553,'multiline':False]['text':' See if we have the complex case:','line_number':561,'multiline':False]['text':'  movw r_temp, #imm1','line_number':562,'multiline':False]['text':'  movt r_temp, #imm2','line_number':563,'multiline':False]['text':'  bx r_temp','line_number':564,'multiline':False]['text':' OR','line_number':565,'multiline':False]['text':'  movw r_temp, #imm1','line_number':566,'multiline':False]['text':'  movt r_temp, #imm2','line_number':567,'multiline':False]['text':'  str pc, [sp]','line_number':568,'multiline':False]['text':'  bx r_temp','line_number':569,'multiline':False]['text':' Extract both the temp register and the bottom immediate.','line_number':575,'multiline':False]['text':' Extract the top part of the immediate.','line_number':580,'multiline':False]['text':' Make sure they are being loaded into the same register.','line_number':586,'multiline':False]['text':' Make sure we're branching to the same register.','line_number':589,'multiline':False]['text':' A toggled call sometimes has a NOP instead of a branch for the third','line_number':591,'multiline':False]['text':' instruction. No way to assert that it's valid in that situation.','line_number':592,'multiline':False]['text':' See if we have the complex case:','line_number':633,'multiline':False]['text':'  movw r_temp, #imm1','line_number':634,'multiline':False]['text':'  movt r_temp, #imm2','line_number':635,'multiline':False]['text':' Extract both the temp register and the bottom immediate.','line_number':641,'multiline':False]['text':' Extract the top part of the immediate.','line_number':646,'multiline':False]['text':' Make sure they are being loaded into the same register.','line_number':650,'multiline':False]['text':' No barrier needed since these are constants.','line_number':698,'multiline':False]['text':' static ','line_number':712,'multiline':True]['text':' In the ideal case, we are looking for a number that (in binary) looks','line_number':805,'multiline':False]['text':' like:','line_number':806,'multiline':False]['text':'   0b((00)*)n_1((00)*)n_2((00)*)','line_number':807,'multiline':False]['text':'      left  n1   mid  n2','line_number':808,'multiline':False]['text':'   where both n_1 and n_2 fit into 8 bits.','line_number':809,'multiline':False]['text':' Since this is being done with rotates, we also need to handle the case','line_number':810,'multiline':False]['text':' that one of these numbers is in fact split between the left and right','line_number':811,'multiline':False]['text':' sides, in which case the constant will look like:','line_number':812,'multiline':False]['text':'   0bn_1a((00)*)n_2((00)*)n_1b','line_number':813,'multiline':False]['text':'     n1a  mid  n2   rgh    n1b','line_number':814,'multiline':False]['text':' Also remember, values are rotated by multiples of two, and left, mid or','line_number':815,'multiline':False]['text':' right can have length zero.','line_number':816,'multiline':False]['text':' Not technically needed: this case only happens if we can encode as a','line_number':821,'multiline':False]['text':' single imm8m. There is a perfectly reasonable encoding in this case, but','line_number':822,'multiline':False]['text':' we shouldn't encourage people to do things like this.','line_number':823,'multiline':False]['text':' We hit the easy case, no wraparound.','line_number':833,'multiline':False]['text':' Note: a single constant *may* look like this.','line_number':834,'multiline':False]['text':' This assert does not always hold, in fact, this would lead to','line_number':840,'multiline':False]['text':' some incredibly subtle bugs.','line_number':841,'multiline':False]['text':' assert((imm & 0xff) == no_n1);','line_number':842,'multiline':False]['text':' Either it wraps, or it does not fit. If we initially chopped off more','line_number':854,'multiline':False]['text':' than 8 bits, then it won't fit.','line_number':855,'multiline':False]['text':' All remaining set bits *must* fit into the lower 8 bits.','line_number':861,'multiline':False]['text':' The right == 8 case should be handled by the previous case.','line_number':862,'multiline':False]['text':' Make sure the initial bits that we removed for no_n1 fit into the','line_number':867,'multiline':False]['text':' 8-(32-right) leftmost bits.','line_number':868,'multiline':False]['text':' BUT we may have removed more bits than we needed to for no_n1','line_number':870,'multiline':False]['text':' 0x04104001 e.g. we can encode 0x104 with a single op, then 0x04000001','line_number':871,'multiline':False]['text':' with a second, but we try to encode 0x0410000 and find that we need a','line_number':872,'multiline':False]['text':' second op for 0x4000, and 0x1 cannot be included in the encoding of','line_number':873,'multiline':False]['text':' 0x04100000.','line_number':874,'multiline':False]['text':' Now assemble all of this information into a two coherent constants it is','line_number':883,'multiline':False]['text':' a rotate right from the lower 8 bits.','line_number':884,'multiline':False]['text':' left + 8 + mid is the position of the leftmost bit of n_2.','line_number':888,'multiline':False]['text':' We needed to rotate 0x000000ab right by 8 in order to get 0xab000000,','line_number':889,'multiline':False]['text':' then shift again by the leftmost bit in order to get the constant that we','line_number':890,'multiline':False]['text':' care about.','line_number':891,'multiline':False]['text':' Find an alternate ALUOp to get the job done, and use a different imm.','line_number':902,'multiline':False]['text':' orr has orn on thumb2 only.','line_number':934,'multiline':False]['text':' Some instructions can't be processed as two separate instructions such as','line_number':941,'multiline':False]['text':' and, and possibly add (when we're setting ccodes). There is also some','line_number':942,'multiline':False]['text':' hilarity with *reading* condition codes. For example, adc dest, src1,','line_number':943,'multiline':False]['text':' 0xfff; (add with carry) can be split up into adc dest, src1, 0xf00; add','line_number':944,'multiline':False]['text':' dest, dest, 0xff, since "reading" the condition code increments the','line_number':945,'multiline':False]['text':' result by one conditionally, that only needs to be done on one of the two','line_number':946,'multiline':False]['text':' instructions.','line_number':947,'multiline':False]['text':' Even when we are setting condition codes, sometimes we can get away with','line_number':961,'multiline':False]['text':' splitting an operation into two. For example, if our immediate is','line_number':962,'multiline':False]['text':' 0x00ff00ff, and the operation is eors we can split this in half, since x','line_number':963,'multiline':False]['text':' ^ 0x00ff0000 ^ 0x000000ff should set all of its condition codes exactly','line_number':964,'multiline':False]['text':' the same as x ^ 0x00ff00ff. However, if the operation were adds, we','line_number':965,'multiline':False]['text':' cannot split this in half. If the source on the add is 0xfff00ff0, the','line_number':966,'multiline':False]['text':' result sholud be 0xef10ef, but do we set the overflow bit or not?','line_number':967,'multiline':False]['text':' Depending on which half is performed first (0x00ff0000 or 0x000000ff) the','line_number':968,'multiline':False]['text':' V bit will be set differently, and *not* updating the V bit would be','line_number':969,'multiline':False]['text':' wrong. Theoretically, the following should work:','line_number':970,'multiline':False]['text':'  adds r0, r1, 0x00ff0000;','line_number':971,'multiline':False]['text':'  addsvs r0, r1, 0x000000ff;','line_number':972,'multiline':False]['text':'  addvc r0, r1, 0x000000ff;','line_number':973,'multiline':False]['text':' But this is 3 instructions, and at that point, we might as well use','line_number':974,'multiline':False]['text':' something else.','line_number':975,'multiline':False]['text':' All of the compare operations are dest-less variants of a standard','line_number':987,'multiline':False]['text':' operation. Given the dest-less variant, return the dest-ful variant.','line_number':988,'multiline':False]['text':' static ','line_number':1047,'multiline':True]['text':' TODO: It is probably worthwhile to verify that src is actually a branch.','line_number':1061,'multiline':False]['text':' NOTE: This does not explicitly shift the offset of the destination left by','line_number':1062,'multiline':False]['text':' 2, since it is indexing into an array of instruction sized objects.','line_number':1063,'multiline':False]['text':' VFPRegister implementation','line_number':1071,'multiline':False]['text':' There are no corresponding float registers for d16-d31.','line_number':1083,'multiline':False]['text':' There are no corresponding float registers for d16-d31.','line_number':1099,'multiline':False]['text':' There are no corresponding float registers for d16-d31.','line_number':1110,'multiline':False]['text':' Size of the instruction stream, in bytes. Including pools. This function','line_number':1124,'multiline':False]['text':' expects all pools that need to be placed have been placed. If they haven't','line_number':1125,'multiline':False]['text':' then we need to go an flush the pools :(','line_number':1126,'multiline':False]['text':' Size of the relocation table, in bytes.','line_number':1128,'multiline':False]['text':' Size of the data table, in bytes.','line_number':1136,'multiline':False]['text':' Allocate memory for a branch instruction, it will be overwritten','line_number':1141,'multiline':False]['text':' subsequently and should not be disassembled.','line_number':1142,'multiline':False]['text':' HLT with payload 0xBAAD','line_number':1154,'multiline':False]['text':' static ','line_number':1179,'multiline':True]['text':' static ','line_number':1185,'multiline':True]['text':' Logical operations.','line_number':1196,'multiline':False]['text':' Reverse byte operations.','line_number':1214,'multiline':False]['text':' Mathematical operations.','line_number':1228,'multiline':False]['text':' Test operations.','line_number':1254,'multiline':False]['text':' Sign extension operations.','line_number':1279,'multiline':False]['text':' Not quite ALU worthy, but these are useful none the less. These also have','line_number':1311,'multiline':False]['text':' the isue of these being formatted completly differently from the standard ALU','line_number':1312,'multiline':False]['text':' operations.','line_number':1313,'multiline':False]['text':' static ','line_number':1318,'multiline':True]['text':' static ','line_number':1328,'multiline':True]['text':' Data transfer instructions: ldr, str, ldrb, strb. Using an int to','line_number':1397,'multiline':False]['text':' differentiate between 8 bits and 32 bits is overkill, but meh.','line_number':1398,'multiline':False]['text':' static ','line_number':1413,'multiline':True]['text':' Set 0 to bogus, since that is the value most likely to be','line_number':1422,'multiline':False]['text':' accidentally left somewhere.','line_number':1423,'multiline':False]['text':' If this *was* a PoolBranch, but the branch has already been bound','line_number':1483,'multiline':False]['text':' then this isn't going to look like a real poolhintdata, but we still','line_number':1484,'multiline':False]['text':' want to lie about it so everyone knows it *used* to be a branch.','line_number':1485,'multiline':False]['text':' Most instructions cannot have a condition that is 0xf. Notable','line_number':1493,'multiline':False]['text':' exceptions are blx and the entire NEON instruction set. For the','line_number':1494,'multiline':False]['text':' purposes of pool loads, and possibly patched branches, the possible','line_number':1495,'multiline':False]['text':' instructions are ldr and b, neither of which can have a condition','line_number':1496,'multiline':False]['text':' code of 0xf.','line_number':1497,'multiline':False]['text':' Handles all of the other integral data transferring functions: ldrsb, ldrsh,','line_number':1507,'multiline':False]['text':' ldrd, etc. The size is given in bits.','line_number':1508,'multiline':False]['text':' 'case 32' doesn't need to be handled, it is handled by the default','line_number':1522,'multiline':False]['text':' ldr/str.','line_number':1523,'multiline':False]['text':' Or fix the disassembly','line_number':1553,'multiline':False]['text':' This is also used for instructions that might be resolved into branches,','line_number':1567,'multiline':False]['text':' or might not.  If dest==pc then it is effectively a branch.','line_number':1568,'multiline':False]['text':' static ','line_number':1579,'multiline':True]['text':' Insert floats into the double pool as they have the same limitations on','line_number':1594,'multiline':False]['text':' immediate offset. This wastes 4 bytes padding per float. An alternative','line_number':1595,'multiline':False]['text':' would be to have a separate pool for floats.','line_number':1596,'multiline':False]['text':' Pool callbacks stuff:','line_number':1603,'multiline':False]['text':' patchConstantPoolLoad takes the address of the instruction that wants to be','line_number':1612,'multiline':False]['text':' patched, and the address of the start of the constant pool, and figures','line_number':1613,'multiline':False]['text':' things out from there.','line_number':1614,'multiline':False]['text':' Either this used to be a poolBranch, and the label was already bound,','line_number':1629,'multiline':False]['text':' so it was replaced with a real branch, or this may happen in the','line_number':1630,'multiline':False]['text':' future. If this is going to happen in the future, then the actual','line_number':1631,'multiline':False]['text':' bits that are written here don't matter (except the condition code,','line_number':1632,'multiline':False]['text':' since that is always preserved across patchings) but if it does not','line_number':1633,'multiline':False]['text':' get bound later, then we want to make sure this is a load from the','line_number':1634,'multiline':False]['text':' pool entry (and the pool entry should be nullptr so it will crash).','line_number':1635,'multiline':False]['text':' Atomic instruction stuff:','line_number':1654,'multiline':False]['text':' True restriction on Cortex-A7 (RPi2)','line_number':1688,'multiline':False]['text':' True restriction on Cortex-A7 (RPi2)','line_number':1694,'multiline':False]['text':' True restriction on Cortex-A7 (RPi2)','line_number':1700,'multiline':False]['text':' Memory barrier stuff:','line_number':1706,'multiline':False]['text':' option == SY','line_number':1715,'multiline':False]['text':' DSB is "mcr 15, 0, r0, c7, c10, 4".','line_number':1718,'multiline':False]['text':' See eg https://bugs.kde.org/show_bug.cgi?id=228060.','line_number':1719,'multiline':False]['text':' ARMv7 manual, "VMSA CP15 c7 register summary".','line_number':1720,'multiline':False]['text':' Flagged as "legacy" starting with ARMv8, may be disabled on chip, see','line_number':1721,'multiline':False]['text':' ARMv8 manual E2.7.3 and G3.18.16.','line_number':1722,'multiline':False]['text':' DMB is "mcr 15, 0, r0, c7, c10, 5".','line_number':1726,'multiline':False]['text':' ARMv7 manual, "VMSA CP15 c7 register summary".','line_number':1727,'multiline':False]['text':' Flagged as "legacy" starting with ARMv8, may be disabled on chip, see','line_number':1728,'multiline':False]['text':' ARMv8 manual E2.7.3 and G3.18.16.','line_number':1729,'multiline':False]['text':' ISB is "mcr 15, 0, r0, c7, c5, 4".','line_number':1733,'multiline':False]['text':' ARMv7 manual, "VMSA CP15 c7 register summary".','line_number':1734,'multiline':False]['text':' Flagged as "legacy" starting with ARMv8, may be disabled on chip, see','line_number':1735,'multiline':False]['text':' ARMv8 manual E2.7.3 and G3.18.16.','line_number':1736,'multiline':False]['text':' NOP (see as_nop) on architectures where this instruction is not defined.','line_number':1741,'multiline':False]['text':'','line_number':1742,'multiline':False]['text':' https://developer.arm.com/-/media/developer/pdf/Cache_Speculation_Side-channels_22Feb18.pdf','line_number':1743,'multiline':False]['text':' CSDB A32: 1110_0011_0010_0000_1111_0000_0001_0100','line_number':1744,'multiline':False]['text':' Control flow stuff:','line_number':1748,'multiline':False]['text':' bx can *only* branch to a register, never to an immediate.','line_number':1750,'multiline':False]['text':' Branch can branch to an immediate *or* to a register.','line_number':1765,'multiline':False]['text':' Branches to immediates are pc relative, branches to registers are absolute.','line_number':1766,'multiline':False]['text':' Note only one instruction is emitted here, the NOP is overwritten.','line_number':1774,'multiline':False]['text':' JS_DISASM_ARM NOTE: Can't disassemble here, because numerous callers use','line_number':1814,'multiline':False]['text':' this to patchup old code.  Must disassemble in caller where it makes sense.','line_number':1815,'multiline':False]['text':' Not many callers.','line_number':1816,'multiline':False]['text':' blx can go to either an immediate or a register.','line_number':1821,'multiline':False]['text':' When blx'ing to a register, we change processor state depending on the low','line_number':1822,'multiline':False]['text':' bit of the register when blx'ing to an immediate, we *always* change','line_number':1823,'multiline':False]['text':' processor state.','line_number':1824,'multiline':False]['text':' bl can only branch to an pc-relative immediate offset','line_number':1830,'multiline':False]['text':' It cannot change the processor state.','line_number':1831,'multiline':False]['text':' Note only one instruction is emitted here, the NOP is overwritten.','line_number':1839,'multiline':False]['text':' See if the list was empty.','line_number':1861,'multiline':False]['text':' Hardcode the 'mask' field to 0b11 for now. It is bits 18 and 19, which','line_number':1890,'multiline':False]['text':' are the two high bits of the 'c' in this constant.','line_number':1891,'multiline':False]['text':' VFP instructions!','line_number':1896,'multiline':False]['text':' static ','line_number':1905,'multiline':True]['text':' Unityped variants: all registers hold the same (ieee754 single/double)','line_number':1912,'multiline':False]['text':' notably not included are vcvt; vmov vd, #imm; vmov rt, vn.','line_number':1913,'multiline':False]['text':' Make sure we believe that all of our operands are the same kind.','line_number':1916,'multiline':False]['text':' Specifically, a move between two same sized-registers.','line_number':1978,'multiline':False]['text':' Transfer between Core and VFP.','line_number':1983,'multiline':False]['text':' Unlike the next function, moving between the core registers and vfp registers','line_number':1985,'multiline':False]['text':' can't be *that* properly typed. Namely, since I don't want to munge the type','line_number':1986,'multiline':False]['text':' VFPRegister to also include core registers. Thus, the core and vfp registers','line_number':1987,'multiline':False]['text':' are passed in based on their type, and src/dest is determined by the','line_number':1988,'multiline':False]['text':' float2core.','line_number':1989,'multiline':False]['text':' Technically, this can be done with a vmov à la ARM ARM under vmov','line_number':1995,'multiline':False]['text':' however, that requires at least an extra bit saying if the operation','line_number':1996,'multiline':False]['text':' should be performed on the lower or upper half of the double. Moving','line_number':1997,'multiline':False]['text':' a single to/from 2N/2N+1 isn't equivalent, since there are 32 single','line_number':1998,'multiline':False]['text':' registers, and 32 double registers so there is no way to encode the','line_number':1999,'multiline':False]['text':' last 16 double registers.','line_number':2000,'multiline':False]['text':' If we are transferring a single half of the double then it must be','line_number':2003,'multiline':False]['text':' moving a VFP reg to a core reg.','line_number':2004,'multiline':False]['text':' We are doing a 64 bit transfer.','line_number':2016,'multiline':False]['text':' Use the default rounding mode, which rounds truncates.','line_number':2024,'multiline':False]['text':' Use whatever rounding mode the fpscr specifies.','line_number':2025,'multiline':False]['text':' Our encoding actually allows just the src and the dest (and their types) to','line_number':2034,'multiline':False]['text':' uniquely specify the encoding that we are going to use.','line_number':2035,'multiline':False]['text':' Unlike other cases, the source and dest types cannot be the same.','line_number':2038,'multiline':False]['text':' Doing a float -> float conversion.','line_number':2042,'multiline':False]['text':' At least one of the registers should be a float.','line_number':2049,'multiline':False]['text':' Transfer between VFP and memory.','line_number':2084,'multiline':False]['text':' vfp doesn't have a wb option ','line_number':2092,'multiline':True]['text':' static ','line_number':2097,'multiline':True]['text':' VFP's ldm/stm work differently from the standard arm ones. You can only','line_number':2104,'multiline':False]['text':' transfer a range.','line_number':2105,'multiline':False]['text':' also has update conditions ','line_number':2109,'multiline':True]['text':' vld1 (multiple single elements) with align=0, size=3, numregs=1','line_number':2124,'multiline':False]['text':' vld1 (single element to single lane) with index=0, size=2','line_number':2127,'multiline':False]['text':' vst1 (multiple single elements) with align=0, size=3, numregs=1','line_number':2136,'multiline':False]['text':' vst1 (single element from one lane) with index=0, size=2','line_number':2139,'multiline':False]['text':' Propagate the next link back to the caller, by constructing a new','line_number':2169,'multiline':False]['text':' BufferOffset into the space they provided.','line_number':2170,'multiline':False]['text':' Ensure we always bind the label. This matches what we do on','line_number':2180,'multiline':False]['text':' x86/x64 and silences the assert in ~Label.','line_number':2181,'multiline':False]['text':' If our caller didn't give us an explicit target to bind to then we','line_number':2188,'multiline':False]['text':' want to bind to the location of the next instruction.','line_number':2189,'multiline':False]['text':' The target is not bound but used. Prepend label's branch list','line_number':2222,'multiline':False]['text':' onto target's.','line_number':2223,'multiline':False]['text':' Find the head of the use chain for label.','line_number':2227,'multiline':False]['text':' Then patch the head of label's use chain to the tail of target's','line_number':2232,'multiline':False]['text':' use chain, prepending the entire use chain of target.','line_number':2233,'multiline':False]['text':' The target is unbound and unused. We can just take the head of','line_number':2246,'multiline':False]['text':' the list hanging off of label, and dump that into target.','line_number':2247,'multiline':False]['text':' This is a count of how many times a breakpoint instruction has been','line_number':2256,'multiline':False]['text':' generated. It is embedded into the instruction for debugging','line_number':2257,'multiline':False]['text':' purposes. Gdb will print "bkpt xxx" when you attempt to dissassemble a','line_number':2258,'multiline':False]['text':' breakpoint with the number xxx embedded into it. If this breakpoint is','line_number':2259,'multiline':False]['text':' being hit, then you can run (in gdb):','line_number':2260,'multiline':False]['text':'  >b dbg_break','line_number':2261,'multiline':False]['text':'  >b main','line_number':2262,'multiline':False]['text':'  >commands','line_number':2263,'multiline':False]['text':'  >set stopBKPT = xxx','line_number':2264,'multiline':False]['text':'  >c','line_number':2265,'multiline':False]['text':'  >end','line_number':2266,'multiline':False]['text':' which will set a breakpoint on the function dbg_break above set a','line_number':2267,'multiline':False]['text':' scripted breakpoint on main that will set the (otherwise unmodified)','line_number':2268,'multiline':False]['text':' value to the number of the breakpoint, so dbg_break will actuall be','line_number':2269,'multiline':False]['text':' called and finally, when you run the executable, execution will halt when','line_number':2270,'multiline':False]['text':' that breakpoint is generated.','line_number':2271,'multiline':False]['text':' Encoding of the permanently-undefined 'udf' instruction, with the imm16','line_number':2281,'multiline':False]['text':' set to 0.','line_number':2282,'multiline':False]['text':' The size should take into account the pool header.','line_number':2298,'multiline':False]['text':' The size is in units of Instruction (4 bytes), not byte.','line_number':2299,'multiline':False]['text':' Go through the usual rigmarole to get the size of the pool.','line_number':2348,'multiline':False]['text':' The size of an arbitrary 32-bit call in the instruction stream. On ARM this','line_number':2358,'multiline':False]['text':' sequence is |pc = ldr pc - 4; imm32| given that we never reach the imm32.','line_number':2359,'multiline':False]['text':' Overwrite whatever instruction used to be here with a call. Since the','line_number':2365,'multiline':False]['text':' destination is in the same function, it will be within range of the','line_number':2366,'multiline':False]['text':' 24 << 2 byte bl instruction.','line_number':2367,'multiline':False]['text':' Patch over actual instructions.','line_number':2386,'multiline':False]['text':' This just stomps over memory with 32 bits of raw data. Its purpose is to','line_number':2400,'multiline':False]['text':' overwrite the call of JITed code with 32 bits worth of an offset. This will','line_number':2401,'multiline':False]['text':' is only meant to function on code that has been invalidated, so it should be','line_number':2402,'multiline':False]['text':' totally safe. Since that instruction will never be executed again, a ICache','line_number':2403,'multiline':False]['text':' flush should not be necessary','line_number':2404,'multiline':False]['text':' Raw is going to be the return address.','line_number':2406,'multiline':False]['text':' Overwrite the 4 bytes before the return address, which will end up being','line_number':2408,'multiline':False]['text':' the call instruction.','line_number':2409,'multiline':False]['text':' See if the next instruction is a pool header.','line_number':2430,'multiline':False]['text':' See if the next instruction is a pool header.','line_number':2445,'multiline':False]['text':' In some special situations, it is necessary to insert a NOP into the','line_number':2452,'multiline':False]['text':' instruction stream that nobody knows about, since nobody should know','line_number':2453,'multiline':False]['text':' about it, make sure it gets skipped when Instruction::next() is called.','line_number':2454,'multiline':False]['text':' this generates a very specific nop, namely a branch to the next','line_number':2455,'multiline':False]['text':' instruction.','line_number':2456,'multiline':False]['text':' If the current instruction was automatically-inserted, skip past it.','line_number':2472,'multiline':False]['text':' Loop until an intentionally-placed instruction is found.','line_number':2475,'multiline':False]['text':' Don't skip a natural guard.','line_number':2478,'multiline':False]['text':' If this is a guard, and the next instruction is a header, always work','line_number':2493,'multiline':False]['text':' around the pool. If it isn't a guard, then start looking ahead.','line_number':2494,'multiline':False]['text':' Don't skip a natural guard.','line_number':2496,'multiline':False]['text':' Cases to be handled:','line_number':2509,'multiline':False]['text':' 1) no pools or branches in sight => return this+1','line_number':2510,'multiline':False]['text':' 2) branch to next instruction => return this+2, because a nop needed to be','line_number':2511,'multiline':False]['text':'    inserted into the stream.','line_number':2512,'multiline':False]['text':' 3) this+1 is an artificial guard for a pool => return first instruction','line_number':2513,'multiline':False]['text':'    after the pool','line_number':2514,'multiline':False]['text':' 4) this+1 is a natural guard => return the branch','line_number':2515,'multiline':False]['text':' 5) this is a branch, right before a pool => return first instruction after','line_number':2516,'multiline':False]['text':'    the pool','line_number':2517,'multiline':False]['text':' in assembly form:','line_number':2518,'multiline':False]['text':' 1) add r0, r0, r0 <= this','line_number':2519,'multiline':False]['text':'    add r1, r1, r1 <= returned value','line_number':2520,'multiline':False]['text':'    add r2, r2, r2','line_number':2521,'multiline':False]['text':'','line_number':2522,'multiline':False]['text':' 2) add r0, r0, r0 <= this','line_number':2523,'multiline':False]['text':'    b foo','line_number':2524,'multiline':False]['text':'    foo:','line_number':2525,'multiline':False]['text':'    add r2, r2, r2 <= returned value','line_number':2526,'multiline':False]['text':'','line_number':2527,'multiline':False]['text':' 3) add r0, r0, r0 <= this','line_number':2528,'multiline':False]['text':'    b after_pool;','line_number':2529,'multiline':False]['text':'    .word 0xffff0002  # bit 15 being 0 indicates that the branch was not','line_number':2530,'multiline':False]['text':'                      # requested by the assembler','line_number':2531,'multiline':False]['text':'    0xdeadbeef        # the 2 indicates that there is 1 pool entry, and the','line_number':2532,'multiline':False]['text':'                      # pool header','line_number':2533,'multiline':False]['text':'    add r4, r4, r4 <= returned value','line_number':2534,'multiline':False]['text':' 4) add r0, r0, r0 <= this','line_number':2535,'multiline':False]['text':'    b after_pool  <= returned value','line_number':2536,'multiline':False]['text':'    .word 0xffff8002  # bit 15 being 1 indicates that the branch was','line_number':2537,'multiline':False]['text':'                      # requested by the assembler','line_number':2538,'multiline':False]['text':'    0xdeadbeef','line_number':2539,'multiline':False]['text':'    add r4, r4, r4','line_number':2540,'multiline':False]['text':' 5) b after_pool  <= this','line_number':2541,'multiline':False]['text':'    .word 0xffff8002  # bit 15 has no bearing on the returned value','line_number':2542,'multiline':False]['text':'    0xdeadbeef','line_number':2543,'multiline':False]['text':'    add r4, r4, r4  <= returned value','line_number':2544,'multiline':False]['text':' If the current instruction is followed by a pool header,','line_number':2549,'multiline':False]['text':' move past the current instruction and the pool.','line_number':2550,'multiline':False]['text':' The next instruction is then known to not be a PoolHeader.','line_number':2556,'multiline':False]['text':' Zero bits 20-27, then set 24-27 to be correct for a branch.','line_number':2567,'multiline':False]['text':' 20-23 will be party of the B's immediate, and should be 0.','line_number':2568,'multiline':False]['text':' Ensure that this masking operation doesn't affect the offset of the','line_number':2578,'multiline':False]['text':' branch instruction when it gets toggled back.','line_number':2579,'multiline':False]['text':' Also make sure that the CMP is valid. Part of having a valid CMP is that','line_number':2582,'multiline':False]['text':' all of the bits describing the destination in most ALU instructions are','line_number':2583,'multiline':False]['text':' all unset (looks like it is encoding r0).','line_number':2584,'multiline':False]['text':' Zero out bits 20-27, then set them to be correct for a compare.','line_number':2587,'multiline':False]['text':' If it looks like the start of a movw/movt sequence, then make sure we','line_number':2596,'multiline':False]['text':' have all of it (and advance the iterator past the full sequence).','line_number':2597,'multiline':False]['text':' Nothing to do.','line_number':2606,'multiline':False]['text':' If it looks like the start of a movw/movt sequence, then make sure we','line_number':2624,'multiline':False]['text':' have all of it (and advance the iterator past the full sequence).','line_number':2625,'multiline':False]['text':' The iterator skips over any automatically-inserted instructions.','line_number':2636,'multiline':False]['text':' static ','line_number':2681,'multiline':True]['text':' The line is normally laid out like this:','line_number':2691,'multiline':False]['text':'','line_number':2692,'multiline':False]['text':' xxxxxxxx        ldr r, op   ; comment','line_number':2693,'multiline':False]['text':'','line_number':2694,'multiline':False]['text':' where xx...x is the instruction bit pattern.','line_number':2695,'multiline':False]['text':'','line_number':2696,'multiline':False]['text':' Labels are laid out by themselves to line up with the instructions above','line_number':2697,'multiline':False]['text':' and below:','line_number':2698,'multiline':False]['text':'','line_number':2699,'multiline':False]['text':'            nnnn:','line_number':2700,'multiline':False]['text':'','line_number':2701,'multiline':False]['text':' Branch targets are normally on the same line as the branch instruction,','line_number':2702,'multiline':False]['text':' but when they cannot be they will be on a line by themselves, indented','line_number':2703,'multiline':False]['text':' significantly:','line_number':2704,'multiline':False]['text':'','line_number':2705,'multiline':False]['text':'                     -> label','line_number':2706,'multiline':False]['text':' 10','line_number':2708,'multiline':False]['text':' 20','line_number':2709,'multiline':False]['text':' Labels are named as they are encountered by adding names to a','line_number':2714,'multiline':False]['text':' table, using the Label address as the key.  This is made tricky by','line_number':2715,'multiline':False]['text':' the (memory for) Label objects being reused, but reused label','line_number':2716,'multiline':False]['text':' objects are recognizable from being marked as not used or not','line_number':2717,'multiline':False]['text':' bound.  See spew_.refLabel().','line_number':2718,'multiline':False]['text':'','line_number':2719,'multiline':False]['text':' In a number of cases there is no information about the target, and','line_number':2720,'multiline':False]['text':' we just end up printing "patchable constant load to PC".  This is','line_number':2721,'multiline':False]['text':' true especially for jumps to bailout handlers (which have no','line_number':2722,'multiline':False]['text':' names).  See allocLiteralLoadEntry() and its callers.  In some cases','line_number':2723,'multiline':False]['text':' (loop back edges) some information about the intended target may be','line_number':2724,'multiline':False]['text':' propagated from higher levels, and if so it's printed here.','line_number':2725,'multiline':False]['text':' If a target label is known, always print that and do not attempt to','line_number':2737,'multiline':False]['text':' disassemble the branch operands, as they will often be encoding','line_number':2738,'multiline':False]['text':' metainformation (pointers for a chain of jump instructions), and','line_number':2739,'multiline':False]['text':' not actual branch targets.','line_number':2740,'multiline':False]['text':' The target information in the instruction is likely garbage, so remove','line_number':2763,'multiline':False]['text':' it. The target label will in any case be printed if we have it.','line_number':2764,'multiline':False]['text':'','line_number':2765,'multiline':False]['text':' The format of the instruction disassembly is [0-9a-f]{8}\s+\S+\s+.*,','line_number':2766,'multiline':False]['text':' where the \S+ string is the opcode.  Strip everything after the opcode,','line_number':2767,'multiline':False]['text':' and attach the label if we have it.','line_number':2768,'multiline':False]['text':' See patchConstantPoolLoad, above.  We assemble the instruction into a','line_number':2798,'multiline':False]['text':' buffer with a zero offset, as documentation, but the offset will be','line_number':2799,'multiline':False]['text':' patched later.','line_number':2800,'multiline':False]['text':' JS_DISASM_ARM','line_number':2833,'multiline':False]