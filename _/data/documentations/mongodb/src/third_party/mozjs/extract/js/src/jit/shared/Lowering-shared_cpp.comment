['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' lhs and rhs are used by the commutative operator.','line_number':26,'multiline':False]['text':' Ensure that if there is a constant, then it is in rhs.','line_number':30,'multiline':False]['text':' Since clobbering binary operations clobber the left operand, prefer a','line_number':38,'multiline':False]['text':' non-constant lhs operand with no further uses. To be fully precise, we','line_number':39,'multiline':False]['text':' should check whether this is the *last* use, but checking hasOneDefUse()','line_number':40,'multiline':False]['text':' is a decent approximation which doesn't require any extra analysis.','line_number':41,'multiline':False]['text':' If this is a reduction-style computation, such as','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':'   sum = 0;','line_number':56,'multiline':False]['text':'   for (...)','line_number':57,'multiline':False]['text':'      sum += ...;','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':' put the phi on the left to promote coalescing. This is fairly specific.','line_number':60,'multiline':False]['text':' We check ins->type() in addition to ins->isUnused() because','line_number':134,'multiline':False]['text':' EliminateDeadResumePointOperands may replace nodes with the constant','line_number':135,'multiline':False]['text':' MagicValue(JS_OPTIMIZED_OUT).','line_number':136,'multiline':False]['text':' Check that optimized out operands are in eliminable slots.','line_number':175,'multiline':False]['text':' Guards should never be eliminated.','line_number':192,'multiline':False]['text':' Snapshot operands other than constants should never be','line_number':195,'multiline':False]['text':' emitted-at-uses. Try-catch support depends on there being no','line_number':196,'multiline':False]['text':' code between an instruction and the LOsiPoint that follows it.','line_number':197,'multiline':False]['text':' The register allocation will fill these fields in with actual','line_number':200,'multiline':False]['text':' register/stack assignments. During code generation, we can restore','line_number':201,'multiline':False]['text':' interpreter state with the given information. Note that for','line_number':202,'multiline':False]['text':' constants, including known types, we record a dummy placeholder,','line_number':203,'multiline':False]['text':' since we can recover the same information, much cleaner, from MIR.','line_number':204,'multiline':False]['text':' Check that optimized out operands are in eliminable slots.','line_number':236,'multiline':False]['text':' Guards should never be eliminated.','line_number':249,'multiline':False]['text':' Snapshot operands other than constants should never be','line_number':252,'multiline':False]['text':' emitted-at-uses. Try-catch support depends on there being no','line_number':253,'multiline':False]['text':' code between an instruction and the LOsiPoint that follows it.','line_number':254,'multiline':False]['text':' assignSnapshot must be called before define/add, since','line_number':272,'multiline':False]['text':' it may add new instructions for emitted-at-use operands.','line_number':273,'multiline':False]['text':' Simple shared compare-and-select for all platforms that don't specialize','line_number':322,'multiline':False]['text':' further.  See emitWasmCompareAndSelect in CodeGenerator.cpp.','line_number':323,'multiline':False]['text':' Specialization analysis for SIMD operations.  This is still x86-centric but','line_number':344,'multiline':False]['text':' generalizes fairly easily to other architectures.','line_number':345,'multiline':False]['text':' Optimization of v8x16.shuffle.  The general byte shuffle+blend is very','line_number':347,'multiline':False]['text':' expensive (equivalent to at least a dozen instructions), and we want to avoid','line_number':348,'multiline':False]['text':' that if we can.  So look for special cases - there are many.','line_number':349,'multiline':False]['text':'','line_number':350,'multiline':False]['text':' The strategy is to sort the operation into one of three buckets depending','line_number':351,'multiline':False]['text':' on the shuffle pattern and inputs:','line_number':352,'multiline':False]['text':'','line_number':353,'multiline':False]['text':'  - single operand; shuffles on these values are rotations, reversals,','line_number':354,'multiline':False]['text':'    transpositions, and general permutations','line_number':355,'multiline':False]['text':'  - single-operand-with-interesting-constant (especially zero); shuffles on','line_number':356,'multiline':False]['text':'    these values are often byte shift or scatter operations','line_number':357,'multiline':False]['text':'  - dual operand; shuffles on these operations are blends, catenated','line_number':358,'multiline':False]['text':'    shifts, and (in the worst case) general shuffle+blends','line_number':359,'multiline':False]['text':'','line_number':360,'multiline':False]['text':' We're not trying to solve the general problem, only to lower reasonably','line_number':361,'multiline':False]['text':' expressed patterns that express common operations.  Producers that produce','line_number':362,'multiline':False]['text':' dense and convoluted patterns will end up with the general byte shuffle.','line_number':363,'multiline':False]['text':' Producers that produce simpler patterns that easily map to hardware will','line_number':364,'multiline':False]['text':' get faster code.','line_number':365,'multiline':False]['text':'','line_number':366,'multiline':False]['text':' In particular, these matchers do not try to combine transformations, so a','line_number':367,'multiline':False]['text':' shuffle that optimally is lowered to rotate + permute32x4 + rotate, say, is','line_number':368,'multiline':False]['text':' usually going to end up as a general byte shuffle.','line_number':369,'multiline':False]['text':' Reduce a 0..31 byte mask to a 0..15 word mask if possible and if so return','line_number':371,'multiline':False]['text':' true, updating *control.','line_number':372,'multiline':False]['text':' Reduce a 0..31 byte mask to a 0..7 dword mask if possible and if so return','line_number':386,'multiline':False]['text':' true, updating *control.','line_number':387,'multiline':False]['text':' Reduce a 0..31 byte mask to a 0..3 qword mask if possible and if so return','line_number':402,'multiline':False]['text':' true, updating *control.','line_number':403,'multiline':False]['text':' Skip across consecutive values in lanes starting at i, returning the index','line_number':420,'multiline':False]['text':' after the last element.  Lane values must be <= len-1 ("masked").','line_number':421,'multiline':False]['text':'','line_number':422,'multiline':False]['text':' Since every element is a 1-element run, the return value is never the same as','line_number':423,'multiline':False]['text':' the starting i.','line_number':424,'multiline':False]['text':' Skip across consecutive values in lanes starting at i, returning the index','line_number':438,'multiline':False]['text':' after the last element.  Lane values must be <= len*2-1 ("unmasked"); the','line_number':439,'multiline':False]['text':' values len-1 and len are not considered consecutive.','line_number':440,'multiline':False]['text':'','line_number':441,'multiline':False]['text':' Since every element is a 1-element run, the return value is never the same as','line_number':442,'multiline':False]['text':' the starting i.','line_number':443,'multiline':False]['text':' Skip lanes that equal v starting at i, returning the index just beyond the','line_number':462,'multiline':False]['text':' last of those.  There is no requirement that the initial lanes[i] == v.','line_number':463,'multiline':False]['text':' Mask lane values denoting rhs elements into lhs elements.','line_number':474,'multiline':False]['text':' Apply a transformation to each lane value.','line_number':483,'multiline':False]['text':' Recognize an identity permutation, assuming lanes is masked.','line_number':492,'multiline':False]['text':' Recognize part of an identity permutation starting at start, with','line_number':498,'multiline':False]['text':' the first value of the permutation expected to be bias.','line_number':499,'multiline':False]['text':' We can permute by dwords if the mask is reducible to a dword mask, and in','line_number':513,'multiline':False]['text':' this case a single PSHUFD is enough.','line_number':514,'multiline':False]['text':' Can we perform a byte rotate right?  We can use PALIGNR.  The shift count is','line_number':524,'multiline':False]['text':' just lanes[0], and *control is unchanged.','line_number':525,'multiline':False]['text':' Look for the end of the first run of consecutive bytes.','line_number':528,'multiline':False]['text':' First run must start at a value s.t. we have a rotate if all remaining','line_number':531,'multiline':False]['text':' bytes are a run.','line_number':532,'multiline':False]['text':' If we reached the end of the vector, we're done.','line_number':537,'multiline':False]['text':' Second run must start at source lane zero.','line_number':542,'multiline':False]['text':' Second run must end at the end of the lane vector.','line_number':547,'multiline':False]['text':' We can permute by words if the mask is reducible to a word mask.','line_number':551,'multiline':False]['text':' A single word lane is copied into all the other lanes: PSHUF*W + PSHUFD.','line_number':561,'multiline':False]['text':' A single byte lane is copied int all the other lanes: PUNPCK*BW + PSHUF*W +','line_number':575,'multiline':False]['text':' PSHUFD.','line_number':576,'multiline':False]['text':' Look for permutations of a single operand.','line_number':585,'multiline':False]['text':' Lane indices are input-agnostic for single-operand permutations.','line_number':587,'multiline':False]['text':' Get rid of no-ops immediately, so nobody else needs to check.','line_number':591,'multiline':False]['text':' Default control is the masked bytes.','line_number':596,'multiline':False]['text':' Analysis order matters here and is architecture-dependent or even','line_number':599,'multiline':False]['text':' microarchitecture-dependent: ideally the cheapest implementation first.','line_number':600,'multiline':False]['text':' The Intel manual says that the cost of a PSHUFB is about five other','line_number':601,'multiline':False]['text':' operations, so make that our cutoff.','line_number':602,'multiline':False]['text':'','line_number':603,'multiline':False]['text':' Word, dword, and qword reversals are handled optimally by general permutes.','line_number':604,'multiline':False]['text':'','line_number':605,'multiline':False]['text':' Byte reversals are probably best left to PSHUFB, no alternative rendition','line_number':606,'multiline':False]['text':' seems to reliably go below five instructions.  (Discuss.)','line_number':607,'multiline':False]['text':'','line_number':608,'multiline':False]['text':' Word swaps within doublewords and dword swaps within quadwords are handled','line_number':609,'multiline':False]['text':' optimally by general permutes.','line_number':610,'multiline':False]['text':'','line_number':611,'multiline':False]['text':' Dword and qword broadcasts are handled by dword permute.','line_number':612,'multiline':False]['text':' TODO: (From v8) Unzip and transpose generally have renditions that slightly','line_number':630,'multiline':False]['text':' beat a general permute (three or four instructions)','line_number':631,'multiline':False]['text':'','line_number':632,'multiline':False]['text':' TODO: (From MacroAssemblerX86Shared::ShuffleX4): MOVLHPS and MOVHLPS can be','line_number':633,'multiline':False]['text':' used when merging two values.','line_number':634,'multiline':False]['text':'','line_number':635,'multiline':False]['text':' TODO: Byteswap is MOV + PSLLW + PSRLW + POR, a small win over PSHUFB.','line_number':636,'multiline':False]['text':' The default operation is to permute bytes with the default control.','line_number':638,'multiline':False]['text':' Can we shift the bytes left or right by a constant?  A shift is a run of','line_number':642,'multiline':False]['text':' lanes from the rhs (which is zero) on one end and a run of values from the','line_number':643,'multiline':False]['text':' lhs on the other end.','line_number':644,'multiline':False]['text':' Represent all zero lanes by 16','line_number':648,'multiline':False]['text':' TODO: Optimization opportunity? A byte-blend-with-zero is just a CONST;','line_number':686,'multiline':False]['text':' PAND.  This may beat the general byte blend code below.','line_number':687,'multiline':False]['text':' Concat: if the result is the suffix (high bytes) of the rhs in front of a','line_number':691,'multiline':False]['text':' prefix (low bytes) of the lhs then this is PALIGNR; ditto if the operands are','line_number':692,'multiline':False]['text':' swapped.','line_number':693,'multiline':False]['text':' First run must end with 15 % 16','line_number':699,'multiline':False]['text':' Second run must start with 0 % 16','line_number':703,'multiline':False]['text':' The two runs must come from different inputs','line_number':707,'multiline':False]['text':' Must end at the left end','line_number':714,'multiline':False]['text':' If the suffix is from the lhs then swap the operands','line_number':719,'multiline':False]['text':' Blend words: if we pick words from both operands without a pattern but all','line_number':727,'multiline':False]['text':' the input words stay in their position then this is PBLENDW (immediate mask);','line_number':728,'multiline':False]['text':' this also handles all larger sizes on x64.','line_number':729,'multiline':False]['text':' Blend bytes: if we pick bytes ditto then this is a byte blend, which can be','line_number':747,'multiline':False]['text':' handled with a CONST, PAND, PANDNOT, and POR.','line_number':748,'multiline':False]['text':'','line_number':749,'multiline':False]['text':' TODO: Optimization opportunity? If we pick all but one lanes from one with at','line_number':750,'multiline':False]['text':' most one from the other then it could be a MOV + PEXRB + PINSRB (also if this','line_number':751,'multiline':False]['text':' element is not in its source location).','line_number':752,'multiline':False]['text':' Unpack/interleave:','line_number':776,'multiline':False]['text':'  - if we interleave the low (bytes/words/doublewords) of the inputs into','line_number':777,'multiline':False]['text':'    the output then this is UNPCKL*W (possibly with a swap of operands).','line_number':778,'multiline':False]['text':'  - if we interleave the high ditto then it is UNPCKH*W (ditto)','line_number':779,'multiline':False]['text':' Reorder the operands if that seems useful, notably, move a constant to the','line_number':874,'multiline':False]['text':' right hand side.  Rewrites the control to account for any move.','line_number':875,'multiline':False]['text':' Control may be updated, but only once we commit to an operation or when we','line_number':896,'multiline':False]['text':' swap operands.','line_number':897,'multiline':False]['text':' If only one of the inputs is used, determine which.','line_number':902,'multiline':False]['text':' Deal with one-ignored-input.','line_number':922,'multiline':False]['text':' Move constants to rhs.','line_number':930,'multiline':False]['text':' Deal with constant rhs.','line_number':933,'multiline':False]['text':' Two operands both of which are used.  If there's one constant operand it is','line_number':946,'multiline':False]['text':' now on the rhs.','line_number':947,'multiline':False]['text':' DEBUG','line_number':1036,'multiline':False]['text':' ENABLE_WASM_SIMD','line_number':1038,'multiline':False]