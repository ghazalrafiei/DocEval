['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::jit::JitActivation','line_number':20,'multiline':False]['text':' Last instruction may be an indirect jump so eagerly insert an undefined','line_number':417,'multiline':False]['text':' instruction byte to prevent processors from decoding data values into','line_number':418,'multiline':False]['text':' their pipelines. See Intel performance guides.','line_number':419,'multiline':False]['text':' SIMD memory values must be suitably aligned.','line_number':450,'multiline':False]['text':' Reserve space for exception information.','line_number':467,'multiline':False]['text':' Call the handler.','line_number':471,'multiline':False]['text':' Invalid kind.','line_number':503,'multiline':False]['text':' No exception handler. Load the error value, load the new stack pointer','line_number':505,'multiline':False]['text':' and return from the entry frame.','line_number':506,'multiline':False]['text':' If we found a catch handler, this must be a baseline frame. Restore state','line_number':512,'multiline':False]['text':' and jump to the catch block.','line_number':513,'multiline':False]['text':' If we found a finally block, this must be a baseline frame. Push','line_number':520,'multiline':False]['text':' two values expected by JSOp::Retsub: BooleanValue(true) and the','line_number':521,'multiline':False]['text':' exception.','line_number':522,'multiline':False]['text':' Only used in debug mode. Return BaselineFrame->returnValue() to the caller.','line_number':535,'multiline':False]['text':' If profiling is enabled, then update the lastProfilingFrame to refer to','line_number':544,'multiline':False]['text':' caller frame before returning.','line_number':545,'multiline':False]['text':' Test if profiler enabled.','line_number':548,'multiline':False]['text':' If we are bailing out to baseline to handle an exception, jump to the','line_number':559,'multiline':False]['text':' bailout tail stub. Load 1 (true) in ReturnReg to indicate success.','line_number':560,'multiline':False]['text':' If we are throwing and the innermost frame was a wasm frame, reset SP and','line_number':566,'multiline':False]['text':' FP; SP is pointing to the unwound return address to the wasm entry, so','line_number':567,'multiline':False]['text':' we can just ret().','line_number':568,'multiline':False]['text':' Found a wasm catch handler, restore state and jump to it.','line_number':574,'multiline':False]['text':' On windows, we cannot skip very far down the stack without touching the','line_number':606,'multiline':False]['text':' memory pages in-between.  This is a corner-case code for situations where','line_number':607,'multiline':False]['text':' the Ion frame data for a piece of code is very large.  To handle this','line_number':608,'multiline':False]['text':' special case, for frames over 4k in size we allocate memory on the stack','line_number':609,'multiline':False]['text':' incrementally, touching it as we go.','line_number':610,'multiline':False]['text':'','line_number':611,'multiline':False]['text':' When the amount is quite large, which it can be, we emit an actual loop,','line_number':612,'multiline':False]['text':' in order to keep the function prologue compact.  Compactness is a','line_number':613,'multiline':False]['text':' requirement for eg Wasm's CodeRange data structure, which can encode only','line_number':614,'multiline':False]['text':' 8-bit offsets.','line_number':615,'multiline':False]['text':' Save scratch register.','line_number':626,'multiline':False]['text':' Restore scratch register.','line_number':643,'multiline':False]['text':'{{{ check_macroassembler_style','line_number':649,'multiline':False]['text':' ===============================================================','line_number':650,'multiline':False]['text':' ABI function calls.','line_number':651,'multiline':False]['text':' sizeof(intptr_t) accounts for the saved stack pointer pushed by','line_number':667,'multiline':False]['text':' setupUnalignedABICall.','line_number':668,'multiline':False]['text':' Position all arguments.','line_number':680,'multiline':False]['text':' Calls to native functions in wasm pass through a thunk which already','line_number':699,'multiline':False]['text':' fixes up the return value for us.','line_number':700,'multiline':False]['text':' ===============================================================','line_number':740,'multiline':False]['text':' Move instructions','line_number':741,'multiline':False]['text':' Either one or both of the source registers could be the same as a','line_number':777,'multiline':False]['text':' destination register.','line_number':778,'multiline':False]['text':' If both are, this is just a swap of two registers.','line_number':781,'multiline':False]['text':' If only one is, copy that source first.','line_number':785,'multiline':False]['text':' ===============================================================','line_number':807,'multiline':False]['text':' Branch functions','line_number':808,'multiline':False]['text':' A temp register is required for x86.','line_number':820,'multiline':False]['text':' A temp register is required for x86.','line_number':829,'multiline':False]['text':' ========================================================================','line_number':897,'multiline':False]['text':' Memory access primitives.','line_number':898,'multiline':False]['text':' Store the type tag if needed.','line_number':908,'multiline':False]['text':' Store the payload.','line_number':913,'multiline':False]['text':' wasm specific methods, used in both the wasm baseline compiler and ion.','line_number':929,'multiline':False]['text':' vmovss does the right thing also for access.isZeroExtendSimd128Load()','line_number':963,'multiline':False]['text':' vmovsd does the right thing also for access.isZeroExtendSimd128Load()','line_number':993,'multiline':False]['text':' Atomic i64 load must use lock_cmpxchg8b.','line_number':1013,'multiline':False]['text':' Use wasmLoad()','line_number':1017,'multiline':False]['text':' Use wasmLoad()','line_number':1018,'multiline':False]['text':' Use wasmLoad()','line_number':1019,'multiline':False]['text':' Atomic i64 store must use lock_cmpxchg8b.','line_number':1132,'multiline':False]['text':' Store the high word first so as to hit guard-page-based OOB checks without','line_number':1137,'multiline':False]['text':' writing partial data.','line_number':1138,'multiline':False]['text':' In the event edx:eax matches what's in memory, ecx:ebx will be','line_number':1155,'multiline':False]['text':' stored.  The two pairs must therefore have the same values.','line_number':1156,'multiline':False]['text':' edx:eax has garbage initially, and that is the best we can do unless','line_number':1220,'multiline':False]['text':' we can guess with high probability what's in memory.','line_number':1221,'multiline':False]['text':' We don't have enough registers for all the operands on x86, so the rhs','line_number':1256,'multiline':False]['text':' operand is in memory.','line_number':1257,'multiline':False]['text':' Make sure input fits in uint64.','line_number':1406,'multiline':False]['text':' The OOL path computes the right values.','line_number':1417,'multiline':False]['text':' The OOL path just checks the input values.','line_number':1420,'multiline':False]['text':' Convert the double/float to uint64.','line_number':1426,'multiline':False]['text':' Load value into int64 register.','line_number':1430,'multiline':False]['text':' Make sure input fits in uint64.','line_number':1445,'multiline':False]['text':' The OOL path computes the right values.','line_number':1456,'multiline':False]['text':' The OOL path just checks the input values.','line_number':1459,'multiline':False]['text':' Convert the float to uint64.','line_number':1465,'multiline':False]['text':' Load value into int64 register.','line_number':1469,'multiline':False]['text':' ========================================================================','line_number':1478,'multiline':False]['text':' Primitive atomic operations.','line_number':1479,'multiline':False]['text':' ========================================================================','line_number':1540,'multiline':False]['text':' Convert floating point.','line_number':1541,'multiline':False]['text':' SUBPD needs SSE2, HADDPD needs SSE3.','line_number':1547,'multiline':False]['text':' Zero the dest register to break dependencies, see convertInt32ToDouble.','line_number':1551,'multiline':False]['text':' 2^64','line_number':1560,'multiline':False]['text':' Following operation uses entire 128-bit of dest XMM register.','line_number':1575,'multiline':False]['text':' Currently higher 64-bit is free when we have access to lower 64-bit.','line_number':1576,'multiline':False]['text':' Assume that src is represented as following:','line_number':1581,'multiline':False]['text':'   src      = 0x HHHHHHHH LLLLLLLL','line_number':1582,'multiline':False]['text':' Move src to dest (=dest128) and ScratchInt32x4Reg (=scratch):','line_number':1584,'multiline':False]['text':'   dest     = 0x 00000000 00000000  00000000 LLLLLLLL','line_number':1585,'multiline':False]['text':'   scratch  = 0x 00000000 00000000  00000000 HHHHHHHH','line_number':1586,'multiline':False]['text':' Unpack and interleave dest and scratch to dest:','line_number':1590,'multiline':False]['text':'   dest     = 0x 00000000 00000000  HHHHHHHH LLLLLLLL','line_number':1591,'multiline':False]['text':' Unpack and interleave dest and a constant C1 to dest:','line_number':1594,'multiline':False]['text':'   C1       = 0x 00000000 00000000  45300000 43300000','line_number':1595,'multiline':False]['text':'   dest     = 0x 45300000 HHHHHHHH  43300000 LLLLLLLL','line_number':1596,'multiline':False]['text':' here, each 64-bit part of dest represents following double:','line_number':1597,'multiline':False]['text':'   HI(dest) = 0x 1.00000HHHHHHHH * 2**84 == 2**84 + 0x HHHHHHHH 00000000','line_number':1598,'multiline':False]['text':'   LO(dest) = 0x 1.00000LLLLLLLL * 2**52 == 2**52 + 0x 00000000 LLLLLLLL','line_number':1599,'multiline':False]['text':' See convertUInt64ToDouble for the details.','line_number':1600,'multiline':False]['text':' Subtract a constant C2 from dest, for each 64-bit part:','line_number':1611,'multiline':False]['text':'   C2       = 0x 45300000 00000000  43300000 00000000','line_number':1612,'multiline':False]['text':' here, each 64-bit part of C2 represents following double:','line_number':1613,'multiline':False]['text':'   HI(C2)   = 0x 1.0000000000000 * 2**84 == 2**84','line_number':1614,'multiline':False]['text':'   LO(C2)   = 0x 1.0000000000000 * 2**52 == 2**52','line_number':1615,'multiline':False]['text':' after the operation each 64-bit part of dest represents following:','line_number':1616,'multiline':False]['text':'   HI(dest) = double(0x HHHHHHHH 00000000)','line_number':1617,'multiline':False]['text':'   LO(dest) = double(0x 00000000 LLLLLLLL)','line_number':1618,'multiline':False]['text':' Add HI(dest) and LO(dest) in double and store it into LO(dest),','line_number':1629,'multiline':False]['text':'   LO(dest) = double(0x HHHHHHHH 00000000) + double(0x 00000000 LLLLLLLL)','line_number':1630,'multiline':False]['text':'            = double(0x HHHHHHHH LLLLLLLL)','line_number':1631,'multiline':False]['text':'            = double(src)','line_number':1632,'multiline':False]['text':' Zero the output register to break dependencies, see convertInt32ToDouble.','line_number':1638,'multiline':False]['text':' Zero the dest register to break dependencies, see convertInt32ToDouble.','line_number':1653,'multiline':False]['text':' Set the FPU precision to 80 bits.','line_number':1656,'multiline':False]['text':' 2^64','line_number':1670,'multiline':False]['text':' Restore FPU precision to the initial value.','line_number':1682,'multiline':False]['text':' Zero the output register to break dependencies, see convertInt32ToDouble.','line_number':1689,'multiline':False]['text':'}}} check_macroassembler_style','line_number':1716,'multiline':False]