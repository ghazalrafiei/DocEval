['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' DeclaredNameInfo, FunctionBoxVector','line_number':15,'multiline':False]['text':' TaggedParserAtomIndex','line_number':17,'multiline':False]['text':' ScriptIndex','line_number':18,'multiline':False]['text':' JSMSG_*','line_number':21,'multiline':False]['text':' js::GeneratorKind, js::FunctionAsyncKind','line_number':22,'multiline':False]['text':' js::AbstractGeneratorObject::FixedSlotLimit','line_number':23,'multiline':False]['text':' js_*_str','line_number':24,'multiline':False]['text':' Returns true if the declaration is `var` or equivalent.','line_number':34,'multiline':False]['text':'
 * The struct ParseContext stores information about the current parsing context,
 * which is part of the parser state (see the field Parser::pc). The current
 * parsing context is either the global context, or the function currently being
 * parsed. When the parser encounters a function definition, it creates a new
 * ParseContext, makes it the new current context.
 ','line_number':39,'multiline':True]['text':' The intra-function statement stack.','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':' Used for early error checking that depend on the nesting structure of','line_number':50,'multiline':False]['text':' statements, such as continue/break targets, labels, and unbraced','line_number':51,'multiline':False]['text':' lexical declarations.','line_number':52,'multiline':False]['text':' The intra-function scope stack.','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':' Tracks declared and used names within a scope.','line_number':97,'multiline':False]['text':' Names declared in this scope. Corresponds to the union of','line_number':99,'multiline':False]['text':' VarDeclaredNames and LexicallyDeclaredNames in the ES spec.','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':' A 'var' declared name is a member of the declared name set of every','line_number':102,'multiline':False]['text':' scope in its scope contour.','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':' A lexically declared name is a member only of the declared name set of','line_number':105,'multiline':False]['text':' the scope in which it is declared.','line_number':106,'multiline':False]['text':' FunctionBoxes in this scope that need to be considered for Annex','line_number':109,'multiline':False]['text':' B.3.3 semantics. This is checked on Scope exit, as by then we have','line_number':110,'multiline':False]['text':' all the declared names and would know if Annex B.3.3 is applicable.','line_number':111,'multiline':False]['text':' Monotonically increasing id.','line_number':114,'multiline':False]['text':' Scope size info, relevant for scopes in generators and async functions','line_number':117,'multiline':False]['text':' only. During parsing, this is the estimated number of slots needed for','line_number':118,'multiline':False]['text':' nested scopes inside this one. When the parser leaves a scope, this is','line_number':119,'multiline':False]['text':' set to UINT32_MAX if there are too many bindings overrall to store them','line_number':120,'multiline':False]['text':' in stack frames, and 0 otherwise.','line_number':121,'multiline':False]['text':' Add a FunctionBox as a possible candidate for Annex B.3.3 semantics.','line_number':178,'multiline':False]['text':' Check if the candidate function boxes for Annex B.3.3 should in','line_number':182,'multiline':False]['text':' fact get Annex B semantics. Checked on Scope exit.','line_number':183,'multiline':False]['text':' Add and remove catch parameter names. Used to implement the odd','line_number':187,'multiline':False]['text':' semantics of catch bodies.','line_number':188,'multiline':False]['text':' This is called as we leave a function, var, or lexical scope in a','line_number':197,'multiline':False]['text':' generator or async function. `ownSlotCount` is the number of `bindings_`','line_number':198,'multiline':False]['text':' that are not closed over.','line_number':199,'multiline':False]['text':' Determine if this scope is too big to optimize bindings into stack','line_number':201,'multiline':False]['text':' slots. The meaning of sizeBits_ changes from "maximum nested slot','line_number':202,'multiline':False]['text':' count" to "UINT32_MAX if too big".','line_number':203,'multiline':False]['text':' Propagate total size to enclosing scope.','line_number':212,'multiline':False]['text':' An iterator for the set of names a scope binds: the set of all','line_number':226,'multiline':False]['text':' declared names for 'var' scopes, and the set of lexically declared','line_number':227,'multiline':False]['text':' names, plus synthetic names, for non-'var' scopes.','line_number':228,'multiline':False]['text':' Both var and lexically declared names are binding in a var','line_number':250,'multiline':False]['text':' scope.','line_number':251,'multiline':False]['text':' Otherwise, only lexically declared names are binding. Pop the range','line_number':256,'multiline':False]['text':' until we find such a name.','line_number':257,'multiline':False]['text':' Trace logging of parsing time.','line_number':314,'multiline':False]['text':' Context shared between parsing and bytecode generation.','line_number':317,'multiline':False]['text':' A mechanism used for error reporting.','line_number':320,'multiline':False]['text':' The innermost statement, i.e., top of the statement stack.','line_number':323,'multiline':False]['text':' The innermost scope, i.e., top of the scope stack.','line_number':326,'multiline':False]['text':'','line_number':327,'multiline':False]['text':' The outermost scope in the stack is usually varScope_. In the case of','line_number':328,'multiline':False]['text':' functions, the outermost scope is functionScope_, which may be','line_number':329,'multiline':False]['text':' varScope_. See comment above functionScope_.','line_number':330,'multiline':False]['text':' If isFunctionBox() and the function is a named lambda, the DeclEnv','line_number':333,'multiline':False]['text':' scope for named lambdas.','line_number':334,'multiline':False]['text':' If isFunctionBox(), the scope for the function. If there are no','line_number':337,'multiline':False]['text':' parameter expressions, this is scope for the entire function. If there','line_number':338,'multiline':False]['text':' are parameter expressions, this holds the special function names','line_number':339,'multiline':False]['text':' ('.this', 'arguments') and the formal parameters.','line_number':340,'multiline':False]['text':' The body-level scope. This always exists, but not necessarily at the','line_number':343,'multiline':False]['text':' beginning of parsing the script in the case of functions with parameter','line_number':344,'multiline':False]['text':' expressions.','line_number':345,'multiline':False]['text':' Simple formal parameter names, in order of appearance. Only used when','line_number':348,'multiline':False]['text':' isFunctionBox().','line_number':349,'multiline':False]['text':' Closed over binding names, in order of appearance. Null-delimited','line_number':352,'multiline':False]['text':' between scopes. Only used when syntax parsing.','line_number':353,'multiline':False]['text':' All inner functions in this context. Only used when syntax parsing.','line_number':357,'multiline':False]['text':' The Functions (or FunctionCreateionDatas) are traced as part of the','line_number':358,'multiline':False]['text':' CompilationStencil function vector.','line_number':359,'multiline':False]['text':' In a function context, points to a Directive struct that can be updated','line_number':362,'multiline':False]['text':' to reflect new directives encountered in the Directive Prologue that','line_number':363,'multiline':False]['text':' require reparsing the function. In global/module/generator-tail contexts,','line_number':364,'multiline':False]['text':' we don't need to reparse when encountering a DirectivePrologue so this','line_number':365,'multiline':False]['text':' pointer may be nullptr.','line_number':366,'multiline':False]['text':' lastYieldOffset stores the offset of the last yield that was parsed.','line_number':369,'multiline':False]['text':' NoYieldOffset is its initial value.','line_number':370,'multiline':False]['text':' lastAwaitOffset stores the offset of the last await that was parsed.','line_number':374,'multiline':False]['text':' NoAwaitOffset is its initial value.','line_number':375,'multiline':False]['text':' Monotonically increasing id.','line_number':380,'multiline':False]['text':' Set when encountering a super.property inside a method. We need to mark','line_number':383,'multiline':False]['text':' the nearest super scope as needing a home object.','line_number':384,'multiline':False]['text':' `true` if we are in the body of a function definition.','line_number':396,'multiline':False]['text':' There is always at least one scope: the 'var' scope.','line_number':404,'multiline':False]['text':' (Statement*) -> bool ','line_number':429,'multiline':True]['text':' (Statement*) -> bool ','line_number':434,'multiline':True]['text':' Unlabeled break must be inside loop or switch.','line_number':453,'multiline':False]['text':' Return Err(true) if we have encountered at least one loop,','line_number':458,'multiline':False]['text':' Err(false) otherwise.','line_number':459,'multiline':False]['text':' True if we are at the topmost level of a entire script or function body.','line_number':470,'multiline':False]['text':' For example, while parsing this code we would encounter f1 and f2 at','line_number':471,'multiline':False]['text':' body level, but we would not encounter f3 or f4 at body level:','line_number':472,'multiline':False]['text':'','line_number':473,'multiline':False]['text':'   function f1() { function f2() { } }','line_number':474,'multiline':False]['text':'   if (cond) { function f3() { if (cond) { function f4() { } } } }','line_number':475,'multiline':False]['text':'','line_number':476,'multiline':False]['text':' True if we are at the topmost level of a module only.','line_number':481,'multiline':False]['text':' True if we are at the topmost level of an entire script or module.  For','line_number':484,'multiline':False]['text':' example, in the comment on |atBodyLevel()| above, we would encounter |f1|','line_number':485,'multiline':False]['text':' and the outermost |if (cond)| at top level, and everything else would not','line_number':486,'multiline':False]['text':' be at top level.','line_number':487,'multiline':False]['text':' True if we are at the topmost level of an entire module.','line_number':491,'multiline':False]['text':'','line_number':492,'multiline':False]['text':' For example, this is used to determine if an await statement should','line_number':493,'multiline':False]['text':' mark a module as an async module during parsing.','line_number':494,'multiline':False]['text':'','line_number':495,'multiline':False]['text':' Example module:','line_number':496,'multiline':False]['text':'   import x from "y";','line_number':497,'multiline':False]['text':'','line_number':498,'multiline':False]['text':'   await x.foo(); // mark as Top level await.','line_number':499,'multiline':False]['text':'','line_number':500,'multiline':False]['text':'   if (cond) {','line_number':501,'multiline':False]['text':'     await x.bar(); // mark as Top level await.','line_number':502,'multiline':False]['text':'   }','line_number':503,'multiline':False]['text':'','line_number':504,'multiline':False]['text':'   async function z() {','line_number':505,'multiline':False]['text':'     await x.baz(); // do not mark as Top level await.','line_number':506,'multiline':False]['text':'   }','line_number':507,'multiline':False]['text':' True if this is the outermost ParserContext for current compile. For','line_number':511,'multiline':False]['text':' delazification, this lets us identify if the lazy PrivateScriptData is for','line_number':512,'multiline':False]['text':' current parser context.','line_number':513,'multiline':False]['text':' A generator is marked as a generator before its body is parsed.','line_number':530,'multiline':False]['text':' namespace frontend','line_number':610,'multiline':False]['text':' namespace js','line_number':612,'multiline':False]['text':' frontend_ParseContext_h','line_number':614,'multiline':False]