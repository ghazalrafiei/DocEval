['text':' Copyright (C) 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':' file: rbbi_cache.cpp','line_number':4,'multiline':False]['text':'
 * DictionaryCache implementation
 ','line_number':24,'multiline':True]['text':' Sequential iteration, move from previous boundary to the following','line_number':51,'multiline':False]['text':' Random indexing. Linear search for the boundary following the given position.','line_number':67,'multiline':False]['text':' Loop through the text, looking for ranges of dictionary characters.','line_number':139,'multiline':False]['text':' For each span, find the appropriate break engine, and ask it to find','line_number':140,'multiline':False]['text':' any breaks within the span.','line_number':141,'multiline':False]['text':' TODO: cleaner loop structure.','line_number':151,'multiline':False]['text':' We now have a dictionary character. Get the appropriate language object','line_number':159,'multiline':False]['text':' to deal with it.','line_number':160,'multiline':False]['text':' Ask the language object if there are any breaks. It will add them to the cache and','line_number':163,'multiline':False]['text':' leave the text pointer on the other side of its range, ready to search for the next one.','line_number':164,'multiline':False]['text':' Reload the loop variables for the next go-round','line_number':169,'multiline':False]['text':' If we found breaks, ensure that the first and last entries are','line_number':174,'multiline':False]['text':' the original starting and ending position. And initialize the','line_number':175,'multiline':False]['text':' cache iteration position to the first entry.','line_number':176,'multiline':False]['text':' printf("foundBreakCount = %d\n", foundBreakCount);','line_number':178,'multiline':False]['text':' The dictionary did not place a boundary at the start of the segment of text.','line_number':182,'multiline':False]['text':' Add one now. This should not commonly happen, but it would be easy for interactions','line_number':183,'multiline':False]['text':' of the rules for dictionary segments and the break engine implementations to','line_number':184,'multiline':False]['text':' inadvertently cause it. Cover it here, just in case.','line_number':185,'multiline':False]['text':' Note: Dictionary matching may extend beyond the original limit.','line_number':192,'multiline':False]['text':' there were no language-based breaks, even though the segment contained','line_number':196,'multiline':False]['text':' dictionary characters. Subsequent attempts to fetch boundaries from the dictionary cache','line_number':197,'multiline':False]['text':' for this range will fail, and the calling code will fall back to the rule based boundaries.','line_number':198,'multiline':False]['text':'
 *   BreakCache implemetation
 ','line_number':203,'multiline':True]['text':' startPos is in the cache. Do a next() from that position.','line_number':240,'multiline':False]['text':' TODO: an awkward set of interactions with bi->fDone','line_number':241,'multiline':False]['text':'       seek() does not clear it; it can't because of interactions with populateNear().','line_number':242,'multiline':False]['text':'       next() does not clear it in the fast-path case, where everything matters. Maybe it should.','line_number':243,'multiline':False]['text':'       So clear it here, for the case where seek() succeeded on an iterator that had previously run off the end.','line_number':244,'multiline':False]['text':' seek() leaves the BreakCache positioned at the preceding boundary','line_number':260,'multiline':False]['text':'        if the requested position is between two boundaries.','line_number':261,'multiline':False]['text':' current() pushes the BreakCache position out to the BreakIterator itself.','line_number':262,'multiline':False]['text':'
 * Out-of-line code for BreakCache::next().
 * Cache does not already contain the boundary
 ','line_number':271,'multiline':True]['text':' At start of cache. Prepend to it.','line_number':289,'multiline':False]['text':' Cache already holds the next boundary','line_number':292,'multiline':False]['text':' Common case: seek(0), from BreakIterator::first()','line_number':308,'multiline':False]['text':' Find a boundary somewhere in the vicinity of the requested position.','line_number':344,'multiline':False]['text':' Depending on the safe rules and the text data, it could be either before, at, or after','line_number':345,'multiline':False]['text':' the requested position.','line_number':346,'multiline':False]['text':' If the requested position is not near already cached positions, clear the existing cache,','line_number':349,'multiline':False]['text':' find a near-by boundary and begin new cache contents there.','line_number':350,'multiline':False]['text':' Advance to the boundary following the backup position.','line_number':359,'multiline':False]['text':' There is a complication: the safe reverse rules identify pairs of code points','line_number':360,'multiline':False]['text':' that are safe. If advancing from the safe point moves forwards by less than','line_number':361,'multiline':False]['text':' two code points, we need to advance one more time to ensure that the boundary','line_number':362,'multiline':False]['text':' is good, including a correct rules status value.','line_number':363,'multiline':False]['text':'','line_number':364,'multiline':False]['text':' +4 is a quick test for possibly having advanced only one codepoint.','line_number':368,'multiline':False]['text':' Four being the length of the longest potential code point, a supplementary in UTF-8','line_number':369,'multiline':False]['text':' The initial handleNext() only advanced by a single code point. Go again.','line_number':372,'multiline':False]['text':' Safe rules identify safe pairs.','line_number':373,'multiline':False]['text':' Reset cache to hold aBoundary as a single starting point.','line_number':379,'multiline':False]['text':' Fill in boundaries between existing cache content and the new requested position.','line_number':382,'multiline':False]['text':' The last position in the cache precedes the requested position.','line_number':385,'multiline':False]['text':' Add following position(s) to the cache.','line_number':386,'multiline':False]['text':' Set iterator position to the end of the buffer.','line_number':392,'multiline':False]['text':' Required because populateFollowing may add extra boundaries.','line_number':393,'multiline':False]['text':' Move backwards to a position at or preceding the requested pos.','line_number':394,'multiline':False]['text':' The first position in the cache is beyond the requested position.','line_number':401,'multiline':False]['text':' back up more until we get a boundary <= the requested position.','line_number':402,'multiline':False]['text':' Set iterator position to the start of the buffer.','line_number':406,'multiline':False]['text':' Required because populatePreceding may add extra boundaries.','line_number':407,'multiline':False]['text':' Move forwards to a position at or following the requested pos.','line_number':408,'multiline':False]['text':' If position is not itself a boundary, the next() loop above will overshoot.','line_number':412,'multiline':False]['text':' Back up one, leaving cache position at the boundary preceding the requested position.','line_number':413,'multiline':False]['text':' The text segment obtained from the rules includes dictionary characters.','line_number':444,'multiline':False]['text':' Subdivide it, with subdivided results going into the dictionary cache.','line_number':445,'multiline':False]['text':' TODO: may want to move a sizable chunk of dictionary cache to break cache at this point.','line_number':450,'multiline':False]['text':'       But be careful with interactions with populateNear().','line_number':451,'multiline':False]['text':' Rule based segment did not include dictionary characters.','line_number':455,'multiline':False]['text':' Or, it did contain dictionary chars, but the dictionary segmenter didn't handle them,','line_number':456,'multiline':False]['text':'    meaning that we didn't take the return, above.','line_number':457,'multiline':False]['text':' Add its end point to the cache.','line_number':458,'multiline':False]['text':' Add several non-dictionary boundaries at this point, to optimize straight forward iteration.','line_number':461,'multiline':False]['text':'    (subsequent calls to BreakIterator::next() will take the fast path, getting cached results.','line_number':462,'multiline':False]['text':'','line_number':463,'multiline':False]['text':' Find a boundary somewhere preceding the first already-cached boundary','line_number':496,'multiline':False]['text':' Advance to the boundary following the backup position.','line_number':508,'multiline':False]['text':' There is a complication: the safe reverse rules identify pairs of code points','line_number':509,'multiline':False]['text':' that are safe. If advancing from the safe point moves forwards by less than','line_number':510,'multiline':False]['text':' two code points, we need to advance one more time to ensure that the boundary','line_number':511,'multiline':False]['text':' is good, including a correct rules status value.','line_number':512,'multiline':False]['text':'','line_number':513,'multiline':False]['text':' +4 is a quick test for possibly having advanced only one codepoint.','line_number':517,'multiline':False]['text':' Four being the length of the longest potential code point, a supplementary in UTF-8','line_number':518,'multiline':False]['text':' The initial handleNext() only advanced by a single code point. Go again.','line_number':521,'multiline':False]['text':' Safe rules identify safe pairs.','line_number':522,'multiline':False]['text':' Find boundaries between the one we just located and the first already-cached boundary','line_number':529,'multiline':False]['text':' Put them in a side buffer, because we don't yet know where they will fall in the circular cache buffer..','line_number':530,'multiline':False]['text':' Segment from the rules includes dictionary characters.','line_number':547,'multiline':False]['text':' Subdivide it, with subdivided results going into the dictionary cache.','line_number':548,'multiline':False]['text':' Move boundaries from the side buffer to the main circular buffer.','line_number':571,'multiline':False]['text':' No space in circular buffer to hold a new preceding result while','line_number':584,'multiline':False]['text':' also retaining the current cache (iteration) position.','line_number':585,'multiline':False]['text':' Bailing out is safe; the cache will refill again if needed.','line_number':586,'multiline':False]['text':' TODO: experiment. Probably revert to 1.','line_number':600,'multiline':False]['text':' Set current position to the newly added boundary.','line_number':606,'multiline':False]['text':' Retaining the original cache position.','line_number':610,'multiline':False]['text':' Check if the added boundary wraps around the buffer, and would over-write the original position.','line_number':611,'multiline':False]['text':' It's the responsibility of callers of this function to not add too many.','line_number':612,'multiline':False]['text':' Failure. The insertion of the new boundary would claim the buffer position that is the','line_number':623,'multiline':False]['text':' current iteration position. And we also want to retain the current iteration position.','line_number':624,'multiline':False]['text':' (The buffer is already completely full of entries that precede the iteration position.)','line_number':625,'multiline':False]['text':' #if !UCONFIG_NO_BREAK_ITERATION','line_number':655,'multiline':False]