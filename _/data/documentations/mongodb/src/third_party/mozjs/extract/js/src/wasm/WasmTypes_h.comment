['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]['text':' namespace jit','line_number':61,'multiline':False]['text':' Exception tags are used to uniquely identify exceptions. They are stored','line_number':83,'multiline':False]['text':' in a vector in Instances and used by both WebAssembly.Exception for import','line_number':84,'multiline':False]['text':' and export, and by the representation of thrown exceptions.','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' Since an exception tag is a (trivial) substructure of AtomicRefCounted, the','line_number':87,'multiline':False]['text':' RefPtr SharedExceptionTag can have many instances/modules referencing a','line_number':88,'multiline':False]['text':' single constant exception tag.','line_number':89,'multiline':False]['text':' WasmJSExceptionObject wraps a JS Value in order to provide a uniform','line_number':98,'multiline':False]['text':' method of handling JS thrown exceptions. Exceptions originating in Wasm','line_number':99,'multiline':False]['text':' are WebAssemby.RuntimeException objects, whereas exceptions from JS are','line_number':100,'multiline':False]['text':' wrapped as WasmJSExceptionObject objects.','line_number':101,'multiline':False]['text':' A Module can either be asm.js or wasm.','line_number':113,'multiline':False]['text':' ArgTypeVector type.','line_number':117,'multiline':False]['text':'','line_number':118,'multiline':False]['text':' Functions usually receive one ABI argument per WebAssembly argument.  However','line_number':119,'multiline':False]['text':' if a function has multiple results and some of those results go to the stack,','line_number':120,'multiline':False]['text':' then it additionally receives a synthetic ABI argument holding a pointer to','line_number':121,'multiline':False]['text':' the stack result area.','line_number':122,'multiline':False]['text':'','line_number':123,'multiline':False]['text':' Given the presence of synthetic arguments, sometimes we need a name for','line_number':124,'multiline':False]['text':' non-synthetic arguments.  We call those "natural" arguments.','line_number':125,'multiline':False]['text':' To allow ABIArgIterBase<VecT, ABIArgGeneratorT>, we define a private','line_number':133,'multiline':False]['text':' length() method.  To prevent accidental errors, other users need to be','line_number':134,'multiline':False]['text':' explicit and call lengthWithStackResults() or','line_number':135,'multiline':False]['text':' lengthWithoutStackResults().','line_number':136,'multiline':False]['text':' The pointer to stack results area, if present, is a synthetic argument','line_number':154,'multiline':False]['text':' tacked on at the end.','line_number':155,'multiline':False]['text':' Because the synthetic argument, if present, is tacked on the end, an','line_number':164,'multiline':False]['text':' argument index that isn't synthetic is natural.','line_number':165,'multiline':False]['text':' ResultType represents the WebAssembly spec's `resulttype`. Semantically, a','line_number':245,'multiline':False]['text':' result type is just a vec(valtype).  For effiency, though, the ResultType','line_number':246,'multiline':False]['text':' value is packed into a word, with separate encodings for these 3 cases:','line_number':247,'multiline':False]['text':'  []','line_number':248,'multiline':False]['text':'  [valtype]','line_number':249,'multiline':False]['text':'  pointer to ValTypeVector','line_number':250,'multiline':False]['text':'','line_number':251,'multiline':False]['text':' Additionally there is an encoding indicating uninitialized ResultType','line_number':252,'multiline':False]['text':' values.','line_number':253,'multiline':False]['text':'','line_number':254,'multiline':False]['text':' Generally in the latter case the ValTypeVector is the args() or results() of','line_number':255,'multiline':False]['text':' a FuncType in the compilation unit, so as long as the lifetime of the','line_number':256,'multiline':False]['text':' ResultType value is less than the OpIter, we can just borrow the pointer','line_number':257,'multiline':False]['text':' without ownership or copying.','line_number':258,'multiline':False]['text':' BlockType represents the WebAssembly spec's `blocktype`. Semantically, a','line_number':364,'multiline':False]['text':' block type is just a (vec(valtype) -> vec(valtype)) with four special','line_number':365,'multiline':False]['text':' encodings which are represented explicitly in BlockType:','line_number':366,'multiline':False]['text':'  [] -> []','line_number':367,'multiline':False]['text':'  [] -> [valtype]','line_number':368,'multiline':False]['text':'  [params] -> [results] via pointer to FuncType','line_number':369,'multiline':False]['text':'  [] -> [results] via pointer to FuncType (ignoring [params])','line_number':370,'multiline':False]['text':' CacheableChars is used to cacheably store UniqueChars.','line_number':470,'multiline':False]['text':' Import describes a single wasm import. An ImportVector describes all','line_number':482,'multiline':False]['text':' of a single module's imports.','line_number':483,'multiline':False]['text':'','line_number':484,'multiline':False]['text':' ImportVector is built incrementally by ModuleGenerator and then stored','line_number':485,'multiline':False]['text':' immutably by Module.','line_number':486,'multiline':False]['text':' Export describes the export of a definition in a Module to a field in the','line_number':502,'multiline':False]['text':' export object. The Export stores the index of the exported item in the','line_number':503,'multiline':False]['text':' appropriate type-specific module data structure (function table, global','line_number':504,'multiline':False]['text':' table, table table, and - eventually - memory table).','line_number':505,'multiline':False]['text':'','line_number':506,'multiline':False]['text':' Note a single definition can be exported by multiple Exports in the','line_number':507,'multiline':False]['text':' ExportVector.','line_number':508,'multiline':False]['text':'','line_number':509,'multiline':False]['text':' ExportVector is built incrementally by ModuleGenerator and then stored','line_number':510,'multiline':False]['text':' immutably by Module.','line_number':511,'multiline':False]['text':' FuncFlags provides metadata for a function definition.','line_number':540,'multiline':False]['text':' The function maybe be accessible by JS and needs thunks generated for it.','line_number':544,'multiline':False]['text':' See `[SMDOC] Exported wasm functions and the jit-entry stubs` in','line_number':545,'multiline':False]['text':' WasmJS.cpp for more information.','line_number':546,'multiline':False]['text':' The function should have thunks generated upon instantiation, not upon','line_number':548,'multiline':False]['text':' first call. May only be set if `Exported` is set.','line_number':549,'multiline':False]['text':' The function can be the target of a ref.func instruction in the code','line_number':551,'multiline':False]['text':' section. May only be set if `Exported` is set.','line_number':552,'multiline':False]['text':' A FuncDesc describes a single function definition.','line_number':556,'multiline':False]['text':' Bit pack to keep this struct small on 32-bit systems','line_number':563,'multiline':False]['text':' Assert that the bit packing scheme is viable','line_number':567,'multiline':False]['text':' A GlobalDesc describes a single global variable.','line_number':589,'multiline':False]['text':'','line_number':590,'multiline':False]['text':' wasm can import and export mutable and immutable globals.','line_number':591,'multiline':False]['text':'','line_number':592,'multiline':False]['text':' asm.js can import mutable and immutable globals, but a mutable global has a','line_number':593,'multiline':False]['text':' location that is private to the module, and its initial value is copied into','line_number':594,'multiline':False]['text':' that cell from the environment.  asm.js cannot export globals.','line_number':595,'multiline':False]['text':' Stores the value type of this global for all kinds, and the initializer','line_number':601,'multiline':False]['text':' expression when `constant` or `variable`.','line_number':602,'multiline':False]['text':' Metadata for the global when `variable` or `import`.','line_number':604,'multiline':False]['text':' Metadata for the global when `import`.','line_number':609,'multiline':False]['text':' Private, as they have unusual semantics.','line_number':612,'multiline':False]['text':' If isIndirect() is true then storage for the value is not in the','line_number':678,'multiline':False]['text':' instance's global area, but in a WasmGlobalObject::Cell hanging off a','line_number':679,'multiline':False]['text':' WasmGlobalObject; the global area contains a pointer to the Cell.','line_number':680,'multiline':False]['text':'','line_number':681,'multiline':False]['text':' We don't want to indirect unless we must, so only mutable, exposed','line_number':682,'multiline':False]['text':' globals are indirected - in all other cases we copy values into and out','line_number':683,'multiline':False]['text':' of their module.','line_number':684,'multiline':False]['text':'','line_number':685,'multiline':False]['text':' Note that isIndirect() isn't equivalent to getting a WasmGlobalObject:','line_number':686,'multiline':False]['text':' an immutable exported global will still get an object, but will not be','line_number':687,'multiline':False]['text':' indirect.','line_number':688,'multiline':False]['text':' An EventDesc describes a single event for non-local control flow, such as','line_number':700,'multiline':False]['text':' for exceptions.','line_number':701,'multiline':False]['text':' When a ElemSegment is "passive" it is shared between a wasm::Module and its','line_number':718,'multiline':False]['text':' wasm::Instances. To allow each segment to be released as soon as the last','line_number':719,'multiline':False]['text':' Instance elem.drops it and the Module is destroyed, each ElemSegment is','line_number':720,'multiline':False]['text':' individually atomically ref-counted.','line_number':721,'multiline':False]['text':' Element may be NullFuncIndex','line_number':734,'multiline':False]['text':' NullFuncIndex represents the case when an element segment (of type funcref)','line_number':745,'multiline':False]['text':' contains a null element.','line_number':746,'multiline':False]['text':' DataSegmentEnv holds the initial results of decoding a data segment from the','line_number':754,'multiline':False]['text':' bytecode and is stored in the ModuleEnvironment during compilation. When','line_number':755,'multiline':False]['text':' compilation completes, (non-Env) DataSegments are created and stored in','line_number':756,'multiline':False]['text':' the wasm::Module which contain copies of the data segment payload. This','line_number':757,'multiline':False]['text':' allows non-compilation uses of wasm validation to avoid expensive copies.','line_number':758,'multiline':False]['text':'','line_number':759,'multiline':False]['text':' When a DataSegment is "passive" it is shared between a wasm::Module and its','line_number':760,'multiline':False]['text':' wasm::Instances. To allow each segment to be released as soon as the last','line_number':761,'multiline':False]['text':' Instance mem.drops it and the Module is destroyed, each DataSegment is','line_number':762,'multiline':False]['text':' individually atomically ref-counted.','line_number':763,'multiline':False]['text':' The CustomSection(Env) structs are like DataSegment(Env): CustomSectionEnv is','line_number':801,'multiline':False]['text':' stored in the ModuleEnvironment and CustomSection holds a copy of the payload','line_number':802,'multiline':False]['text':' and is stored in the wasm::Module.','line_number':803,'multiline':False]['text':' A Name represents a string of utf8 chars embedded within the name custom','line_number':823,'multiline':False]['text':' section. The offset of a name is expressed relative to the beginning of the','line_number':824,'multiline':False]['text':' name section's payload so that Names can stored in wasm::Code, which only','line_number':825,'multiline':False]['text':' holds the name section's bytes, not the whole bytecode.','line_number':826,'multiline':False]['text':' All fields are treated as cacheable POD:','line_number':829,'multiline':False]['text':' TypeIdDesc describes the runtime representation of a TypeDef suitable for','line_number':838,'multiline':False]['text':' type equality checks. The kind of representation depends on whether the type','line_number':839,'multiline':False]['text':' is a function or a struct. This will likely be simplified in the future once','line_number':840,'multiline':False]['text':' mutually recursives types are able to be collected.','line_number':841,'multiline':False]['text':'','line_number':842,'multiline':False]['text':' For functions, a FuncType is allocated and stored in a process-wide hash','line_number':843,'multiline':False]['text':' table, so that pointer equality implies structural equality. As an','line_number':844,'multiline':False]['text':' optimization for the 99% case where the FuncType has a small number of','line_number':845,'multiline':False]['text':' parameters, the FuncType is bit-packed into a uint32 immediate value so that','line_number':846,'multiline':False]['text':' integer equality implies structural equality. Both cases can be handled with','line_number':847,'multiline':False]['text':' a single comparison by always setting the LSB for the immediates','line_number':848,'multiline':False]['text':' (the LSB is necessarily 0 for allocated FuncType pointers due to alignment).','line_number':849,'multiline':False]['text':'','line_number':850,'multiline':False]['text':' TODO: Write description for StructTypes once it is well formed.','line_number':851,'multiline':False]['text':' TypeDefWithId pairs a FuncType with TypeIdDesc, describing either how to','line_number':885,'multiline':False]['text':' compile code that compares this signature's id or, at instantiation what','line_number':886,'multiline':False]['text':' signature ids to allocate in the global hash and where to put them.','line_number':887,'multiline':False]['text':' A wrapper around the bytecode offset of a wasm instruction within a whole','line_number':905,'multiline':False]['text':' module, used for trap offsets or call offsets. These offsets should refer to','line_number':906,'multiline':False]['text':' the first byte of the instruction that triggered the trap / did the call and','line_number':907,'multiline':False]['text':' should ultimately derive from OpIter::bytecodeOffset.','line_number':908,'multiline':False]['text':' A TrapSite (in the TrapSiteVector for a given Trap code) represents a wasm','line_number':925,'multiline':False]['text':' instruction at a given bytecode offset that can fault at the given pc offset.','line_number':926,'multiline':False]['text':' When such a fault occurs, a signal/exception handler looks up the TrapSite to','line_number':927,'multiline':False]['text':' confirm the fault is intended/safe and redirects pc to the trap stub.','line_number':928,'multiline':False]['text':' On trap, the bytecode offset to be reported in callstacks is saved.','line_number':953,'multiline':False]['text':' The resumePC indicates where, if the trap doesn't throw, the trap stub','line_number':956,'multiline':False]['text':' should jump to after restoring all register state.','line_number':957,'multiline':False]['text':' The unwoundPC is the PC after adjustment by wasm::StartUnwinding(), which','line_number':960,'multiline':False]['text':' basically unwinds partially-construted wasm::Frames when pc is in the','line_number':961,'multiline':False]['text':' prologue/epilogue. Stack traces during a trap should use this PC since','line_number':962,'multiline':False]['text':' it corresponds to the JitActivation::wasmExitFP.','line_number':963,'multiline':False]['text':' The (,Callable,Func)Offsets classes are used to record the offsets of','line_number':970,'multiline':False]['text':' different key points in a CodeRange during compilation.','line_number':971,'multiline':False]['text':' These define a [begin, end) contiguous range of instructions compiled','line_number':977,'multiline':False]['text':' into a CodeRange.','line_number':978,'multiline':False]['text':' The offset of the return instruction precedes 'end' by a variable number','line_number':986,'multiline':False]['text':' of instructions due to out-of-line codegen.','line_number':987,'multiline':False]['text':' There are a few instructions in the Jit exit where FP may be trash','line_number':995,'multiline':False]['text':' (because it may have been clobbered by the JS Jit), known as the','line_number':996,'multiline':False]['text':' untrusted FP zone.','line_number':997,'multiline':False]['text':' Function CodeRanges have a checked call entry which takes an extra','line_number':1006,'multiline':False]['text':' signature argument which is checked against the callee's signature before','line_number':1007,'multiline':False]['text':' falling through to the normal prologue. The checked call entry is thus at','line_number':1008,'multiline':False]['text':' the beginning of the CodeRange and the unchecked call entry is at some','line_number':1009,'multiline':False]['text':' offset after the checked call entry.','line_number':1010,'multiline':False]['text':' The tierEntry is the point within a function to which the patching code','line_number':1013,'multiline':False]['text':' within a Tier-1 function jumps.  It could be the instruction following','line_number':1014,'multiline':False]['text':' the jump in the Tier-1 function, or the point following the standard','line_number':1015,'multiline':False]['text':' prologue within a Tier-2 function.','line_number':1016,'multiline':False]['text':' A CodeRange describes a single contiguous range of code within a wasm','line_number':1022,'multiline':False]['text':' module's code segment. A CodeRange describes what the code does and, for','line_number':1023,'multiline':False]['text':' function bodies, the name and source coordinates of the function.','line_number':1024,'multiline':False]['text':' function definition','line_number':1029,'multiline':False]['text':' calls into wasm from C++','line_number':1030,'multiline':False]['text':' calls into wasm from jit code','line_number':1031,'multiline':False]['text':' slow-path calling from wasm into C++ interp','line_number':1032,'multiline':False]['text':' fast-path calling from wasm into jit code','line_number':1033,'multiline':False]['text':' fast-path calling from wasm into a C++ native','line_number':1034,'multiline':False]['text':' calls C++ to report and jumps to throw stub','line_number':1035,'multiline':False]['text':' calls C++ to handle debug event','line_number':1036,'multiline':False]['text':' inserted to connect otherwise out-of-range insns','line_number':1037,'multiline':False]['text':' special stack-unwinding stub jumped to by other stubs','line_number':1038,'multiline':False]['text':' All fields are treated as cacheable POD:','line_number':1042,'multiline':False]['text':' All CodeRanges have a begin and end.','line_number':1082,'multiline':False]['text':' Other fields are only available for certain CodeRange::Kinds.','line_number':1087,'multiline':False]['text':' Function, import exits and trap exits have standard callable prologues','line_number':1102,'multiline':False]['text':' and epilogues. Asynchronous frame iteration needs to know the offset of','line_number':1103,'multiline':False]['text':' the return instruction to calculate the frame pointer.','line_number':1104,'multiline':False]['text':' Functions, export stubs and import stubs all have an associated function','line_number':1114,'multiline':False]['text':' index.','line_number':1115,'multiline':False]['text':' TrapExit CodeRanges have a Trap field.','line_number':1128,'multiline':False]['text':' Function CodeRanges have two entry points: one for normal calls (with a','line_number':1135,'multiline':False]['text':' known signature) and one for table calls (which involves dynamic','line_number':1136,'multiline':False]['text':' signature checking).','line_number':1137,'multiline':False]['text':' ImportJitExit have a particular range where the value of FP can't be','line_number':1156,'multiline':False]['text':' trusted for profiling and thus must be ignored.','line_number':1157,'multiline':False]['text':' A sorted array of CodeRanges can be looked up via BinarySearch and','line_number':1168,'multiline':False]['text':' OffsetInCode.','line_number':1169,'multiline':False]['text':' While the frame-pointer chain allows the stack to be unwound without','line_number':1186,'multiline':False]['text':' metadata, Error.stack still needs to know the line/column of every call in','line_number':1187,'multiline':False]['text':' the chain. A CallSiteDesc describes a single callsite to which CallSite adds','line_number':1188,'multiline':False]['text':' the metadata necessary to walk up to the next frame. Lastly CallSiteAndTarget','line_number':1189,'multiline':False]['text':' adds the function index of the callee.','line_number':1190,'multiline':False]['text':' pc-relative call to a specific function','line_number':1202,'multiline':False]['text':' dynamic callee called via register','line_number':1203,'multiline':False]['text':' call to a single symbolic callee','line_number':1204,'multiline':False]['text':' call to a enter frame handler','line_number':1205,'multiline':False]['text':' call to a leave frame handler','line_number':1206,'multiline':False]['text':' call to instruction breakpoint','line_number':1207,'multiline':False]['text':' A CallSiteTarget describes the callee of a CallSite, either a function or a','line_number':1238,'multiline':False]['text':' trap exit. Although checked in debug builds, a CallSiteTarget doesn't','line_number':1239,'multiline':False]['text':' officially know whether it targets a function or trap, relying on the Kind of','line_number':1240,'multiline':False]['text':' the CallSite to discriminate.','line_number':1241,'multiline':False]['text':' WasmTryNotes are stored in a vector that acts as an exception table for','line_number':1291,'multiline':False]['text':' wasm try-catch blocks. These represent the information needed to take','line_number':1292,'multiline':False]['text':' exception handling actions after a throw is executed.','line_number':1293,'multiline':False]['text':' Begin code offset of try instructions.','line_number':1299,'multiline':False]['text':' End code offset of try instructions.','line_number':1300,'multiline':False]['text':' The offset of the landing pad.','line_number':1301,'multiline':False]['text':' Track offset from frame of stack pointer.','line_number':1302,'multiline':False]['text':' Represents the resizable limits of memories and tables.','line_number':1320,'multiline':False]['text':' `shared` is Shareable::False for tables but may be Shareable::True for','line_number':1326,'multiline':False]['text':' memories.','line_number':1327,'multiline':False]['text':' Memories can be 32-bit (indices are 32 bits and the max is 4GB) or 64-bit','line_number':1336,'multiline':False]['text':' (indices are 64 bits and the max is XXX).','line_number':1337,'multiline':False]['text':' MemoryDesc describes a memory.','line_number':1341,'multiline':False]['text':' Whether a backing store for this memory may move when grown.','line_number':1349,'multiline':False]['text':' Whether the bounds check limit (see the doc comment in','line_number':1352,'multiline':False]['text':' ArrayBufferObject.cpp regarding linear memory structure) can ever be','line_number':1353,'multiline':False]['text':' larger than 32-bits.','line_number':1354,'multiline':False]['text':' The initial length of this memory in pages.','line_number':1360,'multiline':False]['text':' The maximum length of this memory in pages.','line_number':1363,'multiline':False]['text':' The initial length of this memory in bytes. Only valid for memory32.','line_number':1368,'multiline':False]['text':' See static_assert after MemoryDesc for why this is safe.','line_number':1371,'multiline':False]['text':' The maximum length of this memory in bytes. Only valid for memory32.','line_number':1375,'multiline':False]['text':' See static_assert after MemoryDesc for why this is safe.','line_number':1379,'multiline':False]['text':' We don't need to worry about overflow with a Memory32 field when','line_number':1389,'multiline':False]['text':' using a uint64_t.','line_number':1390,'multiline':False]['text':' TableDesc describes a table as well as the offset of the table's base pointer','line_number':1393,'multiline':False]['text':' in global memory.','line_number':1394,'multiline':False]['text':'','line_number':1395,'multiline':False]['text':' A TableDesc contains the element type and whether the table is for asm.js,','line_number':1396,'multiline':False]['text':' which determines the table representation.','line_number':1397,'multiline':False]['text':'  - ExternRef: a wasm anyref word (wasm::AnyRef)','line_number':1398,'multiline':False]['text':'  - FuncRef: a two-word FunctionTableElem (wasm indirect call ABI)','line_number':1399,'multiline':False]['text':'  - FuncRef (if `isAsmJS`): a two-word FunctionTableElem (asm.js ABI)','line_number':1400,'multiline':False]['text':' Eventually there should be a single unified AnyRef representation.','line_number':1401,'multiline':False]['text':' CalleeDesc describes how to compile one of the variety of asm.js/wasm calls.','line_number':1425,'multiline':False]['text':' This is hoisted into WasmTypes.h for sharing between Ion and Baseline.','line_number':1426,'multiline':False]['text':' Calls a function defined in the same module by its index.','line_number':1431,'multiline':False]['text':' Calls the import identified by the offset of its FuncImportTls in','line_number':1434,'multiline':False]['text':' thread-local data.','line_number':1435,'multiline':False]['text':' Calls a WebAssembly table (heterogeneous, index must be bounds','line_number':1438,'multiline':False]['text':' checked, callee instance depends on TableDesc).','line_number':1439,'multiline':False]['text':' Calls an asm.js table (homogeneous, masked index, same-instance).','line_number':1442,'multiline':False]['text':' Call a C++ function identified by SymbolicAddress.','line_number':1445,'multiline':False]['text':' Like Builtin, but automatically passes Instance* as first argument.','line_number':1448,'multiline':False]['text':' which_ shall be initialized in the static constructors','line_number':1453,'multiline':False]['text':' Because ARM has a fixed-width instruction encoding, ARM can only express a','line_number':1541,'multiline':False]['text':' limited subset of immediates (in a single instruction).','line_number':1542,'multiline':False]['text':' Bounds checks always compare the base of the memory access with the bounds','line_number':1550,'multiline':False]['text':' check limit. If the memory access is unaligned, this means that, even if the','line_number':1551,'multiline':False]['text':' bounds check succeeds, a few bytes of the access can extend past the end of','line_number':1552,'multiline':False]['text':' memory. To guard against this, extra space is included in the guard region to','line_number':1553,'multiline':False]['text':' catch the overflow. MaxMemoryAccessSize is a conservative approximation of','line_number':1554,'multiline':False]['text':' the maximum guard space needed to catch all unaligned overflows.','line_number':1555,'multiline':False]['text':' On WASM_SUPPORTS_HUGE_MEMORY platforms, every asm.js or WebAssembly 32-bit','line_number':1561,'multiline':False]['text':' memory unconditionally allocates a huge region of virtual memory of size','line_number':1562,'multiline':False]['text':' wasm::HugeMappedSize. This allows all memory resizing to work without','line_number':1563,'multiline':False]['text':' reallocation and provides enough guard space for all offsets to be folded','line_number':1564,'multiline':False]['text':' into memory accesses.','line_number':1565,'multiline':False]['text':' On !WASM_SUPPORTS_HUGE_MEMORY platforms:','line_number':1580,'multiline':False]['text':'  - To avoid OOM in ArrayBuffer::prepareForAsmJS, asm.js continues to use the','line_number':1581,'multiline':False]['text':'    original ArrayBuffer allocation which has no guard region at all.','line_number':1582,'multiline':False]['text':'  - For WebAssembly memories, an additional GuardSize is mapped after the','line_number':1583,'multiline':False]['text':'    accessible region of the memory to catch folded (base+offset) accesses','line_number':1584,'multiline':False]['text':'    where `offset < OffsetGuardLimit` as well as the overflow from unaligned','line_number':1585,'multiline':False]['text':'    accesses, as described above for MaxMemoryAccessSize.','line_number':1586,'multiline':False]['text':' Return whether the given immediate satisfies the constraints of the platform','line_number':1606,'multiline':False]['text':' (viz. that, on ARM, IsValidARMImmediate).','line_number':1607,'multiline':False]['text':' For a given WebAssembly/asm.js max pages, return the number of bytes to','line_number':1611,'multiline':False]['text':' map which will necessarily be a multiple of the system page size and greater','line_number':1612,'multiline':False]['text':' than maxPages in bytes. For a returned mappedSize:','line_number':1613,'multiline':False]['text':'   boundsCheckLimit = mappedSize - GuardSize','line_number':1614,'multiline':False]['text':'   IsValidBoundsCheckImmediate(boundsCheckLimit)','line_number':1615,'multiline':False]['text':' The following thresholds were derived from a microbenchmark. If we begin to','line_number':1619,'multiline':False]['text':' ship this optimization for more platforms, we will need to extend this list.','line_number':1620,'multiline':False]['text':' Verbose logging support.','line_number':1636,'multiline':False]['text':' Codegen debug support.','line_number':1640,'multiline':False]['text':' namespace wasm','line_number':1661,'multiline':False]['text':' namespace js','line_number':1662,'multiline':False]['text':' wasm_types_h','line_number':1664,'multiline':False]