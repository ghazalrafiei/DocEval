['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' -*- indent-tabs-mode: nil; js-indent-level: 4 -*- ','line_number':5,'multiline':True]['text':' unused','line_number':19,'multiline':False]['text':' RAII types within which we should assume GC is suppressed, eg','line_number':28,'multiline':False]['text':' AutoSuppressGC.','line_number':29,'multiline':False]['text':' Map from descriptor string => Set of typeName','line_number':33,'multiline':False]['text':' Map from field => list of <parent, fieldName>','line_number':35,'multiline':False]['text':' Map from field => list of <parent, fieldName>','line_number':36,'multiline':False]['text':' Map from struct name => list of base class name strings','line_number':37,'multiline':False]['text':' Map from struct name => list of subclass  name strings','line_number':38,'multiline':False]['text':' map from parent struct => Set of GC typed children','line_number':40,'multiline':False]['text':' map from parent struct => Set of GC typed children','line_number':41,'multiline':False]['text':' Pure virtual functions will not have field.Variable; others will.','line_number':100,'multiline':False]['text':' csu.field is of type inner','line_number':111,'multiline':False]['text':' Skip fields that are really base classes, to avoid duplicating the base','line_number':117,'multiline':False]['text':' fields; addBaseClass already added a "base-N" name.','line_number':118,'multiline':False]['text':' Everything that inherits from a "Rooted Base" is considered to be rooted.','line_number':166,'multiline':False]['text':' This is for things like CustomAutoRooter and its subclasses.','line_number':167,'multiline':False]['text':' Now that we have the whole hierarchy set up, add all the types and propagate','line_number':176,'multiline':False]['text':' info.','line_number':177,'multiline':False]['text':' GC Thing and GC Pointer annotations can be inherited from template args if','line_number':185,'multiline':False]['text':' this annotation is used. Think of Maybe<T> for example: Maybe<JSObject*> has','line_number':186,'multiline':False]['text':' the same GC rules as JSObject*. But this needs to be done in a conservative','line_number':187,'multiline':False]['text':' direction: Maybe<AutoSuppressGC> should not be regarding as suppressing GC','line_number':188,'multiline':False]['text':' (because it might still be None).','line_number':189,'multiline':False]['text':'','line_number':190,'multiline':False]['text':' Note that there is an order-dependence here that is being mostly ignored (eg','line_number':191,'multiline':False]['text':' Maybe<Maybe<Cell*>> -- if that is processed before Maybe<Cell*> is','line_number':192,'multiline':False]['text':' processed, we won't get the right answer). We'll at least sort by string','line_number':193,'multiline':False]['text':' length to make it hard to hit that case.','line_number':194,'multiline':False]['text':' Unfortunately, we just have a string type name, not the full structure','line_number':197,'multiline':False]['text':' of a templatized type, so we will have to resort to loose (buggy)','line_number':198,'multiline':False]['text':' pattern matching.','line_number':199,'multiline':False]['text':'','line_number':200,'multiline':False]['text':' Currently, the simplest ways I know of to break this are:','line_number':201,'multiline':False]['text':'','line_number':202,'multiline':False]['text':'   foo<T>::bar<U>','line_number':203,'multiline':False]['text':'   foo<bar<T,U>>','line_number':204,'multiline':False]['text':'','line_number':205,'multiline':False]['text':' "typeName is a (pointer to a)^'typePtrLevel' GC type because it contains a field','line_number':224,'multiline':False]['text':' named 'child' of type 'why' (or pointer to 'why' if fieldPtrLevel == 1), which is','line_number':225,'multiline':False]['text':' itself a GCThing or GCPointer."','line_number':226,'multiline':False]['text':' Some types, like UniquePtr, do not mark/trace/relocate their contained','line_number':229,'multiline':False]['text':' pointers and so should not hold them live across a GC. UniquePtr in','line_number':230,'multiline':False]['text':' particular should be the only thing pointing to a structure containing a','line_number':231,'multiline':False]['text':' GCPointer, so nothing else can possibly trace it and it'll die when the','line_number':232,'multiline':False]['text':' UniquePtr goes out of scope. So we say that memory pointed to by a','line_number':233,'multiline':False]['text':' UniquePtr is just as unsafe as the stack for storing GC pointers.','line_number':234,'multiline':False]['text':' The UniquePtr itself is on the stack but when you dereference the','line_number':236,'multiline':False]['text':' contained pointer, you get to the unsafe memory that we are treating','line_number':237,'multiline':False]['text':' as if it were the stack (aka ptrLevel 0). Note that','line_number':238,'multiline':False]['text':' UniquePtr<UniquePtr<JSObject*>> is fine, so we don't want to just','line_number':239,'multiline':False]['text':' hardcode the ptrLevel.','line_number':240,'multiline':False]['text':' Example: with:','line_number':244,'multiline':False]['text':'    struct Pair { JSObject* foo; int bar; };','line_number':245,'multiline':False]['text':'    struct { Pair** info }***','line_number':246,'multiline':False]['text':' make a call to:','line_number':247,'multiline':False]['text':'    child='info' typePtrLevel=3 fieldPtrLevel=2','line_number':248,'multiline':False]['text':' for a final ptrLevel of 5, used to later call:','line_number':249,'multiline':False]['text':'    child='foo' typePtrLevel=5 fieldPtrLevel=1','line_number':250,'multiline':False]['text':'','line_number':251,'multiline':False]['text':' ...except when > 2 levels of pointers away from an actual GC thing, stop','line_number':254,'multiline':False]['text':' searching the graph. (This would just be > 1, except that a UniquePtr','line_number':255,'multiline':False]['text':' field might still have a GC pointer.)','line_number':256,'multiline':False]['text':' Call a function for a type and every type that contains the type in a field','line_number':312,'multiline':False]['text':' or as a base class (which internally is pretty much the same thing --','line_number':313,'multiline':False]['text':' subclasses are structs beginning with the base class and adding on their','line_number':314,'multiline':False]['text':' local fields.)','line_number':315,'multiline':False]['text':' Redirect output to the typeInfo file and close the gcTypes file.','line_number':388,'multiline':False]['text':' Compute the set of types that suppress GC within their RAII scopes (eg','line_number':391,'multiline':False]['text':' AutoSuppressGC, AutoSuppressGCForAnalysis).','line_number':392,'multiline':False]