['text':' Copyright 2019 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]['text':' Use of this source code is governed by a BSD-style license that can be','line_number':2,'multiline':False]['text':' found in the LICENSE file.','line_number':3,'multiline':False]['text':' Trie-Node for storing bytecode sequences we want to optimize.','line_number':46,'multiline':False]['text':' Dummy bytecode used when we need to store/return a bytecode but it's not a','line_number':49,'multiline':False]['text':' valid bytecode in the current context.','line_number':50,'multiline':False]['text':' Adds a new node as child of the current node if it isn't a child already.','line_number':54,'multiline':False]['text':' Marks the end of a sequence and sets optimized bytecode to replace all','line_number':56,'multiline':False]['text':' bytecodes of the sequence with.','line_number':57,'multiline':False]['text':' Maps arguments of bytecodes in the sequence to the optimized bytecode.','line_number':59,'multiline':False]['text':' Order of invocation determines order of arguments in the optimized','line_number':60,'multiline':False]['text':' bytecode.','line_number':61,'multiline':False]['text':' Invoking this method is only allowed on nodes that mark the end of a valid','line_number':62,'multiline':False]['text':' sequence (i.e. after ReplaceWith()).','line_number':63,'multiline':False]['text':' bytecode_index_in_sequence: Zero-based index of the referred bytecode','line_number':64,'multiline':False]['text':' within the sequence (e.g. the bytecode passed to CreateSequence() has','line_number':65,'multiline':False]['text':' index 0).','line_number':66,'multiline':False]['text':' argument_offset: Zero-based offset to the argument within the bytecode','line_number':67,'multiline':False]['text':' (e.g. the first argument that's not packed with the bytecode has offset 4).','line_number':68,'multiline':False]['text':' argument_byte_length: Length of the argument.','line_number':69,'multiline':False]['text':' new_argument_byte_length: Length of the argument in the new bytecode','line_number':70,'multiline':False]['text':' (= argument_byte_length if omitted).','line_number':71,'multiline':False]['text':' Adds a check to the sequence node making it only a valid sequence when the','line_number':76,'multiline':False]['text':' argument of the current bytecode at the specified offset matches the offset','line_number':77,'multiline':False]['text':' to check against.','line_number':78,'multiline':False]['text':' argument_offset: Zero-based offset to the argument within the bytecode','line_number':79,'multiline':False]['text':' (e.g. the first argument that's not packed with the bytecode has offset 4).','line_number':80,'multiline':False]['text':' argument_byte_length: Length of the argument.','line_number':81,'multiline':False]['text':' check_byte_offset: Zero-based offset relative to the beginning of the','line_number':82,'multiline':False]['text':' sequence that needs to match the value given by argument_offset. (e.g.','line_number':83,'multiline':False]['text':' check_byte_offset 0 matches the address of the first bytecode in the','line_number':84,'multiline':False]['text':' sequence).','line_number':85,'multiline':False]['text':' Adds a check to the sequence node making it only a valid sequence when the','line_number':89,'multiline':False]['text':' argument of the current bytecode at the specified offset matches the','line_number':90,'multiline':False]['text':' argument of another bytecode in the sequence.','line_number':91,'multiline':False]['text':' This is similar to IfArgumentEqualsOffset, except that this method matches','line_number':92,'multiline':False]['text':' the values of both arguments.','line_number':93,'multiline':False]['text':' Marks an argument as unused.','line_number':98,'multiline':False]['text':' All arguments that are not mapped explicitly have to be marked as unused.','line_number':99,'multiline':False]['text':' bytecode_index_in_sequence: Zero-based index of the referred bytecode','line_number':100,'multiline':False]['text':' within the sequence (e.g. the bytecode passed to CreateSequence() has','line_number':101,'multiline':False]['text':' index 0).','line_number':102,'multiline':False]['text':' argument_offset: Zero-based offset to the argument within the bytecode','line_number':103,'multiline':False]['text':' (e.g. the first argument that's not packed with the bytecode has offset 4).','line_number':104,'multiline':False]['text':' argument_byte_length: Length of the argument.','line_number':105,'multiline':False]['text':' Checks if the current node is valid for the sequence. I.e. all conditions','line_number':109,'multiline':False]['text':' set by IfArgumentEqualsOffset and IfArgumentEquals are fulfilled by this','line_number':110,'multiline':False]['text':' node for the actual bytecode sequence.','line_number':111,'multiline':False]['text':' Returns whether this node marks the end of a valid sequence (i.e. can be','line_number':113,'multiline':False]['text':' replaced with an optimized bytecode).','line_number':114,'multiline':False]['text':' Returns the length of the sequence in bytes.','line_number':116,'multiline':False]['text':' Returns the optimized bytecode for the node or kDummyBytecode if it is not','line_number':118,'multiline':False]['text':' the end of a valid sequence.','line_number':119,'multiline':False]['text':' Returns the child of the current node matching the given bytecode or','line_number':121,'multiline':False]['text':' nullptr if no such child is found.','line_number':122,'multiline':False]['text':' Returns number of arguments mapped to the current node.','line_number':124,'multiline':False]['text':' Invoking this method is only allowed on nodes that mark the end of a valid','line_number':125,'multiline':False]['text':' sequence (i.e. if IsSequence())','line_number':126,'multiline':False]['text':' Returns the argument-mapping of the argument at index.','line_number':128,'multiline':False]['text':' Invoking this method is only allowed on nodes that mark the end of a valid','line_number':129,'multiline':False]['text':' sequence (i.e. if IsSequence())','line_number':130,'multiline':False]['text':' Returns an iterator to begin of ignored arguments.','line_number':132,'multiline':False]['text':' Invoking this method is only allowed on nodes that mark the end of a valid','line_number':133,'multiline':False]['text':' sequence (i.e. if IsSequence())','line_number':134,'multiline':False]['text':' Returns an iterator to end of ignored arguments.','line_number':136,'multiline':False]['text':' Invoking this method is only allowed on nodes that mark the end of a valid','line_number':137,'multiline':False]['text':' sequence (i.e. if IsSequence())','line_number':138,'multiline':False]['text':' Returns whether the current node has ignored argument or not.','line_number':140,'multiline':False]['text':' Returns a node in the sequence specified by its index within the sequence.','line_number':144,'multiline':False]['text':' These definitions are here in order to please the linker, which in debug mode','line_number':161,'multiline':False]['text':' sometimes requires static constants to be defined in .cc files.','line_number':162,'multiline':False]['text':' Parses bytecode and fills the internal buffer with the potentially','line_number':170,'multiline':False]['text':' optimized bytecode. Returns true when optimizations were performed, false','line_number':171,'multiline':False]['text':' otherwise.','line_number':172,'multiline':False]['text':' Copies the internal bytecode buffer to another buffer. The caller is','line_number':174,'multiline':False]['text':' responsible for allocating/freeing the memory.','line_number':175,'multiline':False]['text':' Sets up all sequences that are going to be used.','line_number':180,'multiline':False]['text':' Starts a new bytecode sequence.','line_number':182,'multiline':False]['text':' Checks for optimization candidates at pc and emits optimized bytecode to','line_number':184,'multiline':False]['text':' the internal buffer. Returns the length of replaced bytecodes in bytes.','line_number':185,'multiline':False]['text':' Emits optimized bytecode to the internal buffer. start_pc points to the','line_number':188,'multiline':False]['text':' start of the sequence in bytecode and last_node is the last','line_number':189,'multiline':False]['text':' BytecodeSequenceNode of the matching sequence found.','line_number':190,'multiline':False]['text':' Adds a relative jump source fixup at pos.','line_number':193,'multiline':False]['text':' Jump source fixups are used to find offsets in the new bytecode that','line_number':194,'multiline':False]['text':' contain jump sources.','line_number':195,'multiline':False]['text':' Adds a relative jump destination fixup at pos.','line_number':197,'multiline':False]['text':' Jump destination fixups are used to find offsets in the new bytecode that','line_number':198,'multiline':False]['text':' can be jumped to.','line_number':199,'multiline':False]['text':' Sets an absolute jump destination fixup at pos.','line_number':201,'multiline':False]['text':' Prepare internal structures used to fixup jumps.','line_number':203,'multiline':False]['text':' Updates all jump targets in the new bytecode.','line_number':205,'multiline':False]['text':' Update a single jump.','line_number':207,'multiline':False]['text':' Jumps used in old bytecode.','line_number':223,'multiline':False]['text':' Key: Jump source (offset where destination is stored in old bytecode)','line_number':224,'multiline':False]['text':' Value: Destination','line_number':225,'multiline':False]['text':' Jumps used in new bytecode.','line_number':227,'multiline':False]['text':' Key: Jump source (offset where destination is stored in new bytecode)','line_number':228,'multiline':False]['text':' Value: Destination','line_number':229,'multiline':False]['text':' Number of times a jump destination is used within the bytecode.','line_number':231,'multiline':False]['text':' Key: Jump destination (offset in old bytecode).','line_number':232,'multiline':False]['text':' Value: Number of times jump destination is used.','line_number':233,'multiline':False]['text':' Maps offsets in old bytecode to fixups of sources (delta to new bytecode).','line_number':235,'multiline':False]['text':' Key: Offset in old bytecode from where the fixup is valid.','line_number':236,'multiline':False]['text':' Value: Delta to map jump source from old bytecode to new bytecode in bytes.','line_number':237,'multiline':False]['text':' Maps offsets in old bytecode to fixups of destinations (delta to new','line_number':239,'multiline':False]['text':' bytecode).','line_number':240,'multiline':False]['text':' Key: Offset in old bytecode from where the fixup is valid.','line_number':241,'multiline':False]['text':' Value: Delta to map jump destinations from old bytecode to new bytecode in','line_number':242,'multiline':False]['text':' bytes.','line_number':243,'multiline':False]['text':' If node is not the first in the sequence, set offsets and parent.','line_number':291,'multiline':False]['text':' Sentinel fixups at beginning of bytecode (position -1) so we don't have to','line_number':484,'multiline':False]['text':' check for end of iterator inside the fixup loop.','line_number':485,'multiline':False]['text':' In general fixups are deltas of original offsets of jump','line_number':486,'multiline':False]['text':' sources/destinations (in the old bytecode) to find them in the new','line_number':487,'multiline':False]['text':' bytecode. All jump targets are fixed after the new bytecode is fully','line_number':488,'multiline':False]['text':' emitted in the internal buffer.','line_number':489,'multiline':False]['text':' Sentinel fixups at end of (old) bytecode so we don't have to check for','line_number':491,'multiline':False]['text':' end of iterator inside the fixup loop.','line_number':492,'multiline':False]['text':' Commonly used sequences can be found by creating regexp bytecode traces','line_number':498,'multiline':False]['text':' (--trace-regexp-bytecodes) and using v8/tools/regexp-sequences.py.','line_number':499,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':503,'multiline':False]['text':' first bytecode in this sequence.','line_number':504,'multiline':False]['text':' load offset','line_number':507,'multiline':False]['text':' advance by','line_number':508,'multiline':False]['text':' bit table','line_number':509,'multiline':False]['text':' goto when match','line_number':510,'multiline':False]['text':' goto on failure','line_number':511,'multiline':False]['text':' loop jump','line_number':512,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':518,'multiline':False]['text':' first bytecode in this sequence.','line_number':519,'multiline':False]['text':' load offset','line_number':522,'multiline':False]['text':' advance_by','line_number':523,'multiline':False]['text':' c','line_number':524,'multiline':False]['text':' eats at least','line_number':525,'multiline':False]['text':' goto when match','line_number':526,'multiline':False]['text':' goto on failure','line_number':527,'multiline':False]['text':' loop jump','line_number':528,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':534,'multiline':False]['text':' first bytecode in this sequence.','line_number':535,'multiline':False]['text':' load offset','line_number':538,'multiline':False]['text':' advance_by','line_number':539,'multiline':False]['text':' c','line_number':540,'multiline':False]['text':' mask','line_number':541,'multiline':False]['text':' eats at least','line_number':542,'multiline':False]['text':' goto when match','line_number':543,'multiline':False]['text':' goto on failure','line_number':544,'multiline':False]['text':' loop jump','line_number':545,'multiline':False]['text':' TODO(pthier): It might make sense for short sequences like this one to only','line_number':547,'multiline':False]['text':' optimize them if the resulting optimization is not longer than the current','line_number':548,'multiline':False]['text':' one. This could be the case if there are jumps inside the sequence and we','line_number':549,'multiline':False]['text':' have to replicate parts of the sequence. A method to mark such sequences','line_number':550,'multiline':False]['text':' might be useful.','line_number':551,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':555,'multiline':False]['text':' first bytecode in this sequence.','line_number':556,'multiline':False]['text':' load offset','line_number':559,'multiline':False]['text':' advance by','line_number':560,'multiline':False]['text':' character','line_number':561,'multiline':False]['text':' goto when match','line_number':562,'multiline':False]['text':' goto on failure','line_number':563,'multiline':False]['text':' loop jump','line_number':564,'multiline':False]['text':' Sequence is only valid if the jump targets of both CHECK_CHAR bytecodes','line_number':569,'multiline':False]['text':' are equal.','line_number':570,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':573,'multiline':False]['text':' first bytecode in this sequence.','line_number':574,'multiline':False]['text':' load offset','line_number':577,'multiline':False]['text':' advance by','line_number':578,'multiline':False]['text':' character 1','line_number':579,'multiline':False]['text':' character 2','line_number':580,'multiline':False]['text':' goto when match','line_number':581,'multiline':False]['text':' goto on failure','line_number':582,'multiline':False]['text':' goto when match 2','line_number':583,'multiline':False]['text':' loop jump','line_number':584,'multiline':False]['text':' Sequence is only valid if the jump target of CHECK_GT is the first','line_number':588,'multiline':False]['text':' bytecode AFTER the whole sequence.','line_number':589,'multiline':False]['text':' Sequence is only valid if the jump target of CHECK_BIT_IN_TABLE is','line_number':592,'multiline':False]['text':' the ADVANCE_CP_AND_GOTO bytecode at the end of the sequence.','line_number':593,'multiline':False]['text':' Sequence is only valid if the jump target of GOTO is the same as the','line_number':596,'multiline':False]['text':' jump target of CHECK_GT (i.e. both jump to the first bytecode AFTER the','line_number':597,'multiline':False]['text':' whole sequence.','line_number':598,'multiline':False]['text':' Sequence is only valid if the jump target of ADVANCE_CP_AND_GOTO is the','line_number':601,'multiline':False]['text':' first bytecode in this sequence.','line_number':602,'multiline':False]['text':' load offset','line_number':605,'multiline':False]['text':' advance by','line_number':606,'multiline':False]['text':' character','line_number':607,'multiline':False]['text':' bit table','line_number':608,'multiline':False]['text':' goto when match','line_number':609,'multiline':False]['text':' goto on failure','line_number':610,'multiline':False]['text':' indirect loop jump','line_number':611,'multiline':False]['text':' jump out of loop','line_number':612,'multiline':False]['text':' loop jump','line_number':613,'multiline':False]['text':' Check for the longest valid sequence matching any of the pre-defined','line_number':662,'multiline':False]['text':' sequences in the Trie data structure.','line_number':663,'multiline':False]['text':' Jump sources that are mapped or marked as unused will be deleted at the end','line_number':686,'multiline':False]['text':' of this method. We don't delete them immediately as we might need the','line_number':687,'multiline':False]['text':' information when we have to preserve bytecodes at the end.','line_number':688,'multiline':False]['text':' TODO(pthier): Replace with a stack-allocated data structure.','line_number':689,'multiline':False]['text':' If we map any jump source we mark the old source for deletion and insert','line_number':698,'multiline':False]['text':' a new jump.','line_number':699,'multiline':False]['text':' Add new jump edge add current position.','line_number':704,'multiline':False]['text':' Mark old jump edge for deletion.','line_number':706,'multiline':False]['text':' Decrement usage count of jump destination.','line_number':708,'multiline':False]['text':' TODO(pthier): DCHECK that mapped arguments are never sources of jumps','line_number':714,'multiline':False]['text':' to destinations inside the sequence.','line_number':715,'multiline':False]['text':' Remove jumps from arguments we ignore.','line_number':721,'multiline':False]['text':' Mark old jump edge for deletion.','line_number':729,'multiline':False]['text':' Decrement usage count of jump destination.','line_number':731,'multiline':False]['text':' Check if there are any jumps inside the old sequence.','line_number':742,'multiline':False]['text':' If so we have to keep the bytecodes that are jumped to around.','line_number':743,'multiline':False]['text':' Jump destinations only jumped to from inside the sequence will be ignored.','line_number':747,'multiline':False]['text':' Check if any jump in the sequence we are preserving has a jump','line_number':759,'multiline':False]['text':' destination inside the optimized sequence before the current position we','line_number':760,'multiline':False]['text':' want to preserve. If so we have to preserve all bytecodes starting at','line_number':761,'multiline':False]['text':' this jump destination.','line_number':762,'multiline':False]['text':' jump source ','line_number':765,'multiline':True]['text':' We preserve everything to the end of the sequence. This is conservative','line_number':774,'multiline':False]['text':' since it would be enough to preserve all bytecudes up to an unconditional','line_number':775,'multiline':False]['text':' jump.','line_number':776,'multiline':False]['text':' Jumps after the start of the preserved sequence need fixup.','line_number':779,'multiline':False]['text':' All jump targets after the start of the optimized sequence need to be','line_number':782,'multiline':False]['text':' fixed relative to the length of the optimized sequence including','line_number':783,'multiline':False]['text':' bytecodes we preserved.','line_number':784,'multiline':False]['text':' Jumps to the sequence we preserved need absolute fixup as they could','line_number':786,'multiline':False]['text':' occur before or after the sequence.','line_number':787,'multiline':False]['text':' Jumps after the end of the old sequence need fixup.','line_number':792,'multiline':False]['text':' Delete jumps we definitely don't need anymore','line_number':796,'multiline':False]['text':' Next position where fixup changes.','line_number':845,'multiline':False]['text':' Mapped jump edges don't need source fixups, as the position already is an','line_number':864,'multiline':False]['text':' offset in the new bytecode.','line_number':865,'multiline':False]['text':' TODO(pthier): This check could be better if we track the bytecodes','line_number':880,'multiline':False]['text':' actually used and check if we jump to one of them.','line_number':881,'multiline':False]['text':' Length 3 only occurs in 'packed' arguments where the lowermost byte is','line_number':945,'multiline':False]['text':' the current bytecode, and the remaining 3 bytes are the packed value.','line_number':946,'multiline':False]['text':'','line_number':947,'multiline':False]['text':' We load 4 bytes from position - 1 and shift out the bytecode.','line_number':948,'multiline':False]['text':' V8_TARGET_BIG_ENDIAN','line_number':954,'multiline':False]['text':' Pack with previously emitted value.','line_number':961,'multiline':False]['text':' V8_TARGET_BIG_ENDIAN','line_number':973,'multiline':False]['text':' namespace','line_number':1007,'multiline':False]['text':' static','line_number':1009,'multiline':False]['text':' namespace internal','line_number':1029,'multiline':False]['text':' namespace v8','line_number':1030,'multiline':False]