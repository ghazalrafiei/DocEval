['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' shared','line_number':38,'multiline':False]['text':' Skip past trivial blocks.','line_number':78,'multiline':False]['text':' All non-table-based bailouts will go here.','line_number':187,'multiline':False]['text':' Push the frame size, so the handler can recover the IonScript.','line_number':190,'multiline':False]['text':' Frame size is stored in 'ra' and pushed by GenerateBailoutThunk','line_number':191,'multiline':False]['text':' We have to use 'ra' because generateBailoutTable will implicitly do','line_number':192,'multiline':False]['text':' the same.','line_number':193,'multiline':False]['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':209,'multiline':False]['text':' the known value makes sense. We can't use bailout tables if the stack','line_number':210,'multiline':False]['text':' isn't properly aligned to the static frame size.','line_number':211,'multiline':False]['text':' We don't use table bailouts because retargeting is easier this way.','line_number':215,'multiline':False]['text':' If there is no snapshot, we don't need to check for overflow','line_number':264,'multiline':False]['text':' If there is no snapshot, we don't need to check for overflow','line_number':307,'multiline':False]['text':' Bailout on -0.0','line_number':356,'multiline':False]['text':' If it cannot overflow, we can do lots of optimizations.','line_number':392,'multiline':False]['text':' See if the constant has one bit set, meaning it can be','line_number':395,'multiline':False]['text':' encoded as a bitshift.','line_number':396,'multiline':False]['text':' If the constant cannot be encoded as (1<<C1), see if it can','line_number':402,'multiline':False]['text':' be encoded as (1<<C1) | (1<<C2), which can be computed','line_number':403,'multiline':False]['text':' using an add and a shift.','line_number':404,'multiline':False]['text':' To stay on the safe side, only optimize things that are a','line_number':417,'multiline':False]['text':' power of 2.','line_number':418,'multiline':False]['text':' dest = lhs * pow(2, shift)','line_number':421,'multiline':False]['text':' At runtime, check (lhs == dest >> shift), if this does','line_number':423,'multiline':False]['text':' not hold, some bits were lost due to overflow, and the','line_number':424,'multiline':False]['text':' computation should be resumed as a double.','line_number':425,'multiline':False]['text':' Result is -0 if lhs or rhs is negative.','line_number':459,'multiline':False]['text':' In that case result must be double value so bailout','line_number':460,'multiline':False]['text':' nop','line_number':485,'multiline':False]['text':' Use shift if constant is power of 2.','line_number':501,'multiline':False]['text':' Extract the registers from this instruction','line_number':518,'multiline':False]['text':' Handle divide by zero.','line_number':527,'multiline':False]['text':' Truncated division by zero is zero (Infinity|0 == 0)','line_number':535,'multiline':False]['text':' Handle an integer overflow exception from -2147483648 / -1.','line_number':547,'multiline':False]['text':' (-INT32_MIN)|0 == INT32_MIN','line_number':560,'multiline':False]['text':' Handle negative 0. (0/-Y)','line_number':573,'multiline':False]['text':' Note: above safety checks could not be verified as Ion seems to be','line_number':580,'multiline':False]['text':' smarter and requires double arithmetic in such cases.','line_number':581,'multiline':False]['text':' All regular. Lets call div.','line_number':583,'multiline':False]['text':' If the remainder is going to be != 0, bailout since this must','line_number':611,'multiline':False]['text':' be a double.','line_number':612,'multiline':False]['text':' Numerator is unsigned, so needs no adjusting. Do the shift.','line_number':618,'multiline':False]['text':' Adjust the value so that shifting produces a correctly rounded result','line_number':623,'multiline':False]['text':' when the numerator is negative. See 10-1 "Signed Division by a Known','line_number':624,'multiline':False]['text':' Power of 2" in Henry S. Warren, Jr.'s Hacker's Delight.','line_number':625,'multiline':False]['text':' Do the shift.','line_number':635,'multiline':False]['text':' Extract the registers from this instruction','line_number':643,'multiline':False]['text':' Prevent INT_MIN % -1;','line_number':653,'multiline':False]['text':' The integer division will give INT_MIN, but we want -(double)INT_MIN.','line_number':654,'multiline':False]['text':' (INT_MIN % -1)|0 == 0','line_number':658,'multiline':False]['text':' 0/X (with X < 0) is bad because both of these values *should* be','line_number':671,'multiline':False]['text':' doubles, and the result should be -0.0, which cannot be represented in','line_number':672,'multiline':False]['text':' integers. X/0 is bad because it will give garbage (or abort), when it','line_number':673,'multiline':False]['text':' should give either \infty, -\infty or NAN.','line_number':674,'multiline':False]['text':' Prevent 0 / X (with X < 0) and X / 0','line_number':676,'multiline':False]['text':' testing X / Y.  Compare Y with 0.','line_number':677,'multiline':False]['text':' There are three cases: (Y < 0), (Y == 0) and (Y > 0)','line_number':678,'multiline':False]['text':' If (Y < 0), then we compare X with 0, and bail if X == 0','line_number':679,'multiline':False]['text':' If (Y == 0), then we simply want to bail.','line_number':680,'multiline':False]['text':' if (Y > 0), we don't bail.','line_number':681,'multiline':False]['text':' NaN|0 == 0 and (0 % -X)|0 == 0','line_number':707,'multiline':False]['text':' If X%Y == 0 and X < 0, then we *actually* wanted to return -0.0','line_number':726,'multiline':False]['text':' -0.0|0 == 0','line_number':729,'multiline':False]['text':' See if X < 0','line_number':732,'multiline':False]['text':' Switch based on sign of the lhs.','line_number':748,'multiline':False]['text':' Positive numbers are just a bitmask','line_number':749,'multiline':False]['text':' Negative numbers need a negate, bitmask, negate','line_number':756,'multiline':False]['text':' -0|0 == 0','line_number':768,'multiline':False]['text':' all of these bitops should be either imm32's, or integer registers.','line_number':804,'multiline':False]['text':' x >>> 0 can overflow.','line_number':891,'multiline':False]['text':' The shift amounts should be AND'ed into the 0-31 range','line_number':902,'multiline':False]['text':' x >>> 0 can overflow.','line_number':915,'multiline':False]['text':' Masm.pow(-Infinity, 0.5) == Infinity.','line_number':1056,'multiline':False]['text':' Math.pow(-0, 0.5) == 0 == Math.pow(0, 0.5).','line_number':1064,'multiline':False]['text':' Adding 0 converts any -0 to 0.','line_number':1065,'multiline':False]['text':' Push snapshotOffset and make sure stack is aligned.','line_number':1197,'multiline':False]['text':' Combine.','line_number':1230,'multiline':False]['text':' Manipulate high words of double inputs.','line_number':1244,'multiline':False]['text':' Combine.','line_number':1248,'multiline':False]['text':' If 0, or NaN, the result is false.','line_number':1278,'multiline':False]['text':' If 0, or NaN, the result is false.','line_number':1297,'multiline':False]['text':' See ../CodeGenerator.cpp for more information.','line_number':1375,'multiline':False]['text':' Since this operation is not, we want to set a bit if','line_number':1394,'multiline':False]['text':' the double is falsey, which means 0.0, -0.0 or NaN.','line_number':1395,'multiline':False]['text':' Since this operation is not, we want to set a bit if','line_number':1405,'multiline':False]['text':' the float32 is falsey, which means 0.0, -0.0 or NaN.','line_number':1406,'multiline':False]['text':' Ensure that there is enough space in the buffer for the OsiPoint','line_number':1420,'multiline':False]['text':' patching to occur. Otherwise, we could overwrite the invalidation','line_number':1421,'multiline':False]['text':' epilogue.','line_number':1422,'multiline':False]['text':' Push the return address of the point that we bailed out at to the stack','line_number':1429,'multiline':False]['text':' Push the Ion script onto the stack (when we determine what that','line_number':1432,'multiline':False]['text':' pointer is).','line_number':1433,'multiline':False]['text':' Jump to the invalidator which will replace the current frame.','line_number':1436,'multiline':False]['text':' The entries of the jump table need to be absolute addresses and thus','line_number':1471,'multiline':False]['text':' must be patched after codegen is finished.','line_number':1472,'multiline':False]['text':' Lower value with low value','line_number':1485,'multiline':False]['text':' Jump to default case if input is out of range','line_number':1490,'multiline':False]['text':' To fill in the CodeLabels for the case entries, we need to first','line_number':1494,'multiline':False]['text':' generate the case entries (we don't yet know their offsets in the','line_number':1495,'multiline':False]['text':' instruction stream).','line_number':1496,'multiline':False]['text':' Compute the position where a pointer to the right case stands.','line_number':1500,'multiline':False]['text':' Jump to the right case','line_number':1505,'multiline':False]['text':' Offset is ok, let's load value.','line_number':1664,'multiline':False]['text':' Offset is out of range. Load default values.','line_number':1680,'multiline':False]['text':' Offset is ok, let's store value.','line_number':1784,'multiline':False]['text':' Prevent divide by zero.','line_number':1978,'multiline':False]['text':' Infinity|0 == 0','line_number':1987,'multiline':False]['text':' If the remainder is > 0, bailout since this must be a double.','line_number':2006,'multiline':False]['text':' Get quotient','line_number':2011,'multiline':False]