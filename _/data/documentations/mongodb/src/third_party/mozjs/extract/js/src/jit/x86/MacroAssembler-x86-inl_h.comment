['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'{{{ check_macroassembler_style','line_number':17,'multiline':False]['text':' ===============================================================','line_number':108,'multiline':False]['text':' Load instructions','line_number':109,'multiline':False]['text':' ===============================================================','line_number':115,'multiline':False]['text':' Logical functions','line_number':116,'multiline':False]['text':' ===============================================================','line_number':174,'multiline':False]['text':' Swap instructions','line_number':175,'multiline':False]['text':' ===============================================================','line_number':183,'multiline':False]['text':' Arithmetic functions','line_number':184,'multiline':False]['text':' Note: this function clobbers eax and edx.','line_number':274,'multiline':False]['text':' LOW32  = LOW(LOW(dest) * LOW(imm));','line_number':276,'multiline':False]['text':' HIGH32 = LOW(HIGH(dest) * LOW(imm)) [multiply imm into upper bits]','line_number':277,'multiline':False]['text':'        + LOW(LOW(dest) * HIGH(imm)) [multiply dest into upper bits]','line_number':278,'multiline':False]['text':'        + HIGH(LOW(dest) * LOW(imm)) [carry]','line_number':279,'multiline':False]['text':' HIGH(dest) = LOW(HIGH(dest) * LOW(imm));','line_number':284,'multiline':False]['text':' edx:eax = LOW(dest) * LOW(imm);','line_number':288,'multiline':False]['text':' HIGH(dest) += edx;','line_number':293,'multiline':False]['text':' HIGH(dest) += LOW(LOW(dest) * HIGH(imm));','line_number':296,'multiline':False]['text':' LOW(dest) = eax;','line_number':304,'multiline':False]['text':' LOW32  = LOW(LOW(dest) * LOW(src));                                  (1)','line_number':310,'multiline':False]['text':' HIGH32 = LOW(HIGH(dest) * LOW(src)) [multiply src into upper bits]   (2)','line_number':311,'multiline':False]['text':'        + LOW(LOW(dest) * HIGH(src)) [multiply dest into upper bits]  (3)','line_number':312,'multiline':False]['text':'        + HIGH(LOW(dest) * LOW(src)) [carry]                          (4)','line_number':313,'multiline':False]['text':' Compute mul64','line_number':320,'multiline':False]['text':' (2)','line_number':321,'multiline':False]['text':' (3)','line_number':322,'multiline':False]['text':', dest.low','line_number':325,'multiline':True]['text':' (4) + (1) output in edx:eax','line_number':325,'multiline':False]['text':' (dest_hi:dest_lo)','line_number':326,'multiline':False]['text':' LOW32  = LOW(LOW(dest) * LOW(src));                                  (1)','line_number':332,'multiline':False]['text':' HIGH32 = LOW(HIGH(dest) * LOW(src)) [multiply src into upper bits]   (2)','line_number':333,'multiline':False]['text':'        + LOW(LOW(dest) * HIGH(src)) [multiply dest into upper bits]  (3)','line_number':334,'multiline':False]['text':'        + HIGH(LOW(dest) * LOW(src)) [carry]                          (4)','line_number':335,'multiline':False]['text':' Make sure the rhs.high isn't the dest.high register anymore.','line_number':340,'multiline':False]['text':' This saves us from doing other register moves.','line_number':341,'multiline':False]['text':' Compute mul64','line_number':344,'multiline':False]['text':' (2)','line_number':345,'multiline':False]['text':' (3)','line_number':346,'multiline':False]['text':', dest.low','line_number':349,'multiline':True]['text':' (4) + (1) output in edx:eax','line_number':349,'multiline':False]['text':' (dest_hi:dest_lo)','line_number':350,'multiline':False]['text':' ===============================================================','line_number':380,'multiline':False]['text':' Shift functions','line_number':381,'multiline':False]['text':' 32 - 63 bit shift','line_number':422,'multiline':False]['text':' 32 - 63 bit shift','line_number':468,'multiline':False]['text':' 32 - 63 bit shift','line_number':505,'multiline':False]['text':' ===============================================================','line_number':512,'multiline':False]['text':' Rotation functions','line_number':513,'multiline':False]['text':' ===============================================================','line_number':583,'multiline':False]['text':' Bit counting functions','line_number':584,'multiline':False]['text':' Because |dest| may be equal to |src.low|, we rely on BSR not modifying its','line_number':604,'multiline':False]['text':' output when the input is zero. AMD ISA documents BSR not modifying the','line_number':605,'multiline':False]['text':' output and current Intel CPUs follow AMD.','line_number':606,'multiline':False]['text':' Because |dest| may be equal to |src.low|, we rely on BSF not modifying its','line_number':642,'multiline':False]['text':' output when the input is zero. AMD ISA documents BSF not modifying the','line_number':643,'multiline':False]['text':' output and current Intel CPUs follow AMD.','line_number':644,'multiline':False]['text':' The tmp register is only needed if there is no native POPCNT.','line_number':662,'multiline':False]['text':' ===============================================================','line_number':679,'multiline':False]['text':' Condition functions','line_number':680,'multiline':False]['text':' ===============================================================','line_number':688,'multiline':False]['text':' Branch functions','line_number':689,'multiline':False]['text':' vcvttss2si returns 0x80000000 on failure. Test for it by','line_number':903,'multiline':False]['text':' subtracting 1 and testing overflow (this permits the use of a','line_number':904,'multiline':False]['text':' smaller immediate field).','line_number':905,'multiline':False]['text':' TODO: X64 supports supports integers up till 64bits. Here we only support','line_number':918,'multiline':False]['text':' 32bits, before failing. Implementing this for x86 might give a x86 kraken','line_number':919,'multiline':False]['text':' win.','line_number':920,'multiline':False]['text':' vcvttsd2si returns 0x80000000 on failure. Test for it by','line_number':928,'multiline':False]['text':' subtracting 1 and testing overflow (this permits the use of a','line_number':929,'multiline':False]['text':' smaller immediate field).','line_number':930,'multiline':False]['text':' ========================================================================','line_number':1108,'multiline':False]['text':' SIMD','line_number':1109,'multiline':False]['text':' SSE4.1','line_number':1114,'multiline':False]['text':' ========================================================================','line_number':1137,'multiline':False]['text':' Truncate floating point.','line_number':1138,'multiline':False]['text':' For unsigned conversion the case of [INT64, UINT64] needs to get handle','line_number':1149,'multiline':False]['text':' seperately.','line_number':1150,'multiline':False]['text':' Move the value inside INT64 range.','line_number':1154,'multiline':False]['text':' For unsigned conversion the case of [INT64, UINT64] needs to get handle','line_number':1177,'multiline':False]['text':' seperately.','line_number':1178,'multiline':False]['text':' Move the value inside INT64 range.','line_number':1182,'multiline':False]['text':'}}} check_macroassembler_style','line_number':1233,'multiline':False]['text':' ===============================================================','line_number':1234,'multiline':False]['text':' Note: this function clobbers the source register.','line_number':1236,'multiline':False]['text':' src is [0, 2^32-1]','line_number':1239,'multiline':False]['text':' Now src is [-2^31, 2^31-1] - int range, but not the same value.','line_number':1242,'multiline':False]['text':' dest is now a double with the int range.','line_number':1245,'multiline':False]['text':' correct the double value by adding 0x80000000.','line_number':1246,'multiline':False]['text':' Note: this function clobbers the source register.','line_number':1250,'multiline':False]['text':' If source is a double, load it into dest. If source is int32,','line_number':1295,'multiline':False]['text':' convert it to double. Else, branch to failure.','line_number':1296,'multiline':False]['text':' namespace jit','line_number':1312,'multiline':False]['text':' namespace js','line_number':1313,'multiline':False]['text':' jit_x86_MacroAssembler_x86_inl_h ','line_number':1315,'multiline':True]