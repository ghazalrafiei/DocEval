['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' JS::shadow::Zone','line_number':17,'multiline':False]['text':' Check whether a weak map entry is marked correctly.','line_number':32,'multiline':False]['text':' namespace gc','line_number':36,'multiline':False]['text':' A subclass template of js::HashMap whose keys and values may be','line_number':38,'multiline':False]['text':' garbage-collected. When a key is collected, the table entry disappears,','line_number':39,'multiline':False]['text':' dropping its reference to the value.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' More precisely:','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':'     A WeakMap entry is live if and only if both the WeakMap and the entry's','line_number':44,'multiline':False]['text':'     key are live. An entry holds a strong reference to its value.','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' You must call this table's 'trace' method when its owning object is reached','line_number':47,'multiline':False]['text':' by the garbage collection tracer. Once a table is known to be live, the','line_number':48,'multiline':False]['text':' implementation takes care of the special weak marking (ie, marking through','line_number':49,'multiline':False]['text':' the implicit edges stored in the map) and of removing (sweeping) table','line_number':50,'multiline':False]['text':' entries when collection is complete.','line_number':51,'multiline':False]['text':' WeakMaps are marked with an incremental linear-time algorithm that handles','line_number':53,'multiline':False]['text':' all orderings of map and key marking. The basic algorithm is:','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' At first while marking, do nothing special when marking WeakMap keys (there','line_number':56,'multiline':False]['text':' is no straightforward way to know whether a particular object is being used','line_number':57,'multiline':False]['text':' as a key in some weakmap.) When a WeakMap is marked, scan through it to mark','line_number':58,'multiline':False]['text':' all entries with live keys, and collect all unmarked keys into a "weak keys"','line_number':59,'multiline':False]['text':' table.','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' At some point, everything reachable has been marked. At this point, enter','line_number':62,'multiline':False]['text':' "weak marking mode". In this mode, whenever any object is marked, look it up','line_number':63,'multiline':False]['text':' in the weak keys table to see if it is the key for any WeakMap entry and if','line_number':64,'multiline':False]['text':' so, mark the value. When entering weak marking mode, scan the weak key table','line_number':65,'multiline':False]['text':' to find all keys that have been marked since we added them to the table, and','line_number':66,'multiline':False]['text':' mark those entries.','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':' In addition, we want weakmap marking to work incrementally. So WeakMap','line_number':69,'multiline':False]['text':' mutations are barriered to keep the weak keys table up to date: entries are','line_number':70,'multiline':False]['text':' removed if their key is removed from the table, etc.','line_number':71,'multiline':False]['text':'','line_number':72,'multiline':False]['text':' You can break down various ways that WeakMap values get marked based on the','line_number':73,'multiline':False]['text':' order that the map and key are marked. All of these assume the map and key','line_number':74,'multiline':False]['text':' get marked at some point:','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':'   key marked, then map marked:','line_number':77,'multiline':False]['text':'    - value was marked with map in `markEntries()`','line_number':78,'multiline':False]['text':'   map marked, key already in map, key marked before weak marking mode:','line_number':79,'multiline':False]['text':'    - key added to gcEphemeronEdges when map marked in `markEntries()`','line_number':80,'multiline':False]['text':'    - value marked during `enterWeakMarkingMode`','line_number':81,'multiline':False]['text':'   map marked, key already in map, key marked after weak marking mode:','line_number':82,'multiline':False]['text':'    - when key is marked, gcEphemeronEdges[key] triggers marking of value in','line_number':83,'multiline':False]['text':'      `markImplicitEdges()`','line_number':84,'multiline':False]['text':'   map marked, key inserted into map, key marked:','line_number':85,'multiline':False]['text':'    - value was live when inserted and must get marked at some point','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' Common base class for all WeakMap specializations, used for calling','line_number':92,'multiline':False]['text':' subclasses' GC-related methods.','line_number':93,'multiline':False]['text':' Garbage collector entry points.','line_number':105,'multiline':False]['text':' Unmark all weak maps in a zone.','line_number':107,'multiline':False]['text':' Trace all the weakmaps in a zone.','line_number':110,'multiline':False]['text':' Check all weak maps in a zone that have been marked as live in this garbage','line_number':113,'multiline':False]['text':' collection, and mark the values of all entries that have become strong','line_number':114,'multiline':False]['text':' references to them. Return true if we marked any new values, indicating','line_number':115,'multiline':False]['text':' that we need to make another pass. In other words, mark my marked maps'','line_number':116,'multiline':False]['text':' marked members' mid-collection.','line_number':117,'multiline':False]['text':' Add zone edges for weakmaps with key delegates in a different zone.','line_number':120,'multiline':False]['text':' Sweep the weak maps in a zone, removing dead weak maps and removing','line_number':123,'multiline':False]['text':' entries of live weak maps whose keys are dead.','line_number':124,'multiline':False]['text':' Sweep the marked weak maps in a zone, updating moved keys.','line_number':127,'multiline':False]['text':' Trace all weak map bindings. Used by the cycle collector.','line_number':130,'multiline':False]['text':' Save information about which weak maps are marked for a zone.','line_number':133,'multiline':False]['text':' Restore information about which weak maps are marked for many zones.','line_number':137,'multiline':False]['text':' Instance member functions called by the above. Instantiations of WeakMap','line_number':145,'multiline':False]['text':' override these with definitions appropriate for their Key and Value types.','line_number':146,'multiline':False]['text':' We have a key that, if it or its delegate is marked, may lead to a WeakMap','line_number':153,'multiline':False]['text':' value getting marked. Insert it or its delegate (if any) into the','line_number':154,'multiline':False]['text':' appropriate zone's gcEphemeronEdges or gcNurseryEphemeronEdges.','line_number':155,'multiline':False]['text':' Any weakmap key types that want to participate in the non-iterative','line_number':159,'multiline':False]['text':' ephemeron marking must override this method.','line_number':160,'multiline':False]['text':' Object that this weak map is part of, if any.','line_number':172,'multiline':False]['text':' Zone containing this weak map.','line_number':175,'multiline':False]['text':' Whether this object has been marked during garbage collection and which','line_number':178,'multiline':False]['text':' color it was marked.','line_number':179,'multiline':False]['text':' namespace detail','line_number':195,'multiline':False]['text':' Resolve ambiguity with LinkedListElement<>::remove.','line_number':219,'multiline':False]['text':' Add a read barrier to prevent an incorrectly gray value from escaping the','line_number':226,'multiline':False]['text':' weak map. See the UnmarkGrayTracer::onChild comment in gc/Marking.cpp.','line_number':227,'multiline':False]['text':' Find sweep group edges for delegates, if the key type has delegates. (If','line_number':298,'multiline':False]['text':' not, the optimizer should make this a nop.)','line_number':299,'multiline':False]['text':'*
   * If a wrapper is used as a key in a weakmap, the garbage collector should
   * keep that object around longer than it otherwise would. We want to avoid
   * collecting the wrapper (and removing the weakmap entry) as long as the
   * wrapped object is alive (because the object can be rewrapped and looked up
   * again). As long as the wrapper is used as a weakmap key, it will not be
   * collected (and remain in the weakmap) until the wrapped object is
   * collected.
   ','line_number':302,'multiline':True]['text':' memberOf can be nullptr, which means that the map is not part of a','line_number':326,'multiline':False]['text':' JSObject.','line_number':327,'multiline':False]['text':' Generic weak map for mapping objects to other objects.','line_number':347,'multiline':False]['text':' namespace js ','line_number':374,'multiline':True]['text':' gc_WeakMap_h ','line_number':376,'multiline':True]