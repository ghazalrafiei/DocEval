['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]['text':' JSMSG_*','line_number':25,'multiline':False]['text':' Note: Be careful to order operators such that we first make the','line_number':77,'multiline':False]['text':' value smaller and then larger, so that we don't get false','line_number':78,'multiline':False]['text':' overflow errors due to (e.g.) adding `align` and then','line_number':79,'multiline':False]['text':' subtracting `1` afterwards when merely adding `align-1` would','line_number':80,'multiline':False]['text':' not have overflowed. Note that due to the nature of two's','line_number':81,'multiline':False]['text':' complement representation, if `address` is already aligned,','line_number':82,'multiline':False]['text':' then adding `align-1` cannot itself cause an overflow.','line_number':83,'multiline':False]['text':' The field adders return the offset of the the field.','line_number':93,'multiline':False]['text':' Alignment of the struct is the max of the alignment of its fields.','line_number':98,'multiline':False]['text':' Align the pointer.','line_number':101,'multiline':False]['text':' Allocate space.','line_number':107,'multiline':False]['text':' The close method rounds up the structure size to the appropriate','line_number':116,'multiline':False]['text':' alignment and returns that size.','line_number':117,'multiline':False]['text':' kind_ was replaced -- call in-place constructors for union members.','line_number':204,'multiline':False]['text':' Anything's equal to itself.','line_number':245,'multiline':False]['text':' Two references must have the same nullability to be equal','line_number':252,'multiline':False]['text':' Non type-index references are equal if they have the same kind','line_number':257,'multiline':False]['text':' Type-index references can be equal','line_number':262,'multiline':False]['text':' Anything's equal to itself.','line_number':276,'multiline':False]['text':' A struct may be equal to a struct','line_number':283,'multiline':False]['text':' An array may be equal to an array','line_number':288,'multiline':False]['text':' Structs must have the same number of fields to be equal','line_number':309,'multiline':False]['text':' Assume these structs are equal while checking fields. If any field is','line_number':314,'multiline':False]['text':' not equal then we remove the assumption.','line_number':315,'multiline':False]['text':' Struct fields must share the same mutability to equal','line_number':334,'multiline':False]['text':' Struct field types must be equal','line_number':338,'multiline':False]['text':' Assume these arrays are equal while checking fields. If the array','line_number':351,'multiline':False]['text':' element is not equal then we remove the assumption.','line_number':352,'multiline':False]['text':' Array elements must share the same mutability to be equal','line_number':367,'multiline':False]['text':' Array elements must be equal','line_number':371,'multiline':False]['text':' Anything's a subtype of itself.','line_number':378,'multiline':False]['text':' A subtype must have the same nullability as the supertype or the','line_number':385,'multiline':False]['text':' supertype must be nullable.','line_number':386,'multiline':False]['text':' Non type-index references are subtypes if they have the same kind','line_number':391,'multiline':False]['text':' Structs are subtypes of eqref','line_number':396,'multiline':False]['text':' Arrays are subtypes of eqref','line_number':401,'multiline':False]['text':' Type-index references can be subtypes','line_number':406,'multiline':False]['text':' Anything's a subtype of itself.','line_number':420,'multiline':False]['text':' Structs may be subtypes of structs','line_number':427,'multiline':False]['text':' Arrays may be subtypes of arrays','line_number':432,'multiline':False]['text':' A subtype must have at least as many fields as its supertype','line_number':452,'multiline':False]['text':' Assume these structs are subtypes while checking fields. If any field','line_number':457,'multiline':False]['text':' fails a check then we remove the assumption.','line_number':458,'multiline':False]['text':' Mutable fields are invariant w.r.t. field types','line_number':477,'multiline':False]['text':' Immutable fields are covariant w.r.t. field types','line_number':481,'multiline':False]['text':' Assume these arrays are subtypes while checking elements. If the elements','line_number':497,'multiline':False]['text':' fail the check then we remove the assumption.','line_number':498,'multiline':False]['text':' Mutable elements are invariant w.r.t. field types','line_number':513,'multiline':False]['text':' Immutable elements are covariant w.r.t. field types','line_number':517,'multiline':False]