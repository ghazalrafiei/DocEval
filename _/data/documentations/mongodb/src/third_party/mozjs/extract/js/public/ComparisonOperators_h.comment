['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'
 * Support comparison operations on wrapper types -- e.g. |JS::Rooted<T>|,
 * |JS::Handle<T>|, and so on -- against raw |T| values, against pointers or
 * |nullptr| if the wrapper is a pointer wrapper, and against other wrappers
 * around compatible types.
 ','line_number':7,'multiline':True]['text':' std::false_type, std::true_type, std::enable_if_t, std::is_pointer_v, std::remove_pointer_t','line_number':17,'multiline':False]['text':' To define |operator==| and |operator!=| for a wrapper class |W| (which may','line_number':19,'multiline':False]['text':' or may not be a template class) that contains a |T|:','line_number':20,'multiline':False]['text':'','line_number':21,'multiline':False]['text':'   * Specialize |JS::detail::DefineComparisonOps| for |W|:','line_number':22,'multiline':False]['text':'     - Make it inherit from |std::true_type|.','line_number':23,'multiline':False]['text':'     - Include within your specialization a |static get(const W& v)| function','line_number':24,'multiline':False]['text':'       that returns the value (which may be an lvalue reference) of the |T| in','line_number':25,'multiline':False]['text':'       |W|.','line_number':26,'multiline':False]['text':'   * If needed, add |using JS::detail::wrapper_comparison::operator==;| and','line_number':27,'multiline':False]['text':'     |using JS::detail::wrapper_comparison::operator!=;| to the namespace','line_number':28,'multiline':False]['text':'     directly containing |W| at the end of this header.  (If you are not in','line_number':29,'multiline':False]['text':'     SpiderMonkey code and have questionably decided to define your own','line_number':30,'multiline':False]['text':'     wrapper class, add these to its namespace somewhere in your code.)','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' The first step opts the wrapper class into comparison support and defines a','line_number':33,'multiline':False]['text':' generic means of extracting a comparable |T| out of an instance.','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' The second step ensures that symmetric |operator==| and |operator!=| are','line_number':36,'multiline':False]['text':' exposed for the wrapper, accepting two wrappers or a wrapper and a suitable','line_number':37,'multiline':False]['text':' raw value.','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' Failure to perform *both* steps will likely result in errors like','line_number':40,'multiline':False]['text':' 'invalid operands to binary expression' or 'no match for operator=='','line_number':41,'multiline':False]['text':' when comparing an instance of your wrapper.','line_number':42,'multiline':False]['text':' By default, comparison ops are not supported for types.','line_number':48,'multiline':False]['text':' Define functions for the core equality operations, that the actual operators','line_number':52,'multiline':False]['text':' can all invoke.','line_number':53,'multiline':False]['text':' Compare two wrapper types.  Assumes both wrapper types support comparison','line_number':55,'multiline':False]['text':' operators.','line_number':56,'multiline':False]['text':' Compare a wrapper against a value of its unwrapped element type (or against a','line_number':63,'multiline':False]['text':' value that implicitly converts to that unwrapped element type).  Assumes its','line_number':64,'multiline':False]['text':' wrapper argument supports comparison operators.','line_number':65,'multiline':False]['text':' Compare a wrapper containing a pointer against a pointer to const element','line_number':72,'multiline':False]['text':' type.  Assumes its wrapper argument supports comparison operators.','line_number':73,'multiline':False]['text':' It is idiomatic C++ to define operators on user-defined types in the','line_number':81,'multiline':False]['text':' namespace of their operands' types (not at global scope, which isn't examined','line_number':82,'multiline':False]['text':' if at point of operator use another operator definition shadows the global','line_number':83,'multiline':False]['text':' definition).  But our wrappers live in *multiple* namespaces (|namespace js|','line_number':84,'multiline':False]['text':' and |namespace JS| in SpiderMonkey), so we can't literally do that without','line_number':85,'multiline':False]['text':' defining ambiguous overloads.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' Instead, we define the operators *once* in a namespace containing nothing','line_number':88,'multiline':False]['text':' else at all.  Then we |using| the operators into each namespace containing','line_number':89,'multiline':False]['text':' a wrapper type.  |using| creates *aliases*, so two |using|s of the same','line_number':90,'multiline':False]['text':' operator contribute only one overload to overload resolution.','line_number':91,'multiline':False]['text':' Comparisons between potentially-differing wrappers.','line_number':94,'multiline':False]['text':' Comparisons between a wrapper and its unwrapped element type.','line_number':111,'multiline':False]['text':' For wrappers around a pointer type, comparisons between a wrapper object','line_number':136,'multiline':False]['text':' and a const element pointer.','line_number':137,'multiline':False]['text':' For wrappers around a pointer type, comparisons between a wrapper object','line_number':174,'multiline':False]['text':' and |nullptr|.','line_number':175,'multiline':False]['text':'','line_number':176,'multiline':False]['text':' These overloads are a workaround for gcc hazard build bugs.  Per spec,','line_number':177,'multiline':False]['text':' |nullptr -> const T*| for the wrapper-pointer operators immediately above','line_number':178,'multiline':False]['text':' this is a standard conversion sequence (consisting of a single pointer','line_number':179,'multiline':False]['text':' conversion).  Meanwhile, |nullptr -> T* const&| for the wrapper-element','line_number':180,'multiline':False]['text':' operators just above that, is a pointer conversion to |T*|, then an identity','line_number':181,'multiline':False]['text':' conversion of the |T* const| to a reference.  The former conversion sequence','line_number':182,'multiline':False]['text':' is a proper subsequence of the latter, so it *should* be a better conversion','line_number':183,'multiline':False]['text':' sequence and thus should be the better overload.  But gcc doesn't implement','line_number':184,'multiline':False]['text':' things this way, so we add overloads directly targeting |nullptr| as an exact','line_number':185,'multiline':False]['text':' match, preferred to either of those overloads.','line_number':186,'multiline':False]['text':'','line_number':187,'multiline':False]['text':' We should be able to remove these overloads when gcc hazard builds use modern','line_number':188,'multiline':False]['text':' clang.','line_number':189,'multiline':False]['text':' namespace wrapper_comparison','line_number':214,'multiline':False]['text':' namespace detail','line_number':216,'multiline':False]['text':' namespace JS','line_number':218,'multiline':False]['text':' Expose wrapper-supporting |operator==| and |operator!=| in the namespaces of','line_number':220,'multiline':False]['text':' all SpiderMonkey's wrapper classes that support comparisons.','line_number':221,'multiline':False]['text':' namespace JS','line_number':228,'multiline':False]['text':' namespace js','line_number':235,'multiline':False]['text':' js_ComparisonOperators_h','line_number':237,'multiline':False]