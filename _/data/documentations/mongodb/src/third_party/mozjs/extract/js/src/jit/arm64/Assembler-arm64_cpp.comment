['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' Note this is used for inter-wasm calls and may pass arguments and results','line_number':29,'multiline':False]['text':' in floating point registers even if the system ABI does not.','line_number':30,'multiline':False]['text':' Note that in Assembler-x64.cpp there's a special case for Win64 which','line_number':77,'multiline':False]['text':' does not allow passing SIMD by value.  Since there's Win64 on ARM64 we','line_number':78,'multiline':False]['text':' may need to duplicate that logic here.','line_number':79,'multiline':False]['text':' The extended jump table is part of the code buffer.','line_number':91,'multiline':False]['text':' This buffer uses fixed-size chunks so there's no point in reserving','line_number':102,'multiline':False]['text':' now vs. on-demand.','line_number':103,'multiline':False]['text':' For now, specialize to the one use case. As long as wasm::Bytes is a','line_number':108,'multiline':False]['text':' Vector, not a linked-list of chunks, there's not much we can do other','line_number':109,'multiline':False]['text':' than copy.','line_number':110,'multiline':False]['text':' Each JumpTableEntry is of the form:','line_number':130,'multiline':False]['text':'   LDR ip0 [PC, 8]','line_number':131,'multiline':False]['text':'   BR ip0','line_number':132,'multiline':False]['text':'   [Patchable 8-byte constant low bits]','line_number':133,'multiline':False]['text':'   [Patchable 8-byte constant high bits]','line_number':134,'multiline':False]['text':' The unguarded use of ScratchReg64 here is OK:','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' - The present function is called from code that does not claim any','line_number':139,'multiline':False]['text':'   scratch registers, we're done compiling user code and are emitting jump','line_number':140,'multiline':False]['text':'   tables.  Hence the scratch registers are available when we enter.','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':' - The pendingJumps_ represent jumps to other code sections that are not','line_number':143,'multiline':False]['text':'   known to this MacroAssembler instance, and we're generating code to','line_number':144,'multiline':False]['text':'   jump there.  It is safe to assume that any code using such a generated','line_number':145,'multiline':False]['text':'   branch to an unknown location did not store any valuable value in any','line_number':146,'multiline':False]['text':'   scratch register.  Hence the scratch registers can definitely be','line_number':147,'multiline':False]['text':'   clobbered here.','line_number':148,'multiline':False]['text':'','line_number':149,'multiline':False]['text':' - Scratch register usage is restricted to sequential control flow within','line_number':150,'multiline':False]['text':'   MacroAssembler functions.  Hence the scratch registers will not be','line_number':151,'multiline':False]['text':'   clobbered by ldr and br as they are Assembler primitives, not','line_number':152,'multiline':False]['text':'   MacroAssembler functions.','line_number':153,'multiline':False]['text':' Copy the code and all constant pools into the output buffer.','line_number':178,'multiline':False]['text':' Patch any relative jumps that target code outside the buffer.','line_number':181,'multiline':False]['text':' The extended jump table may be used for distant jumps.','line_number':182,'multiline':False]['text':' Currently a two-instruction call, it should be possible to optimize','line_number':200,'multiline':False]['text':' this into a single instruction call + nop in some instances, but this','line_number':201,'multiline':False]['text':' will work.','line_number':202,'multiline':False]['text':' Nothing has seen the label yet: just mark the location.','line_number':247,'multiline':False]['text':' If we've run out of memory, don't attempt to modify the buffer which may','line_number':248,'multiline':False]['text':' not be there. Just mark the label as bound to the (possibly bogus)','line_number':249,'multiline':False]['text':' targetOffset.','line_number':250,'multiline':False]['text':' Get the most recent instruction that used the label, as stored in the','line_number':256,'multiline':False]['text':' label. This instruction is the head of an implicit linked list of label','line_number':257,'multiline':False]['text':' uses.','line_number':258,'multiline':False]['text':' Before overwriting the offset in this instruction, get the offset of','line_number':262,'multiline':False]['text':' the next link in the implicit branch list.','line_number':263,'multiline':False]['text':' Linking against the actual (Instruction*) would be invalid,','line_number':266,'multiline':False]['text':' since that Instruction could be anywhere in memory.','line_number':267,'multiline':False]['text':' Instead, just link against the correct relative offset, assuming','line_number':268,'multiline':False]['text':' no constant pools, which will be taken into consideration','line_number':269,'multiline':False]['text':' during finalization.','line_number':270,'multiline':False]['text':' This branch may still be registered for callbacks. Stop tracking it.','line_number':275,'multiline':False]['text':' Is link able to reach the label?','line_number':286,'multiline':False]['text':' Write a new relative offset into the instruction.','line_number':289,'multiline':False]['text':' This is a short-range branch, and it can't reach the label directly.','line_number':292,'multiline':False]['text':' Verify that it branches to a veneer: an unconditional branch.','line_number':293,'multiline':False]['text':' Bind the label, so that future uses may encode the offset immediately.','line_number':301,'multiline':False]['text':' This jump is not patchable at runtime. Extended jump table entry','line_number':313,'multiline':False]['text':' requirements cannot be known until finalization, so to be safe, give each','line_number':314,'multiline':False]['text':' jump and entry. This also causes GC tracing of the target.','line_number':315,'multiline':False]['text':' Refer to instruction layout in ToggleToCmp().','line_number':350,'multiline':False]['text':' bit 23 is reserved, and the simulator throws an assertion when this happens','line_number':362,'multiline':False]['text':' It'll be messy to decode, but we can steal bit 30 or bit 31.','line_number':363,'multiline':False]['text':' 31 - 64-bit if set, 32-bit if unset. (OK!)','line_number':366,'multiline':False]['text':' 30 - sub if set, add if unset. (OK!)','line_number':367,'multiline':False]['text':' 29 - SetFlagsBit. Must be set.','line_number':368,'multiline':False]['text':' 22:23 - ShiftAddSub. (OK!)','line_number':369,'multiline':False]['text':' 10:21 - ImmAddSub. (OK!)','line_number':370,'multiline':False]['text':' 5:9 - First source register (Rn). (OK!)','line_number':371,'multiline':False]['text':' 0:4 - Destination Register. Must be xzr.','line_number':372,'multiline':False]['text':' From the above, there is a safe 19-bit contiguous region from 5:23.','line_number':374,'multiline':False]['text':' There might be a constant pool at the very first instruction.','line_number':385,'multiline':False]['text':' Skip the stack pointer restore instruction.','line_number':388,'multiline':False]['text':' The call instruction follows the load, but there may be an injected','line_number':395,'multiline':False]['text':' constant pool.','line_number':396,'multiline':False]['text':' If the second instruction is blr(), then we have:','line_number':405,'multiline':False]['text':'   ldr x17, [pc, offset]','line_number':406,'multiline':False]['text':'   blr x17','line_number':407,'multiline':False]['text':' We want to transform this to:','line_number':409,'multiline':False]['text':'   adr xzr, [pc, offset]','line_number':410,'multiline':False]['text':'   nop','line_number':411,'multiline':False]['text':' We have:','line_number':416,'multiline':False]['text':'   adr xzr, [pc, offset] (or ldr x17, [pc, offset])','line_number':417,'multiline':False]['text':'   nop','line_number':418,'multiline':False]['text':' Transform this to:','line_number':421,'multiline':False]['text':'   ldr x17, [pc, offset]','line_number':422,'multiline':False]['text':'   blr x17','line_number':423,'multiline':False]['text':' Patches loads generated by MacroAssemblerCompat::mov(CodeLabel*, Register).','line_number':431,'multiline':False]['text':' The loading code is implemented in movePatchablePtr().','line_number':432,'multiline':False]['text':' We're expecting a call created by MacroAssembler::call(JitCode*).','line_number':461,'multiline':False]['text':' It looks like:','line_number':462,'multiline':False]['text':'','line_number':463,'multiline':False]['text':'   ldr scratch, [pc, offset]','line_number':464,'multiline':False]['text':'   blr scratch','line_number':465,'multiline':False]['text':'','line_number':466,'multiline':False]['text':' If the call has been toggled by ToggleCall(), it looks like:','line_number':467,'multiline':False]['text':'','line_number':468,'multiline':False]['text':'   adr xzr, [pc, offset]','line_number':469,'multiline':False]['text':'   nop','line_number':470,'multiline':False]['text':'','line_number':471,'multiline':False]['text':' There might be a constant pool at the very first instruction.','line_number':472,'multiline':False]['text':' See also ToggleCall().','line_number':473,'multiline':False]['text':' Skip the stack pointer restore instruction.','line_number':476,'multiline':False]['text':' This is an immediate branch.','line_number':482,'multiline':False]['text':' This is an ldr+blr call that is enabled. See ToggleCall().','line_number':485,'multiline':False]['text':' This is a disabled call: adr+nop. See ToggleCall().','line_number':491,'multiline':False]['text':' This is what Literal64 would do with the corresponding ldr.','line_number':496,'multiline':False]['text':' If the jump is within the code buffer, it uses the extended jump table.','line_number':502,'multiline':False]['text':' static ','line_number':526,'multiline':True]['text':' The only valid traceable operation is a 64-bit load to an ARMRegister.','line_number':537,'multiline':False]['text':' Refer to movePatchablePtr() for generation.','line_number':538,'multiline':False]['text':' Data relocations can be for Values or for raw pointers. If a Value is','line_number':544,'multiline':False]['text':' zero-tagged, we can trace it as if it were a raw pointer. If a Value','line_number':545,'multiline':False]['text':' is not zero-tagged, we have to interpret it as a Value to ensure that the','line_number':546,'multiline':False]['text':' tag bits are masked off to recover the actual pointer.','line_number':547,'multiline':False]['text':' This relocation is a Value with a non-zero tag.','line_number':550,'multiline':False]['text':' This relocation is a raw pointer or a Value with a zero tag.','line_number':562,'multiline':False]['text':' No barriers needed since the pointers are constants.','line_number':563,'multiline':False]['text':' The target is not bound but used. Prepend label's branch list','line_number':584,'multiline':False]['text':' onto target's.','line_number':585,'multiline':False]['text':' Find the head of the use chain for label.','line_number':588,'multiline':False]['text':' Then patch the head of label's use chain to the tail of target's','line_number':595,'multiline':False]['text':' use chain, prepending the entire use chain of target.','line_number':596,'multiline':False]['text':' The target is unbound and unused. We can just take the head of','line_number':600,'multiline':False]['text':' the list hanging off of label, and dump that into target.','line_number':601,'multiline':False]['text':' namespace jit','line_number':608,'multiline':False]['text':' namespace js','line_number':609,'multiline':False]