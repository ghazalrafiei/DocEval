['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' namespace jit','line_number':45,'multiline':False]['text':' namespace js','line_number':46,'multiline':False]['text':' Whether there might be a path from src to dest, excluding loop backedges.','line_number':79,'multiline':False]['text':' This is approximate and really ought to depend on precomputed reachability','line_number':80,'multiline':False]['text':' information.','line_number':81,'multiline':False]['text':' Don't iloop.','line_number':93,'multiline':False]['text':' [SMDOC] IonMonkey Alias Analysis','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' This pass annotates every load instruction with the last store instruction','line_number':139,'multiline':False]['text':' on which it depends. The algorithm is optimistic in that it ignores explicit','line_number':140,'multiline':False]['text':' dependencies and only considers loads and stores.','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':' Loads inside loops only have an implicit dependency on a store before the','line_number':143,'multiline':False]['text':' loop header if no instruction inside the loop body aliases it. To calculate','line_number':144,'multiline':False]['text':' this efficiently, we maintain a list of maybe-invariant loads and the','line_number':145,'multiline':False]['text':' combined alias set for all stores inside the loop. When we see the loop's','line_number':146,'multiline':False]['text':' backedge, this information is used to mark every load we wrongly assumed to','line_number':147,'multiline':False]['text':' be loop invariant as having an implicit dependency on the last instruction of','line_number':148,'multiline':False]['text':' the loop header, so that it's never moved before the loop header.','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' The algorithm depends on the invariant that both control instructions and','line_number':151,'multiline':False]['text':' effectful instructions (stores) are never hoisted.','line_number':152,'multiline':False]['text':' Initialize to the first instruction.','line_number':158,'multiline':False]['text':' Type analysis may have inserted new instructions. Since this pass depends','line_number':170,'multiline':False]['text':' on the instruction number ordering, all instructions are renumbered.','line_number':171,'multiline':False]['text':' For the purposes of alias analysis, all recoverable operations','line_number':203,'multiline':False]['text':' are treated as effect free as the memory represented by these','line_number':204,'multiline':False]['text':' operations cannot be aliased by others.','line_number':205,'multiline':False]['text':' Find the most recent store on which this instruction depends.','line_number':227,'multiline':False]['text':' If the last store was before the current loop, we assume this load','line_number':247,'multiline':False]['text':' is loop invariant. If a later instruction writes to the same','line_number':248,'multiline':False]['text':' location, we will fix this at the end of the loop.','line_number':249,'multiline':False]['text':' Renumber the last instruction, as the analysis depends on this and the','line_number':258,'multiline':False]['text':' order.','line_number':259,'multiline':False]['text':' This instruction depends on stores inside the loop body. Mark it as','line_number':296,'multiline':False]['text':' having a dependency on the last instruction of the loop header. The','line_number':297,'multiline':False]['text':' last instruction is a control instruction and these are never','line_number':298,'multiline':False]['text':' hoisted.','line_number':299,'multiline':False]