['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' js::AutoCheckRecursionLimit','line_number':20,'multiline':False]['text':' js::IsWindow, js::IsWindowProxy, js::ToWindowProxyIfWindow','line_number':21,'multiline':False]['text':' Assert that the postbarriers have worked and that nothing is left in the','line_number':56,'multiline':False]['text':' wrapper map that points into the nursery, and that the hash table entries','line_number':57,'multiline':False]['text':' are discoverable.','line_number':58,'multiline':False]['text':' JSGC_HASH_TABLE_CHECKS','line_number':67,'multiline':False]['text':'
   * Directly allocate the copy in the destination compartment, rather than
   * first flattening it (and possibly allocating in source compartment),
   * because we don't know whether the flattening will pay off later.
   ','line_number':103,'multiline':True]['text':' Only use AutoStableStringChars if the NoGC allocation fails. ','line_number':112,'multiline':True]['text':' If the string is already in this compartment, we are done. ','line_number':158,'multiline':True]['text':'
   * If the string is an atom, we don't have to copy, but we do need to mark
   * the atom as being in use by the new zone.
   ','line_number':164,'multiline':True]['text':' Check the cache. ','line_number':173,'multiline':True]['text':' No dice. Make a copy, and cache it. ','line_number':179,'multiline':True]['text':' Ensure that we have entered a realm.','line_number':209,'multiline':False]['text':' If we have a cross-compartment wrapper, make sure that the cx isn't','line_number':212,'multiline':False]['text':' associated with the self-hosting zone. We don't want to create','line_number':213,'multiline':False]['text':' wrappers for objects in other runtimes, which may be the case for the','line_number':214,'multiline':False]['text':' self-hosting zone.','line_number':215,'multiline':False]['text':' The object is already in the right compartment. Normally same-','line_number':219,'multiline':False]['text':' compartment returns the object itself, however, windows are always','line_number':220,'multiline':False]['text':' wrapped by a proxy, so we have to check for that case here manually.','line_number':221,'multiline':False]['text':' Note that if the object is same-compartment, but has been wrapped into a','line_number':227,'multiline':False]['text':' different compartment, we need to unwrap it and return the bare same-','line_number':228,'multiline':False]['text':' compartment object. Note again that windows are always wrapped by a','line_number':229,'multiline':False]['text':' WindowProxy even when same-compartment so take care not to strip this','line_number':230,'multiline':False]['text':' particular wrapper.','line_number':231,'multiline':False]['text':' stopAtWindowProxy = ','line_number':233,'multiline':True]['text':' Disallow creating new wrappers if we nuked the object's realm or the','line_number':239,'multiline':False]['text':' current compartment.','line_number':240,'multiline':False]['text':' Use the WindowProxy instead of the Window here, so that we don't have to','line_number':247,'multiline':False]['text':' deal with this in the rest of the wrapping code.','line_number':248,'multiline':False]['text':' ToWindowProxyIfWindow can return a CCW if |obj| was a navigated-away-from','line_number':252,'multiline':False]['text':' Window. Strip any CCWs.','line_number':253,'multiline':False]['text':' We crossed a compartment boundary there, so may now have a gray object.','line_number':263,'multiline':False]['text':' This function is not allowed to return gray objects, so don't do that.','line_number':264,'multiline':False]['text':' If the object is a dead wrapper, return a new dead wrapper rather than','line_number':268,'multiline':False]['text':' trying to wrap it for a different compartment.','line_number':269,'multiline':False]['text':' Invoke the prewrap callback. The prewrap callback is responsible for','line_number':275,'multiline':False]['text':' doing similar reification as above, but can account for any additional','line_number':276,'multiline':False]['text':' embedder requirements.','line_number':277,'multiline':False]['text':'','line_number':278,'multiline':False]['text':' We're a bit worried about infinite recursion here, so we do a check -','line_number':279,'multiline':False]['text':' see bug 809295.','line_number':280,'multiline':False]['text':' If we already have a wrapper for this value, use it.','line_number':299,'multiline':False]['text':' Ensure that the wrappee is exposed in case we are creating a new wrapper','line_number':306,'multiline':False]['text':' for a gray object.','line_number':307,'multiline':False]['text':' Create a new wrapper for the object.','line_number':310,'multiline':False]['text':' We maintain the invariant that the key in the cross-compartment wrapper','line_number':317,'multiline':False]['text':' map is always directly wrapped by the value.','line_number':318,'multiline':False]['text':' Enforce the invariant that all cross-compartment wrapper object are','line_number':322,'multiline':False]['text':' in the map by nuking the wrapper if we couldn't add it.','line_number':323,'multiline':False]['text':' Unfortunately it's possible for the wrapper to still be marked if we','line_number':324,'multiline':False]['text':' took this path, for example if the object metadata callback stashes a','line_number':325,'multiline':False]['text':' reference to it.','line_number':326,'multiline':False]['text':' Anything we're wrapping has already escaped into script, so must have','line_number':346,'multiline':False]['text':' been unmarked-gray at some point in the past.','line_number':347,'multiline':False]['text':' The passed object may already be wrapped, or may fit a number of special','line_number':350,'multiline':False]['text':' cases that we need to check for and manually correct.','line_number':351,'multiline':False]['text':' origObj = ','line_number':352,'multiline':True]['text':' If the reification above did not result in a same-compartment object,','line_number':357,'multiline':False]['text':' get or create a new wrapper object in this compartment for it.','line_number':358,'multiline':False]['text':' Ensure that the wrapper is also exposed.','line_number':365,'multiline':False]['text':' It may not be possible to re-use existing; if so, clear it so that we','line_number':380,'multiline':False]['text':' are forced to create a new wrapper. Note that this cannot call out to','line_number':381,'multiline':False]['text':' |wrap| because of the different gray unmarking semantics.','line_number':382,'multiline':False]['text':' Note: Class asserted above, so all that's left to check is callability','line_number':385,'multiline':False]['text':' The passed object may already be wrapped, or may fit a number of special','line_number':390,'multiline':False]['text':' cases that we need to check for and manually correct. We pass in','line_number':391,'multiline':False]['text':' |existingArg| instead of |existing|, because the purpose is to get the','line_number':392,'multiline':False]['text':' address of the object we are transplanting onto, not to find a wrapper','line_number':393,'multiline':False]['text':' to reuse.','line_number':394,'multiline':False]['text':' If the reification above resulted in a same-compartment object, we do','line_number':399,'multiline':False]['text':' not need to create or return an existing wrapper.','line_number':400,'multiline':False]['text':' Trace cross compartment wrapper private pointers into collected zones to','line_number':464,'multiline':False]['text':' either mark or update them. Wrapped object pointers are updated by','line_number':465,'multiline':False]['text':' sweepCrossCompartmentObjectWrappers().','line_number':466,'multiline':False]['text':' static ','line_number':488,'multiline':True]['text':' Currently we trace all debugger edges as black.','line_number':503,'multiline':False]['text':' Remove dead wrappers from the table or update pointers to moved objects.','line_number':517,'multiline':False]['text':' Sweep the wrapper map to update keys (wrapped values) in other','line_number':526,'multiline':False]['text':' compartments that may have been moved.','line_number':527,'multiline':False]['text':' Trace the wrappers in the map to update their cross-compartment edges','line_number':530,'multiline':False]['text':' to wrapped values in other compartments that may have been moved.','line_number':531,'multiline':False]['text':' Sweep the wrapper map to update values (wrapper objects) in this','line_number':542,'multiline':False]['text':' compartment that may have been moved.','line_number':543,'multiline':False]