['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' Since wasm uses the system ABI which does not necessarily use a','line_number':82,'multiline':False]['text':' regular array where all slots are sizeof(Value), it maintains the max','line_number':83,'multiline':False]['text':' argument stack depth separately.','line_number':84,'multiline':False]['text':' On X64/x86 and ARM64, we don't need alignment for Wasm SIMD at this time.','line_number':91,'multiline':False]['text':' An MWasmCall does not align the stack pointer at calls sites but','line_number':99,'multiline':False]['text':' instead relies on the a priori stack adjustment. This must be the','line_number':100,'multiline':False]['text':' last adjustment of frameDepth_.','line_number':101,'multiline':False]['text':' FrameSizeClass is only used for bailing, which cannot happen in','line_number':106,'multiline':False]['text':' wasm code.','line_number':107,'multiline':False]['text':' If profiling, save the current frame pointer to a per-thread global field.','line_number':122,'multiline':False]['text':' Ensure that the Ion frame is properly aligned.','line_number':127,'multiline':False]['text':' Note that this automatically sets MacroAssembler::framePushed().','line_number':130,'multiline':False]['text':' If profiling, reset the per-thread global lastJitFrame to point to','line_number':152,'multiline':False]['text':' the previous frame.','line_number':153,'multiline':False]['text':' On systems that use a constant pool, this is a good time to emit.','line_number':160,'multiline':False]['text':' OOL paths should not attempt to use |current| as it's the last block','line_number':166,'multiline':False]['text':' instead of the block corresponding to the OOL path.','line_number':167,'multiline':False]['text':' Add native => bytecode mapping entries for OOL sites.','line_number':171,'multiline':False]['text':' Not enabled on wasm yet since it doesn't contain bytecode mappings.','line_number':172,'multiline':False]['text':' Skip the table entirely if profiling is not enabled.','line_number':213,'multiline':False]['text':' Fails early if the last added instruction caused the macro assembler to','line_number':218,'multiline':False]['text':' run out of memory as continuity assumption below do not hold.','line_number':219,'multiline':False]['text':' If the new entry is for the same inlineScriptTree and same','line_number':236,'multiline':False]['text':' bytecodeOffset, but the nativeOffset has changed, do nothing.','line_number':237,'multiline':False]['text':' The same site just generated some more code.','line_number':238,'multiline':False]['text':' If the new entry is for the same native offset, then update the','line_number':245,'multiline':False]['text':' previous entry with the new bytecode site, since the previous','line_number':246,'multiline':False]['text':' bytecode site did not generate any native code.','line_number':247,'multiline':False]['text':' This overwrite might have made the entry merge-able with a','line_number':253,'multiline':False]['text':' previous one.  If so, merge it.','line_number':254,'multiline':False]['text':' Otherwise, some native code was generated for the previous bytecode site.','line_number':269,'multiline':False]['text':' Add a new entry for code that is about to be generated.','line_number':270,'multiline':False]['text':' see OffsetOfFrameSlot','line_number':326,'multiline':False]['text':' This MDefinition is recovered, thus it should be listed in the','line_number':360,'multiline':False]['text':' LRecoverInfo.','line_number':361,'multiline':False]['text':' Lambda should have a default value readable for iterating over the','line_number':364,'multiline':False]['text':' inner frames.','line_number':365,'multiline':False]['text':' This set an extra bit as part of the RValueAllocation, such that we know','line_number':501,'multiline':False]['text':' that recover instruction have to be executed without wrapping the','line_number':502,'multiline':False]['text':' instruction in a no-op recover instruction.','line_number':503,'multiline':False]['text':' Can we not use bailout tables at all?','line_number':593,'multiline':False]['text':' Is the bailout table full?','line_number':604,'multiline':False]['text':' Add script from current tree.','line_number':632,'multiline':False]['text':' Process rest of tree','line_number':646,'multiline':False]['text':' If children exist, emit children.','line_number':648,'multiline':False]['text':' Otherwise, find the first tree up the chain (including this one)','line_number':654,'multiline':False]['text':' that contains a next sibling.','line_number':655,'multiline':False]['text':' If we found a sibling, use it.','line_number':660,'multiline':False]['text':' Otherwise, we must have reached the top without finding any siblings.','line_number':666,'multiline':False]['text':' Allocate array for list.','line_number':671,'multiline':False]['text':' Success.','line_number':681,'multiline':False]['text':' Writer is done, copy it to sized buffer.','line_number':719,'multiline':False]['text':' The pointer to the table must be 4-byte aligned','line_number':749,'multiline':False]['text':' Verify that numRegions was encoded correctly.','line_number':753,'multiline':False]['text':' Region offset for first region should be at the start of the payload','line_number':758,'multiline':False]['text':' region. Since the offsets are backward from the start of the table, the','line_number':759,'multiline':False]['text':' first entry backoffset should be equal to the forward table offset from the','line_number':760,'multiline':False]['text':' start of the allocated data.','line_number':761,'multiline':False]['text':' Verify each region.','line_number':764,'multiline':False]['text':' Back-offset must point into the payload region preceding the table, not','line_number':766,'multiline':False]['text':' before it.','line_number':767,'multiline':False]['text':' Back-offset must point to a later area in the payload region than','line_number':770,'multiline':False]['text':' previous back-offset.  This means that back-offsets decrease','line_number':771,'multiline':False]['text':' monotonically.','line_number':772,'multiline':False]['text':' Ensure native code offset for region falls within jitcode.','line_number':778,'multiline':False]['text':' Read out script/pc stack and verify.','line_number':781,'multiline':False]['text':' Ensure scriptIdx refers to a valid script in the list.','line_number':788,'multiline':False]['text':' Ensure pcOffset falls within the script.','line_number':792,'multiline':False]['text':' Obtain the original nativeOffset and pcOffset and script.','line_number':796,'multiline':False]['text':' Read out nativeDeltas and pcDeltas and verify.','line_number':807,'multiline':False]['text':' Ensure that nativeOffset still falls within jitcode after delta.','line_number':817,'multiline':False]['text':' Ensure that pcOffset still falls within bytecode after delta.','line_number':820,'multiline':False]['text':' DEBUG','line_number':824,'multiline':False]['text':' For a refresher, an invalidation point is of the form:','line_number':840,'multiline':False]['text':' 1: call <target>','line_number':841,'multiline':False]['text':' 2: ...','line_number':842,'multiline':False]['text':' 3: <osipoint>','line_number':843,'multiline':False]['text':'','line_number':844,'multiline':False]['text':' The four bytes *before* instruction 2 are overwritten with an offset.','line_number':845,'multiline':False]['text':' Callers must ensure that the instruction itself has enough bytes to','line_number':846,'multiline':False]['text':' support this.','line_number':847,'multiline':False]['text':'','line_number':848,'multiline':False]['text':' The bytes *at* instruction 3 are overwritten with an invalidation jump.','line_number':849,'multiline':False]['text':' jump. These bytes may be in a completely different IR sequence, but','line_number':850,'multiline':False]['text':' represent the join point of the call out of the function.','line_number':851,'multiline':False]['text':'','line_number':852,'multiline':False]['text':' At points where we want to ensure that invalidation won't corrupt an','line_number':853,'multiline':False]['text':' important instruction, we make sure to pad with nops.','line_number':854,'multiline':False]['text':' float32 ','line_number':913,'multiline':True]['text':' float32 ','line_number':939,'multiline':True]['text':' If the current function makes no calls (which means it isn't recursive)','line_number':960,'multiline':False]['text':' and it uses only a small amount of stack space, it doesn't need a','line_number':961,'multiline':False]['text':' stack overflow check. Note that the actual number here is somewhat','line_number':962,'multiline':False]['text':' arbitrary, and codegen actually uses small bounded amounts of','line_number':963,'multiline':False]['text':' additional stack space in some cases too.','line_number':964,'multiline':False]['text':' Skip past trivial blocks.','line_number':985,'multiline':False]['text':' No jump necessary if we can fall through to the next block.','line_number':988,'multiline':False]['text':' Skip past trivial blocks.','line_number':997,'multiline':False]['text':' This function is not used for MIPS/MIPS64. MIPS has branchToBlock.','line_number':1001,'multiline':False]['text':' Skip past trivial blocks.','line_number':1005,'multiline':False]['text':' In what follows, 0 < d < 2^maxLog and d is not a power of 2.','line_number':1013,'multiline':False]['text':' Speeding up division by non power-of-2 constants is possible by','line_number':1016,'multiline':False]['text':' calculating, during compilation, a value M such that high-order','line_number':1017,'multiline':False]['text':' bits of M*n correspond to the result of the division of n by d.','line_number':1018,'multiline':False]['text':' No value of M can serve this purpose for arbitrarily big values','line_number':1019,'multiline':False]['text':' of n but, for optimizing integer division, we're just concerned','line_number':1020,'multiline':False]['text':' with values of n whose absolute value is bounded (by fitting in','line_number':1021,'multiline':False]['text':' an integer type, say). With this in mind, we'll find a constant','line_number':1022,'multiline':False]['text':' M as above that works for -2^maxLog <= n < 2^maxLog; maxLog can','line_number':1023,'multiline':False]['text':' then be 31 for signed division or 32 for unsigned division.','line_number':1024,'multiline':False]['text':'','line_number':1025,'multiline':False]['text':' The original presentation of this technique appears in Hacker's','line_number':1026,'multiline':False]['text':' Delight, a book by Henry S. Warren, Jr.. A proof of correctness','line_number':1027,'multiline':False]['text':' for our version follows; we'll denote maxLog by L in the proof,','line_number':1028,'multiline':False]['text':' for conciseness.','line_number':1029,'multiline':False]['text':'','line_number':1030,'multiline':False]['text':' Formally, for |d| < 2^L, we'll compute two magic values M and s','line_number':1031,'multiline':False]['text':' in the ranges 0 <= M < 2^(L+1) and 0 <= s <= L such that','line_number':1032,'multiline':False]['text':'     (M * n) >> (32 + s) = floor(n/d)    if    0 <= n < 2^L','line_number':1033,'multiline':False]['text':'     (M * n) >> (32 + s) = ceil(n/d) - 1 if -2^L <= n < 0.','line_number':1034,'multiline':False]['text':'','line_number':1035,'multiline':False]['text':' Define p = 32 + s, M = ceil(2^p/d), and assume that s satisfies','line_number':1036,'multiline':False]['text':'                     M - 2^p/d <= 2^(p-L)/d.                 (1)','line_number':1037,'multiline':False]['text':' (Observe that p = CeilLog32(d) + L satisfies this, as the right','line_number':1038,'multiline':False]['text':' side of (1) is at least one in this case). Then,','line_number':1039,'multiline':False]['text':'','line_number':1040,'multiline':False]['text':' a) If p <= CeilLog32(d) + L, then M < 2^(L+1) - 1.','line_number':1041,'multiline':False]['text':' Proof: Indeed, M is monotone in p and, for p equal to the above','line_number':1042,'multiline':False]['text':' value, the bounds 2^L > d >= 2^(p-L-1) + 1 readily imply that','line_number':1043,'multiline':False]['text':'    2^p / d <  2^p/(d - 1) * (d - 1)/d','line_number':1044,'multiline':False]['text':'            <= 2^(L+1) * (1 - 1/d) < 2^(L+1) - 2.','line_number':1045,'multiline':False]['text':' The claim follows by applying the ceiling function.','line_number':1046,'multiline':False]['text':'','line_number':1047,'multiline':False]['text':' b) For any 0 <= n < 2^L, floor(Mn/2^p) = floor(n/d).','line_number':1048,'multiline':False]['text':' Proof: Put x = floor(Mn/2^p); it's the unique integer for which','line_number':1049,'multiline':False]['text':'                    Mn/2^p - 1 < x <= Mn/2^p.                (2)','line_number':1050,'multiline':False]['text':' Using M >= 2^p/d on the LHS and (1) on the RHS, we get','line_number':1051,'multiline':False]['text':'           n/d - 1 < x <= n/d + n/(2^L d) < n/d + 1/d.','line_number':1052,'multiline':False]['text':' Since x is an integer, it's not in the interval (n/d, (n+1)/d),','line_number':1053,'multiline':False]['text':' and so n/d - 1 < x <= n/d, which implies x = floor(n/d).','line_number':1054,'multiline':False]['text':'','line_number':1055,'multiline':False]['text':' c) For any -2^L <= n < 0, floor(Mn/2^p) + 1 = ceil(n/d).','line_number':1056,'multiline':False]['text':' Proof: The proof is similar. Equation (2) holds as above. Using','line_number':1057,'multiline':False]['text':' M > 2^p/d (d isn't a power of 2) on the RHS and (1) on the LHS,','line_number':1058,'multiline':False]['text':'                 n/d + n/(2^L d) - 1 < x < n/d.','line_number':1059,'multiline':False]['text':' Using n >= -2^L and summing 1,','line_number':1060,'multiline':False]['text':'                  n/d - 1/d < x + 1 < n/d + 1.','line_number':1061,'multiline':False]['text':' Since x + 1 is an integer, this implies n/d <= x + 1 < n/d + 1.','line_number':1062,'multiline':False]['text':' In other words, x + 1 = ceil(n/d).','line_number':1063,'multiline':False]['text':'','line_number':1064,'multiline':False]['text':' Condition (1) isn't necessary for the existence of M and s with','line_number':1065,'multiline':False]['text':' the properties above. Hacker's Delight provides a slightly less','line_number':1066,'multiline':False]['text':' restrictive condition when d >= 196611, at the cost of a 3-page','line_number':1067,'multiline':False]['text':' proof of correctness, for the case L = 31.','line_number':1068,'multiline':False]['text':'','line_number':1069,'multiline':False]['text':' Note that, since d*M - 2^p = d - (2^p)%d, (1) can be written as','line_number':1070,'multiline':False]['text':'                   2^(p-L) >= d - (2^p)%d.','line_number':1071,'multiline':False]['text':' In order to avoid overflow in the (2^p) % d calculation, we can','line_number':1072,'multiline':False]['text':' compute it as (2^p-1) % d + 1, where 2^p-1 can then be computed','line_number':1073,'multiline':False]['text':' without overflow as UINT64_MAX >> (64-p).','line_number':1074,'multiline':False]['text':' We now compute the least p >= 32 with the property above...','line_number':1076,'multiline':False]['text':' ...and the corresponding M. For either the signed (L=31) or the','line_number':1082,'multiline':False]['text':' unsigned (L=32) case, this value can be too large (cf. item a).','line_number':1083,'multiline':False]['text':' Codegen can still multiply by M by multiplying by (M - 2^L) and','line_number':1084,'multiline':False]['text':' adjusting the value afterwards, if this is the case.','line_number':1085,'multiline':False]['text':' namespace jit','line_number':1199,'multiline':False]['text':' namespace js','line_number':1200,'multiline':False]