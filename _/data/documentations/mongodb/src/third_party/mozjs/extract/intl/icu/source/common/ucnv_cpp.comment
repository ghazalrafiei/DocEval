['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]['text':'
******************************************************************************
*
*   Copyright (C) 1998-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*
*  ucnv.c:
*  Implements APIs for the ICU's codeset conversion library;
*  mostly calls through internal functions;
*  created by Bertrand A. Damiba
*
* Modification History:
*
*   Date        Name        Description
*   04/04/99    helena      Fixed internal header inclusion.
*   05/09/00    helena      Added implementation to handle fallback mappings.
*   06/20/2000  helena      OS/400 port changes; mostly typecast.
','line_number':3,'multiline':True]['text':' size of intermediate and preflighting buffers in ucnv_convert() ','line_number':46,'multiline':True]['text':'{ "ibm-54191_P100-2006", 0xa5 },','line_number':61,'multiline':True]['text':'{ "ibm-62383_P100-2007", 0xa5 },','line_number':62,'multiline':True]['text':'{ "ibm-891_P100-1995", 0x20a9 },','line_number':63,'multiline':True]['text':'Calls through createConverter ','line_number':71,'multiline':True]['text':'Extracts the UChar* to a char* and calls through createConverter ','line_number':92,'multiline':True]['text':' Copy the string that is represented by the UConverterPlatform enum
 * @param platformString An output buffer
 * @param platform An enum representing a platform
 * @return the length of the copied string.
 ','line_number':111,'multiline':True]['text':' default to empty string ','line_number':128,'multiline':True]['text':'Assumes a $platform-#codepage.$CONVERTER_FILE_EXTENSION scheme and calls
 *through createConverter','line_number':133,'multiline':True]['text':' ucnv_copyPlatformString could return "ibm-" or "cp" ','line_number':146,'multiline':True]['text':' Creating a temporary stack-based object that can be used in one thread, 
and created from a converter that is shared across threads.
','line_number':153,'multiline':True]['text':' call the custom safeClone function for sizing ','line_number':202,'multiline':True]['text':' inherent sizing ','line_number':212,'multiline':True]['text':' 'preflighting' request - set needed size into *pBufferSize ','line_number':221,'multiline':True]['text':' Adjust (if necessary) the stackBuffer pointer to be aligned correctly for a UConverter.
     * TODO(Jira ICU-20736) Redo this using std::align() once g++4.9 compatibility is no longer needed.
     ','line_number':228,'multiline':True]['text':' prevent using the stack buffer but keep the size > 0 so that we do not just preflight ','line_number':239,'multiline':True]['text':' Now, see if we must allocate any memory ','line_number':244,'multiline':True]['text':' allocate one here...','line_number':247,'multiline':True]['text':' record the fact that memory was allocated ','line_number':257,'multiline':True]['text':' just use the stack buffer ','line_number':260,'multiline':True]['text':' Copy initial state ','line_number':267,'multiline':True]['text':' copy the substitution string ','line_number':271,'multiline':True]['text':' now either call the safeclone fcn or not ','line_number':284,'multiline':True]['text':' call the custom safeClone function ','line_number':286,'multiline':True]['text':' increment refcount of shared data if needed ','line_number':299,'multiline':True]['text':' we're using user provided data - set to not destroy ','line_number':305,'multiline':True]['text':' allow callback functions to handle any memory allocation ','line_number':309,'multiline':True]['text':'Decreases the reference counter in the shared immutable section of the object
 *and frees the mutable part','line_number':322,'multiline':True]['text':' In order to speed up the close, only call the callbacks when they have been changed.
    This performance check will only work when the callbacks are set within a shared library
    or from user code that statically links this code. ','line_number':341,'multiline':True]['text':' first, notify the callback functions that the converter is closed ','line_number':344,'multiline':True]['text':'returns a single Name from the list, will return NULL if out of bounds
 ','line_number':396,'multiline':True]['text':' Unicode string or empty string from ucnv_setSubstString(). ','line_number':428,'multiline':True]['text':'not enough space in subChars ','line_number':433,'multiline':True]['text':'fills in the subchars ','line_number':439,'multiline':True]['text':'store # of bytes copied to buffer ','line_number':440,'multiline':True]['text':'Makes sure that the subChar is within the codepages char length boundaries ','line_number':452,'multiline':True]['text':'copies the subchars ','line_number':460,'multiline':True]['text':'sets the new len ','line_number':461,'multiline':True]['text':'
    * There is currently (2001Feb) no separate API to set/get subChar1.
    * In order to always have subChar written after it is explicitly set,
    * we set subChar1 to 0.
    ','line_number':463,'multiline':True]['text':' Let the following functions check all arguments. ','line_number':485,'multiline':True]['text':' The converter is not stateful. Store the charset bytes as a fixed string. ','line_number':501,'multiline':True]['text':'
         * The converter has a non-default writeSub() function, indicating
         * that it is stateful.
         * Store the Unicode string for on-the-fly conversion for correct
         * state handling.
         ','line_number':504,'multiline':True]['text':'
             * Should not occur. The converter should output at least one byte
             * per UChar, which means that ucnv_fromUChars() should catch all
             * overflows.
             ','line_number':511,'multiline':True]['text':'
     * For storing the substitution string, select either the small buffer inside
     * UConverter or allocate a subChars buffer.
     ','line_number':526,'multiline':True]['text':' Use a separate buffer for the string. Outside UConverter to not make it too large. ','line_number':531,'multiline':True]['text':' Allocate a new buffer for the string. ','line_number':533,'multiline':True]['text':' Copy the substitution string into the UConverter or its subChars buffer. ','line_number':544,'multiline':True]['text':' subChars == s ','line_number':551,'multiline':True]['text':' See comment in ucnv_setSubstChars(). ','line_number':556,'multiline':True]['text':'resets the internal states of a converter
 *goal : have the same behaviour than a freshly created converter
 ','line_number':560,'multiline':True]['text':' first, notify the callback functions that the converter is reset ','line_number':570,'multiline':True]['text':' now reset the converter itself ','line_number':605,'multiline':True]['text':' call the custom reset function ','line_number':622,'multiline':True]['text':' Rare case. This is for cases like gb18030,
        which doesn't have an IBM canonical name, but does have an IBM alias. ','line_number':682,'multiline':True]['text':' +1 to skip '-' ','line_number':688,'multiline':True]['text':'
         * adjust each offset by adding the previous sourceIndex
         * minus the length of the input sequence that caused an
         * error, if any
         ','line_number':763,'multiline':True]['text':'
         * set each offset to -1 because this conversion function
         * does not handle offsets
         ','line_number':770,'multiline':True]['text':' most common case, nothing to do ','line_number':779,'multiline':True]['text':' add the delta to each offset (but not if the offset is <0) ','line_number':781,'multiline':True]['text':' delta<0 ','line_number':789,'multiline':True]['text':'
         * set each offset to -1 because this conversion function
         * does not handle offsets
         * or the error input sequence started in a previous buffer
         ','line_number':790,'multiline':True]['text':' ucnv_fromUnicode --------------------------------------------------------- ','line_number':801,'multiline':True]['text':'
 * Implementation note for m:n conversions
 *
 * While collecting source units to find the longest match for m:n conversion,
 * some source units may need to be stored for a partial match.
 * When a second buffer does not yield a match on all of the previously stored
 * source units, then they must be "replayed", i.e., fed back into the converter.
 *
 * The code relies on the fact that replaying will not nest -
 * converting a replay buffer will not result in a replay.
 * This is because a replay is necessary only after the _continuation_ of a
 * partial match failed, but a replay buffer is converted as a whole.
 * It may result in some of its units being stored again for a partial match,
 * but there will not be a continuation _during_ the replay which could fail.
 *
 * It is conceivable that a callback function could call the converter
 * recursively in a way that causes another replay to be stored, but that
 * would be an error in the callback function.
 * Such violations will cause assertion failures in a debug build,
 * and wrong output, but they will not cause a crash.
 ','line_number':803,'multiline':True]['text':' variables for m:n conversion ','line_number':836,'multiline':True]['text':' get the converter implementation function ','line_number':847,'multiline':True]['text':' there is no WithOffsets implementation ','line_number':854,'multiline':True]['text':' we will write -1 for each offset ','line_number':856,'multiline':True]['text':' normal mode ','line_number':862,'multiline':True]['text':' avoid compiler warnings - not otherwise necessary, and the values do not matter ','line_number':865,'multiline':True]['text':'
         * Previous m:n conversion stored source units from a partial match
         * and failed to consume all of them.
         * We need to "replay" them from a temporary buffer and convert them first.
         ','line_number':870,'multiline':True]['text':'
     * loop for conversion and error handling
     *
     * loop {
     *   convert
     *   loop {
     *     update offsets
     *     handle end of input
     *     handle errors/call callback
     *   }
     * }
     ','line_number':889,'multiline':True]['text':' convert ','line_number':903,'multiline':True]['text':'
             * set a flag for whether the converter
             * successfully processed the end of the input
             *
             * need not check cnv->preFromULength==0 because a replay (<0) will cause
             * s<sourceLimit before converterSawEndOfInput is checked
             ','line_number':906,'multiline':True]['text':' handle error from ucnv_convertEx() ','line_number':918,'multiline':True]['text':' no callback called yet for this iteration ','line_number':922,'multiline':True]['text':' no sourceIndex adjustment for conversion, only for callback output ','line_number':925,'multiline':True]['text':'
         * loop for offsets and error handling
         *
         * iterates at most 3 times:
         * 1. to clean up after the conversion function
         * 2. after the callback
         * 3. after the callback again if there was truncated input
         ','line_number':928,'multiline':True]['text':' update offsets if we write any ','line_number':937,'multiline':True]['text':'
                     * if a converter handles offsets and updates the offsets
                     * pointer at the end, then pArgs->offset should not change
                     * here;
                     * however, some converters do not handle offsets at all
                     * (sourceIndex<0) or may not update the offsets pointer
                     ','line_number':943,'multiline':True]['text':'
                 * switch the source to new replay units (cannot occur while replaying)
                 * after offset handling and before end-of-input and callback handling
                 ','line_number':959,'multiline':True]['text':' see implementation note before _fromUnicodeWithCallback() ','line_number':979,'multiline':True]['text':' update pointers ','line_number':985,'multiline':True]['text':'
                     * continue with the conversion loop while there is still input left
                     * (continue converting by breaking out of only the inner loop)
                     ','line_number':991,'multiline':True]['text':' switch back from replaying to the real source and continue ','line_number':997,'multiline':True]['text':'
                     * the entire input stream is consumed
                     * and there is a partial, truncated input sequence left
                     ','line_number':1006,'multiline':True]['text':' inject an error and continue with callback handling ','line_number':1011,'multiline':True]['text':' new error condition ','line_number':1013,'multiline':True]['text':' input consumed ','line_number':1015,'multiline':True]['text':'
                         * return to the conversion loop once more if the flush
                         * flag is set and the conversion function has not
                         * successfully processed the end of the input yet
                         *
                         * (continue converting by breaking out of only the inner loop)
                         ','line_number':1017,'multiline':True]['text':' reset the converter without calling the callback function ','line_number':1028,'multiline':True]['text':' done successfully ','line_number':1032,'multiline':True]['text':' U_FAILURE(*err) ','line_number':1037,'multiline':True]['text':'
                     * the callback did not or cannot resolve the error:
                     * set output pointers and return
                     *
                     * the check for buffer overflow is redundant but it is
                     * a high-runner case and hopefully documents the intent
                     * well
                     *
                     * if we were replaying, then the replay buffer must be
                     * copied back into the UConverter
                     * and the real arguments must be restored
                     ','line_number':1047,'multiline':True]['text':' callback handling ','line_number':1079,'multiline':True]['text':' get and write the code point ','line_number':1083,'multiline':True]['text':' set the converter state to deal with the next character ','line_number':1089,'multiline':True]['text':' call the callback function ','line_number':1092,'multiline':True]['text':'
             * loop back to the offset handling
             *
             * this flag will indicate after offset handling
             * that a callback was called;
             * if the callback did not resolve the error, then we return
             ','line_number':1099,'multiline':True]['text':'
 * Output the fromUnicode overflow buffer.
 * Call this function if(cnv->charErrorBufferLength>0).
 * @return TRUE if overflow
 ','line_number':1111,'multiline':True]['text':' the overflow buffer contains too much, keep the rest ','line_number':1137,'multiline':True]['text':' copy the overflow contents to the target ','line_number':1153,'multiline':True]['text':' no source index available for old output ','line_number':1156,'multiline':True]['text':' the overflow buffer is completely copied to the target ','line_number':1160,'multiline':True]['text':' check parameters ','line_number':1180,'multiline':True]['text':'
        Prevent code from going into an infinite loop in case we do hit this
        limit. The limit pointer is expected to be on a UChar * boundary.
        This also prevents the next argument check from failing.
        ','line_number':1194,'multiline':True]['text':'
     * All these conditions should never happen.
     *
     * 1) Make sure that the limits are >= to the address source or target
     *
     * 2) Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be targetLimit=t+0x7fffffff; for example.
     *
     * 3) Make sure that the user didn't incorrectly cast a UChar * pointer
     * to a char * pointer and provide an incomplete UChar code unit.
     ','line_number':1202,'multiline':True]['text':' output the target overflow buffer ','line_number':1230,'multiline':True]['text':' U_BUFFER_OVERFLOW_ERROR ','line_number':1234,'multiline':True]['text':' *target may have moved, therefore stop using t ','line_number':1237,'multiline':True]['text':' the overflow buffer is emptied and there is no new input: we are done ','line_number':1240,'multiline':True]['text':'
     * Do not simply return with a buffer overflow error if
     * !flush && t==targetLimit
     * because it is possible that the source will not generate any output.
     * For example, the skip callback may be called;
     * it does not output anything.
     ','line_number':1244,'multiline':True]['text':' prepare the converter arguments ','line_number':1252,'multiline':True]['text':' ucnv_toUnicode() --------------------------------------------------------- ','line_number':1268,'multiline':True]['text':' variables for m:n conversion ','line_number':1281,'multiline':True]['text':' get the converter implementation function ','line_number':1292,'multiline':True]['text':' there is no WithOffsets implementation ','line_number':1299,'multiline':True]['text':' we will write -1 for each offset ','line_number':1301,'multiline':True]['text':' normal mode ','line_number':1307,'multiline':True]['text':' avoid compiler warnings - not otherwise necessary, and the values do not matter ','line_number':1310,'multiline':True]['text':'
         * Previous m:n conversion stored source units from a partial match
         * and failed to consume all of them.
         * We need to "replay" them from a temporary buffer and convert them first.
         ','line_number':1315,'multiline':True]['text':'
     * loop for conversion and error handling
     *
     * loop {
     *   convert
     *   loop {
     *     update offsets
     *     handle end of input
     *     handle errors/call callback
     *   }
     * }
     ','line_number':1334,'multiline':True]['text':' convert ','line_number':1348,'multiline':True]['text':'
             * set a flag for whether the converter
             * successfully processed the end of the input
             *
             * need not check cnv->preToULength==0 because a replay (<0) will cause
             * s<sourceLimit before converterSawEndOfInput is checked
             ','line_number':1351,'multiline':True]['text':' handle error from getNextUChar() or ucnv_convertEx() ','line_number':1363,'multiline':True]['text':' no callback called yet for this iteration ','line_number':1367,'multiline':True]['text':' no sourceIndex adjustment for conversion, only for callback output ','line_number':1370,'multiline':True]['text':'
         * loop for offsets and error handling
         *
         * iterates at most 3 times:
         * 1. to clean up after the conversion function
         * 2. after the callback
         * 3. after the callback again if there was truncated input
         ','line_number':1373,'multiline':True]['text':' update offsets if we write any ','line_number':1382,'multiline':True]['text':'
                     * if a converter handles offsets and updates the offsets
                     * pointer at the end, then pArgs->offset should not change
                     * here;
                     * however, some converters do not handle offsets at all
                     * (sourceIndex<0) or may not update the offsets pointer
                     ','line_number':1388,'multiline':True]['text':'
                 * switch the source to new replay units (cannot occur while replaying)
                 * after offset handling and before end-of-input and callback handling
                 ','line_number':1404,'multiline':True]['text':' see implementation note before _fromUnicodeWithCallback() ','line_number':1424,'multiline':True]['text':' update pointers ','line_number':1430,'multiline':True]['text':'
                     * continue with the conversion loop while there is still input left
                     * (continue converting by breaking out of only the inner loop)
                     ','line_number':1436,'multiline':True]['text':' switch back from replaying to the real source and continue ','line_number':1442,'multiline':True]['text':'
                     * the entire input stream is consumed
                     * and there is a partial, truncated input sequence left
                     ','line_number':1451,'multiline':True]['text':' inject an error and continue with callback handling ','line_number':1456,'multiline':True]['text':' new error condition ','line_number':1458,'multiline':True]['text':' input consumed ','line_number':1460,'multiline':True]['text':'
                         * return to the conversion loop once more if the flush
                         * flag is set and the conversion function has not
                         * successfully processed the end of the input yet
                         *
                         * (continue converting by breaking out of only the inner loop)
                         ','line_number':1462,'multiline':True]['text':' reset the converter without calling the callback function ','line_number':1473,'multiline':True]['text':' done successfully ','line_number':1477,'multiline':True]['text':' U_FAILURE(*err) ','line_number':1482,'multiline':True]['text':'
                     * the callback did not or cannot resolve the error:
                     * set output pointers and return
                     *
                     * the check for buffer overflow is redundant but it is
                     * a high-runner case and hopefully documents the intent
                     * well
                     *
                     * if we were replaying, then the replay buffer must be
                     * copied back into the UConverter
                     * and the real arguments must be restored
                     ','line_number':1494,'multiline':True]['text':' copy toUBytes[] to invalidCharBuffer[] ','line_number':1526,'multiline':True]['text':' set the converter state to deal with the next character ','line_number':1532,'multiline':True]['text':' call the callback function ','line_number':1535,'multiline':True]['text':' reset to default value ','line_number':1543,'multiline':True]['text':'
             * loop back to the offset handling
             *
             * this flag will indicate after offset handling
             * that a callback was called;
             * if the callback did not resolve the error, then we return
             ','line_number':1545,'multiline':True]['text':'
 * Output the toUnicode overflow buffer.
 * Call this function if(cnv->UCharErrorBufferLength>0).
 * @return TRUE if overflow
 ','line_number':1557,'multiline':True]['text':' the overflow buffer contains too much, keep the rest ','line_number':1583,'multiline':True]['text':' copy the overflow contents to the target ','line_number':1599,'multiline':True]['text':' no source index available for old output ','line_number':1602,'multiline':True]['text':' the overflow buffer is completely copied to the target ','line_number':1606,'multiline':True]['text':' check parameters ','line_number':1626,'multiline':True]['text':'
        Prevent code from going into an infinite loop in case we do hit this
        limit. The limit pointer is expected to be on a UChar * boundary.
        This also prevents the next argument check from failing.
        ','line_number':1640,'multiline':True]['text':'
     * All these conditions should never happen.
     *
     * 1) Make sure that the limits are >= to the address source or target
     *
     * 2) Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be sourceLimit=t+0x7fffffff; for example.
     *
     * 3) Make sure that the user didn't incorrectly cast a UChar * pointer
     * to a char * pointer and provide an incomplete UChar code unit.
     ','line_number':1648,'multiline':True]['text':' output the target overflow buffer ','line_number':1676,'multiline':True]['text':' U_BUFFER_OVERFLOW_ERROR ','line_number':1680,'multiline':True]['text':' *target may have moved, therefore stop using t ','line_number':1683,'multiline':True]['text':' the overflow buffer is emptied and there is no new input: we are done ','line_number':1686,'multiline':True]['text':'
     * Do not simply return with a buffer overflow error if
     * !flush && t==targetLimit
     * because it is possible that the source will not generate any output.
     * For example, the skip callback may be called;
     * it does not output anything.
     ','line_number':1690,'multiline':True]['text':' prepare the converter arguments ','line_number':1698,'multiline':True]['text':' ucnv_to/fromUChars() ----------------------------------------------------- ','line_number':1714,'multiline':True]['text':' check arguments ','line_number':1725,'multiline':True]['text':' initialize ','line_number':1738,'multiline':True]['text':' perform the conversion ','line_number':1749,'multiline':True]['text':' if an overflow occurs, then get the preflighting length ','line_number':1753,'multiline':True]['text':' check arguments ','line_number':1781,'multiline':True]['text':' initialize ','line_number':1794,'multiline':True]['text':' perform the conversion ','line_number':1805,'multiline':True]['text':' if an overflow occurs, then get the preflighting length ','line_number':1809,'multiline':True]['text':' ucnv_getNextUChar() ------------------------------------------------------ ','line_number':1830,'multiline':True]['text':' check parameters ','line_number':1842,'multiline':True]['text':'
     * Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be sourceLimit=t+0x7fffffff; for example.
     ','line_number':1858,'multiline':True]['text':' flush the target overflow buffer ','line_number':1877,'multiline':True]['text':' move the remaining overflow contents up to the beginning ','line_number':1886,'multiline':True]['text':'
         * Continue if the overflow buffer contained only a lead surrogate,
         * in case the converter outputs single surrogates from complete
         * input sequences.
         ','line_number':1895,'multiline':True]['text':'
     * flush==TRUE is implied for ucnv_getNextUChar()
     *
     * do not simply return even if s==sourceLimit because the converter may
     * not have seen flush==TRUE before
     ','line_number':1902,'multiline':True]['text':' prepare the converter arguments ','line_number':1909,'multiline':True]['text':'
         * call the native getNextUChar() implementation if we are
         * at a character boundary (toULength==0)
         *
         * unlike with _toUnicode(), getNextUChar() implementations must set
         * U_TRUNCATED_CHAR_FOUND for truncated input,
         * in addition to setting toULength/toUBytes[]
         ','line_number':1920,'multiline':True]['text':' reset the converter without calling the callback function ','line_number':1932,'multiline':True]['text':' no output ','line_number':1934,'multiline':True]['text':'
             * else fall through to use _toUnicode() because
             *   UCNV_GET_NEXT_UCHAR_USE_TO_U: the native function did not want to handle it after all
             *   U_FAILURE: call _toUnicode() for callback handling (do not output c)
             ','line_number':1937,'multiline':True]['text':' convert to one UChar in buffer[0], or handle getNextUChar() errors ','line_number':1945,'multiline':True]['text':' write the lead surrogate from the overflow buffer ','line_number':1955,'multiline':True]['text':' buffer contents starts at i and ends before length ','line_number':1962,'multiline':True]['text':' no output ','line_number':1965,'multiline':True]['text':' no input or only state changes ','line_number':1967,'multiline':True]['text':' no need to reset explicitly because _toUnicodeWithCallback() did it ','line_number':1969,'multiline':True]['text':' no output ','line_number':1970,'multiline':True]['text':' consume c=buffer[0], done ','line_number':1975,'multiline':True]['text':' got a lead surrogate, see if a trail surrogate follows ','line_number':1977,'multiline':True]['text':' got overflow output from the conversion ','line_number':1981,'multiline':True]['text':' got a trail surrogate, too ','line_number':1983,'multiline':True]['text':' move the remaining overflow contents up to the beginning ','line_number':1986,'multiline':True]['text':' c is an unpaired lead surrogate, just return it ','line_number':1992,'multiline':True]['text':' convert once more, to buffer[1] ','line_number':1995,'multiline':True]['text':' got a trail surrogate, too ','line_number':2004,'multiline':True]['text':'
     * move leftover output from buffer[i..length[
     * into the beginning of the overflow buffer
     ','line_number':2012,'multiline':True]['text':' move further overflow back ','line_number':2017,'multiline':True]['text':' ucnv_convert() and siblings ---------------------------------------------- ','line_number':2035,'multiline':True]['text':' error checking ','line_number':2055,'multiline':True]['text':'
     * Make sure that the buffer sizes do not exceed the number range for
     * int32_t. See ucnv_toUnicode() for a more detailed comment.
     ','line_number':2075,'multiline':True]['text':' streaming conversion requires an explicit pivot buffer ','line_number':2089,'multiline':True]['text':' use the stack pivot buffer ','line_number':2094,'multiline':True]['text':' get limit of single-byte-NUL-terminated source string ','line_number':2109,'multiline':True]['text':' output the targetCnv overflow buffer ','line_number':2118,'multiline':True]['text':' U_BUFFER_OVERFLOW_ERROR ','line_number':2120,'multiline':True]['text':' *target has moved, therefore stop using t ','line_number':2123,'multiline':True]['text':' the fromUnicode overflow buffer is emptied and there is no new input: we are done ','line_number':2129,'multiline':True]['text':' Is direct-UTF-8 conversion available? ','line_number':2134,'multiline':True]['text':'
     * If direct-UTF-8 conversion is available, then we use a smaller
     * pivot buffer for error handling and partial matches
     * so that we quickly return to direct conversion.
     *
     * 32 is large enough for UCNV_EXT_MAX_UCHARS and UCNV_ERROR_BUFFER_LENGTH.
     *
     * We could reduce the pivot buffer size further, at the cost of
     * buffer overflows from callbacks.
     * The pivot buffer should not be smaller than the maximum number of
     * fromUnicode extension table input UChars
     * (for m:n conversion, see
     * targetCnv->sharedData->mbcs.extIndexes[UCNV_EXT_COUNT_UCHARS])
     * or 2 for surrogate pairs.
     *
     * Too small a buffer can cause thrashing between pivoting and direct
     * conversion, with function call overhead outweighing the benefits
     * of direct conversion.
     ','line_number':2147,'multiline':True]['text':' prepare the converter arguments ','line_number':2170,'multiline':True]['text':'
     * TODO: Consider separating this function into two functions,
     * extracting exactly the conversion loop,
     * for readability and to reduce the set of visible variables.
     *
     * Otherwise stop using s and t from here on.
     ','line_number':2186,'multiline':True]['text':'
     * conversion loop
     *
     * The sequence of steps in the loop may appear backward,
     * but the principle is simple:
     * In the chain of
     *   source - sourceCnv overflow - pivot - targetCnv overflow - target
     * empty out later buffers before refilling them from earlier ones.
     *
     * The targetCnv overflow buffer is flushed out only once before the loop.
     ','line_number':2195,'multiline':True]['text':'
         * if(pivot not empty or error or replay or flush fromUnicode) {
         *   fromUnicode(pivot -> target);
         * }
         *
         * For pivoting conversion; and for direct conversion for
         * error callback handling and flushing the replay buffer.
         ','line_number':2207,'multiline':True]['text':' target overflow, or conversion error ','line_number':2224,'multiline':True]['text':'
             * _fromUnicodeWithCallback() must have consumed the pivot contents
             * (*pivotSource==*pivotTarget) since it returned with U_SUCCESS()
             ','line_number':2229,'multiline':True]['text':' The pivot buffer is empty; reset it so we start at pivotStart. ','line_number':2235,'multiline':True]['text':'
         * if(sourceCnv overflow buffer not empty) {
         *     move(sourceCnv overflow buffer -> pivot);
         *     continue;
         * }
         ','line_number':2238,'multiline':True]['text':' output the sourceCnv overflow buffer ','line_number':2244,'multiline':True]['text':' U_BUFFER_OVERFLOW_ERROR ','line_number':2247,'multiline':True]['text':'
         * check for end of input and break if done
         *
         * Checking both flush and fromUArgs.flush ensures that the converters
         * have been called with the flush flag set if the ucnv_convertEx()
         * caller set it.
         ','line_number':2253,'multiline':True]['text':' done successfully ','line_number':2264,'multiline':True]['text':'
         * use direct conversion if available
         * but not if continuing a partial match
         * or flushing the toUnicode replay buffer
         ','line_number':2268,'multiline':True]['text':' remove a warning that may be set by this function ','line_number':2275,'multiline':True]['text':'
                     * Fall through to calling _toUnicodeWithCallback()
                     * for callback handling.
                     *
                     * The pivot buffer will be reset with
                     *   *pivotSource=*pivotTarget=pivotStart;
                     * which indicates a toUnicode error to the caller
                     * (*pivotSource==pivotStart shows no pivot UChars consumed).
                     ','line_number':2283,'multiline':True]['text':'
                     * Indicate a fromUnicode error to the caller
                     * (*pivotSource>pivotStart shows some pivot UChars consumed).
                     ','line_number':2293,'multiline':True]['text':'
                     * Loop around to calling _fromUnicodeWithCallbacks()
                     * for callback handling.
                     ','line_number':2298,'multiline':True]['text':'
                 * No error, but the implementation requested to temporarily
                 * fall back to pivoting.
                 ','line_number':2305,'multiline':True]['text':'
             * The following else branches are almost identical to the end-of-input
             * handling in _toUnicodeWithCallback().
             * Avoid calling it just for the end of input.
             ','line_number':2310,'multiline':True]['text':' flush==toUArgs.flush ','line_number':2315,'multiline':True]['text':'
                 * the entire input stream is consumed
                 * and there is a partial, truncated input sequence left
                 ','line_number':2316,'multiline':True]['text':' inject an error and continue with callback handling ','line_number':2321,'multiline':True]['text':' input consumed ','line_number':2324,'multiline':True]['text':' reset the converters without calling the callback functions ','line_number':2326,'multiline':True]['text':' done successfully ','line_number':2331,'multiline':True]['text':'
         * toUnicode(source -> pivot);
         *
         * For pivoting conversion; and for direct conversion for
         * error callback handling, continuing partial matches
         * and flushing the replay buffer.
         *
         * The pivot buffer is empty and reset.
         ','line_number':2336,'multiline':True]['text':' ==*pivotTarget ','line_number':2345,'multiline':True]['text':' toUArgs.targetLimit=pivotLimit; already set before the loop ','line_number':2346,'multiline':True]['text':' pivot overflow: continue with the conversion loop ','line_number':2350,'multiline':True]['text':' conversion error, or there was nothing left to convert ','line_number':2353,'multiline':True]['text':'
         * else:
         * _toUnicodeWithCallback() wrote into the pivot buffer,
         * continue with fromUnicode conversion.
         *
         * Set the fromUnicode flush flag if we flush and if toUnicode has
         * processed the end of the input.
         ','line_number':2356,'multiline':True]['text':'
     * The conversion loop is exited when one of the following is true:
     * - the entire source text has been converted successfully to the target buffer
     * - a target buffer overflow occurred
     * - a conversion error occurred
     ','line_number':2372,'multiline':True]['text':' terminate the target buffer if possible ','line_number':2382,'multiline':True]['text':' internal implementation of ucnv_convert() etc. with preflighting ','line_number':2395,'multiline':True]['text':' set up ','line_number':2409,'multiline':True]['text':' if there is no input data, we're done ','line_number':2416,'multiline':True]['text':' perform real conversion ','line_number':2426,'multiline':True]['text':'
     * If the output buffer is exhausted (or we are only "preflighting"), we need to stop writing
     * to it but continue the conversion in order to store in targetCapacity
     * the number of bytes that was required.
     ','line_number':2438,'multiline':True]['text':' done with preflighting, set warnings and errors as appropriate ','line_number':2461,'multiline':True]['text':' no need to call u_terminateChars() because ucnv_convertEx() took care of that ','line_number':2465,'multiline':True]['text':' stack-allocated ','line_number':2474,'multiline':True]['text':' if there is no input data, we're done ','line_number':2489,'multiline':True]['text':' create the converters ','line_number':2494,'multiline':True]['text':' @internal ','line_number':2517,'multiline':True]['text':' stack-allocated ','line_number':2525,'multiline':True]['text':' if there is no input data, we're done ','line_number':2540,'multiline':True]['text':' create the algorithmic converter ','line_number':2545,'multiline':True]['text':' reset the other converter ','line_number':2552,'multiline':True]['text':' cnv->Unicode->algo ','line_number':2554,'multiline':True]['text':' algo->Unicode->cnv ','line_number':2559,'multiline':True]['text':' initial 0xa5 bytes: make sure that if we read <SIG_MAX_LEN
     * bytes we don't misdetect something 
     ','line_number':2753,'multiline':True]['text':'
         * UTF-7: Initial U+FEFF is encoded as +/v8  or  +/v9  or  +/v+  or  +/v/
         * depending on the second UTF-16 code unit.
         * Detect the entire, closed Unicode mode sequence +/v8- for only U+FEFF
         * if it occurs.
         *
         * So far we have +/v
         ','line_number':2807,'multiline':True]['text':' 5 bytes +/v8- ','line_number':2816,'multiline':True]['text':' 4 bytes +/v8  or  +/v9  or  +/v+  or  +/v/ ','line_number':2820,'multiline':True]['text':' no known Unicode signature byte sequence recognized ','line_number':2830,'multiline':True]['text':'
 * Hey, Emacs, please set the following:
 *
 * Local Variables:
 * indent-tabs-mode: nil
 * End:
 *
 ','line_number':2903,'multiline':True]