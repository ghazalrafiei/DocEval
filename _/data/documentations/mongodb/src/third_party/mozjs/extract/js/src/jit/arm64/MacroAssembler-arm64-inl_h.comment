['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'{{{ check_macroassembler_style','line_number':15,'multiline':False]['text':' ===============================================================','line_number':77,'multiline':False]['text':' Load instructions','line_number':78,'multiline':False]['text':' ===============================================================','line_number':87,'multiline':False]['text':' Logical instructions','line_number':88,'multiline':False]['text':' ===============================================================','line_number':224,'multiline':False]['text':' Swap instructions','line_number':225,'multiline':False]['text':' ===============================================================','line_number':245,'multiline':False]['text':' Arithmetic functions','line_number':246,'multiline':False]['text':' max number of instructions in scope = ','line_number':323,'multiline':True]['text':' Clear upper 32 bits.','line_number':428,'multiline':False]['text':' This does not deal with x % 0 or INT_MIN % -1, the caller needs to filter','line_number':507,'multiline':False]['text':' those cases when they may occur.','line_number':508,'multiline':False]['text':' Always true for wasm','line_number':585,'multiline':False]['text':' Always true for wasm','line_number':592,'multiline':False]['text':' Always true for wasm','line_number':599,'multiline':False]['text':' Always true for wasm','line_number':606,'multiline':False]['text':' ===============================================================','line_number':611,'multiline':False]['text':' Shift functions','line_number':612,'multiline':False]['text':' ===============================================================','line_number':710,'multiline':False]['text':' Condition functions','line_number':711,'multiline':False]['text':' ===============================================================','line_number':725,'multiline':False]['text':' Rotation functions','line_number':726,'multiline':False]['text':' Really 32 - count, but the upper bits of the result are ignored.','line_number':735,'multiline':False]['text':' Really 64 - count, but the upper bits of the result are ignored.','line_number':755,'multiline':False]['text':' ===============================================================','line_number':783,'multiline':False]['text':' Bit counting functions','line_number':784,'multiline':False]['text':' Equivalent to mozilla::CountPopulation32().','line_number':807,'multiline':False]['text':' Equivalent to mozilla::CountPopulation64(), though likely more efficient.','line_number':835,'multiline':False]['text':' ===============================================================','line_number':860,'multiline':False]['text':' Branch functions','line_number':861,'multiline':False]['text':' not equal *and* ordered','line_number':1141,'multiline':False]['text':' not equal *and* ordered','line_number':1185,'multiline':False]['text':' An out of range integer will be saturated to the destination size.','line_number':1206,'multiline':False]['text':' The x86-biased front end prefers |test foo, foo| to |cmp foo, #0|.  We look','line_number':1300,'multiline':False]['text':' for the former pattern and expand as Cbz/Cbnz when possible.','line_number':1301,'multiline':False]['text':' See branchTest32.','line_number':1341,'multiline':False]['text':' falsy values are zero, and NaN.','line_number':1469,'multiline':False]['text':' truthy values are non-zero and not nan.','line_number':1473,'multiline':False]['text':' If it is overflow','line_number':1474,'multiline':False]['text':' ARM64 does not support conditional loads, so we use a branch with a CSel','line_number':1818,'multiline':False]['text':' (to prevent Spectre attacks).','line_number':1819,'multiline':False]['text':' Can't use branch32() here, because it may select Cbz/Cbnz which don't','line_number':1823,'multiline':False]['text':' affect condition flags.','line_number':1824,'multiline':False]['text':' ARM64 does not support conditional loads, so we use a branch with a CSel','line_number':1839,'multiline':False]['text':' (to prevent Spectre attacks).','line_number':1840,'multiline':False]['text':' ========================================================================','line_number':1929,'multiline':False]['text':' Memory access primitives.','line_number':1930,'multiline':False]['text':' Bug 1715494: Discriminating barriers such as StoreStore are hard to reason','line_number':1950,'multiline':False]['text':' about.  Execute the full barrier for everything that requires a barrier.','line_number':1951,'multiline':False]['text':' ===============================================================','line_number':1957,'multiline':False]['text':' Clamping functions.','line_number':1958,'multiline':False]['text':' dest := src XOR mask','line_number':1976,'multiline':False]['text':' fail if dest >> JSVAL_TAG_SHIFT != 0','line_number':1977,'multiline':False]['text':'}}} check_macroassembler_style','line_number':1997,'multiline':False]['text':' Wasm SIMD','line_number':1999,'multiline':False]['text':'{{{ check_macroassembler_style','line_number':2026,'multiline':False]['text':' Moves','line_number':2028,'multiline':False]['text':' Unclear what the best code is here, xor is just what we do on x86.','line_number':2037,'multiline':False]['text':' Alternatives would be `FMOV dest.4s, #0` and `FMOV dest, xzr`.','line_number':2038,'multiline':False]['text':' Movi does not yet generate good code for many cases, bug 1664397.','line_number':2044,'multiline':False]['text':' Splat','line_number':2049,'multiline':False]['text':' Extract lane as scalar.  Float extraction does not canonicalize the value.','line_number':2085,'multiline':False]['text':' Replace lane value','line_number':2147,'multiline':False]['text':' Shuffle - blend and permute with immediate indices, and its many','line_number':2185,'multiline':False]['text':' specializations.  Lane values other than those mentioned are illegal.','line_number':2186,'multiline':False]['text':' lane values 0..31','line_number':2188,'multiline':False]['text':' The general solution generates ho-hum code.  Realistic programs will use','line_number':2191,'multiline':False]['text':' patterns that can be specialized, and this will be much better.  That will','line_number':2192,'multiline':False]['text':' be handled by bug 1656834, so don't worry about it here.','line_number':2193,'multiline':False]['text':' Set scratch to the lanevalue when it selects from lhs or ~lanevalue when it','line_number':2195,'multiline':False]['text':' selects from rhs.','line_number':2196,'multiline':False]['text':'lanes','line_number':2255,'multiline':True]['text':' Swizzle - permute with variable indices.  `rhs` holds the lanes parameter.','line_number':2371,'multiline':False]['text':' Integer Add','line_number':2382,'multiline':False]['text':' Integer Subtract','line_number':2420,'multiline':False]['text':' Integer Multiply','line_number':2458,'multiline':False]['text':' As documented at https://chromium-review.googlesource.com/c/v8/v8/+/1781696','line_number':2481,'multiline':False]['text':' lhs = <D C> <B A>','line_number':2482,'multiline':False]['text':' rhs = <H G> <F E>','line_number':2483,'multiline':False]['text':' result = <(DG+CH)_low+CG_high CG_low> <(BE+AF)_low+AE_high AE_low>','line_number':2484,'multiline':False]['text':' temp2 = <C D> <A B>','line_number':2486,'multiline':False]['text':' temp2 = <CH DG> <AF BE>','line_number':2487,'multiline':False]['text':' temp1 = <0 0> <G E>','line_number':2488,'multiline':False]['text':' temp2 = <CH+DG AF+BE>..','line_number':2489,'multiline':False]['text':' scratch = <0 0> <C A>','line_number':2490,'multiline':False]['text':' dest = <(DG+CH)_low 0>','line_number':2491,'multiline':False]['text':'        <(BE+AF)_low 0>','line_number':2492,'multiline':False]['text':' Integer Negate','line_number':2632,'multiline':False]['text':' Saturating integer add','line_number':2650,'multiline':False]['text':' Saturating integer subtract','line_number':2690,'multiline':False]['text':' Lane-wise integer minimum','line_number':2730,'multiline':False]['text':' Lane-wise integer maximum','line_number':2789,'multiline':False]['text':' Lane-wise integer rounding average','line_number':2848,'multiline':False]['text':' Lane-wise integer absolute value','line_number':2872,'multiline':False]['text':' Left shift by variable scalar','line_number':2890,'multiline':False]['text':' Right shift by variable scalar','line_number':2952,'multiline':False]['text':' isUnsigned ','line_number':2957,'multiline':True]['text':' isUnsigned ','line_number':2968,'multiline':True]['text':' isUnsigned ','line_number':2979,'multiline':True]['text':' isUnsigned ','line_number':2990,'multiline':True]['text':' isUnsigned ','line_number':3001,'multiline':True]['text':' isUnsigned ','line_number':3012,'multiline':True]['text':' isUnsigned ','line_number':3023,'multiline':True]['text':' isUnsigned ','line_number':3034,'multiline':True]['text':' Bitwise and, or, xor, not','line_number':3042,'multiline':False]['text':' Bitwise AND with complement: dest = ~lhs & rhs, note this is not what Wasm','line_number':3083,'multiline':False]['text':' wants but what the x86 hardware offers.  Hence the name.  Since arm64 has','line_number':3084,'multiline':False]['text':' dest = lhs & ~rhs we just swap operands.','line_number':3085,'multiline':False]['text':' Bitwise select','line_number':3092,'multiline':False]['text':' Population count','line_number':3100,'multiline':False]['text':' Any lane true, ie, any bit set','line_number':3106,'multiline':False]['text':' All lanes true','line_number':3118,'multiline':False]['text':' Bitmask, ie extract and compress high bits of all lanes','line_number':3160,'multiline':False]['text':'','line_number':3161,'multiline':False]['text':' There's no direct support for this on the chip.  These implementations come','line_number':3162,'multiline':False]['text':' from the writeup that added the instruction to the SIMD instruction set.','line_number':3163,'multiline':False]['text':' Generally, shifting and masking is used to isolate the sign bit of each','line_number':3164,'multiline':False]['text':' element in the right position, then a horizontal add creates the result.  For','line_number':3165,'multiline':False]['text':' 8-bit elements an intermediate step is needed to assemble the bits of the','line_number':3166,'multiline':False]['text':' upper and lower 8 bytes into 8 halfwords.','line_number':3167,'multiline':False]['text':' Comparisons (integer and floating-point)','line_number':3213,'multiline':False]['text':' Load','line_number':3283,'multiline':False]['text':' Store','line_number':3295,'multiline':False]['text':' Floating point negation','line_number':3307,'multiline':False]['text':' Floating point absolute value','line_number':3317,'multiline':False]['text':' NaN-propagating minimum','line_number':3327,'multiline':False]['text':' NaN-propagating maximum','line_number':3347,'multiline':False]['text':' Floating add','line_number':3367,'multiline':False]['text':' Floating subtract','line_number':3387,'multiline':False]['text':' Floating division','line_number':3407,'multiline':False]['text':' Floating Multiply','line_number':3427,'multiline':False]['text':' Pairwise add','line_number':3447,'multiline':False]['text':' Floating square root','line_number':3469,'multiline':False]['text':' Integer to floating point with rounding','line_number':3479,'multiline':False]['text':' Floating point to integer with saturation','line_number':3503,'multiline':False]['text':' Floating point narrowing','line_number':3529,'multiline':False]['text':' Floating point widening','line_number':3536,'multiline':False]['text':' Integer to integer narrowing','line_number':3543,'multiline':False]['text':' Integer to integer widening','line_number':3631,'multiline':False]['text':' Compare-based minimum/maximum (experimental as of August, 2020)','line_number':3687,'multiline':False]['text':' https://github.com/WebAssembly/simd/pull/122','line_number':3688,'multiline':False]['text':' Shut up the linter by using the same names as in the declaration, then','line_number':3692,'multiline':False]['text':' aliasing here.','line_number':3693,'multiline':False]['text':' Widening/pairwise integer dot product (experimental as of August, 2020)','line_number':3764,'multiline':False]['text':' https://github.com/WebAssembly/simd/pull/127','line_number':3765,'multiline':False]['text':' Floating point rounding (experimental as of August, 2020)','line_number':3779,'multiline':False]['text':' https://github.com/WebAssembly/simd/pull/232','line_number':3780,'multiline':False]['text':'}}} check_macroassembler_style','line_number':3814,'multiline':False]['text':' ===============================================================','line_number':3815,'multiline':False]['text':' Given that required invariant SP <= PSP, this is probably pointless,','line_number':3819,'multiline':False]['text':' since it gives PSP a larger value.','line_number':3820,'multiline':False]['text':' As above, probably pointless.','line_number':3826,'multiline':False]['text':' As above, probably pointless.','line_number':3835,'multiline':False]['text':' syncStackPtr() not needed since our SP is the real SP.','line_number':3863,'multiline':False]['text':' syncStackPtr() not needed since our SP is the real SP.','line_number':3885,'multiline':False]['text':' Cmp disallows SP as the rhs, so flip the operands and invert the','line_number':3935,'multiline':False]['text':' condition.','line_number':3936,'multiline':False]['text':' Cmp disallows SP as the rhs, so flip the operands and invert the','line_number':3947,'multiline':False]['text':' condition.','line_number':3948,'multiline':False]['text':' If source is a double, load into dest.','line_number':3953,'multiline':False]['text':' If source is int32, convert to double and store in dest.','line_number':3954,'multiline':False]['text':' Else, branch to failure.','line_number':3955,'multiline':False]['text':' namespace jit','line_number':3991,'multiline':False]['text':' namespace js','line_number':3992,'multiline':False]['text':' jit_arm64_MacroAssembler_arm64_inl_h ','line_number':3994,'multiline':True]