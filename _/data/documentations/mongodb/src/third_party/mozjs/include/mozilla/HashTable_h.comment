['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]['text':'---------------------------------------------------------------------------','line_number':7,'multiline':False]['text':' Overview','line_number':8,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':' This file defines HashMap<Key, Value> and HashSet<T>, hash tables that are','line_number':11,'multiline':False]['text':' fast and have a nice API.','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' Both hash tables have two optional template parameters.','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' - HashPolicy. This defines the operations for hashing and matching keys. The','line_number':16,'multiline':False]['text':'   default HashPolicy is appropriate when both of the following two','line_number':17,'multiline':False]['text':'   conditions are true.','line_number':18,'multiline':False]['text':'','line_number':19,'multiline':False]['text':'   - The key type stored in the table (|Key| for |HashMap<Key, Value>|, |T|','line_number':20,'multiline':False]['text':'     for |HashSet<T>|) is an integer, pointer, UniquePtr, float, or double.','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':'   - The type used for lookups (|Lookup|) is the same as the key type. This','line_number':23,'multiline':False]['text':'     is usually the case, but not always.','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':'   There is also a |CStringHasher| policy for |char*| keys. If your keys','line_number':26,'multiline':False]['text':'   don't match any of the above cases, you must provide your own hash policy;','line_number':27,'multiline':False]['text':'   see the "Hash Policy" section below.','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' - AllocPolicy. This defines how allocations are done by the table.','line_number':30,'multiline':False]['text':'','line_number':31,'multiline':False]['text':'   - |MallocAllocPolicy| is the default and is usually appropriate; note that','line_number':32,'multiline':False]['text':'     operations (such as insertions) that might cause allocations are','line_number':33,'multiline':False]['text':'     fallible and must be checked for OOM. These checks are enforced by the','line_number':34,'multiline':False]['text':'     use of [[nodiscard]].','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':'   - |InfallibleAllocPolicy| is another possibility; it allows the','line_number':37,'multiline':False]['text':'     abovementioned OOM checks to be done with MOZ_ALWAYS_TRUE().','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'   Note that entry storage allocation is lazy, and not done until the first','line_number':40,'multiline':False]['text':'   lookupForAdd(), put(), or putNew() is performed.','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':'  See AllocPolicy.h for more details.','line_number':43,'multiline':False]['text':'','line_number':44,'multiline':False]['text':' Documentation on how to use HashMap and HashSet, including examples, is','line_number':45,'multiline':False]['text':' present within those classes. Search for "class HashMap" and "class','line_number':46,'multiline':False]['text':' HashSet".','line_number':47,'multiline':False]['text':'','line_number':48,'multiline':False]['text':' Both HashMap and HashSet are implemented on top of a third class, HashTable.','line_number':49,'multiline':False]['text':' You only need to look at HashTable if you want to understand the','line_number':50,'multiline':False]['text':' implementation.','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' How does mozilla::HashTable (this file) compare with PLDHashTable (and its','line_number':53,'multiline':False]['text':' subclasses, such as nsTHashtable)?','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' - mozilla::HashTable is a lot faster, largely because it uses templates','line_number':56,'multiline':False]['text':'   throughout *and* inlines everything. PLDHashTable inlines operations much','line_number':57,'multiline':False]['text':'   less aggressively, and also uses "virtual ops" for operations like hashing','line_number':58,'multiline':False]['text':'   and matching entries that require function calls.','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':' - Correspondingly, mozilla::HashTable use is likely to increase executable','line_number':61,'multiline':False]['text':'   size much more than PLDHashTable.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':' - mozilla::HashTable has a nicer API, with a proper HashSet vs. HashMap','line_number':64,'multiline':False]['text':'   distinction.','line_number':65,'multiline':False]['text':'','line_number':66,'multiline':False]['text':' - mozilla::HashTable requires more explicit OOM checking. As mentioned','line_number':67,'multiline':False]['text':'   above, the use of |InfallibleAllocPolicy| can simplify things.','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' - mozilla::HashTable has a default capacity on creation of 32 and a minimum','line_number':70,'multiline':False]['text':'   capacity of 4. PLDHashTable has a default capacity on creation of 8 and a','line_number':71,'multiline':False]['text':'   minimum capacity of 8.','line_number':72,'multiline':False]['text':' namespace detail','line_number':111,'multiline':False]['text':' The "generation" of a hash table is an opaque value indicating the state of','line_number':113,'multiline':False]['text':' modification of the hash table through its lifetime.  If the generation of','line_number':114,'multiline':False]['text':' a hash table compares equal at times T1 and T2, then lookups in the hash','line_number':115,'multiline':False]['text':' table, pointers to (or into) hash table entries, etc. at time T1 are valid','line_number':116,'multiline':False]['text':' at time T2.  If the generation compares unequal, these computations are all','line_number':117,'multiline':False]['text':' invalid and must be performed again to be used.','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' Generations are meaningfully comparable only with respect to a single hash','line_number':120,'multiline':False]['text':' table.  It's always nonsensical to compare the generation of distinct hash','line_number':121,'multiline':False]['text':' tables H1 and H2.','line_number':122,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':125,'multiline':False]['text':' HashMap','line_number':126,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':127,'multiline':False]['text':' HashMap is a fast hash-based map from keys to values.','line_number':129,'multiline':False]['text':'','line_number':130,'multiline':False]['text':' Template parameter requirements:','line_number':131,'multiline':False]['text':' - Key/Value: movable, destructible, assignable.','line_number':132,'multiline':False]['text':' - HashPolicy: see the "Hash Policy" section below.','line_number':133,'multiline':False]['text':' - AllocPolicy: see AllocPolicy.h.','line_number':134,'multiline':False]['text':'','line_number':135,'multiline':False]['text':' Note:','line_number':136,'multiline':False]['text':' - HashMap is not reentrant: Key/Value/HashPolicy/AllocPolicy members','line_number':137,'multiline':False]['text':'   called by HashMap must not call back into the same HashMap object.','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' -- Implementation details -----------------------------------------------','line_number':143,'multiline':False]['text':' HashMap is not copyable or assignable.','line_number':145,'multiline':False]['text':' -- Initialization -------------------------------------------------------','line_number':171,'multiline':False]['text':' HashMap is movable.','line_number':179,'multiline':False]['text':' -- Status and sizing ----------------------------------------------------','line_number':183,'multiline':False]['text':' The map's current generation.','line_number':185,'multiline':False]['text':' Is the map empty?','line_number':188,'multiline':False]['text':' Number of keys/values in the map.','line_number':191,'multiline':False]['text':' Number of key/value slots in the map. Note: resize will happen well before','line_number':194,'multiline':False]['text':' count() == capacity().','line_number':195,'multiline':False]['text':' The size of the map's entry storage, in bytes. If the keys/values contain','line_number':198,'multiline':False]['text':' pointers to other heap blocks, you must iterate over the map and measure','line_number':199,'multiline':False]['text':' them separately; hence the "shallow" prefix.','line_number':200,'multiline':False]['text':' Attempt to minimize the capacity(). If the table is empty, this will free','line_number':209,'multiline':False]['text':' the empty storage and upon regrowth it will be given the minimum capacity.','line_number':210,'multiline':False]['text':' Attempt to reserve enough space to fit at least |aLen| elements. Does','line_number':213,'multiline':False]['text':' nothing if the map already has sufficient capacity.','line_number':214,'multiline':False]['text':' -- Lookups --------------------------------------------------------------','line_number':217,'multiline':False]['text':' Does the map contain a key/value matching |aLookup|?','line_number':219,'multiline':False]['text':' Return a Ptr indicating whether a key/value matching |aLookup| is','line_number':224,'multiline':False]['text':' present in the map. E.g.:','line_number':225,'multiline':False]['text':'','line_number':226,'multiline':False]['text':'   using HM = HashMap<int,char>;','line_number':227,'multiline':False]['text':'   HM h;','line_number':228,'multiline':False]['text':'   if (HM::Ptr p = h.lookup(3)) {','line_number':229,'multiline':False]['text':'     assert(p->key() == 3);','line_number':230,'multiline':False]['text':'     char val = p->value();','line_number':231,'multiline':False]['text':'   }','line_number':232,'multiline':False]['text':'','line_number':233,'multiline':False]['text':' Like lookup(), but does not assert if two threads call it at the same','line_number':239,'multiline':False]['text':' time. Only use this method when none of the threads will modify the map.','line_number':240,'multiline':False]['text':' -- Insertions -----------------------------------------------------------','line_number':245,'multiline':False]['text':' Overwrite existing value with |aValue|, or add it if not present. Returns','line_number':247,'multiline':False]['text':' false on OOM.','line_number':248,'multiline':False]['text':' Like put(), but slightly faster. Must only be used when the given key is','line_number':260,'multiline':False]['text':' not already present. (In debug builds, assertions check this.)','line_number':261,'multiline':False]['text':' Like putNew(), but should be only used when the table is known to be big','line_number':275,'multiline':False]['text':' enough for the insertion, and hashing cannot fail. Typically this is used','line_number':276,'multiline':False]['text':' to populate an empty map with known-unique keys after reserving space with','line_number':277,'multiline':False]['text':' reserve(), e.g.','line_number':278,'multiline':False]['text':'','line_number':279,'multiline':False]['text':'   using HM = HashMap<int,char>;','line_number':280,'multiline':False]['text':'   HM h;','line_number':281,'multiline':False]['text':'   if (!h.reserve(3)) {','line_number':282,'multiline':False]['text':'     MOZ_CRASH("OOM");','line_number':283,'multiline':False]['text':'   }','line_number':284,'multiline':False]['text':'   h.putNewInfallible(1, 'a');    // unique key','line_number':285,'multiline':False]['text':'   h.putNewInfallible(2, 'b');    // unique key','line_number':286,'multiline':False]['text':'   h.putNewInfallible(3, 'c');    // unique key','line_number':287,'multiline':False]['text':'','line_number':288,'multiline':False]['text':' Like |lookup(l)|, but on miss, |p = lookupForAdd(l)| allows efficient','line_number':295,'multiline':False]['text':' insertion of Key |k| (where |HashPolicy::match(k,l) == true|) using','line_number':296,'multiline':False]['text':' |add(p,k,v)|. After |add(p,k,v)|, |p| points to the new key/value. E.g.:','line_number':297,'multiline':False]['text':'','line_number':298,'multiline':False]['text':'   using HM = HashMap<int,char>;','line_number':299,'multiline':False]['text':'   HM h;','line_number':300,'multiline':False]['text':'   HM::AddPtr p = h.lookupForAdd(3);','line_number':301,'multiline':False]['text':'   if (!p) {','line_number':302,'multiline':False]['text':'     if (!h.add(p, 3, 'a')) {','line_number':303,'multiline':False]['text':'       return false;','line_number':304,'multiline':False]['text':'     }','line_number':305,'multiline':False]['text':'   }','line_number':306,'multiline':False]['text':'   assert(p->key() == 3);','line_number':307,'multiline':False]['text':'   char val = p->value();','line_number':308,'multiline':False]['text':'','line_number':309,'multiline':False]['text':' N.B. The caller must ensure that no mutating hash table operations occur','line_number':310,'multiline':False]['text':' between a pair of lookupForAdd() and add() calls. To avoid looking up the','line_number':311,'multiline':False]['text':' key a second time, the caller may use the more efficient relookupOrAdd()','line_number':312,'multiline':False]['text':' method. This method reuses part of the hashing computation to more','line_number':313,'multiline':False]['text':' efficiently insert the key if it has not been added. For example, a','line_number':314,'multiline':False]['text':' mutation-handling version of the previous example:','line_number':315,'multiline':False]['text':'','line_number':316,'multiline':False]['text':'    HM::AddPtr p = h.lookupForAdd(3);','line_number':317,'multiline':False]['text':'    if (!p) {','line_number':318,'multiline':False]['text':'      call_that_may_mutate_h();','line_number':319,'multiline':False]['text':'      if (!h.relookupOrAdd(p, 3, 'a')) {','line_number':320,'multiline':False]['text':'        return false;','line_number':321,'multiline':False]['text':'      }','line_number':322,'multiline':False]['text':'    }','line_number':323,'multiline':False]['text':'    assert(p->key() == 3);','line_number':324,'multiline':False]['text':'    char val = p->value();','line_number':325,'multiline':False]['text':'','line_number':326,'multiline':False]['text':' Add a key/value. Returns false on OOM.','line_number':332,'multiline':False]['text':' See the comment above lookupForAdd() for details.','line_number':339,'multiline':False]['text':' -- Removal --------------------------------------------------------------','line_number':347,'multiline':False]['text':' Lookup and remove the key/value matching |aLookup|, if present.','line_number':349,'multiline':False]['text':' Remove a previously found key/value (assuming aPtr.found()). The map must','line_number':356,'multiline':False]['text':' not have been mutated in the interim.','line_number':357,'multiline':False]['text':' Remove all keys/values without changing the capacity.','line_number':360,'multiline':False]['text':' Like clear() followed by compact().','line_number':363,'multiline':False]['text':' -- Rekeying -------------------------------------------------------------','line_number':366,'multiline':False]['text':' Infallibly rekey one entry, if necessary. Requires that template','line_number':368,'multiline':False]['text':' parameters Key and HashPolicy::Lookup are the same type.','line_number':369,'multiline':False]['text':' Infallibly rekey one entry if present, and return whether that happened.','line_number':376,'multiline':False]['text':' -- Iteration ------------------------------------------------------------','line_number':386,'multiline':False]['text':' |iter()| returns an Iterator:','line_number':388,'multiline':False]['text':'','line_number':389,'multiline':False]['text':'   HashMap<int, char> h;','line_number':390,'multiline':False]['text':'   for (auto iter = h.iter(); !iter.done(); iter.next()) {','line_number':391,'multiline':False]['text':'     char c = iter.get().value();','line_number':392,'multiline':False]['text':'   }','line_number':393,'multiline':False]['text':'','line_number':394,'multiline':False]['text':' |modIter()| returns a ModIterator:','line_number':398,'multiline':False]['text':'','line_number':399,'multiline':False]['text':'   HashMap<int, char> h;','line_number':400,'multiline':False]['text':'   for (auto iter = h.modIter(); !iter.done(); iter.next()) {','line_number':401,'multiline':False]['text':'     if (iter.get().value() == 'l') {','line_number':402,'multiline':False]['text':'       iter.remove();','line_number':403,'multiline':False]['text':'     }','line_number':404,'multiline':False]['text':'   }','line_number':405,'multiline':False]['text':'','line_number':406,'multiline':False]['text':' Table resize may occur in ModIterator's destructor.','line_number':407,'multiline':False]['text':' These are similar to Iterator/ModIterator/iter(), but use different','line_number':411,'multiline':False]['text':' terminology.','line_number':412,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':418,'multiline':False]['text':' HashSet','line_number':419,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':420,'multiline':False]['text':' HashSet is a fast hash-based set of values.','line_number':422,'multiline':False]['text':'','line_number':423,'multiline':False]['text':' Template parameter requirements:','line_number':424,'multiline':False]['text':' - T: movable, destructible, assignable.','line_number':425,'multiline':False]['text':' - HashPolicy: see the "Hash Policy" section below.','line_number':426,'multiline':False]['text':' - AllocPolicy: see AllocPolicy.h','line_number':427,'multiline':False]['text':'','line_number':428,'multiline':False]['text':' Note:','line_number':429,'multiline':False]['text':' - HashSet is not reentrant: T/HashPolicy/AllocPolicy members called by','line_number':430,'multiline':False]['text':'   HashSet must not call back into the same HashSet object.','line_number':431,'multiline':False]['text':'','line_number':432,'multiline':False]['text':' -- Implementation details -----------------------------------------------','line_number':436,'multiline':False]['text':' HashSet is not copyable or assignable.','line_number':438,'multiline':False]['text':' -- Initialization -------------------------------------------------------','line_number':460,'multiline':False]['text':' HashSet is movable.','line_number':468,'multiline':False]['text':' -- Status and sizing ----------------------------------------------------','line_number':472,'multiline':False]['text':' The set's current generation.','line_number':474,'multiline':False]['text':' Is the set empty?','line_number':477,'multiline':False]['text':' Number of elements in the set.','line_number':480,'multiline':False]['text':' Number of element slots in the set. Note: resize will happen well before','line_number':483,'multiline':False]['text':' count() == capacity().','line_number':484,'multiline':False]['text':' The size of the set's entry storage, in bytes. If the elements contain','line_number':487,'multiline':False]['text':' pointers to other heap blocks, you must iterate over the set and measure','line_number':488,'multiline':False]['text':' them separately; hence the "shallow" prefix.','line_number':489,'multiline':False]['text':' Attempt to minimize the capacity(). If the table is empty, this will free','line_number':498,'multiline':False]['text':' the empty storage and upon regrowth it will be given the minimum capacity.','line_number':499,'multiline':False]['text':' Attempt to reserve enough space to fit at least |aLen| elements. Does','line_number':502,'multiline':False]['text':' nothing if the map already has sufficient capacity.','line_number':503,'multiline':False]['text':' -- Lookups --------------------------------------------------------------','line_number':506,'multiline':False]['text':' Does the set contain an element matching |aLookup|?','line_number':508,'multiline':False]['text':' Return a Ptr indicating whether an element matching |aLookup| is present','line_number':513,'multiline':False]['text':' in the set. E.g.:','line_number':514,'multiline':False]['text':'','line_number':515,'multiline':False]['text':'   using HS = HashSet<int>;','line_number':516,'multiline':False]['text':'   HS h;','line_number':517,'multiline':False]['text':'   if (HS::Ptr p = h.lookup(3)) {','line_number':518,'multiline':False]['text':'     assert(*p == 3);   // p acts like a pointer to int','line_number':519,'multiline':False]['text':'   }','line_number':520,'multiline':False]['text':'','line_number':521,'multiline':False]['text':' Like lookup(), but does not assert if two threads call it at the same','line_number':527,'multiline':False]['text':' time. Only use this method when none of the threads will modify the set.','line_number':528,'multiline':False]['text':' -- Insertions -----------------------------------------------------------','line_number':533,'multiline':False]['text':' Add |aU| if it is not present already. Returns false on OOM.','line_number':535,'multiline':False]['text':' Like put(), but slightly faster. Must only be used when the given element','line_number':542,'multiline':False]['text':' is not already present. (In debug builds, assertions check this.)','line_number':543,'multiline':False]['text':' Like the other putNew(), but for when |Lookup| is different to |T|.','line_number':549,'multiline':False]['text':' Like putNew(), but should be only used when the table is known to be big','line_number':555,'multiline':False]['text':' enough for the insertion, and hashing cannot fail. Typically this is used','line_number':556,'multiline':False]['text':' to populate an empty set with known-unique elements after reserving space','line_number':557,'multiline':False]['text':' with reserve(), e.g.','line_number':558,'multiline':False]['text':'','line_number':559,'multiline':False]['text':'   using HS = HashMap<int>;','line_number':560,'multiline':False]['text':'   HS h;','line_number':561,'multiline':False]['text':'   if (!h.reserve(3)) {','line_number':562,'multiline':False]['text':'     MOZ_CRASH("OOM");','line_number':563,'multiline':False]['text':'   }','line_number':564,'multiline':False]['text':'   h.putNewInfallible(1);     // unique element','line_number':565,'multiline':False]['text':'   h.putNewInfallible(2);     // unique element','line_number':566,'multiline':False]['text':'   h.putNewInfallible(3);     // unique element','line_number':567,'multiline':False]['text':'','line_number':568,'multiline':False]['text':' Like |lookup(l)|, but on miss, |p = lookupForAdd(l)| allows efficient','line_number':574,'multiline':False]['text':' insertion of T value |t| (where |HashPolicy::match(t,l) == true|) using','line_number':575,'multiline':False]['text':' |add(p,t)|. After |add(p,t)|, |p| points to the new element. E.g.:','line_number':576,'multiline':False]['text':'','line_number':577,'multiline':False]['text':'   using HS = HashSet<int>;','line_number':578,'multiline':False]['text':'   HS h;','line_number':579,'multiline':False]['text':'   HS::AddPtr p = h.lookupForAdd(3);','line_number':580,'multiline':False]['text':'   if (!p) {','line_number':581,'multiline':False]['text':'     if (!h.add(p, 3)) {','line_number':582,'multiline':False]['text':'       return false;','line_number':583,'multiline':False]['text':'     }','line_number':584,'multiline':False]['text':'   }','line_number':585,'multiline':False]['text':'   assert(*p == 3);   // p acts like a pointer to int','line_number':586,'multiline':False]['text':'','line_number':587,'multiline':False]['text':' N.B. The caller must ensure that no mutating hash table operations occur','line_number':588,'multiline':False]['text':' between a pair of lookupForAdd() and add() calls. To avoid looking up the','line_number':589,'multiline':False]['text':' key a second time, the caller may use the more efficient relookupOrAdd()','line_number':590,'multiline':False]['text':' method. This method reuses part of the hashing computation to more','line_number':591,'multiline':False]['text':' efficiently insert the key if it has not been added. For example, a','line_number':592,'multiline':False]['text':' mutation-handling version of the previous example:','line_number':593,'multiline':False]['text':'','line_number':594,'multiline':False]['text':'    HS::AddPtr p = h.lookupForAdd(3);','line_number':595,'multiline':False]['text':'    if (!p) {','line_number':596,'multiline':False]['text':'      call_that_may_mutate_h();','line_number':597,'multiline':False]['text':'      if (!h.relookupOrAdd(p, 3, 3)) {','line_number':598,'multiline':False]['text':'        return false;','line_number':599,'multiline':False]['text':'      }','line_number':600,'multiline':False]['text':'    }','line_number':601,'multiline':False]['text':'    assert(*p == 3);','line_number':602,'multiline':False]['text':'','line_number':603,'multiline':False]['text':' Note that relookupOrAdd(p,l,t) performs Lookup using |l| and adds the','line_number':604,'multiline':False]['text':' entry |t|, where the caller ensures match(l,t).','line_number':605,'multiline':False]['text':' Add an element. Returns false on OOM.','line_number':611,'multiline':False]['text':' See the comment above lookupForAdd() for details.','line_number':617,'multiline':False]['text':' -- Removal --------------------------------------------------------------','line_number':624,'multiline':False]['text':' Lookup and remove the element matching |aLookup|, if present.','line_number':626,'multiline':False]['text':' Remove a previously found element (assuming aPtr.found()). The set must','line_number':633,'multiline':False]['text':' not have been mutated in the interim.','line_number':634,'multiline':False]['text':' Remove all keys/values without changing the capacity.','line_number':637,'multiline':False]['text':' Like clear() followed by compact().','line_number':640,'multiline':False]['text':' -- Rekeying -------------------------------------------------------------','line_number':643,'multiline':False]['text':' Infallibly rekey one entry, if present. Requires that template parameters','line_number':645,'multiline':False]['text':' T and HashPolicy::Lookup are the same type.','line_number':646,'multiline':False]['text':' Infallibly rekey one entry if present, and return whether that happened.','line_number':653,'multiline':False]['text':' Infallibly replace the current key at |aPtr| with an equivalent key.','line_number':663,'multiline':False]['text':' Specifically, both HashPolicy::hash and HashPolicy::match must return','line_number':664,'multiline':False]['text':' identical results for the new and old key when applied against all','line_number':665,'multiline':False]['text':' possible matching values.','line_number':666,'multiline':False]['text':' -- Iteration ------------------------------------------------------------','line_number':679,'multiline':False]['text':' |iter()| returns an Iterator:','line_number':681,'multiline':False]['text':'','line_number':682,'multiline':False]['text':'   HashSet<int> h;','line_number':683,'multiline':False]['text':'   for (auto iter = h.iter(); !iter.done(); iter.next()) {','line_number':684,'multiline':False]['text':'     int i = iter.get();','line_number':685,'multiline':False]['text':'   }','line_number':686,'multiline':False]['text':'','line_number':687,'multiline':False]['text':' |modIter()| returns a ModIterator:','line_number':691,'multiline':False]['text':'','line_number':692,'multiline':False]['text':'   HashSet<int> h;','line_number':693,'multiline':False]['text':'   for (auto iter = h.modIter(); !iter.done(); iter.next()) {','line_number':694,'multiline':False]['text':'     if (iter.get() == 42) {','line_number':695,'multiline':False]['text':'       iter.remove();','line_number':696,'multiline':False]['text':'     }','line_number':697,'multiline':False]['text':'   }','line_number':698,'multiline':False]['text':'','line_number':699,'multiline':False]['text':' Table resize may occur in ModIterator's destructor.','line_number':700,'multiline':False]['text':' These are similar to Iterator/ModIterator/iter(), but use different','line_number':704,'multiline':False]['text':' terminology.','line_number':705,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':711,'multiline':False]['text':' Hash Policy','line_number':712,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':713,'multiline':False]['text':' A hash policy |HP| for a hash table with key-type |Key| must provide:','line_number':715,'multiline':False]['text':'','line_number':716,'multiline':False]['text':'  - a type |HP::Lookup| to use to lookup table entries;','line_number':717,'multiline':False]['text':'','line_number':718,'multiline':False]['text':'  - a static member function |HP::hash| that hashes lookup values:','line_number':719,'multiline':False]['text':'','line_number':720,'multiline':False]['text':'      static mozilla::HashNumber hash(const Lookup&);','line_number':721,'multiline':False]['text':'','line_number':722,'multiline':False]['text':'  - a static member function |HP::match| that tests equality of key and','line_number':723,'multiline':False]['text':'    lookup values:','line_number':724,'multiline':False]['text':'','line_number':725,'multiline':False]['text':'      static bool match(const Key&, const Lookup&);','line_number':726,'multiline':False]['text':'','line_number':727,'multiline':False]['text':' Normally, Lookup = Key. In general, though, different values and types of','line_number':728,'multiline':False]['text':' values can be used to lookup and store. If a Lookup value |l| is not equal','line_number':729,'multiline':False]['text':' to the added Key value |k|, the user must ensure that |HP::match(k,l)| is','line_number':730,'multiline':False]['text':' true. E.g.:','line_number':731,'multiline':False]['text':'','line_number':732,'multiline':False]['text':'   mozilla::HashSet<Key, HP>::AddPtr p = h.lookup(l);','line_number':733,'multiline':False]['text':'   if (!p) {','line_number':734,'multiline':False]['text':'     assert(HP::match(k, l));  // must hold','line_number':735,'multiline':False]['text':'     h.add(p, k);','line_number':736,'multiline':False]['text':'   }','line_number':737,'multiline':False]['text':' A pointer hashing policy that uses HashGeneric() to create good hashes for','line_number':739,'multiline':False]['text':' pointers. Note that we don't shift out the lowest k bits because we don't','line_number':740,'multiline':False]['text':' want to assume anything about the alignment of the pointers.','line_number':741,'multiline':False]['text':' The default hash policy, which only works with integers.','line_number':758,'multiline':False]['text':' Just convert the integer to a HashNumber and use that as is. (This','line_number':764,'multiline':False]['text':' discards the high 32-bits of 64-bit integers!) ScrambleHashCode() is','line_number':765,'multiline':False]['text':' subsequently called on the value to improve the distribution.','line_number':766,'multiline':False]['text':' Use builtin or overloaded operator==.','line_number':771,'multiline':False]['text':' A DefaultHasher specialization for enums.','line_number':778,'multiline':False]['text':' Use builtin or overloaded operator==.','line_number':787,'multiline':False]['text':' A DefaultHasher specialization for pointers.','line_number':794,'multiline':False]['text':' A DefaultHasher specialization for mozilla::UniquePtr.','line_number':798,'multiline':False]['text':' A DefaultHasher specialization for doubles.','line_number':818,'multiline':False]['text':' Just xor the high bits with the low bits, and then treat the bits of the','line_number':825,'multiline':False]['text':' result as a uint32_t.','line_number':826,'multiline':False]['text':' A DefaultHasher specialization for floats.','line_number':838,'multiline':False]['text':' Just use the value as if its bits form an integer. ScrambleHashCode() is','line_number':845,'multiline':False]['text':' subsequently called on the value to improve the distribution.','line_number':846,'multiline':False]['text':' A hash policy for C strings.','line_number':857,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':869,'multiline':False]['text':' Fallible Hashing Interface','line_number':870,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':871,'multiline':False]['text':' Most of the time generating a hash code is infallible so this class provides','line_number':873,'multiline':False]['text':' default methods that always succeed.  Specialize this class for your own hash','line_number':874,'multiline':False]['text':' policy to provide fallible hashing.','line_number':875,'multiline':False]['text':'','line_number':876,'multiline':False]['text':' This is used by MovableCellHasher to handle the fact that generating a unique','line_number':877,'multiline':False]['text':' ID for cell pointer may fail due to OOM.','line_number':878,'multiline':False]['text':' Return true if a hashcode is already available for its argument.  Once','line_number':881,'multiline':False]['text':' this returns true for a specific argument it must continue to do so.','line_number':882,'multiline':False]['text':' Fallible method to ensure a hashcode exists for its argument and create','line_number':888,'multiline':False]['text':' one if not.  Returns false on error, e.g. out of memory.','line_number':889,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':908,'multiline':False]['text':' Implementation Details (HashMapEntry, HashTableEntry, HashTable)','line_number':909,'multiline':False]['text':'---------------------------------------------------------------------------','line_number':910,'multiline':False]['text':' Both HashMap and HashSet are implemented by a single HashTable that is even','line_number':912,'multiline':False]['text':' more heavily parameterized than the other two. This leaves HashTable gnarly','line_number':913,'multiline':False]['text':' and extremely coupled to HashMap and HashSet; thus code should not use','line_number':914,'multiline':False]['text':' HashTable directly.','line_number':915,'multiline':False]['text':' Use this method with caution! If the key is changed such that its hash','line_number':943,'multiline':False]['text':' value also changes, the map will be left in an invalid state.','line_number':944,'multiline':False]['text':' Instead of having a hash table entry store that looks like this:','line_number':968,'multiline':False]['text':'','line_number':969,'multiline':False]['text':' +--------+--------+--------+--------+','line_number':970,'multiline':False]['text':' | entry0 | entry1 |  ....  | entryN |','line_number':971,'multiline':False]['text':' +--------+--------+--------+--------+','line_number':972,'multiline':False]['text':'','line_number':973,'multiline':False]['text':' where the entries contained their cached hash code, we're going to lay out','line_number':974,'multiline':False]['text':' the entry store thusly:','line_number':975,'multiline':False]['text':'','line_number':976,'multiline':False]['text':' +-------+-------+-------+-------+--------+--------+--------+--------+','line_number':977,'multiline':False]['text':' | hash0 | hash1 |  ...  | hashN | entry0 | entry1 |  ....  | entryN |','line_number':978,'multiline':False]['text':' +-------+-------+-------+-------+--------+--------+--------+--------+','line_number':979,'multiline':False]['text':'','line_number':980,'multiline':False]['text':' with all the cached hashes prior to the actual entries themselves.','line_number':981,'multiline':False]['text':'','line_number':982,'multiline':False]['text':' We do this because implementing the first strategy requires us to make','line_number':983,'multiline':False]['text':' HashTableEntry look roughly like:','line_number':984,'multiline':False]['text':'','line_number':985,'multiline':False]['text':' template <typename T>','line_number':986,'multiline':False]['text':' class HashTableEntry {','line_number':987,'multiline':False]['text':'   HashNumber mKeyHash;','line_number':988,'multiline':False]['text':'   T mValue;','line_number':989,'multiline':False]['text':' };','line_number':990,'multiline':False]['text':'','line_number':991,'multiline':False]['text':' The problem with this setup is that, depending on the layout of `T`, there','line_number':992,'multiline':False]['text':' may be platform ABI-mandated padding between `mKeyHash` and the first','line_number':993,'multiline':False]['text':' member of `T`. This ABI-mandated padding is wasted space, and can be','line_number':994,'multiline':False]['text':' surprisingly common, e.g. when `T` is a single pointer on 64-bit platforms.','line_number':995,'multiline':False]['text':' In such cases, we're throwing away a quarter of our entry store on padding,','line_number':996,'multiline':False]['text':' which is undesirable.','line_number':997,'multiline':False]['text':'','line_number':998,'multiline':False]['text':' The second layout above, namely:','line_number':999,'multiline':False]['text':'','line_number':1000,'multiline':False]['text':' +-------+-------+-------+-------+--------+--------+--------+--------+','line_number':1001,'multiline':False]['text':' | hash0 | hash1 |  ...  | hashN | entry0 | entry1 |  ....  | entryN |','line_number':1002,'multiline':False]['text':' +-------+-------+-------+-------+--------+--------+--------+--------+','line_number':1003,'multiline':False]['text':'','line_number':1004,'multiline':False]['text':' means there is no wasted space between the hashes themselves, and no wasted','line_number':1005,'multiline':False]['text':' space between the entries themselves.  However, we would also like there to','line_number':1006,'multiline':False]['text':' be no gap between the last hash and the first entry. The memory allocator','line_number':1007,'multiline':False]['text':' guarantees the alignment of the start of the hashes. The use of a','line_number':1008,'multiline':False]['text':' power-of-two capacity of at least 4 guarantees that the alignment of the','line_number':1009,'multiline':False]['text':' *end* of the hash array is no less than the alignment of the start.','line_number':1010,'multiline':False]['text':' Finally, the static_asserts here guarantee that the entries themselves','line_number':1011,'multiline':False]['text':' don't need to be any more aligned than the alignment of the entry store','line_number':1012,'multiline':False]['text':' itself.','line_number':1013,'multiline':False]['text':'','line_number':1014,'multiline':False]['text':' This assertion is safe for 32-bit builds because on both Windows and Linux','line_number':1015,'multiline':False]['text':' (including Android), the minimum alignment for allocations larger than 8','line_number':1016,'multiline':False]['text':' bytes is 8 bytes, and the actual data for entries in our entry store is','line_number':1017,'multiline':False]['text':' guaranteed to have that alignment as well, thanks to the power-of-two','line_number':1018,'multiline':False]['text':' number of cached hash values stored prior to the entry data.','line_number':1019,'multiline':False]['text':' The allocation policy must allocate a table with at least this much','line_number':1021,'multiline':False]['text':' alignment.','line_number':1022,'multiline':False]['text':' Some versions of GCC treat it as a -Wstrict-aliasing violation (ergo a','line_number':1044,'multiline':False]['text':' -Werror compile error) to reinterpret_cast<> |mValueData| to |T*|, even','line_number':1045,'multiline':False]['text':' through |void*|.  Placing the latter cast in these separate functions','line_number':1046,'multiline':False]['text':' breaks the chain such that affected GCC versions no longer warn/error.','line_number':1047,'multiline':False]['text':' This allows types to use Argument-Dependent-Lookup, and thus use a custom','line_number':1071,'multiline':False]['text':' std::swap, which is needed by types like JS::Heap and such.','line_number':1072,'multiline':False]['text':' A slot represents a cached hash value and its associated entry stored','line_number':1091,'multiline':False]['text':' in the hash table. These two things are not stored in contiguous memory.','line_number':1092,'multiline':False]['text':' A nullable pointer to a hash table element. A Ptr |p| can be tested','line_number':1209,'multiline':False]['text':' either explicitly |if (p.found()) p->...| or using boolean conversion','line_number':1210,'multiline':False]['text':' |if (p) p->...|. Ptr objects must not be used after any mutating hash','line_number':1211,'multiline':False]['text':' table operations unless |generation()| is tested.','line_number':1212,'multiline':False]['text':' This constructor is used only by AddPtr() within lookupForAdd().','line_number':1233,'multiline':False]['text':' A Ptr that can be used to add a key after a failed lookup.','line_number':1298,'multiline':False]['text':' This constructor is used when lookupForAdd() is performed on a table','line_number':1317,'multiline':False]['text':' lacking entry storage; it leaves mSlot null but initializes everything','line_number':1318,'multiline':False]['text':' else.','line_number':1319,'multiline':False]['text':' A hash table iterator that (mostly) doesn't allow table modifications.','line_number':1337,'multiline':False]['text':' As with Ptr/AddPtr, Iterator objects must not be used after any mutating','line_number':1338,'multiline':False]['text':' hash table operation unless the |generation()| is tested.','line_number':1339,'multiline':False]['text':' A hash table iterator that permits modification, removal and rekeying.','line_number':1401,'multiline':False]['text':' Since rehashing when elements were removed during enumeration would be','line_number':1402,'multiline':False]['text':' bad, it is postponed until the ModIterator is destructed. Since the','line_number':1403,'multiline':False]['text':' ModIterator's destructor touches the hash table, the user must ensure','line_number':1404,'multiline':False]['text':' that the hash table is still alive when the destructor runs.','line_number':1405,'multiline':False]['text':' ModIterator is movable but not copyable.','line_number':1413,'multiline':False]['text':' Removes the current element from the table, leaving |get()|','line_number':1431,'multiline':False]['text':' invalid until the next call to |next()|.','line_number':1432,'multiline':False]['text':' Removes the current element and re-inserts it into the table with','line_number':1450,'multiline':False]['text':' a new key at the new Lookup position.  |get()| is invalid after','line_number':1451,'multiline':False]['text':' this operation until the next call to |next()|.','line_number':1452,'multiline':False]['text':' Potentially rehashes the table.','line_number':1466,'multiline':False]['text':' Range is similar to Iterator, but uses different terminology.','line_number':1479,'multiline':False]['text':' Enum is similar to ModIterator, but uses different terminology.','line_number':1496,'multiline':False]['text':' Enum is movable but not copyable.','line_number':1500,'multiline':False]['text':' HashTable is movable','line_number':1527,'multiline':False]['text':' HashTable is not copyable or assignable','line_number':1554,'multiline':False]['text':' entry storage generation number','line_number':1561,'multiline':False]['text':' multiplicative hash shift','line_number':1562,'multiline':False]['text':' entry storage','line_number':1563,'multiline':False]['text':' number of entries in mTable','line_number':1564,'multiline':False]['text':' removed entry sentinels in mTable','line_number':1565,'multiline':False]['text':' The default initial capacity is 32 (enough to hold 16 elements), but it','line_number':1572,'multiline':False]['text':' can be as low as 4.','line_number':1573,'multiline':False]['text':' See the comments in HashTableEntry about this value.','line_number':1576,'multiline':False]['text':' Hash-table alpha is conceptually a fraction, but to avoid floating-point','line_number':1581,'multiline':False]['text':' math we implement it as a ratio of integers.','line_number':1582,'multiline':False]['text':' min alpha: 1/4','line_number':1584,'multiline':False]['text':' max alpha: 3/4','line_number':1585,'multiline':False]['text':' Callers should ensure this is true.','line_number':1599,'multiline':False]['text':' Compute the smallest capacity allowing |aLen| elements to be','line_number':1602,'multiline':False]['text':' inserted without rehashing: ceil(aLen / max-alpha).  (Ceiling','line_number':1603,'multiline':False]['text':' integral division: <http://stackoverflow.com/a/2745086>.)','line_number':1604,'multiline':False]['text':' Reject all lengths whose initial computed capacity would exceed','line_number':1616,'multiline':False]['text':' sMaxCapacity. Round that maximum aLen down to the nearest power of two','line_number':1617,'multiline':False]['text':' for speedier code.','line_number':1618,'multiline':False]['text':' Avoid reserved hash codes.','line_number':1631,'multiline':False]['text':' Fake a struct that we're going to alloc. See the comments in','line_number':1640,'multiline':False]['text':' HashTableEntry about how the table is laid out, and why it's safe.','line_number':1641,'multiline':False]['text':' Warning: in order for readonlyThreadsafeLookup() to be safe this','line_number':1739,'multiline':False]['text':' function must not modify the table in any way when Reason==ForNonAdd.','line_number':1740,'multiline':False]['text':' Compute the primary hash address.','line_number':1748,'multiline':False]['text':' Miss: return space for a new entry.','line_number':1752,'multiline':False]['text':' Hit: return entry.','line_number':1757,'multiline':False]['text':' Collision: double hash.','line_number':1762,'multiline':False]['text':' Save the first removed entry pointer so we can recycle later.','line_number':1765,'multiline':False]['text':' This is a copy of lookup() hardcoded to the assumptions:','line_number':1790,'multiline':False]['text':'   1. the lookup is for an add;','line_number':1791,'multiline':False]['text':'   2. the key, whose |keyHash| has been passed, is not in the table.','line_number':1792,'multiline':False]['text':' We assume 'aKeyHash' has already been distributed.','line_number':1797,'multiline':False]['text':' Compute the primary hash address.','line_number':1799,'multiline':False]['text':' Miss: return space for a new entry.','line_number':1803,'multiline':False]['text':' Collision: double hash.','line_number':1808,'multiline':False]['text':' Look, but don't touch, until we succeed in getting new entry store.','line_number':1830,'multiline':False]['text':' We can't fail from here on, so update table parameters.','line_number':1847,'multiline':False]['text':' Copy only live entries, leaving removed ones behind.','line_number':1853,'multiline':False]['text':' All entries have been destroyed, no need to destroyTable.','line_number':1864,'multiline':False]['text':' Note: if capacity() is zero, this will always succeed, which is','line_number':1874,'multiline':False]['text':' what we want.','line_number':1875,'multiline':False]['text':' Succeed if a quarter or more of all entries are removed. Note that this','line_number':1883,'multiline':False]['text':' always succeeds if capacity() == 0 (i.e. entry storage has not been','line_number':1884,'multiline':False]['text':' allocated), which is what we want, because it means changeTableSize()','line_number':1885,'multiline':False]['text':' will allocate the requested capacity rather than doubling it.','line_number':1886,'multiline':False]['text':' This is identical to changeTableSize(currentSize), but without requiring','line_number':1925,'multiline':False]['text':' a second table.  We do this by recycling the collision bits to tell us if','line_number':1926,'multiline':False]['text':' the element is already inserted or still waiting to be inserted.  Since','line_number':1927,'multiline':False]['text':' already-inserted elements win any conflicts, we get the same table as we','line_number':1928,'multiline':False]['text':' would have gotten through random insertion order.','line_number':1929,'multiline':False]['text':' TODO: this algorithm leaves collision bits on *all* elements, even if','line_number':1958,'multiline':False]['text':' they are on no collision path. We have the option of setting the','line_number':1959,'multiline':False]['text':' collision bits correctly on a subsequent pass or skipping the rehash','line_number':1960,'multiline':False]['text':' unless we are totally filled with tombstones: benchmark to find out','line_number':1961,'multiline':False]['text':' which approach is best.','line_number':1962,'multiline':False]['text':' Note: |aLookup| may be a reference to a piece of |u|, so this function','line_number':1965,'multiline':False]['text':' must take care not to use |aLookup| after moving |u|.','line_number':1966,'multiline':False]['text':'','line_number':1967,'multiline':False]['text':' Prefer to use putNewInfallible; this function does not check','line_number':1968,'multiline':False]['text':' invariants.','line_number':1969,'multiline':False]['text':' Resize the table down to the smallest capacity that doesn't overload the','line_number':1999,'multiline':False]['text':' table. Since we call shrinkIfUnderloaded() on every remove, you only need','line_number':2000,'multiline':False]['text':' to call this after a bulk removal of items done without calling remove().','line_number':2001,'multiline':False]['text':' Free the entry storage.','line_number':2004,'multiline':False]['text':' gives minimum capacity on regrowth','line_number':2007,'multiline':False]['text':' Capacity is already sufficient.','line_number':2037,'multiline':False]['text':' Directly call the constructor in the return statement to avoid','line_number':2094,'multiline':False]['text':' excess copying when building with Visual Studio 2017.','line_number':2095,'multiline':False]['text':' See bug 1385181.','line_number':2096,'multiline':False]['text':' Check for error from ensureHash() here.','line_number':2108,'multiline':False]['text':' Changing an entry from removed to live does not affect whether we are','line_number':2129,'multiline':False]['text':' overloaded and can be handled separately.','line_number':2130,'multiline':False]['text':' Preserve the validity of |aPtr.mSlot|.','line_number':2138,'multiline':False]['text':' Note: |aLookup| may be a reference to a piece of |u|, so this function','line_number':2161,'multiline':False]['text':' must take care not to use |aLookup| after moving |u|.','line_number':2162,'multiline':False]['text':' Note: |aLookup| may be alias arguments in |aArgs|, so this function must','line_number':2170,'multiline':False]['text':' take care not to use |aLookup| after moving |aArgs|.','line_number':2171,'multiline':False]['text':' Note: |aLookup| may be a reference to a piece of |u|, so this function','line_number':2187,'multiline':False]['text':' must take care not to use |aLookup| after moving |u|.','line_number':2188,'multiline':False]['text':' Check for error from ensureHash() here.','line_number':2192,'multiline':False]['text':' Check that aLookup has not been destroyed.','line_number':2202,'multiline':False]['text':' Clear aPtr so it's invalid; add() will allocate storage and redo the','line_number':2209,'multiline':False]['text':' lookup.','line_number':2210,'multiline':False]['text':' namespace detail','line_number':2242,'multiline':False]['text':' namespace mozilla','line_number':2243,'multiline':False]['text':' mozilla_HashTable_h ','line_number':2245,'multiline':True]