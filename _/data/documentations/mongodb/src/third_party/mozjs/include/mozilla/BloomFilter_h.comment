['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]['text':'
 * A counting Bloom filter implementation.  This allows consumers to
 * do fast probabilistic "is item X in set Y?" testing which will
 * never answer "no" when the correct answer is "yes" (but might
 * incorrectly answer "yes" when the correct answer is "no").
 ','line_number':7,'multiline':True]['text':'
 * This class implements a classic Bloom filter as described at
 * <http://en.wikipedia.org/wiki/Bloom_filter>.  This allows quick
 * probabilistic answers to the question "is object X in set Y?" where the
 * contents of Y might not be time-invariant.  The probabilistic nature of the
 * test means that sometimes the answer will be "yes" when it should be "no".
 * If the answer is "no", then X is guaranteed not to be in Y.
 *
 * The filter is parametrized on KeySize, which is the size of the key
 * generated by each of hash functions used by the filter, in bits,
 * and the type of object T being added and removed.  T must implement
 * a |uint32_t hash() const| method which returns a uint32_t hash key
 * that will be used to generate the two separate hash functions for
 * the Bloom filter.  This hash key MUST be well-distributed for good
 * results!  KeySize is not allowed to be larger than 16.
 *
 * The filter uses exactly 2**KeySize bit (2**(KeySize-3) bytes) of memory.
 * From now on we will refer to the memory used by the filter as M.
 *
 * The expected rate of incorrect "yes" answers depends on M and on
 * the number N of objects in set Y.  As long as N is small compared
 * to M, the rate of such answers is expected to be approximately
 * 4*(N/M)**2 for this filter.  In practice, if Y has a few hundred
 * elements then using a KeySize of 12 gives a reasonably low
 * incorrect answer rate.  A KeySize of 12 has the additional benefit
 * of using exactly one page for the filter in typical hardware
 * configurations.
 ','line_number':25,'multiline':True]['text':'
   * A counting Bloom filter with 8-bit counters.  For now we assume
   * that having two hash functions is enough, but we may revisit that
   * decision later.
   *
   * The filter uses an array with 2**KeySize entries.
   *
   * Assuming a well-distributed hash function, a Bloom filter with
   * array size M containing N elements and
   * using k hash function has expected false positive rate exactly
   *
   * $  (1 - (1 - 1/M)^{kN})^k  $
   *
   * because each array slot has a
   *
   * $  (1 - 1/M)^{kN}  $
   *
   * chance of being 0, and the expected false positive rate is the
   * probability that all of the k hash functions will hit a nonzero
   * slot.
   *
   * For reasonable assumptions (M large, kN large, which should both
   * hold if we're worried about false positives) about M and kN this
   * becomes approximately
   *
   * $$  (1 - \exp(-kN/M))^k   $$
   *
   * For our special case of k == 2, that's $(1 - \exp(-2N/M))^2$,
   * or in other words
   *
   * $$    N/M = -0.5 * \ln(1 - \sqrt(r))   $$
   *
   * where r is the false positive rate.  This can be used to compute
   * the desired KeySize for a given load N and false positive rate r.
   *
   * If N/M is assumed small, then the false positive rate can
   * further be approximated as 4*N^2/M^2.  So increasing KeySize by
   * 1, which doubles M, reduces the false positive rate by about a
   * factor of 4, and a false positive rate of 1% corresponds to
   * about M/N == 20.
   *
   * What this means in practice is that for a few hundred keys using a
   * KeySize of 12 gives false positive rates on the order of 0.25-4%.
   *
   * Similarly, using a KeySize of 10 would lead to a 4% false
   * positive rate for N == 100 and to quite bad false positive
   * rates for larger N.
   ','line_number':55,'multiline':True]['text':' XXX: Should we have a custom operator new using calloc instead and','line_number':108,'multiline':False]['text':' require that we're allocated via the operator?','line_number':109,'multiline':False]['text':'
   * Clear the filter.  This should be done before reusing it.
   ','line_number':113,'multiline':True]['text':'
   * Add an item to the filter.
   ','line_number':118,'multiline':True]['text':'
   * Check whether the filter might contain an item.  This can
   * sometimes return true even if the item is not in the filter,
   * but will never return false for items that are actually in the
   * filter.
   ','line_number':123,'multiline':True]['text':'
   * Methods for add/contain when we already have a hash computed
   ','line_number':131,'multiline':True]['text':' Check that all the slots for this hash contain something','line_number':190,'multiline':False]['text':'
 * This class implements a counting Bloom filter as described at
 * <http://en.wikipedia.org/wiki/Bloom_filter#Counting_filters>, with
 * 8-bit counters.
 *
 * Compared to `BitBloomFilter`, this class supports 'remove' operation.
 *
 * The filter uses exactly 2**KeySize bytes of memory.
 *
 * Other characteristics are the same as BitBloomFilter.
 ','line_number':201,'multiline':True]['text':'
   * Clear the filter.  This should be done before reusing it, because
   * just removing all items doesn't clear counters that hit the upper
   * bound.
   ','line_number':221,'multiline':True]['text':'
   * Add an item to the filter.
   ','line_number':228,'multiline':True]['text':'
   * Remove an item from the filter.
   ','line_number':233,'multiline':True]['text':'
   * Check whether the filter might contain an item.  This can
   * sometimes return true even if the item is not in the filter,
   * but will never return false for items that are actually in the
   * filter.
   ','line_number':238,'multiline':True]['text':'
   * Methods for add/remove/contain when we already have a hash computed
   ','line_number':246,'multiline':True]['text':' If the slots are full, we don't know whether we bumped them to be','line_number':303,'multiline':False]['text':' there when we added or not, so just leave them full.','line_number':304,'multiline':False]['text':' Check that all the slots for this hash contain something','line_number':325,'multiline':False]['text':' namespace mozilla','line_number':336,'multiline':False]['text':' mozilla_BloomFilter_h ','line_number':338,'multiline':True]