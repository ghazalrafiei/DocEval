['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]['text':' Class template for objects that can only be initialized once.','line_number':7,'multiline':False]['text':'aValue','line_number':27,'multiline':True]['text':' namespace ValueCheckPolicies','line_number':36,'multiline':False]['text':' A kind of mozilla::Maybe that can only be initialized and cleared once. It','line_number':38,'multiline':False]['text':' cannot be re-initialized. This is a more stateful than a const Maybe<T> in','line_number':39,'multiline':False]['text':' that it can be cleared, but much less stateful than a non-const Maybe<T>','line_number':40,'multiline':False]['text':' which could be reinitialized multiple times. Can only be used with const T','line_number':41,'multiline':False]['text':' to ensure that the contents cannot be modified either.','line_number':42,'multiline':False]['text':' TODO: Make constructors constexpr when Maybe's constructors are constexpr','line_number':43,'multiline':False]['text':' (Bug 1601336).','line_number':44,'multiline':False]['text':' note: aArg0 is named separately here to disallow calling this with no','line_number':60,'multiline':False]['text':' arguments. The default constructor should only be available conditionally','line_number':61,'multiline':False]['text':' and is declared above.','line_number':62,'multiline':False]['text':' namespace detail','line_number':163,'multiline':False]['text':' The following *InitializedOnce* template aliases allow to declare class','line_number':165,'multiline':False]['text':' member variables that can only be initialized once, but maybe destroyed','line_number':166,'multiline':False]['text':' earlier explicitly than in the containing classes destructor.','line_number':167,'multiline':False]['text':' The intention is to restrict the possible state transitions for member','line_number':168,'multiline':False]['text':' variables that can almost be const, but not quite. This may be particularly','line_number':169,'multiline':False]['text':' useful for classes with a lot of members. Uses in other contexts, e.g. as','line_number':170,'multiline':False]['text':' local variables, are possible, but probably seldom useful. They can only be','line_number':171,'multiline':False]['text':' instantiated with a const element type. Any misuses that cannot be detected','line_number':172,'multiline':False]['text':' at compile time trigger a MOZ_ASSERT at runtime. Individually spelled out','line_number':173,'multiline':False]['text':' assertions for these aspects are not necessary, which may improve the','line_number':174,'multiline':False]['text':' readability of the code without impairing safety.','line_number':175,'multiline':False]['text':'','line_number':176,'multiline':False]['text':' The base variant InitializedOnce requires initialization in the constructor,','line_number':177,'multiline':False]['text':' but allows early destruction using destroy(), and allow move construction. It','line_number':178,'multiline':False]['text':' is similar to Maybe<const T> in some sense, but a Maybe<const T> could be','line_number':179,'multiline':False]['text':' reinitialized arbitrarily. InitializedOnce expresses the intent not to do','line_number':180,'multiline':False]['text':' this, and prohibits reinitialization.','line_number':181,'multiline':False]['text':'','line_number':182,'multiline':False]['text':' The Lazy* variants allow default construction, and can be initialized lazily','line_number':183,'multiline':False]['text':' using init() in that case, but it cannot be reinitialized either. They do not','line_number':184,'multiline':False]['text':' allow early destruction.','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' The Lazy*EarlyDestructible variants allow lazy initialization, early','line_number':187,'multiline':False]['text':' destruction, move construction and move assignment. This should be used only','line_number':188,'multiline':False]['text':' when really required.','line_number':189,'multiline':False]['text':'','line_number':190,'multiline':False]['text':' The *NotNull variants only allow initialization with values that convert to','line_number':191,'multiline':False]['text':' bool as true. They are named NotNull because the typical use case is with','line_number':192,'multiline':False]['text':' (smart) pointer types, but any other type convertible to bool will also work','line_number':193,'multiline':False]['text':' analogously.','line_number':194,'multiline':False]['text':'','line_number':195,'multiline':False]['text':' There is no variant combining detail::DestroyWhen::InConstructorOnly with','line_number':196,'multiline':False]['text':' detail::DestroyWhen::InDestructorOnly because this would be equivalent to a','line_number':197,'multiline':False]['text':' const member.','line_number':198,'multiline':False]['text':'','line_number':199,'multiline':False]['text':' For special cases, e.g. requiring custom value check policies,','line_number':200,'multiline':False]['text':' detail::InitializedOnce might be instantiated directly, but be mindful when','line_number':201,'multiline':False]['text':' doing this.','line_number':202,'multiline':False]['text':' namespace mozilla','line_number':245,'multiline':False]