['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':' MOZ_ALWAYS_INLINE, MOZ_COLD','line_number':10,'multiline':False]['text':' MOZ_LIKELY','line_number':11,'multiline':False]['text':' size_t','line_number':13,'multiline':False]['text':' uintptr_t','line_number':14,'multiline':False]['text':' JS_PUBLIC_API','line_number':16,'multiline':False]['text':' JS::StackKind, JS::StackForTrustedScript, JS::StackForUntrustedScript','line_number':18,'multiline':False]['text':' JS::RootingContext','line_number':19,'multiline':False]['text':' JS_STACK_OOM_POSSIBLY_FAIL','line_number':20,'multiline':False]['text':' AutoCheckRecursionLimit can be used to check whether we're close to using up','line_number':34,'multiline':False]['text':' the C++ stack.','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':' Typical usage is like this:','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':'   AutoCheckRecursionLimit recursion(cx);','line_number':39,'multiline':False]['text':'   if (!recursion.check(cx)) {','line_number':40,'multiline':False]['text':'     return false;','line_number':41,'multiline':False]['text':'   }','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' The check* functions return |false| if we are close to the stack limit.','line_number':44,'multiline':False]['text':' They also report an overrecursion error, except for the DontReport variants.','line_number':45,'multiline':False]['text':'','line_number':46,'multiline':False]['text':' The checkSystem variant gives us a little extra space so we can ensure that','line_number':47,'multiline':False]['text':' crucial code is able to run.','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':' checkConservative allows less space than any other check, including a safety','line_number':50,'multiline':False]['text':' buffer (as in, it uses the untrusted limit and subtracts a little more from','line_number':51,'multiline':False]['text':' it).','line_number':52,'multiline':False]['text':' The JSContext outlives AutoCheckRecursionLimit so it is safe to use raw','line_number':65,'multiline':False]['text':' pointer here.','line_number':66,'multiline':False]['text':' __wasi__','line_number':68,'multiline':False]['text':' __wasi__','line_number':75,'multiline':False]['text':' __wasi__','line_number':82,'multiline':False]['text':' WASI has two limits:','line_number':111,'multiline':False]['text':' 1) The stack pointer in linear memory that grows to zero. See --stack-first','line_number':112,'multiline':False]['text':' in js/src/shell/moz.build. 2) The wasiRecursionDepth_ that counts recursion','line_number':113,'multiline':False]['text':' depth. Here we should check both.','line_number':114,'multiline':False]['text':' __wasi__','line_number':119,'multiline':False]['text':' getStackLimitSlow(cx) is pretty slow because it has to do an uninlined','line_number':163,'multiline':False]['text':' call to runningWithTrustedPrincipals to determine which stack limit to','line_number':164,'multiline':False]['text':' use. To work around this, check the untrusted limit first to avoid the','line_number':165,'multiline':False]['text':' overhead in most cases.','line_number':166,'multiline':False]['text':' namespace js','line_number':224,'multiline':False]['text':' js_friend_StackLimits_h','line_number':226,'multiline':False]