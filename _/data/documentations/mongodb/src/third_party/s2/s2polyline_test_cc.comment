['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' Construct random great circles and divide them randomly into segments.','line_number':51,'multiline':False]['text':' Then make sure that the length and centroid are correct.  Note that','line_number':52,'multiline':False]['text':' because of the way the centroid is computed, it does not matter how','line_number':53,'multiline':False]['text':' we split the great circle into segments.','line_number':54,'multiline':False]['text':' Choose a coordinate frame for the great circle.','line_number':57,'multiline':False]['text':' Close the circle.','line_number':68,'multiline':False]['text':' Check the case where the interpolation fraction is so close to 1 that','line_number':112,'multiline':False]['text':' the interpolated point is identical to the last vertex.','line_number':113,'multiline':False]['text':' Check that the return value is clamped to 1.0.','line_number':147,'multiline':False]['text':' Explicitly test the case where the closest point is an interior vertex.','line_number':202,'multiline':False]['text':' The points are chosen such that they are on different sides of the two','line_number':209,'multiline':False]['text':' edges that the interior vertex is on.','line_number':210,'multiline':False]['text':' No vertices.','line_number':288,'multiline':False]['text':' One vertex.','line_number':290,'multiline':False]['text':' Two vertices.','line_number':292,'multiline':False]['text':' Three points on a straight line.','line_number':294,'multiline':False]['text':' In theory, zero tolerance should work, but in practice there are floating','line_number':295,'multiline':False]['text':' point errors.','line_number':296,'multiline':False]['text':' Zero tolerance on a non-straight line.','line_number':298,'multiline':False]['text':' Negative tolerance should return all vertices.','line_number':300,'multiline':False]['text':' Non-zero tolerance with a straight line.','line_number':302,'multiline':False]['text':' And finally, verify that we still do something reasonable if the client','line_number':305,'multiline':False]['text':' passes in an invalid polyline with two or more adjacent vertices.','line_number':306,'multiline':False]['text':' Check that duplicate vertices are never generated.','line_number':322,'multiline':False]['text':' Check that points are not collapsed if they would create a line segment','line_number':326,'multiline':False]['text':' longer than 90 degrees, and also that the code handles original polyline','line_number':327,'multiline':False]['text':' segments longer than 90 degrees.','line_number':328,'multiline':False]['text':' Check that the output polyline is parametrically equivalent and not just','line_number':332,'multiline':False]['text':' geometrically equivalent, i.e. that backtracking is preserved.  The','line_number':333,'multiline':False]['text':' algorithm achieves this by requiring that the points must be encountered','line_number':334,'multiline':False]['text':' in increasing order of distance along each output segment, except for','line_number':335,'multiline':False]['text':' points that are within "tolerance" of the first vertex of each segment.','line_number':336,'multiline':False]['text':' Close lines, differences within max_error.','line_number':354,'multiline':False]['text':' Close lines, differences outside max_error.','line_number':359,'multiline':False]['text':' Same line, but different number of vertices.','line_number':364,'multiline':False]['text':' Same vertices, in different order.','line_number':367,'multiline':False]['text':' These two polylines trace the exact same polyline, but the second one uses','line_number':403,'multiline':False]['text':' three points instead of two.','line_number':404,'multiline':False]['text':' The second polyline is always within 0.001 degrees of the first polyline,','line_number':409,'multiline':False]['text':' but the first polyline is too long to be covered by the second.','line_number':410,'multiline':False]['text':' These two polylines partially overlap each other, but neither fully','line_number':416,'multiline':False]['text':' overlaps the other.','line_number':417,'multiline':False]['text':' Two lines that backtrack a bit (less than 1.5 degrees) on different edges.','line_number':422,'multiline':False]['text':' A simple greedy matching algorithm would fail on this example.','line_number':423,'multiline':False]['text':' Two arcs with opposite direction do not overlap if the shorter arc is','line_number':431,'multiline':False]['text':' longer than max_error, but do if the shorter arc is shorter than max-error.','line_number':432,'multiline':False]['text':' S2Polyines are not generally supposed to contain adjacent, identical','line_number':438,'multiline':False]['text':' points, but it happens in practice.  When --s2debug=true, debug-mode','line_number':439,'multiline':False]['text':' binaries abort on such polylines, so we also set --s2debug=false.','line_number':440,'multiline':False]['text':' Can handle two possible starting points, only one of which leads to finding','line_number':447,'multiline':False]['text':' a correct path.  In the first polyline, the edge from 0:1.1 to 0:0 and the','line_number':448,'multiline':False]['text':' edge from 0:0.9 to 0:2 might be lucrative starting states for covering the','line_number':449,'multiline':False]['text':' second polyline, because both edges are with the max_error of 1.5 degrees','line_number':450,'multiline':False]['text':' from 0:10.  However, only the latter is actually effective.','line_number':451,'multiline':False]['text':' namespace','line_number':462,'multiline':False]