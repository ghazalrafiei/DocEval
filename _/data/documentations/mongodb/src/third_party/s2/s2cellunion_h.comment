['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' An S2CellUnion is a region consisting of cells of various sizes.  Typically','line_number':18,'multiline':False]['text':' a cell union is used to approximate some other shape.  There is a tradeoff','line_number':19,'multiline':False]['text':' between the accuracy of the approximation and how many cells are used.','line_number':20,'multiline':False]['text':' Unlike polygons, cells have a fixed hierarchical structure.  This makes','line_number':21,'multiline':False]['text':' them more suitable for optimizations based on preprocessing.','line_number':22,'multiline':False]['text':' The default constructor does nothing.  The cell union cannot be used','line_number':25,'multiline':False]['text':' until one of the Init() methods is called.','line_number':26,'multiline':False]['text':' Populates a cell union with the given S2CellIds or 64-bit cells ids, and','line_number':29,'multiline':False]['text':' then calls Normalize().  The InitSwap() version takes ownership of the','line_number':30,'multiline':False]['text':' vector data without copying and clears the given vector.  These methods','line_number':31,'multiline':False]['text':' may be called multiple times.','line_number':32,'multiline':False]['text':' Like Init(), but does not call Normalize().  The cell union *must* be','line_number':37,'multiline':False]['text':' normalized before doing any calculations with it, so it is the caller's','line_number':38,'multiline':False]['text':' responsibility to make sure that the input is normalized.  This method is','line_number':39,'multiline':False]['text':' useful when converting cell unions to another representation and back.','line_number':40,'multiline':False]['text':' These methods may be called multiple times.','line_number':41,'multiline':False]['text':' Adds the given S2CellIds to the covered region and calls Normalize()','line_number':46,'multiline':False]['text':' Gives ownership of the vector data to the client without copying, and','line_number':49,'multiline':False]['text':' clears the content of the cell union.  The original data in cell_ids','line_number':50,'multiline':False]['text':' is lost if there was any.  This is the opposite of InitRawSwap().','line_number':51,'multiline':False]['text':' Convenience methods for accessing the individual cell ids.','line_number':54,'multiline':False]['text':' Direct access to the underlying vector for STL algorithms.','line_number':58,'multiline':False]['text':' Normalizes the cell union by discarding cells that are contained by other','line_number':61,'multiline':False]['text':' cells, replacing groups of 4 child cells by their parent cell whenever','line_number':62,'multiline':False]['text':' possible, and sorting all the cell ids in increasing order.  Returns true','line_number':63,'multiline':False]['text':' if the number of cells was reduced.','line_number':64,'multiline':False]['text':'','line_number':65,'multiline':False]['text':' This method *must* be called before doing any calculations on the cell','line_number':66,'multiline':False]['text':' union, such as Intersects() or Contains().','line_number':67,'multiline':False]['text':' Replaces "output" with an expanded version of the cell union where any','line_number':70,'multiline':False]['text':' cells whose level is less than "min_level" or where (level - min_level)','line_number':71,'multiline':False]['text':' is not a multiple of "level_mod" are replaced by their children, until','line_number':72,'multiline':False]['text':' either both of these conditions are satisfied or the maximum level is','line_number':73,'multiline':False]['text':' reached.','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' This method allows a covering generated by S2RegionCoverer using','line_number':76,'multiline':False]['text':' min_level() or level_mod() constraints to be stored as a normalized cell','line_number':77,'multiline':False]['text':' union (which allows various geometric computations to be done) and then','line_number':78,'multiline':False]['text':' converted back to the original list of cell ids that satisfies the','line_number':79,'multiline':False]['text':' desired constraints.','line_number':80,'multiline':False]['text':' If there are more than "excess" elements of the cell_ids() vector that','line_number':84,'multiline':False]['text':' are allocated but unused, reallocate the array to eliminate the excess','line_number':85,'multiline':False]['text':' space.  This reduces memory usage when many cell unions need to be held','line_number':86,'multiline':False]['text':' in memory at once.','line_number':87,'multiline':False]['text':' Return true if the cell union contains the given cell id.  Containment is','line_number':90,'multiline':False]['text':' defined with respect to regions, e.g. a cell contains its 4 children.','line_number':91,'multiline':False]['text':' This is a fast operation (logarithmic in the size of the cell union).','line_number':92,'multiline':False]['text':' Return true if the cell union intersects the given cell id.','line_number':95,'multiline':False]['text':' This is a fast operation (logarithmic in the size of the cell union).','line_number':96,'multiline':False]['text':' Return true if this cell union contain/intersects the given other cell','line_number':99,'multiline':False]['text':' union.','line_number':100,'multiline':False]['text':' Initialize this cell union to the union, intersection, or','line_number':104,'multiline':False]['text':' difference (x - y) of the two given cell unions.','line_number':105,'multiline':False]['text':' Requires: x != this and y != this.','line_number':106,'multiline':False]['text':' Specialized version of GetIntersection() that gets the intersection of a','line_number':111,'multiline':False]['text':' cell union with the given cell id.  This can be useful for "splitting" a','line_number':112,'multiline':False]['text':' cell union into chunks.','line_number':113,'multiline':False]['text':' Expands the cell union by adding a "rim" of cells on expand_level','line_number':116,'multiline':False]['text':' around the union boundary.','line_number':117,'multiline':False]['text':'','line_number':118,'multiline':False]['text':' For each cell c in the union, we add all cells at level','line_number':119,'multiline':False]['text':' expand_level that abut c.  There are typically eight of those','line_number':120,'multiline':False]['text':' (four edge-abutting and four sharing a vertex).  However, if c is','line_number':121,'multiline':False]['text':' finer than expand_level, we add all cells abutting','line_number':122,'multiline':False]['text':' c.parent(expand_level) as well as c.parent(expand_level) itself,','line_number':123,'multiline':False]['text':' as an expand_level cell rarely abuts a smaller cell.','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':' Note that the size of the output is exponential in','line_number':126,'multiline':False]['text':' "expand_level".  For example, if expand_level == 20 and the input','line_number':127,'multiline':False]['text':' has a cell at level 10, there will be on the order of 4000','line_number':128,'multiline':False]['text':' adjacent cells in the output.  For most applications the','line_number':129,'multiline':False]['text':' Expand(min_radius, max_level_diff) method below is easier to use.','line_number':130,'multiline':False]['text':' Expand the cell union such that it contains all points whose distance to','line_number':133,'multiline':False]['text':' the cell union is at most "min_radius", but do not use cells that are','line_number':134,'multiline':False]['text':' more than "max_level_diff" levels higher than the largest cell in the','line_number':135,'multiline':False]['text':' input.  The second parameter controls the tradeoff between accuracy and','line_number':136,'multiline':False]['text':' output size when a large region is being expanded by a small amount','line_number':137,'multiline':False]['text':' (e.g. expanding Canada by 1km).  For example, if max_level_diff == 4 the','line_number':138,'multiline':False]['text':' region will always be expanded by approximately 1/16 the width of its','line_number':139,'multiline':False]['text':' largest cell.  Note that in the worst case, the number of cells in the','line_number':140,'multiline':False]['text':' output can be up to 4 * (1 + 2 ** max_level_diff) times larger than the','line_number':141,'multiline':False]['text':' number of cells in the input.','line_number':142,'multiline':False]['text':' Create a cell union that corresponds to a continuous range of cell ids.','line_number':145,'multiline':False]['text':' The output is a normalized collection of cell ids that covers the leaf','line_number':146,'multiline':False]['text':' cells between "min_id" and "max_id" inclusive.','line_number':147,'multiline':False]['text':' Requires: min_id.is_leaf(), max_id.is_leaf(), min_id <= max_id.','line_number':148,'multiline':False]['text':' The number of leaf cells covered by the union.','line_number':151,'multiline':False]['text':' This will be no more than 6*2^60 for the whole sphere.','line_number':152,'multiline':False]['text':' Approximate this cell union's area by summing the average area of','line_number':155,'multiline':False]['text':' each contained cell's average area, using the AverageArea method','line_number':156,'multiline':False]['text':' from the S2Cell class.','line_number':157,'multiline':False]['text':' This is equivalent to the number of leaves covered, multiplied by','line_number':158,'multiline':False]['text':' the average area of a leaf.','line_number':159,'multiline':False]['text':' Note that AverageArea does not take into account distortion of cell, and','line_number':160,'multiline':False]['text':' thus may be off by up to a factor of 1.7.','line_number':161,'multiline':False]['text':' NOTE: Since this is proportional to LeafCellsCovered(), it is','line_number':162,'multiline':False]['text':' always better to use the other function if all you care about is','line_number':163,'multiline':False]['text':' the relative average area between objects.','line_number':164,'multiline':False]['text':' Calculates this cell union's area by summing the approximate area for each','line_number':167,'multiline':False]['text':' contained cell, using the ApproxArea method from the S2Cell class.','line_number':168,'multiline':False]['text':' Calculates this cell union's area by summing the exact area for each','line_number':171,'multiline':False]['text':' contained cell, using the Exact method from the S2Cell class.','line_number':172,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////','line_number':175,'multiline':False]['text':' S2Region interface (see s2region.h for details):','line_number':176,'multiline':False]['text':' This is a fast operation (logarithmic in the size of the cell union).','line_number':182,'multiline':False]['text':' This is a fast operation (logarithmic in the size of the cell union).','line_number':185,'multiline':False]['text':' The same as Contains() below, just virtual.','line_number':189,'multiline':False]['text':' The point 'p' does not need to be normalized.','line_number':197,'multiline':False]['text':' This is a fast operation (logarithmic in the size of the cell union).','line_number':198,'multiline':False]['text':' Return true if two cell unions are identical.','line_number':207,'multiline':False]['text':' UTIL_GEOMETRY_S2CELLUNION_H_','line_number':210,'multiline':False]