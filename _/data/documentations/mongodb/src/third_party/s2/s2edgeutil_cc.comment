['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' We compute SimpleCCW() for triangles ACB, CBD, BDA, and DAC.  All','line_number':15,'multiline':False]['text':' of these triangles need to have the same orientation (CW or CCW)','line_number':16,'multiline':False]['text':' for an intersection to exist.  Note that this is slightly more','line_number':17,'multiline':False]['text':' restrictive than the corresponding definition for planar edges,','line_number':18,'multiline':False]['text':' since we need to exclude pairs of line segments that would','line_number':19,'multiline':False]['text':' otherwise "intersect" by crossing two antipodal points.','line_number':20,'multiline':False]['text':' If A == B or C == D there is no intersection.  We need to check this','line_number':41,'multiline':False]['text':' case first in case 3 or more input points are identical.','line_number':42,'multiline':False]['text':' If any other pair of vertices is equal, there is a crossing if and only','line_number':45,'multiline':False]['text':' if OrderedCCW() indicates that the edge AB is further CCW around the','line_number':46,'multiline':False]['text':' shared vertex O (either A or B) than the edge CD, starting from an','line_number':47,'multiline':False]['text':' arbitrary fixed reference point.','line_number':48,'multiline':False]['text':' Changing the following to a warning is a workaround fix for SERVER-19674.','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' Because ExpensiveCCW is subject to numerical errors there are some','line_number':56,'multiline':False]['text':' edge cases where this function will be called with 4 distinct','line_number':57,'multiline':False]['text':' (but with two extremely close) vertices','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':' If the squared distance from x to y is less than dmin2, then replace','line_number':74,'multiline':False]['text':' vmin by y and update dmin2 accordingly.','line_number':75,'multiline':False]['text':' We use RobustCrossProd() to get accurate results even when two endpoints','line_number':88,'multiline':False]['text':' are close together, or when the two line segments are nearly parallel.','line_number':89,'multiline':False]['text':' Make sure the intersection point is on the correct side of the sphere.','line_number':95,'multiline':False]['text':' Since all vertices are unit length, and edges are less than 180 degrees,','line_number':96,'multiline':False]['text':' (a0 + a1) and (b0 + b1) both have positive dot product with the','line_number':97,'multiline':False]['text':' intersection point.  We use the sum of all vertices to make sure that the','line_number':98,'multiline':False]['text':' result is unchanged when the edges are reversed or exchanged.','line_number':99,'multiline':False]['text':' The calculation above is sufficient to ensure that "x" is within','line_number':103,'multiline':False]['text':' kIntersectionTolerance of the great circles through (a0,a1) and (b0,b1).','line_number':104,'multiline':False]['text':' However, if these two great circles are very close to parallel, it is','line_number':105,'multiline':False]['text':' possible that "x" does not lie between the endpoints of the given line','line_number':106,'multiline':False]['text':' segments.  In other words, "x" might be on the great circle through','line_number':107,'multiline':False]['text':' (a0,a1) but outside the range covered by (a0,a1).  In this case we do','line_number':108,'multiline':False]['text':' additional clipping to ensure that it does.','line_number':109,'multiline':False]['text':' Find the acceptable endpoint closest to x and return it.  An endpoint is','line_number':114,'multiline':False]['text':' acceptable if it lies between the endpoints of the other line segment.','line_number':115,'multiline':False]['text':' IEEE floating-point operations have a maximum error of 0.5 ULPS (units in','line_number':128,'multiline':False]['text':' the last place).  For double-precision numbers, this works out to 2**-53','line_number':129,'multiline':False]['text':' (about 1.11e-16) times the magnitude of the result.  It is possible to','line_number':130,'multiline':False]['text':' analyze the calculation done by GetIntersection() and work out the','line_number':131,'multiline':False]['text':' worst-case rounding error.  I have done a rough version of this, and my','line_number':132,'multiline':False]['text':' estimate is that the worst case distance from the intersection point X to','line_number':133,'multiline':False]['text':' the great circle through (a0, a1) is about 12 ULPS, or about 1.3e-15.','line_number':134,'multiline':False]['text':' This needs to be increased by a factor of (1/0.866) to account for the','line_number':135,'multiline':False]['text':' edge_splice_fraction() in S2PolygonBuilder.  Note that the maximum error','line_number':136,'multiline':False]['text':' measured by the unittest in 1,000,000 trials is less than 3e-16.','line_number':137,'multiline':False]['text':' As of crosstool v14, gcc tries to calculate sin(ax_radians),','line_number':154,'multiline':False]['text':' cos(ax_radians), sin(ab_radians), cos(ab_radians) in the','line_number':155,'multiline':False]['text':' following section by two sincos() calls. However, for some','line_number':156,'multiline':False]['text':' inputs, sincos() returns significantly different values between','line_number':157,'multiline':False]['text':' AMD and Intel.','line_number':158,'multiline':False]['text':'','line_number':159,'multiline':False]['text':' As a temporary workaround, "volatile" is added to ax_radians and','line_number':160,'multiline':False]['text':' ab_radians, to prohibit the compiler to use such sincos() call,','line_number':161,'multiline':False]['text':' because sin() and cos() don't seem to have the problem. See','line_number':162,'multiline':False]['text':' b/3088321 for details.','line_number':163,'multiline':False]['text':' The result X is some linear combination X = e*A + f*B of the input','line_number':167,'multiline':False]['text':' points.  The fractions "e" and "f" can be derived by looking at the','line_number':168,'multiline':False]['text':' components of this equation that are parallel and perpendicular to A.','line_number':169,'multiline':False]['text':' Let E = e*A and F = f*B.  Then OEXF is a parallelogram.  You can obtain','line_number':170,'multiline':False]['text':' the distance f = OF by considering the similar triangles produced by','line_number':171,'multiline':False]['text':' dropping perpendiculars from the segments OF and OB to OA.','line_number':172,'multiline':False]['text':' Form the dot product of the first equation with A to obtain','line_number':175,'multiline':False]['text':' A.X = e*A.A + f*A.B.  Since A, B, and X are all unit vectors,','line_number':176,'multiline':False]['text':' cos(ax) = e*1 + f*cos(ab), so','line_number':177,'multiline':False]['text':' Mathematically speaking, if "a" and "b" are unit length then the result','line_number':180,'multiline':False]['text':' is unit length as well.  But we normalize it anyway to prevent points','line_number':181,'multiline':False]['text':' from drifting away from unit length when multiple interpolations are done','line_number':182,'multiline':False]['text':' in succession (i.e. the result of one interpolation is fed into another).','line_number':183,'multiline':False]['text':' There are three cases.  If X is located in the spherical wedge defined by','line_number':206,'multiline':False]['text':' A, B, and the axis A x B, then the closest point is on the segment AB.','line_number':207,'multiline':False]['text':' Otherwise the closest point is either A or B; the dividing line between','line_number':208,'multiline':False]['text':' these two cases is the great circle passing through (A x B) and the','line_number':209,'multiline':False]['text':' midpoint of AB.','line_number':210,'multiline':False]['text':' The closest point to X lies on the segment AB.  We compute the distance','line_number':213,'multiline':False]['text':' to the corresponding great circle.  The result is accurate for small','line_number':214,'multiline':False]['text':' distances but not necessarily for large distances (approaching Pi/2).','line_number':215,'multiline':False]['text':' Due to the guarantees of SimpleCCW().','line_number':217,'multiline':False]['text':' Otherwise, the closest point is either A or B.  The cheapest method is','line_number':221,'multiline':False]['text':' just to compute the minimum of the two linear (as opposed to spherical)','line_number':222,'multiline':False]['text':' distances and convert the result to an angle.  Again, this method is','line_number':223,'multiline':False]['text':' accurate for small but not large distances (approaching Pi).','line_number':224,'multiline':False]['text':' Find the closest point to X along the great circle through AB.','line_number':242,'multiline':False]['text':' If this point is on the edge AB, then it's the closest point.','line_number':245,'multiline':False]['text':' Otherwise, the closest point is either A or B.','line_number':249,'multiline':False]['text':' The point on edge B=b0b1 furthest from edge A=a0a1 is either b0, b1, or','line_number':263,'multiline':False]['text':' some interior point on B.  If it is an interior point on B, then it must be','line_number':264,'multiline':False]['text':' one of the two points where the great circle containing B (circ(B)) is','line_number':265,'multiline':False]['text':' furthest from the great circle containing A (circ(A)).  At these points,','line_number':266,'multiline':False]['text':' the distance between circ(B) and circ(A) is the angle between the planes','line_number':267,'multiline':False]['text':' containing them.','line_number':268,'multiline':False]['text':' If a_nearest_b0 and a_nearest_b1 have opposite orientation from a0 and a1,','line_number':273,'multiline':False]['text':' we invert a_ortho so that it points in the same direction as a_nearest_b0 x','line_number':274,'multiline':False]['text':' a_nearest_b1.  This helps us handle the case where A and B are oppositely','line_number':275,'multiline':False]['text':' oriented but otherwise might be near each other.  We check orientation and','line_number':276,'multiline':False]['text':' invert rather than computing a_nearest_b0 x a_nearest_b1 because those two','line_number':277,'multiline':False]['text':' points might be equal, and have an unhelpful cross product.','line_number':278,'multiline':False]['text':' To check if all points on B are within tolerance of A, we first check to','line_number':282,'multiline':False]['text':' see if the endpoints of B are near A.  If they are not, B is not near A.','line_number':283,'multiline':False]['text':' If b0 and b1 are both within tolerance of A, we check to see if the angle','line_number':289,'multiline':False]['text':' between the planes containing B and A is greater than tolerance.  If it is','line_number':290,'multiline':False]['text':' not, no point on B can be further than tolerance from A (recall that we','line_number':291,'multiline':False]['text':' already know that b0 and b1 are close to A, and S2Edges are all shorter','line_number':292,'multiline':False]['text':' than 180 degrees).  The angle between the planes containing circ(A) and','line_number':293,'multiline':False]['text':' circ(B) is the angle between their normal vectors.','line_number':294,'multiline':False]['text':' As planar_angle approaches M_PI, the projection of a_ortho onto the plane','line_number':301,'multiline':False]['text':' of B approaches the null vector, and normalizing it is numerically','line_number':302,'multiline':False]['text':' unstable.  This makes it unreliable or impossible to identify pairs of','line_number':303,'multiline':False]['text':' points where circ(A) is furthest from circ(B).  At this point in the','line_number':304,'multiline':False]['text':' algorithm, this can only occur for two reasons:','line_number':305,'multiline':False]['text':'','line_number':306,'multiline':False]['text':'  1.) b0 and b1 are closest to A at distinct endpoints of A, in which case','line_number':307,'multiline':False]['text':'      the opposite orientation of a_ortho and b_ortho means that A and B are','line_number':308,'multiline':False]['text':'      in opposite hemispheres and hence not close to each other.','line_number':309,'multiline':False]['text':'','line_number':310,'multiline':False]['text':'  2.) b0 and b1 are closest to A at the same endpoint of A, in which case','line_number':311,'multiline':False]['text':'      the orientation of a_ortho was chosen arbitrarily to be that of a0','line_number':312,'multiline':False]['text':'      cross a1.  B must be shorter than 2*tolerance and all points in B are','line_number':313,'multiline':False]['text':'      close to one endpoint of A, and hence to A.','line_number':314,'multiline':False]['text':'','line_number':315,'multiline':False]['text':' The logic applies when planar_angle is robustly greater than M_PI/2, but','line_number':316,'multiline':False]['text':' may be more computationally expensive than the logic beyond, so we choose a','line_number':317,'multiline':False]['text':' value close to M_PI.','line_number':318,'multiline':False]['text':' Finally, if either of the two points on circ(B) where circ(B) is furthest','line_number':324,'multiline':False]['text':' from circ(A) lie on edge B, edge B is not near edge A.','line_number':325,'multiline':False]['text':'','line_number':326,'multiline':False]['text':' The normalized projection of a_ortho onto the plane of circ(B) is one of','line_number':327,'multiline':False]['text':' the two points along circ(B) where it is furthest from circ(A).  The other','line_number':328,'multiline':False]['text':' is -1 times the normalized projection.','line_number':329,'multiline':False]['text':' A point p lies on B if you can proceed from b_ortho to b0 to p to b1 and','line_number':334,'multiline':False]['text':' back to b_ortho without ever turning right.  We test this for furthest and','line_number':335,'multiline':False]['text':' furthest_inv, and return true if neither point lies on B.','line_number':336,'multiline':False]['text':' For A to contain B (where each loop interior is defined to be its left','line_number':347,'multiline':False]['text':' side), the CCW edge order around ab1 must be a2 b2 b0 a0.  We split','line_number':348,'multiline':False]['text':' this test into two parts that test three vertices each.','line_number':349,'multiline':False]['text':' For A not to intersect B (where each loop interior is defined to be','line_number':356,'multiline':False]['text':' its left side), the CCW edge order around ab1 must be a0 b2 b0 a2.','line_number':357,'multiline':False]['text':' Note that it's important to write these conditions as negatives','line_number':358,'multiline':False]['text':' (!OrderedCCW(a,b,c,o) rather than Ordered(c,b,a,o)) to get correct','line_number':359,'multiline':False]['text':' results when two vertices are the same.','line_number':360,'multiline':False]['text':' There are 6 possible edge orderings at a shared vertex (all','line_number':367,'multiline':False]['text':' of these orderings are circular, i.e. abcd == bcda):','line_number':368,'multiline':False]['text':'','line_number':369,'multiline':False]['text':'  (1) a2 b2 b0 a0: A contains B','line_number':370,'multiline':False]['text':'  (2) a2 a0 b0 b2: B contains A','line_number':371,'multiline':False]['text':'  (3) a2 a0 b2 b0: A and B are disjoint','line_number':372,'multiline':False]['text':'  (4) a2 b0 a0 b2: A and B intersect in one wedge','line_number':373,'multiline':False]['text':'  (5) a2 b2 a0 b0: A and B intersect in one wedge','line_number':374,'multiline':False]['text':'  (6) a2 b0 b2 a0: A and B intersect in two wedges','line_number':375,'multiline':False]['text':'','line_number':376,'multiline':False]['text':' We do not distinguish between 4, 5, and 6.','line_number':377,'multiline':False]['text':' We pay extra attention when some of the edges overlap.When edges','line_number':378,'multiline':False]['text':' overlap, several of these orderings can be satisfied, and we take','line_number':379,'multiline':False]['text':' the most specific.','line_number':380,'multiline':False]['text':' The cases with this vertex ordering are 1, 5, and 6,','line_number':384,'multiline':False]['text':' although case 2 is also possible if a2 == b2.','line_number':385,'multiline':False]['text':' We are in case 5 or 6, or case 2 if a2 == b2.','line_number':388,'multiline':False]['text':' We are in case 2, 3, or 4.','line_number':392,'multiline':False]['text':' ACB and BDA have the appropriate orientations, so now we check the','line_number':399,'multiline':False]['text':' triangles CBD and DAC.','line_number':400,'multiline':False]['text':' We can't just call bound_.AddPoint(b_latlng) here, since we need to','line_number':415,'multiline':False]['text':' ensure that all the longitudes between "a" and "b" are included.','line_number':416,'multiline':False]['text':' Check whether the min/max latitude occurs in the edge interior.  We find','line_number':419,'multiline':False]['text':' the normal to the plane containing AB, and then a vector "dir" in this','line_number':420,'multiline':False]['text':' plane that also passes through the equator.  We use RobustCrossProd to','line_number':421,'multiline':False]['text':' ensure that the edge normal is accurate even when the two points are very','line_number':422,'multiline':False]['text':' close together.','line_number':423,'multiline':False]['text':' Minimum/maximum latitude occurs in the edge interior.','line_number':429,'multiline':False]['text':' It's possible that abs_lat < lat_.lo() due to numerical errors.','line_number':432,'multiline':False]['text':' If the edge comes very close to the north or south pole then we may','line_number':438,'multiline':False]['text':' not be certain which side of the pole it is on.  We handle this by','line_number':439,'multiline':False]['text':' expanding the longitude bounds if the maximum absolute latitude is','line_number':440,'multiline':False]['text':' approximately Pi/2.','line_number':441,'multiline':False]