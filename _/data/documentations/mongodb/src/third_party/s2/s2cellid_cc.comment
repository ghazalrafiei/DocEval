['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' The following lookup tables are used to convert efficiently between an','line_number':32,'multiline':False]['text':' (i,j) cell index and the corresponding position along the Hilbert curve.','line_number':33,'multiline':False]['text':' "lookup_pos" maps 4 bits of "i", 4 bits of "j", and 2 bits representing the','line_number':34,'multiline':False]['text':' orientation of the current cell into 8 bits representing the order in which','line_number':35,'multiline':False]['text':' that subcell is visited by the Hilbert curve, plus 2 bits indicating the','line_number':36,'multiline':False]['text':' new orientation of the Hilbert curve within that subcell.  (Cell','line_number':37,'multiline':False]['text':' orientations are represented as combination of kSwapMask and kInvertMask.)','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' "lookup_ij" is an inverted table used for mapping in the opposite','line_number':40,'multiline':False]['text':' direction.','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' We also experimented with looking up 16 bits at a time (14 bits of position','line_number':43,'multiline':False]['text':' plus 2 of orientation) but found that smaller lookup tables gave better','line_number':44,'multiline':False]['text':' performance.  (2KB fits easily in the primary cache.)','line_number':45,'multiline':False]['text':' Values for these constants are *declared* in the *.h file. Even though','line_number':48,'multiline':False]['text':' the declaration specifies a value for the constant, that declaration','line_number':49,'multiline':False]['text':' is not a *definition* of storage for the value. Because the values are','line_number':50,'multiline':False]['text':' supplied in the declaration, we don't need the values here. Failing to','line_number':51,'multiline':False]['text':' define storage causes link errors for any code that tries to take the','line_number':52,'multiline':False]['text':' address of one of these values.','line_number':53,'multiline':False]['text':' Modern s2geometry does this with std::call_once, so we will copy that technique.','line_number':91,'multiline':False]['text':' https://github.com/google/s2geometry/blob/bec06921d7/src/s2/s2cell_id.cc#L102','line_number':92,'multiline':False]['text':' Fast path for leaf cells.','line_number':104,'multiline':False]['text':' We only need to look at even-numbered bits to determine the','line_number':114,'multiline':False]['text':' level of a valid cell id.','line_number':115,'multiline':False]['text':' Get lowest bit.','line_number':118,'multiline':False]['text':' We clamp the number of steps if necessary to ensure that we do not','line_number':132,'multiline':False]['text':' advance past the End() or before the Begin() of this level.  Note that','line_number':133,'multiline':False]['text':' min_steps and max_steps always fit in a signed 64-bit integer.','line_number':134,'multiline':False]['text':' Unlike advance(), we don't want to return End(level).','line_number':160,'multiline':False]['text':' Simple implementation: convert the id to hex and strip trailing zeros.','line_number':177,'multiline':False]['text':' Using hex has the advantage that the tokens are case-insensitive, all','line_number':178,'multiline':False]['text':' characters are alphanumeric, no characters require any special escaping','line_number':179,'multiline':False]['text':' in Mustang queries, and it's easy to compare cell tokens against the','line_number':180,'multiline':False]['text':' feature ids of the corresponding features.','line_number':181,'multiline':False]['text':'','line_number':182,'multiline':False]['text':' Using base 64 would produce slightly shorter tokens, but for typical cell','line_number':183,'multiline':False]['text':' sizes used during indexing (up to level 15 or so) the average savings','line_number':184,'multiline':False]['text':' would be less than 2 bytes per cell which doesn't seem worth it.','line_number':185,'multiline':False]['text':' Invalid hex string.','line_number':194,'multiline':False]['text':' Converting from floating-point to integers via static_cast is very slow','line_number':205,'multiline':False]['text':' on Intel processors because it requires changing the rounding mode.','line_number':206,'multiline':False]['text':' Rounding to the nearest integer using FastIntRound() is much faster.','line_number':207,'multiline':False]['text':' Optimization notes:','line_number':216,'multiline':False]['text':'  - Non-overlapping bit fields can be combined with either "+" or "|".','line_number':217,'multiline':False]['text':'    Generally "+" seems to produce better code, but not always.','line_number':218,'multiline':False]['text':' gcc doesn't have very good code generation for 64-bit operations.','line_number':220,'multiline':False]['text':' We optimize this by computing the result as two 32-bit integers','line_number':221,'multiline':False]['text':' and combining them at the end.  Declaring the result as an array','line_number':222,'multiline':False]['text':' rather than local variables helps the compiler to do a better job','line_number':223,'multiline':False]['text':' of register allocation as well.  Note that the two 32-bits halves','line_number':224,'multiline':False]['text':' get shifted one bit to the left when they are combined.','line_number':225,'multiline':False]['text':' Alternating faces have opposite Hilbert curve orientations; this','line_number':230,'multiline':False]['text':' is necessary in order for all faces to have a right-handed','line_number':231,'multiline':False]['text':' coordinate system.','line_number':232,'multiline':False]['text':' Each iteration maps 4 bits of "i" and "j" into 8 bits of the Hilbert','line_number':235,'multiline':False]['text':' curve position.  The lookup table transforms a 10-bit key of the form','line_number':236,'multiline':False]['text':' "iiiijjjjoo" to a 10-bit value of the form "ppppppppoo", where the','line_number':237,'multiline':False]['text':' letters [ijpo] denote bits of "i", "j", Hilbert curve position, and','line_number':238,'multiline':False]['text':' Hilbert curve orientation respectively.','line_number':239,'multiline':False]['text':' Each iteration maps 8 bits of the Hilbert curve position into','line_number':281,'multiline':False]['text':' 4 bits of "i" and "j".  The lookup table transforms a key of the','line_number':282,'multiline':False]['text':' form "ppppppppoo" to a value of the form "iiiijjjjoo", where the','line_number':283,'multiline':False]['text':' letters [ijpo] represents bits of "i", "j", the Hilbert curve','line_number':284,'multiline':False]['text':' position, and the Hilbert curve orientation respectively.','line_number':285,'multiline':False]['text':'','line_number':286,'multiline':False]['text':' On the first iteration we need to be careful to clear out the bits','line_number':287,'multiline':False]['text':' representing the cube face.','line_number':288,'multiline':False]['text':' The position of a non-leaf cell at level "n" consists of a prefix of','line_number':313,'multiline':False]['text':' 2*n bits that identifies the cell, followed by a suffix of','line_number':314,'multiline':False]['text':' 2*(kMaxLevel-n)+1 bits of the form 10*.  If n==kMaxLevel, the suffix is','line_number':315,'multiline':False]['text':' just "1" and has no effect.  Otherwise, it consists of "10", followed','line_number':316,'multiline':False]['text':' by (kMaxLevel-n-1) repetitions of "00", followed by "0".  The "10" has','line_number':317,'multiline':False]['text':' no effect, while each occurrence of "00" has the effect of reversing','line_number':318,'multiline':False]['text':' the kSwapMask bit.','line_number':319,'multiline':False]['text':' First we compute the discrete (i,j) coordinates of a leaf cell contained','line_number':331,'multiline':False]['text':' within the given cell.  Given that cells are represented by the Hilbert','line_number':332,'multiline':False]['text':' curve position corresponding at their center, it turns out that the cell','line_number':333,'multiline':False]['text':' returned by ToFaceIJOrientation is always one of two leaf cells closest','line_number':334,'multiline':False]['text':' to the center of the cell (unless the given cell is a leaf cell itself,','line_number':335,'multiline':False]['text':' in which case there is only one possibility).','line_number':336,'multiline':False]['text':'','line_number':337,'multiline':False]['text':' Given a cell of size s >= 2 (i.e. not a leaf cell), and letting (imin,','line_number':338,'multiline':False]['text':' jmin) be the coordinates of its lower left-hand corner, the leaf cell','line_number':339,'multiline':False]['text':' returned by ToFaceIJOrientation() is either (imin + s/2, jmin + s/2)','line_number':340,'multiline':False]['text':' (imin + s/2 - 1, jmin + s/2 - 1).  The first case is the one we want.','line_number':341,'multiline':False]['text':' We can distinguish these two cases by looking at the low bit of "i" or','line_number':342,'multiline':False]['text':' "j".  In the second case the low bit is one, unless s == 2 (i.e. the','line_number':343,'multiline':False]['text':' level just above leaf cells) in which case the low bit is zero.','line_number':344,'multiline':False]['text':'','line_number':345,'multiline':False]['text':' In the code below, the expression ((i ^ (int(id_) >> 2)) & 1) is true','line_number':346,'multiline':False]['text':' if we are in the second case described above.','line_number':347,'multiline':False]['text':' Note that (2 * {i,j} + delta) will never overflow a 32-bit integer.','line_number':352,'multiline':False]['text':' This code would be slightly shorter if we called GetCenterUV(),','line_number':359,'multiline':False]['text':' but this method is heavily used and it's 25% faster to include','line_number':360,'multiline':False]['text':' the method inline.','line_number':361,'multiline':False]['text':' Convert i and j to the coordinates of a leaf cell just beyond the','line_number':387,'multiline':False]['text':' boundary of this face.  This prevents 32-bit overflow in the case','line_number':388,'multiline':False]['text':' of finding the neighbors of a face cell.','line_number':389,'multiline':False]['text':' Find the (u,v) coordinates corresponding to the center of cell (i,j).','line_number':393,'multiline':False]['text':' For our purposes it's sufficient to always use the linear projection','line_number':394,'multiline':False]['text':' from (s,t) to (u,v): u=2*s-1 and v=2*t-1.','line_number':395,'multiline':False]['text':' Find the leaf cell coordinates on the adjacent face, and convert','line_number':400,'multiline':False]['text':' them to a cell id at the appropriate level.  We convert from (u,v)','line_number':401,'multiline':False]['text':' back to (s,t) using s=0.5*(u+1), t=0.5*(v+1).','line_number':402,'multiline':False]['text':' Edges 0, 1, 2, 3 are in the S, E, N, W directions.','line_number':421,'multiline':False]['text':' "level" must be strictly less than this cell's level so that we can','line_number':434,'multiline':False]['text':' determine which vertex this cell is closest to.','line_number':435,'multiline':False]['text':' Determine the i- and j-offsets to the closest neighboring cell in each','line_number':440,'multiline':False]['text':' direction.  This involves looking at the next bit of "i" and "j" to','line_number':441,'multiline':False]['text':' determine which quadrant of this->parent(level) this cell lies in.','line_number':442,'multiline':False]['text':' If i- and j- edge neighbors are *both* on a different face, then this','line_number':465,'multiline':False]['text':' vertex only has three neighbors (it is one of the 8 cube vertices).','line_number':466,'multiline':False]['text':' Find the coordinates of the lower left-hand leaf cell.  We need to','line_number':478,'multiline':False]['text':' normalize (i,j) to a known position within the cell because nbr_level','line_number':479,'multiline':False]['text':' may be larger than this cell's level.','line_number':480,'multiline':False]['text':' We compute the N-S, E-W, and diagonal neighbors in one pass.','line_number':488,'multiline':False]['text':' The loop test is at the end of the loop to avoid 32-bit overflow.','line_number':489,'multiline':False]['text':' North and South neighbors.','line_number':498,'multiline':False]['text':' East, West, and Diagonal neighbors.','line_number':504,'multiline':False]