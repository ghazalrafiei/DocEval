['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' for HASH_NAMESPACE_DECLARATION_START','line_number':22,'multiline':False]['text':' If a loop contains an edge AB, then no other loop may contain AB or BA.','line_number':118,'multiline':False]['text':' Verify that no loop covers more than half of the sphere, and that no','line_number':142,'multiline':False]['text':' two loops cross.','line_number':143,'multiline':False]['text':' This test not only checks for edge crossings, it also detects','line_number':151,'multiline':False]['text':' cases where the two boundaries cross at a shared vertex.','line_number':152,'multiline':False]['text':' No loop may contain the complement of another loop.  (Handling this case','line_number':187,'multiline':False]['text':' is significantly more complicated.)','line_number':188,'multiline':False]['text':' Some of the children of the parent loop may now be children of','line_number':191,'multiline':False]['text':' the new loop.','line_number':192,'multiline':False]['text':' This function is just used to verify that the loop map was','line_number':218,'multiline':False]['text':' constructed correctly.','line_number':219,'multiline':False]['text':' Reorder the loops in depth-first traversal order.','line_number':245,'multiline':False]['text':' Check that the LoopMap is correct (this is fairly cheap).','line_number':250,'multiline':False]['text':' Compute the bounding rectangle of the entire polygon.','line_number':260,'multiline':False]['text':' Optimization.','line_number':274,'multiline':False]['text':' The loop boundaries intersect.','line_number':306,'multiline':False]['text':' True if loop B is contained by the','line_number':309,'multiline':False]['text':' polygon.','line_number':310,'multiline':False]['text':' Return true if any loop contains the given loop.','line_number':314,'multiline':False]['text':' Return true if this polygon (A) contains all the shells of B.','line_number':322,'multiline':False]['text':' Shell of B is not contained by A, or the boundaries intersect.','line_number':326,'multiline':False]['text':' Return true if this polygon (A) excludes (i.e. does not intersect)','line_number':334,'multiline':False]['text':' all holes of B.','line_number':335,'multiline':False]['text':' Hole of B is contained by A, or the boundaries intersect.','line_number':339,'multiline':False]['text':' Return true if this polygon (A) intersects any shell of B.','line_number':347,'multiline':False]['text':' We definitely have an intersection if the loops intersect AND one','line_number':362,'multiline':False]['text':' is not properly contained in the other. If A (this) is properly','line_number':363,'multiline':False]['text':' contained in a loop of B, we don't know yet if it may be actually','line_number':364,'multiline':False]['text':' inside a hole within B.','line_number':365,'multiline':False]['text':' If both polygons have one loop, use the more efficient S2Loop method.','line_number':373,'multiline':False]['text':' Note that S2Loop::Contains does its own bounding rectangle check.','line_number':374,'multiline':False]['text':' Otherwise if neither polygon has holes, we can still use the more','line_number':379,'multiline':False]['text':' efficient S2Loop::Contains method (rather than ContainsOrCrosses),','line_number':380,'multiline':False]['text':' but it's worthwhile to do our own bounds check first.','line_number':381,'multiline':False]['text':' If the union of the bounding boxes spans the full longitude range,','line_number':383,'multiline':False]['text':' it is still possible that polygon A contains B.  (This is only','line_number':384,'multiline':False]['text':' possible if at least one polygon has multiple shells.)','line_number':385,'multiline':False]['text':' This could be implemented more efficiently for polygons with lots of','line_number':395,'multiline':False]['text':' holes by keeping a copy of the LoopMap computed during initialization.','line_number':396,'multiline':False]['text':' However, in practice most polygons are one loop, and multiloop polygons','line_number':397,'multiline':False]['text':' tend to consist of many shells rather than holes.  In any case, the real','line_number':398,'multiline':False]['text':' way to get more efficiency is to implement a sub-quadratic algorithm','line_number':399,'multiline':False]['text':' such as building a trapezoidal map.','line_number':400,'multiline':False]['text':' Every shell of B must be contained by an odd number of loops of A,','line_number':402,'multiline':False]['text':' and every hole of A must be contained by an even number of loops of B.','line_number':403,'multiline':False]['text':' A.Intersects(B) if and only if !Complement(A).Contains(B).  However,','line_number':408,'multiline':False]['text':' implementing a Complement() operation is trickier than it sounds,','line_number':409,'multiline':False]['text':' and in any case it's more efficient to test for intersection directly.','line_number':410,'multiline':False]['text':' If both polygons have one loop, use the more efficient S2Loop method.','line_number':412,'multiline':False]['text':' Note that S2Loop::Intersects does its own bounding rectangle check.','line_number':413,'multiline':False]['text':' Otherwise if neither polygon has holes, we can still use the more','line_number':418,'multiline':False]['text':' efficient S2Loop::Intersects method.  The polygons intersect if and','line_number':419,'multiline':False]['text':' only if some pair of loop regions intersect.','line_number':420,'multiline':False]['text':' Otherwise if any shell of B is contained by an odd number of loops of A,','line_number':431,'multiline':False]['text':' or any shell of A is contained by an odd number of loops of B, or there is','line_number':432,'multiline':False]['text':' an intersection without containment, then there is an intersection.','line_number':433,'multiline':False]['text':' We can't check bound_.Contains(cell.GetRectBound()) because S2Cell's','line_number':446,'multiline':False]['text':' GetRectBound() calculation is not precise.','line_number':447,'multiline':False]['text':' The same as Contains() below, just virtual.','line_number':482,'multiline':False]['text':' Optimization.','line_number':487,'multiline':False]['text':' Shells are disjoint.','line_number':493,'multiline':False]['text':' Sufficient','line_number':499,'multiline':False]['text':' Indexing structure to efficiently ClipEdge() of a polygon.  This is','line_number':548,'multiline':False]['text':' an abstract class because we need to use if for both polygons (for','line_number':549,'multiline':False]['text':' InitToIntersection() and friends) and for sets of vectors of points','line_number':550,'multiline':False]['text':' (for InitToSimplified()).','line_number':551,'multiline':False]['text':'','line_number':552,'multiline':False]['text':' Usage -- in your subclass:','line_number':553,'multiline':False]['text':'   - Call AddLoop() for each of your loops -- and keep them accessible in','line_number':554,'multiline':False]['text':'     your subclass.','line_number':555,'multiline':False]['text':'   - Overwrite EdgeFromTo(), calling DecodeIndex() and accessing your','line_number':556,'multiline':False]['text':'     underlying data with the resulting two indices.','line_number':557,'multiline':False]['text':' It is faster to return both vertices at once.  It makes a difference','line_number':581,'multiline':False]['text':' for small polygons.','line_number':582,'multiline':False]['text':' Map from the unidimensional edge index to the loop this edge','line_number':603,'multiline':False]['text':' belongs to.','line_number':604,'multiline':False]['text':' Reverse of index_to_loop_: maps a loop index to the','line_number':607,'multiline':False]['text':' unidimensional index of the first edge in the loop.','line_number':608,'multiline':False]['text':' Total number of edges.','line_number':611,'multiline':False]['text':' Total number of loops.','line_number':614,'multiline':False]['text':' Indexing structure for an S2Polygon.','line_number':618,'multiline':False]['text':' Indexing structure for a sequence of loops (not in the sense of S2:','line_number':654,'multiline':False]['text':' the loops can self-intersect).  Each loop is given in a vector<S2Point>','line_number':655,'multiline':False]['text':' where, as in S2Loop, the last vertex is implicitely joined to the first.','line_number':656,'multiline':False]['text':' Add each loop individually with AddVector().  The caller owns','line_number':657,'multiline':False]['text':' the vector<S2Point>'s.','line_number':658,'multiline':False]['text':' There is a proper edge crossing.','line_number':692,'multiline':False]['text':' There is a crossing at one of the vertices.  The basic rule is simple:','line_number':698,'multiline':False]['text':' if a0 equals one of the "b" vertices, the crossing occurs at t=0;','line_number':699,'multiline':False]['text':' otherwise, it occurs at t=1.','line_number':700,'multiline':False]['text':'','line_number':701,'multiline':False]['text':' This has the effect that when two symmetric edges are','line_number':702,'multiline':False]['text':' encountered (an edge an its reverse), neither one is included','line_number':703,'multiline':False]['text':' in the output.  When two duplicate edges are encountered, both','line_number':704,'multiline':False]['text':' are included in the output.  The "add_shared_edges" flag allows','line_number':705,'multiline':False]['text':' one of these two copies to be removed by changing its','line_number':706,'multiline':False]['text':' intersection parameter from 0 to 1.','line_number':707,'multiline':False]['text':' Find all points where the polygon B intersects the edge (a0,a1),','line_number':718,'multiline':False]['text':' and add the corresponding parameter values (in the range [0,1]) to','line_number':719,'multiline':False]['text':' "intersections".','line_number':720,'multiline':False]['text':' Clip the boundary of A to the interior of B, and add the resulting edges','line_number':741,'multiline':False]['text':' to "builder".  Shells are directed CCW and holes are directed clockwise,','line_number':742,'multiline':False]['text':' unless "reverse_a" or "reverse_b" is true in which case these directions','line_number':743,'multiline':False]['text':' in the corresponding polygon are reversed.  If "invert_b" is true, the','line_number':744,'multiline':False]['text':' boundary of A is clipped to the exterior rather than the interior of B.','line_number':745,'multiline':False]['text':' If "add_shared_edges" is true, then the output will include any edges','line_number':746,'multiline':False]['text':' that are shared between A and B (both edges must be in the same direction','line_number':747,'multiline':False]['text':' after any edge reversals are taken into account).','line_number':748,'multiline':False]['text':' We want the boundary of A clipped to the interior of B,','line_number':787,'multiline':False]['text':' plus the boundary of B clipped to the interior of A,','line_number':788,'multiline':False]['text':' plus one copy of any directed edges that are in both boundaries.','line_number':789,'multiline':False]['text':' We want the boundary of A clipped to the exterior of B,','line_number':809,'multiline':False]['text':' plus the boundary of B clipped to the exterior of A,','line_number':810,'multiline':False]['text':' plus one copy of any directed edges that are in both boundaries.','line_number':811,'multiline':False]['text':' We want the boundary of A clipped to the exterior of B,','line_number':831,'multiline':False]['text':' plus the reversed boundary of B clipped to the interior of A,','line_number':832,'multiline':False]['text':' plus one copy of any edge in A that is also a reverse edge in B.','line_number':833,'multiline':False]['text':' Takes a loop and simplifies it.  This may return a self-intersecting','line_number':845,'multiline':False]['text':' polyline.  Always keeps the first vertex from the loop.','line_number':846,'multiline':False]['text':' Add the first vertex at the beginning and at the end.','line_number':849,'multiline':False]['text':' Add them all except the last: it is the same as the first.','line_number':857,'multiline':False]['text':' Takes a set of possibly intersecting edges, stored in an','line_number':867,'multiline':False]['text':' S2EdgeIndex.  Breaks the edges into small pieces so that there is','line_number':868,'multiline':False]['text':' no intersection anymore, and adds all these edges to the builder.','line_number':869,'multiline':False]['text':' If there are self intersections, we add the pieces separately.','line_number':872,'multiline':False]['text':' add_shared_edges can be false or true: it makes no difference','line_number':880,'multiline':False]['text':' due to the way we call ClipEdge.','line_number':881,'multiline':False]['text':' Simplifies the polygon.   The algorithm is straightforward and naive:','line_number':892,'multiline':False]['text':'   1. Simplify each loop by removing points while staying in the','line_number':893,'multiline':False]['text':'      tolerance zone.  This uses S2Polyline::SubsampleVertices(),','line_number':894,'multiline':False]['text':'      which is not guaranteed to be optimal in terms of number of','line_number':895,'multiline':False]['text':'      points.','line_number':896,'multiline':False]['text':'   2. Break any edge in pieces such that no piece intersects any','line_number':897,'multiline':False]['text':'      other.','line_number':898,'multiline':False]['text':'   3. Use the polygon builder to regenerate the full polygon.','line_number':899,'multiline':False]['text':' Ideally, we would want to set the vertex_merge_radius of the','line_number':904,'multiline':False]['text':' builder roughly to tolerance (and in fact forego the edge','line_number':905,'multiline':False]['text':' splitting step).  Alas, if we do that, we are liable to the','line_number':906,'multiline':False]['text':' 'chain effect', where vertices are merged with closeby vertices','line_number':907,'multiline':False]['text':' and so on, so that a vertex can move by an arbitrary distance.','line_number':908,'multiline':False]['text':' So we remain conservative:','line_number':909,'multiline':False]['text':' Simplify each loop separately and add to the edge index','line_number':913,'multiline':False]['text':' Clip the polyline A to the interior of this polygon.','line_number':940,'multiline':False]['text':' The resulting polyline(s) will be appended to 'out'.','line_number':941,'multiline':False]['text':' If invert is true, we clip A to the exterior of this polygon instead.','line_number':942,'multiline':False]['text':' Vertices will be dropped such that adjacent vertices will not','line_number':943,'multiline':False]['text':' be closer than 'merge_radius'.','line_number':944,'multiline':False]['text':'','line_number':945,'multiline':False]['text':' We do the intersection/subtraction by walking the polyline edges.','line_number':946,'multiline':False]['text':' For each edge, we compute all intersections with the polygon boundary','line_number':947,'multiline':False]['text':' and sort them in increasing order of distance along that edge.','line_number':948,'multiline':False]['text':' We then divide the intersection points into pairs, and output a','line_number':949,'multiline':False]['text':' clipped polyline segment for each one.','line_number':950,'multiline':False]['text':' We keep track of whether we're inside or outside of the polygon at','line_number':951,'multiline':False]['text':' all times to decide which segments to output.','line_number':952,'multiline':False]['text':' At this point we have a sorted array of vertex pairs representing','line_number':970,'multiline':False]['text':' the edge(s) obtained after clipping (a0,a1) against the polygon.','line_number':971,'multiline':False]['text':' If the gap from the previous vertex to this one is large','line_number':977,'multiline':False]['text':' enough, start a new polyline.','line_number':978,'multiline':False]['text':' Append this segment to the current polyline, ignoring any','line_number':984,'multiline':False]['text':' vertices that are too close to the previous vertex.','line_number':985,'multiline':False]['text':' Effectively create a priority queue of polygons in order of number of','line_number':1030,'multiline':False]['text':' vertices.  Repeatedly union the two smallest polygons and add the result','line_number':1031,'multiline':False]['text':' to the queue until we have a single polygon to return.','line_number':1032,'multiline':False]['text':' Map from # of vertices to polygon.','line_number':1034,'multiline':False]['text':' Pop two simplest polygons from queue.','line_number':1040,'multiline':False]['text':' Union and add result back to queue.','line_number':1050,'multiline':False]['text':' We assume that the number of vertices in the union polygon is the','line_number':1056,'multiline':False]['text':' sum of the number of vertices in the original polygons, which is not','line_number':1057,'multiline':False]['text':' always true, but will almost always be a decent approximation, and','line_number':1058,'multiline':False]['text':' faster than recomputing.','line_number':1059,'multiline':False]['text':' Use a polygon builder to union the cells in the union.  Due to rounding','line_number':1069,'multiline':False]['text':' errors, we can't do an exact union - when a small cell is adjacent to a','line_number':1070,'multiline':False]['text':' larger cell, the shared edges can fail to line up exactly.  Two cell edges','line_number':1071,'multiline':False]['text':' cannot come closer then kMinWidth, so if we have the polygon builder merge','line_number':1072,'multiline':False]['text':' edges within half that distance, we should always merge shared edges','line_number':1073,'multiline':False]['text':' without merging different edges.','line_number':1074,'multiline':False]['text':' For now, we assume that there is at most one candidate match for each','line_number':1140,'multiline':False]['text':' loop.  (So far this method is just used for testing.)','line_number':1141,'multiline':False]['text':' For now, we assume that there is at most one candidate match for each','line_number':1162,'multiline':False]['text':' loop.  (So far this method is just used for testing.)','line_number':1163,'multiline':False]