['text':' Copyright 2008 and onwards Google, Inc.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Functions for splitting and parsing strings.  Functions may be migrated','line_number':3,'multiline':False]['text':' to this file from strutil.h in the future.','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':28,'multiline':False]['text':' SplitStringAllowEmpty()','line_number':29,'multiline':False]['text':' SplitStringToHashsetAllowEmpty()','line_number':30,'multiline':False]['text':' SplitStringToSetAllowEmpty()','line_number':31,'multiline':False]['text':' SplitStringToHashmapAllowEmpty()','line_number':32,'multiline':False]['text':'    Split a string using one or more character delimiters, presented','line_number':34,'multiline':False]['text':'    as a nul-terminated c string. Append the components to 'result'.','line_number':35,'multiline':False]['text':'    If there are consecutive delimiters, this function will return','line_number':36,'multiline':False]['text':'    corresponding empty strings.','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':'    If "full" is the empty string, yields an empty string as the only value.','line_number':39,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':40,'multiline':False]['text':' The even-positioned (0-based) components become the keys for the','line_number':47,'multiline':False]['text':' odd-positioned components that follow them. When there is an odd','line_number':48,'multiline':False]['text':' number of components, the value for the last key will be unchanged','line_number':49,'multiline':False]['text':' if the key was already present in the hash table, or will be the','line_number':50,'multiline':False]['text':' empty string if the key is a newly inserted key.','line_number':51,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':55,'multiline':False]['text':' SplitStringUsing()','line_number':56,'multiline':False]['text':' SplitStringToHashsetUsing()','line_number':57,'multiline':False]['text':' SplitStringToSetUsing()','line_number':58,'multiline':False]['text':' SplitStringToHashmapUsing()','line_number':59,'multiline':False]['text':'    Split a string using one or more character delimiters, presented','line_number':61,'multiline':False]['text':'    as a nul-terminated c string. Append the components to 'result'.','line_number':62,'multiline':False]['text':'    If there are consecutive delimiters, this function skips over','line_number':63,'multiline':False]['text':'    all of them.','line_number':64,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':65,'multiline':False]['text':' The even-positioned (0-based) components become the keys for the','line_number':72,'multiline':False]['text':' odd-positioned components that follow them. When there is an odd','line_number':73,'multiline':False]['text':' number of components, the value for the last key will be unchanged','line_number':74,'multiline':False]['text':' if the key was already present in the hash table, or will be the','line_number':75,'multiline':False]['text':' empty string if the key is a newly inserted key.','line_number':76,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':80,'multiline':False]['text':' SplitOneIntToken()','line_number':81,'multiline':False]['text':' SplitOneInt32Token()','line_number':82,'multiline':False]['text':' SplitOneUint32Token()','line_number':83,'multiline':False]['text':' SplitOneInt64Token()','line_number':84,'multiline':False]['text':' SplitOneUint64Token()','line_number':85,'multiline':False]['text':' SplitOneDoubleToken()','line_number':86,'multiline':False]['text':' SplitOneFloatToken()','line_number':87,'multiline':False]['text':'   Parse a single "delim" delimited number from "*source" into "*value".','line_number':88,'multiline':False]['text':'   Modify *source to point after the delimiter.','line_number':89,'multiline':False]['text':'   If no delimiter is present after the number, set *source to NULL.','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':'   If the start of *source is not an number, return false.','line_number':92,'multiline':False]['text':'   If the int is followed by the null character, return true.','line_number':93,'multiline':False]['text':'   If the int is not followed by a character from delim, return false.','line_number':94,'multiline':False]['text':'   If *source is NULL, return false.','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':'   They cannot handle decimal numbers with leading 0s, since they will be','line_number':97,'multiline':False]['text':'   treated as octal.','line_number':98,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':99,'multiline':False]['text':' Some aliases, so that the function names are standardized against the names','line_number':115,'multiline':False]['text':' of the reflection setters/getters in proto2. This makes it easier to use','line_number':116,'multiline':False]['text':' certain macros with reflection when creating custom text formats for protos.','line_number':117,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':129,'multiline':False]['text':' SplitOneDecimalIntToken()','line_number':130,'multiline':False]['text':' SplitOneDecimalInt32Token()','line_number':131,'multiline':False]['text':' SplitOneDecimalUint32Token()','line_number':132,'multiline':False]['text':' SplitOneDecimalInt64Token()','line_number':133,'multiline':False]['text':' SplitOneDecimalUint64Token()','line_number':134,'multiline':False]['text':' Parse a single "delim"-delimited number from "*source" into "*value".','line_number':135,'multiline':False]['text':' Unlike SplitOneIntToken, etc., this function always interprets','line_number':136,'multiline':False]['text':' the numbers as decimal.','line_number':137,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':149,'multiline':False]['text':' SplitOneHexUint32Token()','line_number':150,'multiline':False]['text':' SplitOneHexUint64Token()','line_number':151,'multiline':False]['text':' Once more, for hexadecimal numbers (unsigned only).','line_number':152,'multiline':False]['text':' STRINGS_SPLIT_H_','line_number':159,'multiline':False]