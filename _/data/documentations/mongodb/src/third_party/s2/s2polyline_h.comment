['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' An S2Polyline represents a sequence of zero or more vertices connected by','line_number':17,'multiline':False]['text':' straight edges (geodesics).  Edges of length 0 and 180 degrees are not','line_number':18,'multiline':False]['text':' allowed, i.e. adjacent vertices should not be identical or antipodal.','line_number':19,'multiline':False]['text':' Creates an empty S2Polyline that should be initialized by calling Init()','line_number':22,'multiline':False]['text':' or Decode().','line_number':23,'multiline':False]['text':' Convenience constructors that call Init() with the given vertices.','line_number':26,'multiline':False]['text':' Initialize a polyline that connects the given vertices. Empty polylines are','line_number':30,'multiline':False]['text':' allowed.  Adjacent vertices should not be identical or antipodal.  All','line_number':31,'multiline':False]['text':' vertices should be unit length.','line_number':32,'multiline':False]['text':' Convenience initialization function that accepts latitude-longitude','line_number':35,'multiline':False]['text':' coordinates rather than S2Points.','line_number':36,'multiline':False]['text':' Return true if the given vertices form a valid polyline.','line_number':41,'multiline':False]['text':' Output errors to "err" if it's not NULL.','line_number':42,'multiline':False]['text':' Return the length of the polyline.','line_number':51,'multiline':False]['text':' Return the true centroid of the polyline multiplied by the length of the','line_number':54,'multiline':False]['text':' polyline (see s2.h for details on centroids).  The result is not unit','line_number':55,'multiline':False]['text':' length, so you may want to normalize it.','line_number':56,'multiline':False]['text':'','line_number':57,'multiline':False]['text':' Prescaling by the polyline length makes it easy to compute the centroid','line_number':58,'multiline':False]['text':' of several polylines (by simply adding up their centroids).','line_number':59,'multiline':False]['text':' Return the point whose distance from vertex 0 along the polyline is the','line_number':62,'multiline':False]['text':' given fraction of the polyline's total length.  Fractions less than zero','line_number':63,'multiline':False]['text':' or greater than one are clamped.  The return value is unit length.  This','line_number':64,'multiline':False]['text':' cost of this function is currently linear in the number of vertices.','line_number':65,'multiline':False]['text':' The polyline must not be empty.','line_number':66,'multiline':False]['text':' Like Interpolate(), but also return the index of the next polyline','line_number':69,'multiline':False]['text':' vertex after the interpolated point P.  This allows the caller to easily','line_number':70,'multiline':False]['text':' construct a given suffix of the polyline by concatenating P with the','line_number':71,'multiline':False]['text':' polyline vertices starting at "next_vertex".  Note that P is guaranteed','line_number':72,'multiline':False]['text':' to be different than vertex(*next_vertex), so this will never result in','line_number':73,'multiline':False]['text':' a duplicate vertex.','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' The polyline must not be empty.  Note that if "fraction" >= 1.0, then','line_number':76,'multiline':False]['text':' "next_vertex" will be set to num_vertices() (indicating that no vertices','line_number':77,'multiline':False]['text':' from the polyline need to be appended).  The value of "next_vertex" is','line_number':78,'multiline':False]['text':' always between 1 and num_vertices().','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' This method can also be used to construct a prefix of the polyline, by','line_number':81,'multiline':False]['text':' taking the polyline vertices up to "next_vertex - 1" and appending the','line_number':82,'multiline':False]['text':' returned point P if it is different from the last vertex (since in this','line_number':83,'multiline':False]['text':' case there is no guarantee of distinctness).','line_number':84,'multiline':False]['text':' The inverse operation of GetSuffix/Interpolate.  Given a point on the','line_number':87,'multiline':False]['text':' polyline, returns the ratio of the distance to the point from the','line_number':88,'multiline':False]['text':' beginning of the polyline over the length of the polyline.  The return','line_number':89,'multiline':False]['text':' value is always betwen 0 and 1 inclusive.  See GetSuffix() for the','line_number':90,'multiline':False]['text':' meaning of "next_vertex".','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':' The polyline should not be empty.  If it has fewer than 2 vertices, the','line_number':93,'multiline':False]['text':' return value is zero.','line_number':94,'multiline':False]['text':' Given a point, returns a point on the polyline that is closest to the given','line_number':97,'multiline':False]['text':' point.  See GetSuffix() for the meaning of "next_vertex", which is chosen','line_number':98,'multiline':False]['text':' here w.r.t. the projected point as opposed to the interpolated point in','line_number':99,'multiline':False]['text':' GetSuffix().','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':' The polyline must be non-empty.','line_number':102,'multiline':False]['text':' Returns true if the point given is on the right hand side of the polyline,','line_number':105,'multiline':False]['text':' using a naive definition of "right-hand-sideness" where the point is on','line_number':106,'multiline':False]['text':' the RHS of the polyline iff the point is on the RHS of the line segment in','line_number':107,'multiline':False]['text':' the polyline which it is closest to.','line_number':108,'multiline':False]['text':'','line_number':109,'multiline':False]['text':' The polyline must have at least 2 vertices.','line_number':110,'multiline':False]['text':' Return true if this polyline intersects the given polyline. If the','line_number':113,'multiline':False]['text':' polylines share a vertex they are considered to be intersecting. When a','line_number':114,'multiline':False]['text':' polyline endpoint is the only intersection with the other polyline, the','line_number':115,'multiline':False]['text':' function may return true or false arbitrarily.','line_number':116,'multiline':False]['text':'','line_number':117,'multiline':False]['text':' The running time is quadratic in the number of vertices.','line_number':118,'multiline':False]['text':' Reverse the order of the polyline vertices.','line_number':121,'multiline':False]['text':' Return a subsequence of vertex indices such that the polyline connecting','line_number':124,'multiline':False]['text':' these vertices is never further than "tolerance" from the original','line_number':125,'multiline':False]['text':' polyline.  The first and last vertices are always preserved.','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':' Some useful properties of the algorithm:','line_number':128,'multiline':False]['text':'','line_number':129,'multiline':False]['text':'  - It runs in linear time.','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'  - The output is always a valid polyline.  In particular, adjacent','line_number':132,'multiline':False]['text':'    output vertices are never identical or antipodal.','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':'  - The method is not optimal, but it tends to produce 2-3% fewer','line_number':135,'multiline':False]['text':'    vertices than the Douglas-Peucker algorithm with the same tolerance.','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':'  - The output is *parametrically* equivalent to the original polyline to','line_number':138,'multiline':False]['text':'    within the given tolerance.  For example, if a polyline backtracks on','line_number':139,'multiline':False]['text':'    itself and then proceeds onwards, the backtracking will be preserved','line_number':140,'multiline':False]['text':'    (to within the given tolerance).  This is different than the','line_number':141,'multiline':False]['text':'    Douglas-Peucker algorithm used in maps/util/geoutil-inl.h, which only','line_number':142,'multiline':False]['text':'    guarantees geometric equivalence.','line_number':143,'multiline':False]['text':' Return true if two polylines have the same number of vertices, and','line_number':146,'multiline':False]['text':' corresponding vertex pairs are separated by no more than "max_error".','line_number':147,'multiline':False]['text':' (For testing purposes.)','line_number':148,'multiline':False]['text':' Return true if "covered" is within "max_error" of a contiguous subpath of','line_number':151,'multiline':False]['text':' this polyline over its entire length.  Specifically, this method returns','line_number':152,'multiline':False]['text':' true if this polyline has parameterization a:[0,1] -> S^2, "covered" has','line_number':153,'multiline':False]['text':' parameterization b:[0,1] -> S^2, and there is a non-decreasing function','line_number':154,'multiline':False]['text':' f:[0,1] -> [0,1] such that distance(a(f(t)), b(t)) <= max_error for all t.','line_number':155,'multiline':False]['text':'','line_number':156,'multiline':False]['text':' You can think of this as testing whether it is possible to drive a car','line_number':157,'multiline':False]['text':' along "covered" and a car along some subpath of this polyline such that no','line_number':158,'multiline':False]['text':' car ever goes backward, and the cars are always within "max_error" of each','line_number':159,'multiline':False]['text':' other.','line_number':160,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////','line_number':164,'multiline':False]['text':' S2Region interface (see s2region.h for details):','line_number':165,'multiline':False]['text':' Polylines do not have a Contains(S2Point) method, because "containment"','line_number':173,'multiline':False]['text':' is not numerically well-defined except at the polyline vertices.','line_number':174,'multiline':False]['text':' Internal constructor used only by Clone() that makes a deep copy of','line_number':181,'multiline':False]['text':' its argument.','line_number':182,'multiline':False]['text':' We store the vertices in an array rather than a vector because we don't','line_number':185,'multiline':False]['text':' need any STL methods, and computing the number of vertices using size()','line_number':186,'multiline':False]['text':' would be relatively expensive (due to division by sizeof(S2Point) == 24).','line_number':187,'multiline':False]['text':' UTIL_GEOMETRY_S2POLYLINE_H__','line_number':194,'multiline':False]