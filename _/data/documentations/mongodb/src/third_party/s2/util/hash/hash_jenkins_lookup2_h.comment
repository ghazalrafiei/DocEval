['text':' Copyright (C) 1999 and onwards Google, Inc.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' This file contains the core of Bob Jenkins lookup2 algorithm.','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' This file contains the basic hash "mix" code which is widely referenced.','line_number':6,'multiline':False]['text':' ','line_number':7,'multiline':False]['text':' This file also contains routines used to load an unaligned little-endian','line_number':8,'multiline':False]['text':' word from memory.  This relatively generic functionality probably','line_number':9,'multiline':False]['text':' shouldn't live in this file.','line_number':10,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':17,'multiline':False]['text':' mix()','line_number':18,'multiline':False]['text':'    The hash function I use is due to Bob Jenkins (see','line_number':19,'multiline':False]['text':'    http://burtleburtle.net/bob/hash/index.html).','line_number':20,'multiline':False]['text':'    Each mix takes 36 instructions, in 18 cycles if you're lucky.','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':'    On x86 architectures, this requires 45 instructions in 27 cycles,','line_number':23,'multiline':False]['text':'    if you're lucky.','line_number':24,'multiline':False]['text':' ----------------------------------------------------------------------','line_number':25,'multiline':False]['text':' 32bit version','line_number':27,'multiline':False]['text':' 64bit version','line_number':39,'multiline':False]['text':' Load an unaligned little endian word from memory.','line_number':55,'multiline':False]['text':'','line_number':56,'multiline':False]['text':' These routines are named Word32At(), Word64At() and Google1At().','line_number':57,'multiline':False]['text':' Long ago, the 32-bit version of this operation was implemented using','line_number':58,'multiline':False]['text':' signed characters.  The hash function that used this variant creates','line_number':59,'multiline':False]['text':' persistent hash values.  The hash routine needs to remain backwards','line_number':60,'multiline':False]['text':' compatible, so we renamed the word loading function 'Google1At' to','line_number':61,'multiline':False]['text':' make it clear this implements special functionality.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':' If a machine has alignment constraints or is big endian, we must','line_number':64,'multiline':False]['text':' load the word a byte at a time.  Otherwise we can load the whole word','line_number':65,'multiline':False]['text':' from memory.','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':' [Plausibly, Word32At() and Word64At() should really be called','line_number':68,'multiline':False]['text':' UNALIGNED_LITTLE_ENDIAN_LOAD32() and UNALIGNED_LITTLE_ENDIAN_LOAD64()','line_number':69,'multiline':False]['text':' but that seems overly verbose.]','line_number':70,'multiline':False]['text':' This produces the same results as the byte-by-byte version below.','line_number':81,'multiline':False]['text':' Here, we mask off the sign bits and subtract off two copies.  To','line_number':82,'multiline':False]['text':' see why this is the same as adding together the sign extensions,','line_number':83,'multiline':False]['text':' start by considering the low-order byte.  If we loaded an unsigned','line_number':84,'multiline':False]['text':' word and wanted to sign extend it, we isolate the sign bit and subtract','line_number':85,'multiline':False]['text':' that from zero which gives us a sequence of bits matching the sign bit','line_number':86,'multiline':False]['text':' at and above the sign bit.  If we remove (subtract) the sign bit and ','line_number':87,'multiline':False]['text':' add in the low order byte, we now have a sign-extended byte as desired.','line_number':88,'multiline':False]['text':' We can then operate on all four bytes in parallel because addition','line_number':89,'multiline':False]['text':' is associative and commutative.','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':' For example, consider sign extending the bytes 0x01 and 0x81.  For 0x01,','line_number':92,'multiline':False]['text':' the sign bit is zero, and 0x01 - 0 -0 = 1.  For 0x81, the sign bit is 1','line_number':93,'multiline':False]['text':' and we are computing 0x81 - 0x80 + (-0x80) == 0x01 + 0xFFFFFF80.','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' Similarily, if we start with 0x8200 and want to sign extend that,','line_number':96,'multiline':False]['text':' we end up calculating 0x8200 - 0x8000 + (-0x8000) == 0xFFFF8000 + 0x0200','line_number':97,'multiline':False]['text':'','line_number':98,'multiline':False]['text':' Suppose we have two bytes at the same time.  Doesn't the adding of all','line_number':99,'multiline':False]['text':' those F's generate something wierd?  Ignore the F's and reassociate','line_number':100,'multiline':False]['text':' the addition.  For 0x8281, processing the bytes one at a time (like','line_number':101,'multiline':False]['text':' we used to do) calculates','line_number':102,'multiline':False]['text':'      [0x8200 - 0x8000 + (-0x8000)] + [0x0081 - 0x80 + (-0x80)]','line_number':103,'multiline':False]['text':'   == 0x8281 - 0x8080 - 0x8000 - 0x80','line_number':104,'multiline':False]['text':'   == 0x8281 - 0x8080 - 0x8080','line_number':105,'multiline':False]['text':' NOTE:  This code is not normally used or tested.','line_number':115,'multiline':False]['text':' !NEED_ALIGNED_LOADS && IS_LITTLE_ENDIAN ','line_number':143,'multiline':True]['text':' Historically, WORD_HASH has always been defined as we always run on','line_number':145,'multiline':False]['text':' machines that don't NEED_ALIGNED_LOADS and which IS_LITTLE_ENDIAN.','line_number':146,'multiline':False]['text':'','line_number':147,'multiline':False]['text':' TODO(user): find occurences of WORD_HASH and adjust the code to','line_number':148,'multiline':False]['text':' use more meaningful concepts.','line_number':149,'multiline':False]['text':' UTIL_HASH_JENKINS_LOOKUP2_H__','line_number':152,'multiline':False]