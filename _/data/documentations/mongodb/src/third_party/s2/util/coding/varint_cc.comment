['text':' Copyright 2001 and onwards Google Inc.','line_number':1,'multiline':False]['text':' Operate on characters as unsigneds','line_number':19,'multiline':False]['text':' Fast path: need to accumulate data in upto three result fragments','line_number':43,'multiline':False]['text':'    res1    bits 0..27','line_number':44,'multiline':False]['text':'    res2    bits 28..55','line_number':45,'multiline':False]['text':'    res3    bits 56..63','line_number':46,'multiline':False]['text':' Value is too long to be a varint64','line_number':62,'multiline':False]['text':' Since this method is rarely called, for simplicity, we just skip backward','line_number':82,'multiline':False]['text':' and then parse forward.','line_number':83,'multiline':False]['text':' no value before 'ptr'','line_number':86,'multiline':False]['text':' Since this method is rarely called, for simplicity, we just skip backward','line_number':94,'multiline':False]['text':' and then parse forward.','line_number':95,'multiline':False]['text':' no value before 'ptr'','line_number':98,'multiline':False]['text':' Value is too long to be a varint64','line_number':133,'multiline':False]['text':' If the initial pointer is at the base or if the previous byte is not','line_number':145,'multiline':False]['text':' the last byte of a varint, we return NULL since there is nothing to skip.','line_number':146,'multiline':False]['text':' value is too long to be a varint32','line_number':155,'multiline':False]['text':' If the initial pointer is at the base or if the previous byte is not','line_number':163,'multiline':False]['text':' the last byte of a varint, we return NULL since there is nothing to skip.','line_number':164,'multiline':False]['text':' value is too long to be a varint64','line_number':173,'multiline':False]['text':' Entry for "-1", which happens when the value is 0','line_number':239,'multiline':False]['text':' Number of bytes we've determined from our tests','line_number':253,'multiline':False]