['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' This class contains various utility functions related to edges.  It','line_number':13,'multiline':False]['text':' collects together common code that is needed to implement polygonal','line_number':14,'multiline':False]['text':' geometry such as polylines, loops, and general polygons.','line_number':15,'multiline':False]['text':' This class allows a vertex chain v0, v1, v2, ... to be efficiently','line_number':18,'multiline':False]['text':' tested for intersection with a given fixed edge AB.','line_number':19,'multiline':False]['text':' AB is the given fixed edge, and C is the first vertex of the vertex','line_number':22,'multiline':False]['text':' chain.  All parameters must point to fixed storage that persists for','line_number':23,'multiline':False]['text':' the lifetime of the EdgeCrosser object.','line_number':24,'multiline':False]['text':' Call this function when your chain 'jumps' to a new place.','line_number':27,'multiline':False]['text':' This method is equivalent to calling the S2EdgeUtil::RobustCrossing()','line_number':30,'multiline':False]['text':' function (defined below) on the edges AB and CD.  It returns +1 if','line_number':31,'multiline':False]['text':' there is a crossing, -1 if there is no crossing, and 0 if two points','line_number':32,'multiline':False]['text':' from different edges are the same.  Returns 0 or -1 if either edge is','line_number':33,'multiline':False]['text':' degenerate.  As a side effect, it saves vertex D to be used as the next','line_number':34,'multiline':False]['text':' vertex C.','line_number':35,'multiline':False]['text':' This method is equivalent to the S2EdgeUtil::EdgeOrVertexCrossing()','line_number':38,'multiline':False]['text':' method defined below.  It is similar to RobustCrossing, but handles','line_number':39,'multiline':False]['text':' cases where two vertices are identical in a way that makes it easy to','line_number':40,'multiline':False]['text':' implement point-in-polygon containment tests.','line_number':41,'multiline':False]['text':' This function handles the "slow path" of RobustCrossing(), which does','line_number':45,'multiline':False]['text':' not need to be inlined.','line_number':46,'multiline':False]['text':' The fields below are all constant.','line_number':49,'multiline':False]['text':' The fields below are updated for each vertex in the chain.','line_number':54,'multiline':False]['text':' Previous vertex in the vertex chain.','line_number':55,'multiline':False]['text':' The orientation of the triangle ACB.','line_number':56,'multiline':False]['text':' This class computes a bounding rectangle that contains all edges','line_number':59,'multiline':False]['text':' defined by a vertex chain v0, v1, v2, ...  All vertices must be unit','line_number':60,'multiline':False]['text':' length.  Note that the bounding rectangle of an edge can be larger than','line_number':61,'multiline':False]['text':' the bounding rectangle of its endpoints, e.g. consider an edge that','line_number':62,'multiline':False]['text':' passes through the north pole.','line_number':63,'multiline':False]['text':' This method is called to add each vertex to the chain.  'b'','line_number':68,'multiline':False]['text':' must point to fixed storage that persists through the next call','line_number':69,'multiline':False]['text':' to AddPoint.  This means that if you don't store all of your','line_number':70,'multiline':False]['text':' points for the lifetime of the bounder, you must at least store','line_number':71,'multiline':False]['text':' the last two points and alternate which one you use for the','line_number':72,'multiline':False]['text':' next point.','line_number':73,'multiline':False]['text':' Return the bounding rectangle of the edge chain that connects the','line_number':76,'multiline':False]['text':' vertices defined so far.','line_number':77,'multiline':False]['text':' The previous vertex in the chain.','line_number':81,'multiline':False]['text':' The corresponding latitude-longitude.','line_number':82,'multiline':False]['text':' The current bounding rectangle.','line_number':83,'multiline':False]['text':' The purpose of this class is to find edges that intersect a given','line_number':86,'multiline':False]['text':' longitude interval.  It can be used as an efficient rejection test when','line_number':87,'multiline':False]['text':' attempting to find edges that intersect a given region.  It accepts a','line_number':88,'multiline':False]['text':' vertex chain v0, v1, v2, ...  and returns a boolean value indicating','line_number':89,'multiline':False]['text':' whether each edge intersects the specified longitude interval.','line_number':90,'multiline':False]['text':' 'interval' is the longitude interval to be tested against, and','line_number':93,'multiline':False]['text':' 'v0' is the first vertex of edge chain.','line_number':94,'multiline':False]['text':' Returns true if the edge (v0, v1) intersects the given longitude','line_number':97,'multiline':False]['text':' interval, and then saves 'v1' to be used as the next 'v0'.','line_number':98,'multiline':False]['text':' The interval to be tested against.','line_number':102,'multiline':False]['text':' The longitude of the next v0.','line_number':103,'multiline':False]['text':' Return true if edge AB crosses CD at a point that is interior','line_number':106,'multiline':False]['text':' to both edges.  Properties:','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':'  (1) SimpleCrossing(b,a,c,d) == SimpleCrossing(a,b,c,d)','line_number':109,'multiline':False]['text':'  (2) SimpleCrossing(c,d,a,b) == SimpleCrossing(a,b,c,d)','line_number':110,'multiline':False]['text':' Like SimpleCrossing, except that points that lie exactly on a line are','line_number':114,'multiline':False]['text':' arbitrarily classified as being on one side or the other (according to','line_number':115,'multiline':False]['text':' the rules of S2::RobustCCW).  It returns +1 if there is a crossing, -1','line_number':116,'multiline':False]['text':' if there is no crossing, and 0 if any two vertices from different edges','line_number':117,'multiline':False]['text':' are the same.  Returns 0 or -1 if either edge is degenerate.','line_number':118,'multiline':False]['text':' Properties of RobustCrossing:','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':'  (1) RobustCrossing(b,a,c,d) == RobustCrossing(a,b,c,d)','line_number':121,'multiline':False]['text':'  (2) RobustCrossing(c,d,a,b) == RobustCrossing(a,b,c,d)','line_number':122,'multiline':False]['text':'  (3) RobustCrossing(a,b,c,d) == 0 if a==c, a==d, b==c, b==d','line_number':123,'multiline':False]['text':'  (3) RobustCrossing(a,b,c,d) <= 0 if a==b or c==d','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':' Note that if you want to check an edge against a *chain* of other','line_number':126,'multiline':False]['text':' edges, it is much more efficient to use an EdgeCrosser (above).','line_number':127,'multiline':False]['text':' Given two edges AB and CD where at least two vertices are identical','line_number':131,'multiline':False]['text':' (i.e. RobustCrossing(a,b,c,d) == 0), this function defines whether the','line_number':132,'multiline':False]['text':' two edges "cross" in a such a way that point-in-polygon containment tests','line_number':133,'multiline':False]['text':' can be implemented by counting the number of edge crossings.  The basic','line_number':134,'multiline':False]['text':' rule is that a "crossing" occurs if AB is encountered after CD during a','line_number':135,'multiline':False]['text':' CCW sweep around the shared vertex starting from a fixed reference point.','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':' Note that according to this rule, if AB crosses CD then in general CD','line_number':138,'multiline':False]['text':' does not cross AB.  However, this leads to the correct result when','line_number':139,'multiline':False]['text':' counting polygon edge crossings.  For example, suppose that A,B,C are','line_number':140,'multiline':False]['text':' three consecutive vertices of a CCW polygon.  If we now consider the edge','line_number':141,'multiline':False]['text':' crossings of a segment BP as P sweeps around B, the crossing number','line_number':142,'multiline':False]['text':' changes parity exactly when BP crosses BA or BC.','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' Useful properties of VertexCrossing (VC):','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':'  (1) VC(a,a,c,d) == VC(a,b,c,c) == false','line_number':147,'multiline':False]['text':'  (2) VC(a,b,a,b) == VC(a,b,b,a) == true','line_number':148,'multiline':False]['text':'  (3) VC(a,b,c,d) == VC(a,b,d,c) == VC(b,a,c,d) == VC(b,a,d,c)','line_number':149,'multiline':False]['text':'  (3) If exactly one of a,b equals one of c,d, then exactly one of','line_number':150,'multiline':False]['text':'      VC(a,b,c,d) and VC(c,d,a,b) is true','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':' It is an error to call this method with 4 distinct vertices.','line_number':153,'multiline':False]['text':' A convenience function that calls RobustCrossing() to handle cases','line_number':157,'multiline':False]['text':' where all four vertices are distinct, and VertexCrossing() to handle','line_number':158,'multiline':False]['text':' cases where two or more vertices are the same.  This defines a crossing','line_number':159,'multiline':False]['text':' function such that point-in-polygon containment tests can be implemented','line_number':160,'multiline':False]['text':' by simply counting edge crossings.','line_number':161,'multiline':False]['text':' Given two edges AB and CD such that RobustCrossing() is true, return','line_number':165,'multiline':False]['text':' their intersection point.  Useful properties of GetIntersection (GI):','line_number':166,'multiline':False]['text':'','line_number':167,'multiline':False]['text':'  (1) GI(b,a,c,d) == GI(a,b,d,c) == GI(a,b,c,d)','line_number':168,'multiline':False]['text':'  (2) GI(c,d,a,b) == GI(a,b,c,d)','line_number':169,'multiline':False]['text':'','line_number':170,'multiline':False]['text':' The returned intersection point X is guaranteed to be close to the edges','line_number':171,'multiline':False]['text':' AB and CD, but if the edges intersect at a very small angle then X may','line_number':172,'multiline':False]['text':' not be close to the true mathematical intersection point P.  See the','line_number':173,'multiline':False]['text':' description of "kIntersectionTolerance" below for details.','line_number':174,'multiline':False]['text':' This distance is an upper bound on the distance from the intersection','line_number':178,'multiline':False]['text':' point returned by GetIntersection() to either of the two edges that were','line_number':179,'multiline':False]['text':' intersected.  In particular, if "x" is the intersection point, then','line_number':180,'multiline':False]['text':' GetDistance(x, a, b) and GetDistance(x, c, d) will both be smaller than','line_number':181,'multiline':False]['text':' this value.  The intersection tolerance is also large enough such if it','line_number':182,'multiline':False]['text':' is passed as the "vertex_merge_radius" of an S2PolygonBuilder, then the','line_number':183,'multiline':False]['text':' intersection point will be spliced into the edges AB and/or CD if they','line_number':184,'multiline':False]['text':' are also supplied to the S2PolygonBuilder.','line_number':185,'multiline':False]['text':' Given a point X and an edge AB, return the distance ratio AX / (AX + BX).','line_number':188,'multiline':False]['text':' If X happens to be on the line segment AB, this is the fraction "t" such','line_number':189,'multiline':False]['text':' that X == Interpolate(A, B, t).  Requires that A and B are distinct.','line_number':190,'multiline':False]['text':' Return the point X along the line segment AB whose distance from A is the','line_number':194,'multiline':False]['text':' given fraction "t" of the distance AB.  Does NOT require that "t" be','line_number':195,'multiline':False]['text':' between 0 and 1.  Note that all distances are measured on the surface of','line_number':196,'multiline':False]['text':' the sphere, so this is more complicated than just computing (1-t)*a + t*b','line_number':197,'multiline':False]['text':' and normalizing the result.','line_number':198,'multiline':False]['text':' Like Interpolate(), except that the parameter "ax" represents the desired','line_number':201,'multiline':False]['text':' distance from A to the result X rather than a fraction between 0 and 1.','line_number':202,'multiline':False]['text':' A slightly more efficient version of InterpolateAtDistance() that can be','line_number':206,'multiline':False]['text':' used when the distance AB is already known.','line_number':207,'multiline':False]['text':' Return the minimum distance from X to any point on the edge AB.  All','line_number':212,'multiline':False]['text':' arguments should be unit length.  The result is very accurate for small','line_number':213,'multiline':False]['text':' distances but may have some numerical error if the distance is large','line_number':214,'multiline':False]['text':' (approximately Pi/2 or greater).  The case A == B is handled correctly.','line_number':215,'multiline':False]['text':' A slightly more efficient version of GetDistance() where the cross','line_number':219,'multiline':False]['text':' product of the two endpoints has been precomputed.  The cross product','line_number':220,'multiline':False]['text':' does not need to be normalized, but should be computed using','line_number':221,'multiline':False]['text':' S2::RobustCrossProd() for the most accurate results.','line_number':222,'multiline':False]['text':' Return the point along the edge AB that is closest to the point X.','line_number':227,'multiline':False]['text':' The fractional distance of this point along the edge AB can be obtained','line_number':228,'multiline':False]['text':' using GetDistanceFraction() above.','line_number':229,'multiline':False]['text':' A slightly more efficient version of GetClosestPoint() where the cross','line_number':233,'multiline':False]['text':' product of the two endpoints has been precomputed.  The cross product','line_number':234,'multiline':False]['text':' does not need to be normalized, but should be computed using','line_number':235,'multiline':False]['text':' S2::RobustCrossProd() for the most accurate results.','line_number':236,'multiline':False]['text':' Return true if every point on edge B=b0b1 is no further than "tolerance"','line_number':241,'multiline':False]['text':' from some point on edge A=a0a1.','line_number':242,'multiline':False]['text':' Requires that tolerance is less than 90 degrees.','line_number':243,'multiline':False]['text':' For an edge chain (x0, x1, x2), a wedge is the region to the left','line_number':248,'multiline':False]['text':' of the edges. More precisely, it is the union of all the rays','line_number':249,'multiline':False]['text':' from x1x0 to x1x2, clockwise.','line_number':250,'multiline':False]['text':' The following are Wedge comparison functions for two wedges A =','line_number':251,'multiline':False]['text':' (a0, ab1, a2) and B = (b0, a12, b2). These are used in S2Loops.','line_number':252,'multiline':False]['text':' Returns true if wedge A fully contains or is equal to wedge B.','line_number':254,'multiline':False]['text':' Returns true if the intersection of the two wedges is not empty.','line_number':259,'multiline':False]['text':' Detailed relation from wedges A to wedge B.','line_number':264,'multiline':False]['text':' A is a strict superset of B.','line_number':267,'multiline':False]['text':' A is a strict subset of B.','line_number':268,'multiline':False]['text':' All of A intsect B, A-B and B-A are non-empty.','line_number':269,'multiline':False]['text':' A is disjoint from B','line_number':270,'multiline':False]['text':' Return the relation from wedge A to B.','line_number':273,'multiline':False]['text':' Contains only static methods.','line_number':278,'multiline':False]['text':' For there to be an edge crossing, the triangles ACB, CBD, BDA, DAC must','line_number':293,'multiline':False]['text':' all be oriented the same way (CW or CCW).  We keep the orientation of ACB','line_number':294,'multiline':False]['text':' as part of our state.  When each new point D arrives, we compute the','line_number':295,'multiline':False]['text':' orientation of BDA and check whether it matches ACB.  This checks whether','line_number':296,'multiline':False]['text':' the points C and D are on opposite sides of the great circle through AB.','line_number':297,'multiline':False]['text':' Recall that RobustCCW is invariant with respect to rotating its','line_number':299,'multiline':False]['text':' arguments, i.e. ABC has the same orientation as BDA.','line_number':300,'multiline':False]['text':' Most common case -- triangles have opposite orientations.','line_number':304,'multiline':False]['text':' At least one value is zero -- two vertices are identical.','line_number':306,'multiline':False]['text':' Slow path.','line_number':307,'multiline':False]['text':' Now save the current vertex D as the next vertex C, and also save the','line_number':312,'multiline':False]['text':' orientation of the new triangle ACB (which is opposite to the current','line_number':313,'multiline':False]['text':' triangle BDA).','line_number':314,'multiline':False]['text':' We need to copy c_ since it is clobbered by RobustCrossing().','line_number':321,'multiline':False]['text':' UTIL_GEOMETRY_S2EDGEUTIL_H__','line_number':336,'multiline':False]