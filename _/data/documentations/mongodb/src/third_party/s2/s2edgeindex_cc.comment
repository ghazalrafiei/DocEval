['text':' Copyright 2009 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':'         julienbasch@google.com (Julien Basch)','line_number':2,'multiline':False]['text':' Implementation of class S2EdgeIndex, a fast lookup structure for edges in S2.','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' An object of this class contains a set S of edges called the test edges.','line_number':6,'multiline':False]['text':' For a query edge q, you want to compute a superset of all test edges that','line_number':7,'multiline':False]['text':' intersect q.','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' The idea is roughly that of','line_number':10,'multiline':False]['text':' Each edge is covered by one or several S2 cells, stored in a multimap','line_number':11,'multiline':False]['text':'   cell -> edge*.','line_number':12,'multiline':False]['text':' To perform a query, you cover the query edge with a set of cells.  For','line_number':13,'multiline':False]['text':' each such cell c, you find all test edges that are in c,in an ancestor of c','line_number':14,'multiline':False]['text':' or in a child of c.','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' This is simple, but there are two complications:','line_number':17,'multiline':False]['text':'','line_number':18,'multiline':False]['text':' 1. For containment queries, the query edge is very long (from S2::Origin()','line_number':19,'multiline':False]['text':'    to the query point).  A standard cell covering of q is either useless or','line_number':20,'multiline':False]['text':'    too large.  The covering needs to be adapted to S: if a cell contains too','line_number':21,'multiline':False]['text':'    many edges from S, you subdivide it and keep only the subcells that','line_number':22,'multiline':False]['text':'    intersect q.  See comments for FindCandidateCrossings().','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' 2. To decide if edge q could possibly cross edge e, we end up comparing','line_number':25,'multiline':False]['text':'    both with edges that bound s2 cells.  Numerical inaccuracies','line_number':26,'multiline':False]['text':'    can lead to inconcistencies, e.g.: there may be an edge b at the','line_number':27,'multiline':False]['text':'    boundary of two cells such that q and e are on opposite sides of b,','line_number':28,'multiline':False]['text':'    yet they cross each other.  This special case happens a lot if your','line_number':29,'multiline':False]['text':'    test and query edges are cell boundaries themselves, and this in turn','line_number':30,'multiline':False]['text':'    is a common case when regions are approximated by cell unions.','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' We expand here on the solution to the second problem.  Two components:','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' 1. Each test edge is thickened to a rectangle before it is S2-covered.','line_number':35,'multiline':False]['text':'    See the comment for GetThickenedEdgeCovering().','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' 2. When recursing through the children of a cell c for a query edge q,','line_number':38,'multiline':False]['text':'    we test q against the boundaries of c's children in a 'lenient'','line_number':39,'multiline':False]['text':'    way.  That is, instead of testing e.g. area(abc)*area(abd) < 0,','line_number':40,'multiline':False]['text':'    we check if it is 'approximately negative'.','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' To see how the second point is necessary, imagine that your query','line_number':43,'multiline':False]['text':' edge q is the North boundary of cell x.  We recurse into the four','line_number':44,'multiline':False]['text':' children a,b,c,d of x.  To do so, we check if q crosses or touches any','line_number':45,'multiline':False]['text':' of a,b,c or d boundaries.  As all the situations are degenerate, it is','line_number':46,'multiline':False]['text':' possible that all crossing tests return false, thus making q suddenly','line_number':47,'multiline':False]['text':' 'disappear'.  Using the lenient crossing test, we are guaranteed that q','line_number':48,'multiline':False]['text':' will intersect one of the four edges of the cross that bounds a,b,c,d.','line_number':49,'multiline':False]['text':' The same holds true if q passes through the cell center of x.','line_number':50,'multiline':False]['text':'"When we test a query edge against a cell, we don't "','line_number':78,'multiline':False]['text':'"recurse if there are only a few test edges in it.  "','line_number':79,'multiline':False]['text':'"For testing, it is useful to always recurse to the end.  "','line_number':80,'multiline':False]['text':'"You don't want to use this flag anywhere but in tests.";','line_number':81,'multiline':False]['text':' If we have m data edges and n query edges, then the brute force cost is','line_number':118,'multiline':False]['text':'   m * n * test_cost','line_number':119,'multiline':False]['text':' where test_cost is taken to be the cost of EdgeCrosser::RobustCrossing,','line_number':120,'multiline':False]['text':' measured to be about 30ns at the time of this writing.','line_number':121,'multiline':False]['text':'','line_number':122,'multiline':False]['text':' If we compute the index, the cost becomes:','line_number':123,'multiline':False]['text':'   m * cost_insert + n * cost_find(m)','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':' - cost_insert can be expected to be reasonably stable, and was measured','line_number':126,'multiline':False]['text':' at 1200ns with the BM_QuadEdgeInsertionCost benchmark.','line_number':127,'multiline':False]['text':'','line_number':128,'multiline':False]['text':' - cost_find depends on the length of the edge .  For m=1000 edges,','line_number':129,'multiline':False]['text':' we got timings ranging from 1ms (edge the length of the polygon) to','line_number':130,'multiline':False]['text':' 40ms.  The latter is for very long query edges, and needs to be','line_number':131,'multiline':False]['text':' optimized.  We will assume for the rest of the discussion that','line_number':132,'multiline':False]['text':' cost_find is roughly 3ms.','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':' When doing one additional query, the differential cost is','line_number':135,'multiline':False]['text':'   m * test_cost - cost_find(m)','line_number':136,'multiline':False]['text':' With the numbers above, it is better to use the quad tree (if we have it)','line_number':137,'multiline':False]['text':' if m >= 100.','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' If m = 100, 30 queries will give m*n*test_cost = m*cost_insert = 100ms,','line_number':140,'multiline':False]['text':' while the marginal cost to find is 3ms.  Thus, this is a reasonable','line_number':141,'multiline':False]['text':' thing to do.','line_number':142,'multiline':False]['text':' Find all parent cells of covering cells.','line_number':155,'multiline':False]['text':' cell is already in => parents are too.','line_number':163,'multiline':False]['text':' Put parent cell edge references into result.','line_number':168,'multiline':False]['text':' Returns true if ab possibly crosses cd, by clipping tiny angles to','line_number':181,'multiline':False]['text':' zero.','line_number':182,'multiline':False]['text':' See comment for RobustCCW() in s2.h','line_number':188,'multiline':False]['text':'S2Point start_vertex = cell.GetVertex(0);','line_number':206,'multiline':False]['text':' Put all edge references of (covering cells + descendant cells) into result.','line_number':231,'multiline':False]['text':' This relies on the natural ordering of S2CellIds.','line_number':232,'multiline':False]['text':' TODO(user): Maybe distinguish between edges in current cell, that','line_number':241,'multiline':False]['text':' are going to be added anyhow, and edges in subcells, and rewind only','line_number':242,'multiline':False]['text':' those.','line_number':243,'multiline':False]['text':' If there are too many to insert, uninsert and recurse.','line_number':254,'multiline':False]['text':' Add cells at this level','line_number':259,'multiline':False]['text':' Recurse on the children -- hopefully some will be empty.','line_number':266,'multiline':False]['text':' TODO(user): Do the check for the four cells at once,','line_number':272,'multiline':False]['text':' as it is enough to check the four edges between the cells.  At','line_number':273,'multiline':False]['text':' this time, we are checking 16 edges, 4 times too many.','line_number':274,'multiline':False]['text':'','line_number':275,'multiline':False]['text':' Note that given the guarantee of AppendCovering, it is enough','line_number':276,'multiline':False]['text':' to check that the edge intersect with the cell boundary as it','line_number':277,'multiline':False]['text':' cannot be fully contained in a cell.','line_number':278,'multiline':False]['text':' Appends to "candidate_crossings" all edge references which may cross the','line_number':289,'multiline':False]['text':' given edge.  This is done by covering the edge and then finding all','line_number':290,'multiline':False]['text':' references of edges whose coverings overlap this covering. Parent cells','line_number':291,'multiline':False]['text':' are checked level by level.  Child cells are checked all at once by taking','line_number':292,'multiline':False]['text':' advantage of the natural ordering of S2CellIds.','line_number':293,'multiline':False]['text':' TODO(user): An important optimization for long query','line_number':303,'multiline':False]['text':' edges (Contains queries): keep a bounding cap and clip the query','line_number':304,'multiline':False]['text':' edge to the cap before starting the descent.','line_number':305,'multiline':False]['text':' Remove duplicates: This is necessary because edge references are','line_number':308,'multiline':False]['text':' inserted into the map once for each covering cell. (Testing shows','line_number':309,'multiline':False]['text':' this to be at least as fast as using a set.)','line_number':310,'multiline':False]['text':' Returns the smallest cell containing all four points, or Sentinel','line_number':318,'multiline':False]['text':' if they are not all on the same face.','line_number':319,'multiline':False]['text':' The points don't need to be normalized.','line_number':320,'multiline':False]['text':' Returns the smallest cell containing both points, or Sentinel','line_number':341,'multiline':False]['text':' if they are not all on the same face.','line_number':342,'multiline':False]['text':' The points don't need to be normalized.','line_number':343,'multiline':False]['text':' Thicken the edge in all directions by roughly 1% of the edge length when','line_number':363,'multiline':False]['text':' thicken_edge is true.','line_number':364,'multiline':False]['text':' Selects the ideal s2 level at which to cover the edge, this will be the','line_number':367,'multiline':False]['text':' level whose S2 cells have a width roughly commensurate to the length of','line_number':368,'multiline':False]['text':' the edge.  We multiply the edge length by 2*kThickening to guarantee the','line_number':369,'multiline':False]['text':' thickening is honored (it's not a big deal if we honor it when we don't','line_number':370,'multiline':False]['text':' request it) when doing the covering-by-cap trick.','line_number':371,'multiline':False]['text':' If the edge is tiny, instabilities are more likely, so we','line_number':381,'multiline':False]['text':' want to limit the number of operations.','line_number':382,'multiline':False]['text':' We pretend we are in a cell much larger so as to trigger the','line_number':383,'multiline':False]['text':' 'needs covering' case, so we won't try to thicken the edge.','line_number':384,'multiline':False]['text':' If p and q were antipodal, the edge wouldn't be lengthened,','line_number':392,'multiline':False]['text':' and it could even flip!  This is not a problem because','line_number':393,'multiline':False]['text':' ideal_level != 0 here.  The farther p and q can be is roughly','line_number':394,'multiline':False]['text':' a quarter Earth away from each other, so we remain','line_number':395,'multiline':False]['text':' Theta(kThickening).','line_number':396,'multiline':False]['text':' Best case: edge is fully contained in a cell that's not too big.','line_number':402,'multiline':False]['text':' Edge is very long, maybe even longer than a face width, so the','line_number':410,'multiline':False]['text':' trick below doesn't work.  For now, we will add the whole S2 sphere.','line_number':411,'multiline':False]['text':' TODO(user): Do something a tad smarter (and beware of the','line_number':412,'multiline':False]['text':' antipodal case).','line_number':413,'multiline':False]['text':' TODO(user): Check trick below works even when vertex is at interface','line_number':420,'multiline':False]['text':' between three faces.','line_number':421,'multiline':False]['text':' Use trick as in S2PolygonBuilder::PointIndex::FindNearbyPoint:','line_number':423,'multiline':False]['text':' Cover the edge by a cap centered at the edge midpoint, then cover','line_number':424,'multiline':False]['text':' the cap by four big-enough cells around the cell vertex closest to the','line_number':425,'multiline':False]['text':' cap center.','line_number':426,'multiline':False]