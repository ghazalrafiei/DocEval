['text':' Copyright 2007 Google Inc.','line_number':1,'multiline':False]['text':' All Rights Reserved.','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':'  This is an implementation designed to match the anticipated future TR2','line_number':8,'multiline':False]['text':'  implementation of the scoped_ptr class, and its closely-related brethren,','line_number':9,'multiline':False]['text':'  scoped_array, scoped_ptr_malloc, and make_scoped_ptr.','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':'  file.','line_number':12,'multiline':False]['text':' NOTE(user):','line_number':19,'multiline':False]['text':' The C++ standard says that <stdlib.h> declares both ::foo and std::foo','line_number':20,'multiline':False]['text':' But this isn't done in QNX version 6.3.2 200709062316.','line_number':21,'multiline':False]['text':' A scoped_ptr<T> is like a T*, except that the destructor of scoped_ptr<T>','line_number':34,'multiline':False]['text':' automatically deletes the pointer it holds (if any).','line_number':35,'multiline':False]['text':' That is, scoped_ptr<T> owns the T object that it points to.','line_number':36,'multiline':False]['text':' Like a T*, a scoped_ptr<T> may hold either NULL or a pointer to a T object.','line_number':37,'multiline':False]['text':' Also like T*, scoped_ptr<T> is thread-compatible, and once you','line_number':38,'multiline':False]['text':' dereference it, you get the threadsafety guarantees of T.','line_number':39,'multiline':False]['text':'','line_number':40,'multiline':False]['text':' The size of a scoped_ptr is small:','line_number':41,'multiline':False]['text':' sizeof(scoped_ptr<C>) == sizeof(C*)','line_number':42,'multiline':False]['text':' The element type','line_number':47,'multiline':False]['text':' Constructor.  Defaults to intializing with NULL.','line_number':50,'multiline':False]['text':' There is no way to create an uninitialized scoped_ptr.','line_number':51,'multiline':False]['text':' The input parameter must be allocated with new.','line_number':52,'multiline':False]['text':' Destructor.  If there is a C object, delete it.','line_number':55,'multiline':False]['text':' We don't need to test ptr_ == NULL because C++ does that for us.','line_number':56,'multiline':False]['text':' Reset.  Deletes the current owned object, if any.','line_number':62,'multiline':False]['text':' Then takes ownership of a new object, if given.','line_number':63,'multiline':False]['text':' this->reset(this->get()) works.','line_number':64,'multiline':False]['text':' Accessors to get the owned object.','line_number':73,'multiline':False]['text':' operator* and operator-> will assert() if there is no current object.','line_number':74,'multiline':False]['text':' Comparison operators.','line_number':85,'multiline':False]['text':' These return whether a scoped_ptr and a raw pointer refer to','line_number':86,'multiline':False]['text':' the same object, not just to two different but equal objects.','line_number':87,'multiline':False]['text':' Swap two scoped pointers.','line_number':91,'multiline':False]['text':' Release a pointer.','line_number':98,'multiline':False]['text':' The return value is the current pointer held by this object.','line_number':99,'multiline':False]['text':' If this object holds a NULL pointer, the return value is NULL.','line_number':100,'multiline':False]['text':' After this operation, this object will hold a NULL pointer,','line_number':101,'multiline':False]['text':' and will not own the object any more.','line_number':102,'multiline':False]['text':' google3 friend class that can access copy ctor (although if it actually','line_number':112,'multiline':False]['text':' calls a copy ctor, there will be a problem) see below','line_number':113,'multiline':False]['text':' Forbid comparison of scoped_ptr types.  If C2 != C, it totally doesn't','line_number':116,'multiline':False]['text':' make sense, and if C2 == C, it still doesn't make sense because you should','line_number':117,'multiline':False]['text':' never have the same object owned by two different scoped_ptrs.','line_number':118,'multiline':False]['text':' Disallow evil constructors','line_number':122,'multiline':False]['text':' Free functions','line_number':127,'multiline':False]['text':' This does nothing but to return a scoped_ptr of the type that the passed','line_number':155,'multiline':False]['text':' pointer is of.  (This eliminates the need to specify the name of T when','line_number':156,'multiline':False]['text':' making a scoped_ptr that is used anonymously/temporarily.)  From an','line_number':157,'multiline':False]['text':' access control point of view, we construct an unnamed scoped_ptr here','line_number':158,'multiline':False]['text':' which we return and thus copy-construct.  Hence, we need to have access','line_number':159,'multiline':False]['text':' to scoped_ptr::scoped_ptr(scoped_ptr const &).  However, it is guaranteed','line_number':160,'multiline':False]['text':' that we never actually call the copy constructor, which is a good thing','line_number':161,'multiline':False]['text':' as we would call the temporary's object destructor (and thus delete p)','line_number':162,'multiline':False]['text':' if we actually did copy some object, here.','line_number':163,'multiline':False]['text':' scoped_array<C> is like scoped_ptr<C>, except that the caller must allocate','line_number':167,'multiline':False]['text':' with new [] and the destructor deletes objects with delete [].','line_number':168,'multiline':False]['text':'','line_number':169,'multiline':False]['text':' As with scoped_ptr<C>, a scoped_array<C> either points to an object','line_number':170,'multiline':False]['text':' or is NULL.  A scoped_array<C> owns the object that it points to.','line_number':171,'multiline':False]['text':' scoped_array<T> is thread-compatible, and once you index into it,','line_number':172,'multiline':False]['text':' the returned objects have only the threadsafety guarantees of T.','line_number':173,'multiline':False]['text':'','line_number':174,'multiline':False]['text':' Size: sizeof(scoped_array<C>) == sizeof(C*)','line_number':175,'multiline':False]['text':' The element type','line_number':180,'multiline':False]['text':' Constructor.  Defaults to intializing with NULL.','line_number':183,'multiline':False]['text':' There is no way to create an uninitialized scoped_array.','line_number':184,'multiline':False]['text':' The input parameter must be allocated with new [].','line_number':185,'multiline':False]['text':' Destructor.  If there is a C object, delete it.','line_number':188,'multiline':False]['text':' We don't need to test ptr_ == NULL because C++ does that for us.','line_number':189,'multiline':False]['text':' Reset.  Deletes the current owned object, if any.','line_number':195,'multiline':False]['text':' Then takes ownership of a new object, if given.','line_number':196,'multiline':False]['text':' this->reset(this->get()) works.','line_number':197,'multiline':False]['text':' Get one element of the current object.','line_number':206,'multiline':False]['text':' Will assert() if there is no current object, or index i is negative.','line_number':207,'multiline':False]['text':' Get a pointer to the zeroth element of the current object.','line_number':214,'multiline':False]['text':' If there is no current object, return NULL.','line_number':215,'multiline':False]['text':' Comparison operators.','line_number':220,'multiline':False]['text':' These return whether a scoped_array and a raw pointer refer to','line_number':221,'multiline':False]['text':' the same array, not just to two different but equal arrays.','line_number':222,'multiline':False]['text':' Swap two scoped arrays.','line_number':226,'multiline':False]['text':' Release an array.','line_number':233,'multiline':False]['text':' The return value is the current pointer held by this object.','line_number':234,'multiline':False]['text':' If this object holds a NULL pointer, the return value is NULL.','line_number':235,'multiline':False]['text':' After this operation, this object will hold a NULL pointer,','line_number':236,'multiline':False]['text':' and will not own the object any more.','line_number':237,'multiline':False]['text':' Forbid comparison of different scoped_array types.','line_number':247,'multiline':False]['text':' Disallow evil constructors','line_number':251,'multiline':False]['text':' Free functions','line_number':256,'multiline':False]['text':' This class wraps the c library function free() in a class that can be','line_number':282,'multiline':False]['text':' passed as a template argument to scoped_ptr_malloc below.','line_number':283,'multiline':False]['text':' scoped_ptr_malloc<> is similar to scoped_ptr<>, but it accepts a','line_number':291,'multiline':False]['text':' second template argument, the functor used to free the object.','line_number':292,'multiline':False]['text':' The element type','line_number':298,'multiline':False]['text':' Construction with no arguments sets ptr_ to NULL.','line_number':301,'multiline':False]['text':' There is no way to create an uninitialized scoped_ptr.','line_number':302,'multiline':False]['text':' The input parameter must be allocated with an allocator that matches the','line_number':303,'multiline':False]['text':' Free functor.  For the default Free functor, this is malloc, calloc, or','line_number':304,'multiline':False]['text':' realloc.','line_number':305,'multiline':False]['text':' Construct with a C*, and provides an error with a D*.','line_number':308,'multiline':False]['text':' Construct with a void*, such as you get from malloc.','line_number':312,'multiline':False]['text':' Destructor.  If there is a C object, call the Free functor.','line_number':315,'multiline':False]['text':' Reset.  Calls the Free functor on the current owned object, if any.','line_number':320,'multiline':False]['text':' Then takes ownership of a new object, if given.','line_number':321,'multiline':False]['text':' this->reset(this->get()) works.','line_number':322,'multiline':False]['text':' Reallocates the existing pointer, and returns 'true' if','line_number':330,'multiline':False]['text':' the reallcation is succesfull.  If the reallocation failed, then','line_number':331,'multiline':False]['text':' the pointer remains in its previous state.','line_number':332,'multiline':False]['text':'','line_number':333,'multiline':False]['text':' Note: this calls realloc() directly, even if an alternate 'free'','line_number':334,'multiline':False]['text':' functor is provided in the template instantiation.','line_number':335,'multiline':False]['text':' Get the current object.','line_number':345,'multiline':False]['text':' operator* and operator-> will cause an assert() failure if there is','line_number':346,'multiline':False]['text':' no current object.','line_number':347,'multiline':False]['text':' Comparison operators.','line_number':362,'multiline':False]['text':' These return whether a scoped_ptr_malloc and a plain pointer refer','line_number':363,'multiline':False]['text':' to the same object, not just to two different but equal objects.','line_number':364,'multiline':False]['text':' For compatibility with the boost-derived implementation, these','line_number':365,'multiline':False]['text':' take non-const arguments.','line_number':366,'multiline':False]['text':' Swap two scoped pointers.','line_number':375,'multiline':False]['text':' Release a pointer.','line_number':382,'multiline':False]['text':' The return value is the current pointer held by this object.','line_number':383,'multiline':False]['text':' If this object holds a NULL pointer, the return value is NULL.','line_number':384,'multiline':False]['text':' After this operation, this object will hold a NULL pointer,','line_number':385,'multiline':False]['text':' and will not own the object any more.','line_number':386,'multiline':False]['text':' no reason to use these: each scoped_ptr_malloc should have its own object','line_number':396,'multiline':False]['text':' Disallow evil constructors','line_number':404,'multiline':False]['text':' BASE_SCOPED_PTR_H__','line_number':427,'multiline':False]