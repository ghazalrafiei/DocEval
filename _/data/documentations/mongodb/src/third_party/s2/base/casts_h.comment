['text':' Copyright 2009 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Various Google-specific casting templates.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' This code is compiled directly on many platforms, including client','line_number':5,'multiline':False]['text':' platforms like Windows, Mac, and embedded systems.  Before making','line_number':6,'multiline':False]['text':' any changes here, make sure that you're not breaking any platforms.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' for use with down_cast<>','line_number':13,'multiline':False]['text':' for memcpy','line_number':14,'multiline':False]['text':' for enumeration casts and tests','line_number':15,'multiline':False]['text':' for enumeration casts and tests','line_number':16,'multiline':False]['text':' Use implicit_cast as a safe version of static_cast or const_cast','line_number':21,'multiline':False]['text':' for upcasting in the type hierarchy (i.e. casting a pointer to Foo','line_number':22,'multiline':False]['text':' to a pointer to SuperclassOfFoo or casting a pointer to Foo to','line_number':23,'multiline':False]['text':' a const pointer to Foo).','line_number':24,'multiline':False]['text':' When you use implicit_cast, the compiler checks that the cast is safe.','line_number':25,'multiline':False]['text':' Such explicit implicit_casts are necessary in surprisingly many','line_number':26,'multiline':False]['text':' situations where C++ demands an exact type match instead of an','line_number':27,'multiline':False]['text':' argument type convertable to a target type.','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' The From type can be inferred, so the preferred syntax for using','line_number':30,'multiline':False]['text':' implicit_cast is the same as for static_cast etc.:','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':'   implicit_cast<ToType>(expr)','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' implicit_cast would have been part of the C++ standard library,','line_number':35,'multiline':False]['text':' but the proposal was submitted too late.  It will probably make','line_number':36,'multiline':False]['text':' its way into the language in the future.','line_number':37,'multiline':False]['text':' When you upcast (that is, cast a pointer from type Foo to type','line_number':44,'multiline':False]['text':' SuperclassOfFoo), it's fine to use implicit_cast<>, since upcasts','line_number':45,'multiline':False]['text':' always succeed.  When you downcast (that is, cast a pointer from','line_number':46,'multiline':False]['text':' type Foo to type SubclassOfFoo), static_cast<> isn't safe, because','line_number':47,'multiline':False]['text':' how do you know the pointer is really of type SubclassOfFoo?  It','line_number':48,'multiline':False]['text':' could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,','line_number':49,'multiline':False]['text':' when you downcast, you should use this macro.  In debug mode, we','line_number':50,'multiline':False]['text':' use dynamic_cast<> to double-check the downcast is legal (we die','line_number':51,'multiline':False]['text':' if it's not).  In normal mode, we do the efficient static_cast<>','line_number':52,'multiline':False]['text':' instead.  Thus, it's important to test in debug mode to make sure','line_number':53,'multiline':False]['text':' the cast is legal!','line_number':54,'multiline':False]['text':'    This is the only place in the code we should use dynamic_cast<>.','line_number':55,'multiline':False]['text':' In particular, you SHOULDN'T be using dynamic_cast<> in order to','line_number':56,'multiline':False]['text':' do RTTI (eg code like this:','line_number':57,'multiline':False]['text':'    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);','line_number':58,'multiline':False]['text':'    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);','line_number':59,'multiline':False]['text':' You should design the code some other way not to need this.','line_number':60,'multiline':False]['text':' use like this: down_cast<T*>(foo);','line_number':62,'multiline':False]['text':' so we only accept pointers','line_number':63,'multiline':False]['text':' Ensures that To is a sub-type of From *.  This test is here only','line_number':64,'multiline':False]['text':' for compile-time type checking, and has no overhead in an','line_number':65,'multiline':False]['text':' optimized build at run-time, as it will be optimized away','line_number':66,'multiline':False]['text':' completely.','line_number':67,'multiline':False]['text':' TODO(user): This should use COMPILE_ASSERT.','line_number':69,'multiline':False]['text':' uses RTTI in dbg and fastbuild. asserts are disabled in opt builds.','line_number':74,'multiline':False]['text':' Overload of down_cast for references. Use like this: down_cast<T&>(foo).','line_number':79,'multiline':False]['text':' The code is slightly convoluted because we're still using the pointer','line_number':80,'multiline':False]['text':' form of dynamic cast. (The reference form throws an exception if it','line_number':81,'multiline':False]['text':' fails.)','line_number':82,'multiline':False]['text':'','line_number':83,'multiline':False]['text':' There's no need for a special const overload either for the pointer','line_number':84,'multiline':False]['text':' or the reference form. If you call down_cast with a const T&, the','line_number':85,'multiline':False]['text':' compiler will just bind From to const T.','line_number':86,'multiline':False]['text':' Compile-time check that To inherits from From. See above for details.','line_number':92,'multiline':False]['text':' RTTI: debug mode only','line_number':96,'multiline':False]['text':' bit_cast<Dest,Source> is a template function that implements the','line_number':100,'multiline':False]['text':' equivalent of "*reinterpret_cast<Dest*>(&source)".  We need this in','line_number':101,'multiline':False]['text':' very low-level functions like the protobuf library and fast math','line_number':102,'multiline':False]['text':' support.','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':'   float f = 3.14159265358979;','line_number':105,'multiline':False]['text':'   int i = bit_cast<int32>(f);','line_number':106,'multiline':False]['text':'   // i = 0x40490fdb','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':' The classical address-casting method is:','line_number':109,'multiline':False]['text':'','line_number':110,'multiline':False]['text':'   // WRONG','line_number':111,'multiline':False]['text':'   float f = 3.14159265358979;            // WRONG','line_number':112,'multiline':False]['text':'   int i = * reinterpret_cast<int*>(&f);  // WRONG','line_number':113,'multiline':False]['text':'','line_number':114,'multiline':False]['text':' The address-casting method actually produces undefined behavior','line_number':115,'multiline':False]['text':' according to ISO C++ specification section 3.10 -15 -.  Roughly, this','line_number':116,'multiline':False]['text':' section says: if an object in memory has one type, and a program','line_number':117,'multiline':False]['text':' accesses it with a different type, then the result is undefined','line_number':118,'multiline':False]['text':' behavior for most values of "different type".','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':' This is true for any cast syntax, either *(int*)&f or','line_number':121,'multiline':False]['text':' *reinterpret_cast<int*>(&f).  And it is particularly true for','line_number':122,'multiline':False]['text':' conversions betweeen integral lvalues and floating-point lvalues.','line_number':123,'multiline':False]['text':'','line_number':124,'multiline':False]['text':' The purpose of 3.10 -15- is to allow optimizing compilers to assume','line_number':125,'multiline':False]['text':' that expressions with different types refer to different memory.  gcc','line_number':126,'multiline':False]['text':' 4.0.1 has an optimizer that takes advantage of this.  So a','line_number':127,'multiline':False]['text':' non-conforming program quietly produces wildly incorrect output.','line_number':128,'multiline':False]['text':'','line_number':129,'multiline':False]['text':' The problem is not the use of reinterpret_cast.  The problem is type','line_number':130,'multiline':False]['text':' punning: holding an object in memory of one type and reading its bits','line_number':131,'multiline':False]['text':' back using a different type.','line_number':132,'multiline':False]['text':'','line_number':133,'multiline':False]['text':' The C++ standard is more subtle and complex than this, but that','line_number':134,'multiline':False]['text':' is the basic idea.','line_number':135,'multiline':False]['text':'','line_number':136,'multiline':False]['text':' Anyways ...','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' bit_cast<> calls memcpy() which is blessed by the standard,','line_number':139,'multiline':False]['text':' especially by the example in section 3.9 .  Also, of course,','line_number':140,'multiline':False]['text':' bit_cast<> wraps up the nasty logic in one place.','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':' Fortunately memcpy() is very fast.  In optimized mode, with a','line_number':143,'multiline':False]['text':' constant size, gcc 2.95.3, gcc 4.0.1, and msvc 7.1 produce inline','line_number':144,'multiline':False]['text':' code with the minimal amount of data movement.  On a 32-bit system,','line_number':145,'multiline':False]['text':' memcpy(d,s,4) compiles to one load and one store, and memcpy(d,s,8)','line_number':146,'multiline':False]['text':' compiles to two loads and two stores.','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':' I tested this code with gcc 2.95.3, gcc 4.0.1, icc 8.1, and msvc 7.1.','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' WARNING: if Dest or Source is a non-POD type, the result of the memcpy','line_number':151,'multiline':False]['text':' is likely to surprise you.','line_number':152,'multiline':False]['text':'','line_number':153,'multiline':False]['text':' Props to Bill Gibbons for the compile time assertion technique and','line_number':154,'multiline':False]['text':' Art Komninos and Igor Tandetnik for the msvc experiments.','line_number':155,'multiline':False]['text':'','line_number':156,'multiline':False]['text':' -- mec 2005-10-17','line_number':157,'multiline':False]['text':' Compile time assertion: sizeof(Dest) == sizeof(Source)','line_number':161,'multiline':False]['text':' A compile error here means your Dest and Source have different sizes.','line_number':162,'multiline':False]['text':' **** Enumeration Casts and Tests','line_number':171,'multiline':False]['text':'','line_number':172,'multiline':False]['text':' C++ requires that the value of an integer that is converted to an','line_number':173,'multiline':False]['text':' enumeration be within the value bounds of the enumeration.  Modern','line_number':174,'multiline':False]['text':' compilers can and do take advantage of this requirement to optimize','line_number':175,'multiline':False]['text':' programs.  So, using a raw static_cast with enums can be bad.  See','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':' The following templates and macros enable casting from an int to an enum','line_number':178,'multiline':False]['text':' with checking against the appropriate bounds.  First, when defining an','line_number':179,'multiline':False]['text':' enumeration, identify the limits of the values of its enumerators.','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':'   enum A { A_min = -18, A_max = 33 };','line_number':182,'multiline':False]['text':'   MAKE_ENUM_LIMITS(A, A_min, A_max)','line_number':183,'multiline':False]['text':'','line_number':184,'multiline':False]['text':' Convert an enum to an int in one of two ways.  The prefered way is a','line_number':185,'multiline':False]['text':' tight conversion, which ensures that A_min <= value <= A_max.','line_number':186,'multiline':False]['text':'','line_number':187,'multiline':False]['text':'   A var = tight_enum_cast<A>(3);','line_number':188,'multiline':False]['text':'','line_number':189,'multiline':False]['text':' However, the C++ language defines the set of possible values for an','line_number':190,'multiline':False]['text':' enumeration to be essentially the range of a bitfield that can represent','line_number':191,'multiline':False]['text':' all the enumerators, i.e. those within the nearest containing power','line_number':192,'multiline':False]['text':' of two.  In the example above, the nearest positive power of two is 64,','line_number':193,'multiline':False]['text':' and so the upper bound is 63.  The nearest negative power of two is','line_number':194,'multiline':False]['text':' -32 and so the lower bound is -32 (two's complement), which is upgraded','line_number':195,'multiline':False]['text':' to match the upper bound, becoming -64.  The values within this range','line_number':196,'multiline':False]['text':' of -64 to 63 are valid, according to the C++ standard.  You can cast','line_number':197,'multiline':False]['text':' values within this range as follows.','line_number':198,'multiline':False]['text':'','line_number':199,'multiline':False]['text':'   A var = loose_enum_cast<A>(45);','line_number':200,'multiline':False]['text':'','line_number':201,'multiline':False]['text':' These casts will log a message if the value does not reside within the','line_number':202,'multiline':False]['text':' specified range, and will be fatal when in debug mode.','line_number':203,'multiline':False]['text':'','line_number':204,'multiline':False]['text':' For those times when an assert too strong, there are test functions.','line_number':205,'multiline':False]['text':'','line_number':206,'multiline':False]['text':'   bool var = tight_enum_test<A>(3);','line_number':207,'multiline':False]['text':'   bool var = loose_enum_test<A>(45);','line_number':208,'multiline':False]['text':'','line_number':209,'multiline':False]['text':' For code that needs to use the enumeration value if and only if','line_number':210,'multiline':False]['text':' it is good, there is a function that both tests and casts.','line_number':211,'multiline':False]['text':'','line_number':212,'multiline':False]['text':'   int i = ....;','line_number':213,'multiline':False]['text':'   A var;','line_number':214,'multiline':False]['text':'   if (tight_enum_test_cast<A>(i, &var))','line_number':215,'multiline':False]['text':'     .... // use valid var with value as indicated by i','line_number':216,'multiline':False]['text':'   else','line_number':217,'multiline':False]['text':'     .... // handle invalid enum cast','line_number':218,'multiline':False]['text':'','line_number':219,'multiline':False]['text':' The enum test/cast facility is currently limited to enumerations that','line_number':220,'multiline':False]['text':' fit within an int.  It is also limited to two's complement ints.','line_number':221,'multiline':False]['text':' ** Implementation Description','line_number':223,'multiline':False]['text':'','line_number':224,'multiline':False]['text':' The enum_limits template class captures the minimum and maximum','line_number':225,'multiline':False]['text':' enumerator.  All uses of this template are intended to be of','line_number':226,'multiline':False]['text':' specializations, so the generic has a field to identify itself as','line_number':227,'multiline':False]['text':' not specialized.  The test/cast templates assert specialization.','line_number':228,'multiline':False]['text':' Now we define the macro to define the specialization for enum_limits.','line_number':238,'multiline':False]['text':' The specialization checks that the enumerators fit within an int.','line_number':239,'multiline':False]['text':' This checking relies on integral promotion.','line_number':240,'multiline':False]['text':' The loose enum test/cast is actually the more complicated one,','line_number':253,'multiline':False]['text':' because of the problem of finding the bounds.','line_number':254,'multiline':False]['text':'','line_number':255,'multiline':False]['text':' The unary upper bound, ub, on a positive number is its positive','line_number':256,'multiline':False]['text':' saturation, i.e. for a value v within pow(2,k-1) <= v < pow(2,k),','line_number':257,'multiline':False]['text':' the upper bound is pow(2,k)-1.','line_number':258,'multiline':False]['text':'','line_number':259,'multiline':False]['text':' The unary lower bound, lb, on a negative number is its negative','line_number':260,'multiline':False]['text':' saturation, i.e. for a value v within -pow(2,k) <= v < -pow(2,k-1),','line_number':261,'multiline':False]['text':' the lower bound is -pow(2,k).','line_number':262,'multiline':False]['text':'','line_number':263,'multiline':False]['text':' The actual bounds are (1) the binary upper bound over the maximum','line_number':264,'multiline':False]['text':' enumerator and the one's complement of a negative minimum enumerator','line_number':265,'multiline':False]['text':' and (2) the binary lower bound over the minimum enumerator and the','line_number':266,'multiline':False]['text':' one's complement of the positive maximum enumerator, except that if no','line_number':267,'multiline':False]['text':' enumerators are negative, the lower bound is zero.','line_number':268,'multiline':False]['text':'','line_number':269,'multiline':False]['text':' The algorithm relies heavily on the observation that','line_number':270,'multiline':False]['text':'','line_number':271,'multiline':False]['text':'   a,b>0 then ub(a,b) == ub(a) | ub(b) == ub(a|b)','line_number':272,'multiline':False]['text':'   a,b<0 then lb(a,b) == lb(a) & lb(b) == lb(a&b)','line_number':273,'multiline':False]['text':'','line_number':274,'multiline':False]['text':' Note that the compiler will boil most of this code away','line_number':275,'multiline':False]['text':' because of value propagation on the constant enumerator bounds.','line_number':276,'multiline':False]['text':' Find the unary bounding negative number of e_min and e_max.','line_number':285,'multiline':False]['text':' Find the unary bounding negative number of e_max.','line_number':287,'multiline':False]['text':' This would be b_min = e_max < 0 ? e_max : ~e_max,','line_number':288,'multiline':False]['text':' but we want to avoid branches to help the compiler.','line_number':289,'multiline':False]['text':' Find the binary bounding negative of both e_min and e_max.','line_number':293,'multiline':False]['text':' However, if e_min is postive, the result will be positive.','line_number':296,'multiline':False]['text':' Now clear all bits right of the most significant clear bit,','line_number':297,'multiline':False]['text':' which is a negative saturation for negative numbers.','line_number':298,'multiline':False]['text':' In the case of positive numbers, this is flush to zero.','line_number':299,'multiline':False]['text':' Find the unary bounding positive number of e_max.','line_number':309,'multiline':False]['text':' Find the binary bounding postive number of that','line_number':312,'multiline':False]['text':' and the unary bounding positive number of e_min.','line_number':313,'multiline':False]['text':' Now set all bits right of the most significant set bit,','line_number':317,'multiline':False]['text':' which is a postive saturation for positive numbers.','line_number':318,'multiline':False]['text':' Finally test the bounds.','line_number':328,'multiline':False]['text':' The plain casts require logging, and we get header recursion if','line_number':360,'multiline':False]['text':' it is done directly.  So, we do it indirectly.','line_number':361,'multiline':False]['text':' The following function is defined in logging.cc.','line_number':362,'multiline':False]['text':' namespace logging','line_number':368,'multiline':False]['text':' Gcc and -fno-rtti; can't issue a warning with enum name.','line_number':374,'multiline':False]['text':' Gcc and -fno-rtti; can't issue a warning with enum name.','line_number':387,'multiline':False]['text':' BASE_CASTS_H_','line_number':396,'multiline':False]