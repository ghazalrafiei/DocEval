['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' To run the benchmarks, use:','line_number':3,'multiline':False]['text':' A set of nested loops around the point 0:0 (lat:lng).','line_number':46,'multiline':False]['text':' Every vertex of kNear0 is a vertex of kNear1.','line_number':47,'multiline':False]['text':' A set of nested loops around the point 0:180 (lat:lng).','line_number':55,'multiline':False]['text':' Every vertex of kFar0 and kFar2 belongs to kFar1, and all','line_number':56,'multiline':False]['text':' the loops except kFar2 are non-convex.','line_number':57,'multiline':False]['text':' opposite direction','line_number':61,'multiline':False]['text':' A set of nested loops around the point -90:0 (lat:lng).','line_number':65,'multiline':False]['text':' Two different loops that surround all the Near and Far loops except','line_number':74,'multiline':False]['text':' for the hemispheres.','line_number':75,'multiline':False]['text':' Loops that result from intersection of other loops.','line_number':81,'multiline':False]['text':' Rectangles that form a cross, with only shared vertices, no crossing edges.','line_number':84,'multiline':False]['text':' Optional holes outside the intersecting region.','line_number':85,'multiline':False]['text':' Two rectangles that intersect, but no edges cross and there's always','line_number':92,'multiline':False]['text':' local containment (rather than crossing) at each shared vertex.','line_number':93,'multiline':False]['text':' In this ugly ASCII art, 1 is A+B, 2 is B+C:','line_number':94,'multiline':False]['text':'      +---+---+---+','line_number':95,'multiline':False]['text':'      | A | B | C |','line_number':96,'multiline':False]['text':'      +---+---+---+','line_number':97,'multiline':False]['text':' Some standard polygons to use in the tests.','line_number':109,'multiline':False]['text':' Get a random S2Cell as a polygon.','line_number':348,'multiline':False]['text':' We want to roughly bisect the polygon, so we make a rectangle that is the','line_number':353,'multiline':False]['text':' top half of the current polygon's bounding rectangle.','line_number':354,'multiline':False]['text':' Turn the S2LatLngRect into an S2Polygon','line_number':359,'multiline':False]['text':' Get the intersection. There is no guarantee that the intersection will be','line_number':367,'multiline':False]['text':' contained by A or B.','line_number':368,'multiline':False]['text':' These cases, when either polygon has a hole, test a different code path','line_number':475,'multiline':False]['text':' from the other cases.','line_number':476,'multiline':False]['text':' Two triangles that share an edge.','line_number':498,'multiline':False]['text':' Two vertical bars and a horizontal bar connecting them.','line_number':510,'multiline':False]['text':' Two vertical bars and two horizontal bars centered around S2::Origin().','line_number':523,'multiline':False]['text':' Two interlocking square doughnuts centered around -S2::Origin().','line_number':541,'multiline':False]['text':' An incredibly thin triangle intersecting a square, such that the two','line_number':556,'multiline':False]['text':' intersection points of the triangle with the square are identical.','line_number':557,'multiline':False]['text':' This results in a degenerate loop that needs to be handled correctly.','line_number':558,'multiline':False]['text':' Empty intersection!','line_number':563,'multiline':False]['text':' Original square with extra vertex, and triangle disappears (due to','line_number':565,'multiline':False]['text':' default vertex_merge_radius of S2EdgeUtil::kIntersectionTolerance).','line_number':566,'multiline':False]['text':' The intersections in the "expected" data were computed in lat-lng','line_number':587,'multiline':False]['text':' space, while the actual intersections are computed using geodesics.','line_number':588,'multiline':False]['text':' The error due to this depends on the length and direction of the line','line_number':589,'multiline':False]['text':' segment being intersected, and how close the intersection is to the','line_number':590,'multiline':False]['text':' endpoints of the segment.  The worst case is for a line segment between','line_number':591,'multiline':False]['text':' two points at the same latitude, where the intersection point is in the','line_number':592,'multiline':False]['text':' middle of the segment.  In this case the error is approximately','line_number':593,'multiline':False]['text':' (p * t^2) / 8, where "p" is the absolute latitude in radians, "t" is','line_number':594,'multiline':False]['text':' the longitude difference in radians, and both "p" and "t" are small.','line_number':595,'multiline':False]['text':' The test cases all have small latitude and longitude differences.','line_number':596,'multiline':False]['text':' If "p" and "t" are converted to degrees, the following error bound is','line_number':597,'multiline':False]['text':' valid as long as (p * t^2 < 150).','line_number':598,'multiline':False]['text':' This tests polyline-polyline intersections.','line_number':654,'multiline':False]['text':' It covers the same edge cases as TestOperations and also adds some','line_number':655,'multiline':False]['text':' extra tests for shared edges.','line_number':656,'multiline':False]['text':' See comments in TestOperations about the vlue of this constant.','line_number':665,'multiline':False]['text':' This duplicates some of the tests in TestOperations by','line_number':668,'multiline':False]['text':' converting the outline of polygon A to a polyline then intersecting','line_number':669,'multiline':False]['text':' it with the polygon B. It then converts B to a polyline and intersects','line_number':670,'multiline':False]['text':' it with A. It then feeds all of the results into a polygon builder and','line_number':671,'multiline':False]['text':' tests that the output is equal to doing an intersection between A and B.','line_number':672,'multiline':False]['text':' Remove a random polygon from "pieces" and return it.','line_number':719,'multiline':False]['text':' Compute the minimum level such that the polygon's bounding','line_number':735,'multiline':False]['text':' cap is guaranteed to be cut.','line_number':736,'multiline':False]['text':' TODO: Choose a level that will have up to 256 cells in the covering.','line_number':740,'multiline':False]['text':' Now we repeatedly remove two random pieces, compute their union, and','line_number':764,'multiline':False]['text':' insert the result as a new piece until only one piece is left.','line_number':765,'multiline':False]['text':'','line_number':766,'multiline':False]['text':' We don't use S2Polygon::DestructiveUnion() because it joins the pieces','line_number':767,'multiline':False]['text':' in a mostly deterministic order.  We don't just call random_shuffle()','line_number':768,'multiline':False]['text':' on the pieces and repeatedly join the last two pieces in the vector','line_number':769,'multiline':False]['text':' because this always joins a single original piece to the current union','line_number':770,'multiline':False]['text':' rather than doing the unions according to a random tree structure.','line_number':771,'multiline':False]['text':' The moment of truth!','line_number':785,'multiline':False]['text':' It takes too long to test all the polygons in debug mode, so we just pick','line_number':793,'multiline':False]['text':' out some of the more interesting ones.','line_number':794,'multiline':False]['text':' Test S2Polygon::InitToCellUnionBorder().','line_number':809,'multiline':False]['text':' The main thing to check is that adjacent cells of different sizes get','line_number':810,'multiline':False]['text':' merged correctly.  To do this we generate two random adjacent cells,','line_number':811,'multiline':False]['text':' convert to polygon, and make sure the polygon only has a single loop.','line_number':812,'multiline':False]['text':' Choose a random non-leaf cell.','line_number':816,'multiline':False]['text':' Get all neighbors at some smaller level.','line_number':819,'multiline':False]['text':' Pick one at random.','line_number':824,'multiline':False]['text':' If it's diagonally adjacent, bail out.','line_number':826,'multiline':False]['text':' If the conversion were perfect we could test containment, but due to','line_number':851,'multiline':False]['text':' rounding the polygon won't always exactly contain both cells.  We can','line_number':852,'multiline':False]['text':' at least test intersection.','line_number':853,'multiline':False]['text':' This test checks that S2Polygons created directly from S2Cells behave','line_number':869,'multiline':False]['text':' identically to S2Polygons created from the vertices of those cells; this','line_number':870,'multiline':False]['text':' previously was not the case, because S2Cells calculate their bounding','line_number':871,'multiline':False]['text':' rectangles slightly differently, and S2Polygons created from them just','line_number':872,'multiline':False]['text':' copied the S2Cell bounds.','line_number':873,'multiline':False]['text':' The point inside the polygon should be projected into itself.','line_number':890,'multiline':False]['text':' The point is on the outside of the polygon.','line_number':895,'multiline':False]['text':' The point is inside the hole in the polygon.','line_number':900,'multiline':False]['text':' Returns the distance of a point to a polygon (distance is 0 if the','line_number':911,'multiline':False]['text':' point is in the polygon).','line_number':912,'multiline':False]['text':' Returns the diameter of a loop (maximum distance between any two','line_number':918,'multiline':False]['text':' points in the loop).','line_number':919,'multiline':False]['text':' Returns the maximum distance from any vertex of poly_a to poly_b, that is,','line_number':933,'multiline':False]['text':' the directed Haussdorf distance of the set of vertices of poly_a to the','line_number':934,'multiline':False]['text':' boundary of poly_b.','line_number':935,'multiline':False]['text':'','line_number':936,'multiline':False]['text':' Doesn't consider loops from poly_a that have diameter less than min_diameter','line_number':937,'multiline':False]['text':' in degrees.','line_number':938,'multiline':False]['text':' As if the first polygon were empty.','line_number':961,'multiline':False]['text':' Owns poly.','line_number':977,'multiline':False]['text':' Here, 10:-2 will be removed and  0:0-20:0 will intersect two edges.','line_number':1004,'multiline':False]['text':' (The resulting polygon will in fact probably have more edges.)','line_number':1005,'multiline':False]['text':' To make sure that this test does something, we check','line_number':1009,'multiline':False]['text':' that the vertex 10:-0.2 is not in the simplification anymore.','line_number':1010,'multiline':False]['text':' near_square's right four-point side will be simplified to a vertical','line_number':1037,'multiline':False]['text':' line at lng=7.9, that will cut the 9 teeth of the saw (the edge will','line_number':1038,'multiline':False]['text':' therefore be broken into 19 pieces).','line_number':1039,'multiline':False]['text':' The resulting polygon's 9 little teeth are very small and disappear','line_number':1050,'multiline':False]['text':' due to the vertex_merge_radius of the polygon builder.  There remains','line_number':1051,'multiline':False]['text':' nine loops.','line_number':1052,'multiline':False]['text':' Two loops, One edge of the second one ([0:1 - 0:2]) is part of an','line_number':1057,'multiline':False]['text':' edge of the first one..','line_number':1058,'multiline':False]['text':' Tests that a regular polygon with many points gets simplified','line_number':1077,'multiline':False]['text':' enough.','line_number':1078,'multiline':False]['text':' in degrees','line_number':1080,'multiline':False]