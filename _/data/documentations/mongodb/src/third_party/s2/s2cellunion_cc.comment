['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':' Returns true if the vector of cell_ids is sorted.  Used only in','line_number':23,'multiline':False]['text':' DCHECKs.','line_number':24,'multiline':False]['text':' Optimize the representation by looking for cases where all subcells','line_number':89,'multiline':False]['text':' of a parent cell are present.','line_number':90,'multiline':False]['text':' Check whether this cell is contained by the previous cell.','line_number':99,'multiline':False]['text':' Discard any previous cells contained by this cell.','line_number':102,'multiline':False]['text':' Check whether the last 3 elements of "output" plus "id" can be','line_number':107,'multiline':False]['text':' collapsed into a single parent cell.','line_number':108,'multiline':False]['text':' A necessary (but not sufficient) condition is that the XOR of the','line_number':110,'multiline':False]['text':' four cells must be zero.  This is also very fast to test.','line_number':111,'multiline':False]['text':' Now we do a slightly more expensive but exact test.  First, compute a','line_number':116,'multiline':False]['text':' mask that blocks out the two bits that encode the child position of','line_number':117,'multiline':False]['text':' "id" with respect to its parent, then check that the other three','line_number':118,'multiline':False]['text':' children all agree with "mask.','line_number':119,'multiline':False]['text':' Replace four children by their parent cell.','line_number':129,'multiline':False]['text':' Round up so that (new_level - min_level) is a multiple of level_mod.','line_number':156,'multiline':False]['text':' (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)','line_number':157,'multiline':False]['text':' Compute the approximate centroid of the region.  This won't produce the','line_number':173,'multiline':False]['text':' bounding cap of minimal area, but it should be close enough.','line_number':174,'multiline':False]['text':' Use the centroid as the cap axis, and expand the cap angle so that it','line_number':187,'multiline':False]['text':' contains the bounding caps of all the individual cells.  Note that it is','line_number':188,'multiline':False]['text':' *not* sufficient to just bound all the cell vertices because the bounding','line_number':189,'multiline':False]['text':' cap may be concave (i.e. cover more than one hemisphere).','line_number':190,'multiline':False]['text':' This function requires that Normalize has been called first.','line_number':207,'multiline':False]['text':'','line_number':208,'multiline':False]['text':' This is an exact test.  Each cell occupies a linear span of the S2','line_number':209,'multiline':False]['text':' space-filling curve, and the cell id is simply the position at the center','line_number':210,'multiline':False]['text':' of this span.  The cell union ids are sorted in increasing order along','line_number':211,'multiline':False]['text':' the space-filling curve.  So we simply find the pair of cell ids that','line_number':212,'multiline':False]['text':' surround the given cell id (using binary search).  There is containment','line_number':213,'multiline':False]['text':' if and only if one of these two cell ids contains this cell.','line_number':214,'multiline':False]['text':' This function requires that Normalize has been called first.','line_number':223,'multiline':False]['text':' This is an exact test; see the comments for Contains() above.','line_number':224,'multiline':False]['text':' TODO: A divide-and-conquer or alternating-skip-search approach may be','line_number':233,'multiline':False]['text':' sigificantly faster in both the average and worst case.','line_number':234,'multiline':False]['text':' TODO: A divide-and-conquer or alternating-skip-search approach may be','line_number':243,'multiline':False]['text':' sigificantly faster in both the average and worst case.','line_number':244,'multiline':False]['text':' This is a fairly efficient calculation that uses binary search to skip','line_number':279,'multiline':False]['text':' over sections of both input vectors.  It takes constant time if all the','line_number':280,'multiline':False]['text':' cells of "x" come before or after all the cells of "y" in S2CellId order.','line_number':281,'multiline':False]['text':' Either j->contains(*i) or the two cells are disjoint.','line_number':290,'multiline':False]['text':' Advance "j" to the first cell possibly contained by *i.','line_number':294,'multiline':False]['text':' The previous cell *(j-1) may now contain *i.','line_number':296,'multiline':False]['text':' Identical to the code above with "i" and "j" reversed.','line_number':300,'multiline':False]['text':' "i" and "j" have the same range_min(), so one contains the other.','line_number':308,'multiline':False]['text':' The output is generated in sorted order, and there should not be any','line_number':315,'multiline':False]['text':' cells that can be merged (provided that both inputs were normalized).','line_number':316,'multiline':False]['text':' Add the difference between cell and y to cell_ids.','line_number':324,'multiline':False]['text':' If they intersect but the difference is non-empty, divides and conquers.','line_number':325,'multiline':False]['text':' Avoid unnecessary next() computation.','line_number':333,'multiline':False]['text':' TODO: this is approximately O(N*log(N)), but could probably use similar','line_number':342,'multiline':False]['text':' techniques as GetIntersection() to be more efficient.','line_number':343,'multiline':False]['text':' The output is generated in sorted order, and there should not be any','line_number':349,'multiline':False]['text':' cells that can be merged (provided that both inputs were normalized).','line_number':350,'multiline':False]['text':' Optimization: skip over any cells contained by this one.  This is','line_number':362,'multiline':False]['text':' especially important when very small regions are being expanded.','line_number':363,'multiline':False]['text':' Find the maximum level such that all cells are at least "min_radius" wide.','line_number':377,'multiline':False]['text':' The requested expansion is greater than the width of a face cell.','line_number':380,'multiline':False]['text':' The easiest way to handle this is to expand twice.','line_number':381,'multiline':False]['text':' We repeatedly add the largest cell we can.','line_number':393,'multiline':False]['text':' Find the largest cell that starts at "next_min_id" and doesn't extend','line_number':398,'multiline':False]['text':' beyond "max_id".','line_number':399,'multiline':False]['text':' The output is already normalized.','line_number':410,'multiline':False]