['text':'
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * Copyright (c) 2011 Helge Bahmann
 * Copyright (c) 2013-2014, 2020 Andrey Semashev
 ','line_number':1,'multiline':True]['text':'!
 * \file   lock_pool.cpp
 *
 * This file contains implementation of the lock pool used to emulate atomic ops.
 ','line_number':9,'multiline':True]['text':' Include boost/winapi/config.hpp first to make sure target Windows version is selected by Boost.WinAPI','line_number':17,'multiline':False]['text':' BOOST_USE_WINAPI_VERSION >= BOOST_WINAPI_VERSION_WIN6','line_number':58,'multiline':False]['text':' BOOST_USE_WINAPI_VERSION >= BOOST_WINAPI_VERSION_WIN6','line_number':63,'multiline':False]['text':' BOOST_OS_WINDOWS','line_number':65,'multiline':False]['text':' BOOST_OS_LINUX','line_number':69,'multiline':False]['text':' BOOST_OS_LINUX','line_number':72,'multiline':False]['text':' BOOST_OS_WINDOWS','line_number':74,'multiline':False]['text':' Cache line size, in bytes','line_number':89,'multiline':False]['text':' NOTE: This constant is made as a macro because some compilers (gcc 4.4 for one) don't allow enums or namespace scope constants in alignment attributes','line_number':90,'multiline':False]['text':'! \c find_address generic implementation','line_number':103,'multiline':False]['text':' First, check the max available cpuid function','line_number':151,'multiline':False]['text':' Obtain CPU features','line_number':158,'multiline':False]['text':' defined(BOOST_ATOMIC_USE_SSE2)','line_number':171,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_USE_RUNTIME_DISPATCH)','line_number':180,'multiline':False]['text':' BOOST_ARCH_X86 && defined(BOOST_ATOMIC_DETAIL_SIZEOF_POINTER) && (BOOST_ATOMIC_DETAIL_SIZEOF_POINTER == 8 || BOOST_ATOMIC_DETAIL_SIZEOF_POINTER == 4)','line_number':189,'multiline':False]['text':' BOOST_ARCH_X86 && defined(BOOST_ATOMIC_DETAIL_SIZEOF_POINTER) && (BOOST_ATOMIC_DETAIL_SIZEOF_POINTER == 8 || BOOST_ATOMIC_DETAIL_SIZEOF_POINTER == 4)','line_number':196,'multiline':False]['text':'! Base class for a wait state','line_number':201,'multiline':False]['text':'! Number of waiters referencing this state','line_number':204,'multiline':False]['text':'! Index of this wait state in the list','line_number':206,'multiline':False]['text':'! List of wait states. Must be a POD structure.','line_number':219,'multiline':False]['text':'! List header','line_number':222,'multiline':False]['text':'! List size','line_number':225,'multiline':False]['text':'! List capacity','line_number':227,'multiline':False]['text':'!
     * \brief Pointer to the list header
     *
     * The list buffer consists of three adjacent areas: header object, array of atomic pointers and array of pointers to the wait_state structures.
     * Each of the arrays have header.capacity elements, of which the first header.size elements correspond to the currently ongoing wait operations
     * and the rest are spare elements. Spare wait_state structures may still be allocated (in which case the wait_state pointer is not null) and
     * can be reused on future requests. Spare atomic pointers are null and unused.
     *
     * This memory layout was designed to optimize wait state lookup by atomic address and also support memory pooling to reduce dynamic memory allocations.
     ','line_number':231,'multiline':True]['text':'! The flag indicates that memory pooling is disabled. Set on process cleanup.','line_number':242,'multiline':False]['text':'! Buffer alignment, in bytes','line_number':245,'multiline':False]['text':'! Alignment of pointer arrays in the buffer, in bytes. This should align atomic pointers to the vector size used in \c find_address implementation.','line_number':247,'multiline':False]['text':'! Offset from the list header to the beginning of the array of atomic pointers in the buffer, in bytes','line_number':249,'multiline':False]['text':'! Initial buffer capacity, in elements. This should be at least as large as a vector size used in \c find_address implementation.','line_number':251,'multiline':False]['text':'! Returns a pointer to the array of atomic pointers','line_number':254,'multiline':False]['text':'! Returns a pointer to the array of atomic pointers','line_number':261,'multiline':False]['text':'! Returns a pointer to the array of pointers to the wait states','line_number':267,'multiline':False]['text':'! Returns a pointer to the array of pointers to the wait states','line_number':273,'multiline':False]['text':'! Returns a pointer to the array of pointers to the wait states','line_number':279,'multiline':False]['text':'! Finds an element with the given pointer to the atomic object','line_number':285,'multiline':False]['text':'! Finds an existing element with the given pointer to the atomic object or allocates a new one. Returns NULL in case of failure.','line_number':301,'multiline':False]['text':'! Releases the previously created wait state','line_number':303,'multiline':False]['text':'! Deallocates spare entries and the list buffer if no allocated entries are left','line_number':306,'multiline':False]['text':'! Allocates new buffer for the list entries. Returns NULL in case of failure.','line_number':308,'multiline':False]['text':' In the platform-specific definitions below, lock_state must be a POD structure and wait_state must derive from wait_state_base.','line_number':314,'multiline':False]['text':'! State of a wait operation associated with an atomic object','line_number':318,'multiline':False]['text':'! Condition variable','line_number':322,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':336,'multiline':False]['text':'! Wakes up one thread blocked in the wait operation','line_number':339,'multiline':False]['text':'! Wakes up all threads blocked in the wait operation','line_number':344,'multiline':False]['text':'! Lock pool entry','line_number':351,'multiline':False]['text':'! Mutex','line_number':354,'multiline':False]['text':'! Wait states','line_number':356,'multiline':False]['text':'! Locks the mutex for a short duration','line_number':359,'multiline':False]['text':'! Locks the mutex for a long duration','line_number':365,'multiline':False]['text':'! Unlocks the mutex','line_number':379,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':388,'multiline':False]['text':' The storage type must be a 32-bit object, as required by futex API','line_number':397,'multiline':False]['text':'! The bit indicates a locked mutex','line_number':403,'multiline':False]['text':'! The bit indicates that there is at least one thread blocked waiting for the mutex to be released','line_number':405,'multiline':False]['text':'! The lowest bit of the counter bits used to mitigate ABA problem. This and any higher bits in the mutex state constitute the counter.','line_number':407,'multiline':False]['text':' namespace mutex_bits','line_number':410,'multiline':False]['text':'! State of a wait operation associated with an atomic object','line_number':412,'multiline':False]['text':'! Condition variable futex. Used as the counter of notify calls.','line_number':416,'multiline':False]['text':'! Number of currently blocked waiters','line_number':418,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':428,'multiline':False]['text':'! Wakes up one thread blocked in the wait operation','line_number':431,'multiline':False]['text':'! Wakes up all threads blocked in the wait operation','line_number':433,'multiline':False]['text':'! Lock pool entry','line_number':437,'multiline':False]['text':'! Mutex futex','line_number':440,'multiline':False]['text':'! Wait states','line_number':442,'multiline':False]['text':'! Locks the mutex for a short duration','line_number':445,'multiline':False]['text':'! Locks the mutex for a long duration','line_number':451,'multiline':False]['text':'! Locks the mutex for a long duration','line_number':470,'multiline':False]['text':'! Unlocks the mutex','line_number':494,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':525,'multiline':False]['text':'! Wakes up one thread blocked in the wait operation','line_number':545,'multiline':False]['text':' Move one blocked thread to the mutex futex and mark the mutex contended so that the thread is unblocked on unlock()','line_number':552,'multiline':False]['text':'! Wakes up all threads blocked in the wait operation','line_number':558,'multiline':False]['text':' Move blocked threads to the mutex futex and mark the mutex contended so that a thread is unblocked on unlock()','line_number':565,'multiline':False]['text':'! State of a wait operation associated with an atomic object','line_number':575,'multiline':False]['text':'! Condition variable','line_number':579,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':588,'multiline':False]['text':'! Wakes up one thread blocked in the wait operation','line_number':591,'multiline':False]['text':'! Wakes up all threads blocked in the wait operation','line_number':596,'multiline':False]['text':'! Lock pool entry','line_number':603,'multiline':False]['text':'! Mutex','line_number':606,'multiline':False]['text':'! Wait states','line_number':608,'multiline':False]['text':'! Locks the mutex for a short duration','line_number':611,'multiline':False]['text':'! Locks the mutex for a long duration','line_number':617,'multiline':False]['text':' Presumably, AcquireSRWLockExclusive already implements spinning internally, so there's no point in doing this ourselves.','line_number':620,'multiline':False]['text':'! Unlocks the mutex','line_number':624,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':633,'multiline':False]['text':' BOOST_USE_WINAPI_VERSION >= BOOST_WINAPI_VERSION_WIN6','line_number':639,'multiline':False]['text':'! The bit indicates a locked mutex','line_number':646,'multiline':False]['text':'! The bit indicates that the critical section is initialized and should be used instead of the fallback mutex','line_number':648,'multiline':False]['text':' namespace mutex_bits','line_number':651,'multiline':False]['text':'! State of a wait operation associated with an atomic object','line_number':653,'multiline':False]['text':'!
     * \brief A semaphore used to block one or more threads
     *
     * A semaphore can be used to block a thread if it has no ongoing notifications (i.e. \c m_notify_count is 0).
     * If there is no such semaphore, the thread has to allocate a new one to block on. This is to guarantee
     * that a thread that is blocked after a notification is not immediately released by the semaphore while
     * there are previously blocked threads.
     *
     * Semaphores are organized in a circular doubly linked list. A single semaphore object represents a list
     * of one semaphore and is said to be "singular".
     ','line_number':657,'multiline':True]['text':'! Pointer to the next semaphore in the list','line_number':670,'multiline':False]['text':'! Pointer to the previous semaphore in the list','line_number':672,'multiline':False]['text':'! Semaphore handle','line_number':675,'multiline':False]['text':'! Number of threads blocked on the semaphore','line_number':677,'multiline':False]['text':'! Number of threads released by notifications','line_number':679,'multiline':False]['text':'! Creates a new semaphore or returns null in case of failure','line_number':698,'multiline':False]['text':'! Returns \c true if the semaphore is the single element of the list','line_number':710,'multiline':False]['text':' && m_prev == this ','line_number':713,'multiline':True]['text':'! Inserts the semaphore list after the specified other semaphore','line_number':716,'multiline':False]['text':'! Inserts the semaphore list before the specified other semaphore','line_number':722,'multiline':False]['text':'! Removes the semaphore from the list','line_number':732,'multiline':False]['text':' Load pointers beforehand, in case we are the only element in the list','line_number':735,'multiline':False]['text':'! Doubly linked circular list of semaphores','line_number':747,'multiline':False]['text':'! Returns \c true if the list is empty','line_number':759,'multiline':False]['text':'! Returns the first semaphore in the list','line_number':765,'multiline':False]['text':'! Returns the first semaphore in the list and leaves the list empty','line_number':771,'multiline':False]['text':'! Inserts the semaphore at the beginning of the list','line_number':779,'multiline':False]['text':'! Removes the first semaphore from the beginning of the list','line_number':788,'multiline':False]['text':'! Removes the semaphore from the list','line_number':797,'multiline':False]['text':'! List of semaphores used for notifying. Here, every semaphore has m_notify_count > 0 && m_waiter_count > 0.','line_number':817,'multiline':False]['text':'! List of semaphores used for waiting. Here, every semaphore has m_notify_count == 0 && m_waiter_count > 0.','line_number':819,'multiline':False]['text':'! List of free semaphores. Here, every semaphore has m_notify_count == 0 && m_waiter_count == 0.','line_number':821,'multiline':False]['text':' All wait and notification operations must have been completed','line_number':831,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':854,'multiline':False]['text':'! Fallback implementation of wait','line_number':856,'multiline':False]['text':'! Wakes up one thread blocked in the wait operation','line_number':859,'multiline':False]['text':' Move the semaphore with waiters to the notify list','line_number':867,'multiline':False]['text':' Remove this semaphore from the list. The waiter will re-insert it into the waiter or free list once there are no more pending notifications in it.','line_number':876,'multiline':False]['text':'! Wakes up all threads blocked in the wait operation','line_number':883,'multiline':False]['text':' Combine all notify and waiter semaphores in one list','line_number':886,'multiline':False]['text':'! Lock pool entry','line_number':922,'multiline':False]['text':'! Mutex','line_number':925,'multiline':False]['text':'! Fallback mutex. Used as indicator of critical section initialization state and a fallback mutex, if critical section cannot be initialized.','line_number':927,'multiline':False]['text':'! Wait states','line_number':929,'multiline':False]['text':'! Locks the mutex for a short duration','line_number':932,'multiline':False]['text':'! Locks the mutex for a long duration','line_number':938,'multiline':False]['text':' We failed to init the critical section, leave the fallback mutex locked and return','line_number':962,'multiline':False]['text':' Wait intil the fallback mutex is unlocked','line_number':968,'multiline':False]['text':'! Unlocks the mutex','line_number':975,'multiline':False]['text':'! Blocks in the wait operation until notified','line_number':995,'multiline':False]['text':' Find a semaphore to block on','line_number':998,'multiline':False]['text':' This semaphore is either in the notify list or not in a list at all','line_number':1045,'multiline':False]['text':' Move the semaphore to the free list','line_number':1057,'multiline':False]['text':'! Fallback implementation of wait','line_number':1063,'multiline':False]['text':' BOOST_USE_WINAPI_VERSION >= BOOST_WINAPI_VERSION_WIN6','line_number':1073,'multiline':False]['text':' The additional padding is needed to avoid false sharing between locks','line_number':1087,'multiline':False]['text':'! Lock pool size. Must be a power of two.','line_number':1107,'multiline':False]['text':' BOOST_ATOMIC_DETAIL_LOCK_POOL_SIZE > 256u','line_number':1117,'multiline':False]['text':' BOOST_ATOMIC_DETAIL_LOCK_POOL_SIZE > 256u','line_number':1119,'multiline':False]['text':'! Pool cleanup function','line_number':1124,'multiline':False]['text':'! Returns index of the lock pool entry for the given pointer value','line_number':1140,'multiline':False]['text':'! Finds an existing element with the given pointer to the atomic object or allocates a new one','line_number':1146,'multiline':False]['text':'! Releases the previously created wait state','line_number':1191,'multiline':False]['text':'! Allocates new buffer for the list entries','line_number':1229,'multiline':False]['text':' copy spare wait state pointers','line_number':1259,'multiline':False]['text':'! Deallocates spare entries and the list buffer if no allocated entries are left','line_number':1272,'multiline':False]['text':' namespace','line_number':1296,'multiline':False]['text':' Note: find_or_create may fail to allocate memory. However, C++20 specifies that wait/notify operations','line_number':1325,'multiline':False]['text':' are noexcept, so allocate_wait_state must succeed. To implement this we return NULL in case of failure and test for NULL','line_number':1326,'multiline':False]['text':' in other wait/notify functions so that all of them become nop (which is a conforming, though inefficient behavior).','line_number':1327,'multiline':False]['text':' A conforming wait operation must unlock and lock the mutex to allow a notify to complete','line_number':1363,'multiline':False]['text':' Emulate full fence by locking/unlocking a mutex','line_number':1396,'multiline':False]['text':' This function is intentionally non-inline, even if empty. This forces the compiler to treat its call as a compiler barrier.','line_number':1403,'multiline':False]['text':' namespace lock_pool','line_number':1409,'multiline':False]['text':' namespace detail','line_number':1410,'multiline':False]['text':' namespace atomics','line_number':1411,'multiline':False]['text':' namespace boost','line_number':1412,'multiline':False]