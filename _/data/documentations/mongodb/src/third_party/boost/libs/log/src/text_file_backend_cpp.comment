['text':'
 *          Copyright Andrey Semashev 2007 - 2015.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 ','line_number':1,'multiline':True]['text':'!
 * \file   text_file_backend.cpp
 * \author Andrey Semashev
 * \date   09.06.2009
 *
 * \brief  This header is the Boost.Log library implementation, see the library documentation
 *         at http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html.
 ','line_number':7,'multiline':True]['text':' !defined(BOOST_LOG_NO_THREADS)','line_number':65,'multiline':False]['text':'! A possible Boost.Filesystem extension - renames or moves the file to the target storage','line_number':81,'multiline':False]['text':' On Windows MoveFile already does what we need','line_number':85,'multiline':False]['text':' On POSIX rename fails if the target points to a different device','line_number':88,'multiline':False]['text':' Attempt to manually move the file instead','line_number':95,'multiline':False]['text':'! An auxiliary traits that contain various constants and functions regarding string and character operations','line_number':110,'multiline':False]['text':' BOOST_LOG_BROKEN_STATIC_CONSTANTS_LINKAGE','line_number':161,'multiline':False]['text':' BOOST_LOG_BROKEN_STATIC_CONSTANTS_LINKAGE','line_number':210,'multiline':False]['text':'! Date and time formatter','line_number':212,'multiline':False]['text':'! Constructor','line_number':226,'multiline':False]['text':'! Copy constructor','line_number':230,'multiline':False]['text':'! The method formats the current date and time according to the format string str and writes the result into it','line_number':234,'multiline':False]['text':' Note: the regular operator<< fails because std::use_facet fails to find the facet in the locale because','line_number':239,'multiline':False]['text':' the facet type in Boost.DateTime has hidden visibility. See this ticket:','line_number':240,'multiline':False]['text':' https://svn.boost.org/trac/boost/ticket/11707','line_number':241,'multiline':False]['text':'! The functor formats the file counter into the file name','line_number':258,'multiline':False]['text':'! The position in the pattern where the file counter placeholder is','line_number':265,'multiline':False]['text':'! File counter width','line_number':267,'multiline':False]['text':'! The file counter formatting stream','line_number':269,'multiline':False]['text':'! Initializing constructor','line_number':273,'multiline':False]['text':'! Copy constructor','line_number':281,'multiline':False]['text':'! The function formats the file counter into the file name','line_number':289,'multiline':False]['text':'! The function returns the pattern as the file name','line_number':305,'multiline':False]['text':'! Initializing constructor','line_number':315,'multiline':False]['text':'! Copy constructor','line_number':319,'multiline':False]['text':'! The function returns the pattern as the file name','line_number':324,'multiline':False]['text':'! The function parses the format placeholder for file counter','line_number':333,'multiline':False]['text':' Skip filler and alignment specification','line_number':344,'multiline':False]['text':' Parse width','line_number':353,'multiline':False]['text':' Skip precision','line_number':363,'multiline':False]['text':'! The function matches the file name and the pattern','line_number':381,'multiline':False]['text':' Verifies that the string contains exactly n digits','line_number':389,'multiline':False]['text':' An escaped '%'','line_number':432,'multiline':False]['text':' Date/time components with 2-digits width','line_number':442,'multiline':False]['text':' Date/time components with 4-digits width','line_number':453,'multiline':False]['text':' Fraction seconds width is configuration-dependent','line_number':459,'multiline':False]['text':' This should be the file counter placeholder or some unsupported placeholder','line_number':468,'multiline':False]['text':' Find where the file number ends','line_number':477,'multiline':False]['text':' The actual file name may end with an additional counter','line_number':501,'multiline':False]['text':' that is added by the collector in case if file name clash','line_number':502,'multiline':False]['text':'! The function parses file name pattern and splits it into path and filename and creates a function object that will generate the actual filename from the pattern','line_number':512,'multiline':False]['text':' Note: avoid calling Boost.Filesystem functions that involve path::codecvt()','line_number':515,'multiline':False]['text':' https://svn.boost.org/trac/boost/ticket/9119','line_number':516,'multiline':False]['text':' Let's try to find the file counter placeholder','line_number':524,'multiline':False]['text':' An escaped percent detected','line_number':542,'multiline':False]['text':' We've found the file counter placeholder in the pattern','line_number':554,'multiline':False]['text':' Construct the formatter functor','line_number':566,'multiline':False]['text':' Both counter and date/time placeholder in the pattern','line_number':571,'multiline':False]['text':' Only date/time placeholders in the pattern','line_number':577,'multiline':False]['text':' Only counter placeholder in the pattern','line_number':583,'multiline':False]['text':' No placeholders detected','line_number':588,'multiline':False]['text':'! Type of the hook used for sequencing file collectors','line_number':596,'multiline':False]['text':'! Log file collector implementation','line_number':601,'multiline':False]['text':'! Information about a single stored file','line_number':608,'multiline':False]['text':'! Ordering predicate by timestamp','line_number':611,'multiline':False]['text':'! Predicate for testing if a file_info refers to a file equivalent to another path','line_number':622,'multiline':False]['text':'! A list of the stored files','line_number':647,'multiline':False]['text':'! The string type compatible with the universal path type','line_number':649,'multiline':False]['text':'! A reference to the repository this collector belongs to','line_number':653,'multiline':False]['text':'! Synchronization mutex','line_number':657,'multiline':False]['text':' !defined(BOOST_LOG_NO_THREADS)','line_number':659,'multiline':False]['text':'! Total file size upper limit','line_number':661,'multiline':False]['text':'! Free space lower limit','line_number':663,'multiline':False]['text':'! File count upper limit','line_number':665,'multiline':False]['text':'! The current path at the point when the collector is created','line_number':668,'multiline':False]['text':'
         * The special member is required to calculate absolute paths with no
         * dependency on the current path for the application, which may change
         ','line_number':669,'multiline':True]['text':'! Target directory to store files to','line_number':674,'multiline':False]['text':'! The list of stored files','line_number':677,'multiline':False]['text':'! Total size of the stored files','line_number':679,'multiline':False]['text':'! Constructor','line_number':683,'multiline':False]['text':'! Destructor','line_number':691,'multiline':False]['text':'! The function stores the specified file in the storage','line_number':694,'multiline':False]['text':'! The function checks if the specified path refers to an existing file in the storage','line_number':697,'multiline':False]['text':'! Scans the target directory for the files that have already been stored','line_number':700,'multiline':False]['text':'! The function updates storage restrictions','line_number':703,'multiline':False]['text':'! The function checks if the directory is governed by this collector','line_number':706,'multiline':False]['text':'! Makes relative path absolute with respect to the base path','line_number':713,'multiline':False]['text':'! Acquires file name string from the path','line_number':718,'multiline':False]['text':'! The singleton of the list of file collectors','line_number':726,'multiline':False]['text':'! Base type','line_number':731,'multiline':False]['text':'! The type of the list of collectors','line_number':740,'multiline':False]['text':'! Synchronization mutex','line_number':748,'multiline':False]['text':' !defined(BOOST_LOG_NO_THREADS)','line_number':750,'multiline':False]['text':'! The list of file collectors','line_number':751,'multiline':False]['text':'! Finds or creates a file collector','line_number':755,'multiline':False]['text':'! Removes the file collector from the list','line_number':759,'multiline':False]['text':'! Initializes the singleton instance','line_number':763,'multiline':False]['text':'! Constructor','line_number':770,'multiline':False]['text':'! Destructor','line_number':789,'multiline':False]['text':'! The function stores the specified file in the storage','line_number':795,'multiline':False]['text':' NOTE FOR THE FOLLOWING CODE:','line_number':798,'multiline':False]['text':' Avoid using Boost.Filesystem functions that would call path::codecvt(). store_file() can be called','line_number':799,'multiline':False]['text':' at process termination, and the global codecvt facet can already be destroyed at this point.','line_number':800,'multiline':False]['text':' https://svn.boost.org/trac/boost/ticket/8642','line_number':801,'multiline':False]['text':' Let's construct the new file name','line_number':803,'multiline':False]['text':' Check if the file is already in the target directory','line_number':812,'multiline':False]['text':' If the file already exists, try to mangle the file name','line_number':821,'multiline':False]['text':' to ensure there's no conflict. I'll need to make this customizable some day.','line_number':822,'multiline':False]['text':' The directory should have been created in constructor, but just in case it got deleted since then...','line_number':844,'multiline':False]['text':' If the sink writes log file into the target dir (is_in_target_dir == true), it is possible that after scanning','line_number':854,'multiline':False]['text':' an old file entry refers to the file that is picked up by the sink for writing. Later on, the sink attempts','line_number':855,'multiline':False]['text':' to store the file in the storage. At best, this would result in duplicate file entries. At worst, if the storage','line_number':856,'multiline':False]['text':' limits trigger a deletion and this file get deleted, we may have an entry that refers to no actual file. In any case,','line_number':857,'multiline':False]['text':' the total size of files in the storage will be incorrect. Here we work around this problem and simply remove','line_number':858,'multiline':False]['text':' the old file entry without removing the file. The entry will be re-added to the list later.','line_number':859,'multiline':False]['text':' Check if an old file should be erased','line_number':878,'multiline':False]['text':' Free space has to be queried as it may not increase equally','line_number':892,'multiline':False]['text':' to the erased file size on compressed filesystems','line_number':893,'multiline':False]['text':' Can't erase the file. Maybe it's locked? Never mind...','line_number':901,'multiline':False]['text':' If it's not a file or is absent, just remove it from the list','line_number':907,'multiline':False]['text':' Move/rename the file to the target storage','line_number':915,'multiline':False]['text':'! The function checks if the specified path refers to an existing file in the storage','line_number':923,'multiline':False]['text':' Check if the file is already in the target directory','line_number':929,'multiline':False]['text':'! Scans the target directory for the files that have already been stored','line_number':947,'multiline':False]['text':' Check that there are no duplicates in the resulting list','line_number':979,'multiline':False]['text':' Check that the file name matches the pattern','line_number':982,'multiline':False]['text':' Test that the file_number >= result.last_file_counter accounting for the integer overflow','line_number':994,'multiline':False]['text':' Sort files chronologically','line_number':1002,'multiline':False]['text':'! The function updates storage restrictions','line_number':1012,'multiline':False]['text':'! Finds or creates a file collector','line_number':1023,'multiline':False]['text':' This may throw if the collector is being currently destroyed','line_number':1034,'multiline':False]['text':'! Removes the file collector from the list','line_number':1052,'multiline':False]['text':'! Checks if the time point is valid','line_number':1059,'multiline':False]['text':' namespace','line_number':1082,'multiline':False]['text':'! Creates and returns a file collector with the specified parameters','line_number':1088,'multiline':False]['text':' namespace aux','line_number':1098,'multiline':False]['text':'! Creates a rotation time point of every day at the specified time','line_number':1100,'multiline':False]['text':'! Creates a rotation time point of each specified weekday at the specified time','line_number':1116,'multiline':False]['text':'! Creates a rotation time point of each specified day of month at the specified time','line_number':1133,'multiline':False]['text':'! Checks if it's time to rotate the file','line_number':1150,'multiline':False]['text':' The rotation takes place every day at the specified time','line_number':1171,'multiline':False]['text':' The rotation takes place on the specified week day at the specified time','line_number':1182,'multiline':False]['text':' The rotation takes place on the specified day of month at the specified time','line_number':1198,'multiline':False]['text':'! Checks if it's time to rotate the file','line_number':1223,'multiline':False]['text':' namespace file','line_number':1242,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':1244,'multiline':False]['text':'  File sink backend implementation','line_number':1245,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':1246,'multiline':False]['text':'! Sink implementation data','line_number':1247,'multiline':False]['text':'! File name pattern','line_number':1250,'multiline':False]['text':'! Directory to store files in','line_number':1252,'multiline':False]['text':'! File name generator (according to m_FileNamePattern)','line_number':1254,'multiline':False]['text':'! Target file name pattern','line_number':1257,'multiline':False]['text':'! Target directory to store files in','line_number':1259,'multiline':False]['text':'! Target file name generator (according to m_TargetFileNamePattern)','line_number':1261,'multiline':False]['text':'! Counter to use in file names','line_number':1264,'multiline':False]['text':'! File open mode','line_number':1267,'multiline':False]['text':'! Current file name','line_number':1270,'multiline':False]['text':'! File stream','line_number':1272,'multiline':False]['text':'! Characters written','line_number':1274,'multiline':False]['text':'! File collector functional object','line_number':1277,'multiline':False]['text':'! File open handler','line_number':1279,'multiline':False]['text':'! File close handler','line_number':1281,'multiline':False]['text':'! The maximum temp file size, in characters written to the stream','line_number':1284,'multiline':False]['text':'! Time-based rotation predicate','line_number':1286,'multiline':False]['text':'! Indicates whether to append a trailing newline after every log record','line_number':1288,'multiline':False]['text':'! The flag shows if every written record should be flushed','line_number':1290,'multiline':False]['text':'! The flag indicates whether the final rotation should be performed','line_number':1292,'multiline':False]['text':'! The flag indicates that \c m_FileCounter is set to the last used counter value','line_number':1295,'multiline':False]['text':'! The flag indicates whether the next opened file will be the first file opened by this backend','line_number':1297,'multiline':False]['text':'! Constructor. No streams attached to the constructed backend, auto flush feature disabled.','line_number':1314,'multiline':False]['text':'! Destructor','line_number':1320,'multiline':False]['text':' Attempt to put the temporary file into storage','line_number':1325,'multiline':False]['text':'! Constructor implementation','line_number':1336,'multiline':False]['text':'! The method sets maximum file size.','line_number':1354,'multiline':False]['text':'! The method sets the maximum time interval between file rotations.','line_number':1360,'multiline':False]['text':'! The method allows to enable or disable log file rotation on sink destruction.','line_number':1366,'multiline':False]['text':'! Sets the flag to automatically flush write buffers of the file being written after each log record.','line_number':1372,'multiline':False]['text':'! Selects whether a trailing newline should be automatically inserted after every log record.','line_number':1378,'multiline':False]['text':'! The method writes the message to the sink','line_number':1384,'multiline':False]['text':' The file stream is not operational. One possible reason is that there is no more free space','line_number':1393,'multiline':False]['text':' on the file system. In this case it is possible that this log record will fail to be written as well,','line_number':1394,'multiline':False]['text':' leaving the newly created file empty. Eventually this results in lots of empty log files.','line_number':1395,'multiline':False]['text':' We should take precautions to avoid this. https://svn.boost.org/trac/boost/ticket/11016','line_number':1396,'multiline':False]['text':' To reuse the empty file avoid re-generating the new file name later','line_number':1404,'multiline':False]['text':' Complete file rotation','line_number':1409,'multiline':False]['text':' If the sink backend is configured to append to a previously written file, don't','line_number':1433,'multiline':False]['text':' increment the file counter and try to open the existing file. Only do this if the','line_number':1434,'multiline':False]['text':' file is not moved to a different storage location by the file collector.','line_number':1435,'multiline':False]['text':' Check the file size before invoking the open handler, as it may write more data to the file','line_number':1482,'multiline':False]['text':' Avoid running the close handler, as we haven't run the open handler yet','line_number':1486,'multiline':False]['text':' Update the size of the written data, but don't rotate the file. If the open handler','line_number':1513,'multiline':False]['text':' exceeds the file size limit we could end up in an infinite loop, as we are constantly','line_number':1514,'multiline':False]['text':' rotating the file and immediately exceeding its size limit after the open handler is run.','line_number':1515,'multiline':False]['text':' Write the log record and then rotate the file upon the next log record.','line_number':1516,'multiline':False]['text':'! The method flushes the currently open log file','line_number':1539,'multiline':False]['text':'! The method sets file name pattern','line_number':1546,'multiline':False]['text':'! The method sets target file name pattern','line_number':1560,'multiline':False]['text':'! Closes the currently open file','line_number':1575,'multiline':False]['text':' Rationale: We should call the close handler even if the stream is !good() because','line_number':1582,'multiline':False]['text':' writing the footer may not be the only thing the handler does. However, there is','line_number':1583,'multiline':False]['text':' a chance that the file had become writable since the last failure (e.g. there was','line_number':1584,'multiline':False]['text':' no space left to write the last record, but it got freed since then), so if the handler','line_number':1585,'multiline':False]['text':' attempts to write a footer it may succeed now. For this reason we clear the stream state','line_number':1586,'multiline':False]['text':' and let the handler have a try.','line_number':1587,'multiline':False]['text':'! The method rotates the file','line_number':1600,'multiline':False]['text':' Check if the file has been created in the first place','line_number':1606,'multiline':False]['text':'! The method sets the file open mode','line_number':1629,'multiline':False]['text':' we need to seek to end after opening the file to obtain its size','line_number':1635,'multiline':False]['text':'! The method sets file collector','line_number':1641,'multiline':False]['text':'! The method sets file open handler','line_number':1647,'multiline':False]['text':'! The method sets file close handler','line_number':1653,'multiline':False]['text':'! The method returns name of the currently open log file. If no file is open, returns an empty path.','line_number':1659,'multiline':False]['text':'! Performs scanning of the target directory for log files','line_number':1665,'multiline':False]['text':' namespace sinks','line_number':1691,'multiline':False]['text':' namespace log','line_number':1693,'multiline':False]['text':' namespace boost','line_number':1695,'multiline':False]