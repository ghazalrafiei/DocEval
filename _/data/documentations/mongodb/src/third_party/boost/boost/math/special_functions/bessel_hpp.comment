['text':'  Copyright (c) 2007, 2013 John Maddock','line_number':1,'multiline':False]['text':'  Copyright Christopher Kormanyos 2013.','line_number':2,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':3,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' This header just defines the function entry points, and adds dispatch','line_number':7,'multiline':False]['text':' to the right implementation method.  Most of the implementation details','line_number':8,'multiline':False]['text':' are in separate headers and copyright Xiaogang Zhang.','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':' ADL of std names','line_number':79,'multiline':False]['text':' better have integer v:','line_number':96,'multiline':False]['text':' ADL of std names.','line_number':118,'multiline':False]['text':' If v is an integer, use the integer recursion','line_number':120,'multiline':False]['text':' method, both that and Steeds method are O(v):','line_number':121,'multiline':False]['text':' ADL of std names','line_number':139,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' Special case, n == 0 resolves down to the sinus cardinal of x:','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':'','line_number':149,'multiline':False]['text':' Special case for x == 0:','line_number':150,'multiline':False]['text':'','line_number':151,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' When x is small we may end up with 0/0, use series evaluation','line_number':155,'multiline':False]['text':' instead, especially as it converges rapidly:','line_number':156,'multiline':False]['text':'','line_number':157,'multiline':False]['text':'','line_number':160,'multiline':False]['text':' Default case is just a naive evaluation of the definition:','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':'','line_number':170,'multiline':False]['text':' This handles all the bessel I functions, note that we don't optimise','line_number':171,'multiline':False]['text':' for integer v, other than the v = 0 or 1 special cases, as Millers','line_number':172,'multiline':False]['text':' algorithm is at least as inefficient as the general case (the general','line_number':173,'multiline':False]['text':' case has better error handling too).','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':' better have integer v:','line_number':179,'multiline':False]['text':' common special case, note try and avoid overflow in exp(x):','line_number':198,'multiline':False]['text':' t ','line_number':225,'multiline':True]['text':' ','line_number':282,'multiline':False]['text':' Post evaluation check for internal overflow during evaluation,','line_number':283,'multiline':False]['text':' can occur when x is small and v is large, in which case the result','line_number':284,'multiline':False]['text':' is -INF:','line_number':285,'multiline':False]['text':'','line_number':286,'multiline':False]['text':' ADL of std names','line_number':320,'multiline':False]['text':'','line_number':322,'multiline':False]['text':' Nothing much to do here but check for errors, and','line_number':323,'multiline':False]['text':' evaluate the function's definition directly:','line_number':324,'multiline':False]['text':'','line_number':325,'multiline':False]['text':' ADL of std names, needed for floor.','line_number':346,'multiline':False]['text':' Handle non-finite order.','line_number':352,'multiline':False]['text':' Handle negative rank.','line_number':358,'multiline':False]['text':' Zeros of Jv(x) with negative rank are not defined and requesting one raises a domain error.','line_number':361,'multiline':False]['text':' Get the absolute value of the order.','line_number':365,'multiline':False]['text':' Check if the order is very close to zero or very close to an integer.','line_number':369,'multiline':False]['text':' The zero'th zero of J0(x) is not defined and requesting it raises a domain error.','line_number':377,'multiline':False]['text':' The zero'th zero of Jv(x) for v < 0 is not defined','line_number':381,'multiline':False]['text':' unless the order is a negative integer.','line_number':382,'multiline':False]['text':' For non-integer, negative order, requesting the zero'th zero raises a domain error.','line_number':385,'multiline':False]['text':' The zero'th zero does exist and its value is zero.','line_number':389,'multiline':False]['text':' Set up the initial guess for the upcoming root-finding.','line_number':393,'multiline':False]['text':' If the order is a negative integer, then use the corresponding','line_number':394,'multiline':False]['text':' positive integer for the order.','line_number':395,'multiline':False]['text':' Select the maximum allowed iterations from the policy.','line_number':398,'multiline':False]['text':' Perform the root-finding using Newton-Raphson iteration from Boost.Math.','line_number':403,'multiline':False]['text':' ADL of std names, needed for floor.','line_number':425,'multiline':False]['text':' Handle non-finite order.','line_number':429,'multiline':False]['text':' Handle negative rank.','line_number':435,'multiline':False]['text':' Get the absolute value of the order.','line_number':443,'multiline':False]['text':' For negative integers, use reflection to positive integer order.','line_number':449,'multiline':False]['text':' Check if the order is very close to a negative half-integer.','line_number':453,'multiline':False]['text':' The zero'th zero of Yv(x) for v < 0 is not defined','line_number':459,'multiline':False]['text':' unless the order is a negative integer.','line_number':460,'multiline':False]['text':' For non-integer, negative order, requesting the zero'th zero raises a domain error.','line_number':463,'multiline':False]['text':' For negative half-integers, use the corresponding','line_number':467,'multiline':False]['text':' spherical Bessel function of positive half-integer order.','line_number':468,'multiline':False]['text':' Set up the initial guess for the upcoming root-finding.','line_number':472,'multiline':False]['text':' If the order is a negative integer, then use the corresponding','line_number':473,'multiline':False]['text':' positive integer for the order.','line_number':474,'multiline':False]['text':' Select the maximum allowed iterations from the policy.','line_number':477,'multiline':False]['text':' Perform the root-finding using Newton-Raphson iteration from Boost.Math.','line_number':482,'multiline':False]['text':' namespace detail','line_number':501,'multiline':False]['text':' pol ','line_number':504,'multiline':True]['text':' pol ','line_number':526,'multiline':True]['text':' pol ','line_number':547,'multiline':True]['text':' pol ','line_number':568,'multiline':True]['text':' pol ','line_number':590,'multiline':True]['text':' pol ','line_number':612,'multiline':True]['text':' pol ','line_number':633,'multiline':True]['text':' pol ','line_number':694,'multiline':True]['text':' namespace math','line_number':754,'multiline':False]['text':' namespace boost','line_number':755,'multiline':False]['text':' BOOST_MATH_BESSEL_HPP','line_number':757,'multiline':False]