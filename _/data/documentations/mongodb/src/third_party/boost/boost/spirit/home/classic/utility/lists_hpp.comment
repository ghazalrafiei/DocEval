['text':'=============================================================================
    Copyright (c) 2002-2003 Hartmut Kaiser
    http://spirit.sourceforge.net/

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':11,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':21,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'  list_parser class','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':'      List parsers allow to parse constructs like','line_number':30,'multiline':False]['text':'','line_number':31,'multiline':False]['text':'          item >> *(delim >> item)','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':'      where 'item' is an auxiliary expression to parse and 'delim' is an','line_number':34,'multiline':False]['text':'      auxiliary delimiter to parse.','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':'      The list_parser class also can match an optional closing delimiter','line_number':37,'multiline':False]['text':'      represented by the 'end' parser at the end of the list:','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'          item >> *(delim >> item) >> !end.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':'      If ItemT is an action_parser_category type (parser with an attached','line_number':42,'multiline':False]['text':'      semantic action) we have to do something special. This happens, if the','line_number':43,'multiline':False]['text':'      user wrote something like:','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':'          list_p(item[f], delim)','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':'      where 'item' is the parser matching one item of the list sequence and','line_number':48,'multiline':False]['text':'      'f' is a functor to be called after matching one item. If we would do','line_number':49,'multiline':False]['text':'      nothing, the resulting code would parse the sequence as follows:','line_number':50,'multiline':False]['text':'','line_number':51,'multiline':False]['text':'          (item[f] - delim) >> *(delim >> (item[f] - delim))','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':'      what in most cases is not what the user expects.','line_number':54,'multiline':False]['text':'      (If this _is_ what you've expected, then please use one of the list_p','line_number':55,'multiline':False]['text':'      generator functions 'direct()', which will inhibit re-attaching','line_number':56,'multiline':False]['text':'      the actor to the item parser).','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':'      To make the list parser behave as expected:','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':'          (item - delim)[f] >> *(delim >> (item - delim)[f])','line_number':61,'multiline':False]['text':'','line_number':62,'multiline':False]['text':'      the actor attached to the 'item' parser has to be re-attached to the','line_number':63,'multiline':False]['text':'      *(item - delim) parser construct, which will make the resulting list','line_number':64,'multiline':False]['text':'      parser 'do the right thing'.','line_number':65,'multiline':False]['text':'','line_number':66,'multiline':False]['text':'      Additionally special care must be taken, if the item parser is a','line_number':67,'multiline':False]['text':'      unary_parser_category type parser as','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':'          list_p(*anychar_p, ',')','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':'      which without any refactoring would result in','line_number':72,'multiline':False]['text':'','line_number':73,'multiline':False]['text':'          (*anychar_p - ch_p(','))','line_number':74,'multiline':False]['text':'              >> *( ch_p(',') >> (*anychar_p - ch_p(',')) )','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':'      and will not give the expected result (the first *anychar_p will eat up','line_number':77,'multiline':False]['text':'      all the input up to the end of the input stream). So we have to','line_number':78,'multiline':False]['text':'      refactor this into:','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':'          *(anychar_p - ch_p(','))','line_number':81,'multiline':False]['text':'              >> *( ch_p(',') >> *(anychar_p - ch_p(',')) )','line_number':82,'multiline':False]['text':'','line_number':83,'multiline':False]['text':'      what will give the correct result.','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':'      The case, where the item parser is a combination of the two mentioned','line_number':86,'multiline':False]['text':'      problems (i.e. the item parser is a unary parser  with an attached','line_number':87,'multiline':False]['text':'      action), is handled accordingly too:','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':'          list_p((*anychar_p)[f], ',')','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':'      will be parsed as expected:','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':'          (*(anychar_p - ch_p(',')))[f]','line_number':94,'multiline':False]['text':'              >> *( ch_p(',') >> (*(anychar_p - ch_p(',')))[f] ).','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':97,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':'  List parser generator template','line_number':128,'multiline':False]['text':'','line_number':129,'multiline':False]['text':'      This is a helper for generating a correct list_parser<> from','line_number':130,'multiline':False]['text':'      auxiliary parameters. There are the following types supported as','line_number':131,'multiline':False]['text':'      parameters yet: parsers, single characters and strings (see','line_number':132,'multiline':False]['text':'      as_parser<> in meta/as_parser.hpp).','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':'      The list_parser_gen by itself can be used for parsing comma separated','line_number':135,'multiline':False]['text':'      lists without item formatting:','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':'          list_p.parse(...)','line_number':138,'multiline':False]['text':'              matches any comma separated list.','line_number':139,'multiline':False]['text':'','line_number':140,'multiline':False]['text':'      If list_p is used with one parameter, this parameter is used to match','line_number':141,'multiline':False]['text':'      the delimiter:','line_number':142,'multiline':False]['text':'','line_number':143,'multiline':False]['text':'          list_p(';').parse(...)','line_number':144,'multiline':False]['text':'              matches any semicolon separated list.','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':'      If list_p is used with two parameters, the first parameter is used to','line_number':147,'multiline':False]['text':'      match the items and the second parameter matches the delimiters:','line_number':148,'multiline':False]['text':'','line_number':149,'multiline':False]['text':'          list_p(uint_p, ',').parse(...)','line_number':150,'multiline':False]['text':'              matches comma separated unsigned integers.','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':'      If list_p is used with three parameters, the first parameter is used','line_number':153,'multiline':False]['text':'      to match the items, the second one is used to match the delimiters and','line_number':154,'multiline':False]['text':'      the third one is used to match an optional ending token sequence:','line_number':155,'multiline':False]['text':'','line_number':156,'multiline':False]['text':'          list_p(real_p, ';', eol_p).parse(...)','line_number':157,'multiline':False]['text':'              matches a semicolon separated list of real numbers optionally','line_number':158,'multiline':False]['text':'              followed by an end of line.','line_number':159,'multiline':False]['text':'','line_number':160,'multiline':False]['text':'      The list_p in the previous examples denotes the predefined parser','line_number':161,'multiline':False]['text':'      generator, which should be used to define list parsers (see below).','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':164,'multiline':False]['text':' construct the list_parser_gen object as an list parser for comma separated','line_number':172,'multiline':False]['text':' lists without item formatting.','line_number':173,'multiline':False]['text':' The following generator functions should be used under normal circumstances.','line_number':179,'multiline':False]['text':' (the operator()(...) functions)','line_number':180,'multiline':False]['text':' Generic generator functions for creation of concrete list parsers, which','line_number':182,'multiline':False]['text':' support 'normal' syntax:','line_number':183,'multiline':False]['text':'','line_number':184,'multiline':False]['text':'      item >> *(delim >> item)','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' If item isn't given, everything between two delimiters is matched.','line_number':187,'multiline':False]['text':' there is no action to re-attach','line_number':194,'multiline':False]['text':' Generic generator function for creation of concrete list parsers, which','line_number':229,'multiline':False]['text':' support 'extended' syntax:','line_number':230,'multiline':False]['text':'','line_number':231,'multiline':False]['text':'      item >> *(delim >> item) >> !end','line_number':232,'multiline':False]['text':' The following functions should be used, if the 'item' parser has an attached','line_number':259,'multiline':False]['text':' semantic action or is a unary_parser_category type parser and the structure','line_number':260,'multiline':False]['text':' of the resulting list parser should _not_ be refactored during parser','line_number':261,'multiline':False]['text':' construction (see comment above).','line_number':262,'multiline':False]['text':' Generic generator function for creation of concrete list parsers, which','line_number':264,'multiline':False]['text':' support 'normal' syntax:','line_number':265,'multiline':False]['text':'','line_number':266,'multiline':False]['text':'      item >> *(delim >> item)','line_number':267,'multiline':False]['text':' inhibit action re-attachment','line_number':274,'multiline':False]['text':' Generic generator function for creation of concrete list parsers, which','line_number':290,'multiline':False]['text':' support 'extended' syntax:','line_number':291,'multiline':False]['text':'','line_number':292,'multiline':False]['text':'      item >> *(delim >> item) >> !end','line_number':293,'multiline':False]['text':' inhibit action re-attachment','line_number':300,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':321,'multiline':False]['text':'','line_number':322,'multiline':False]['text':'  Predefined list parser generator','line_number':323,'multiline':False]['text':'','line_number':324,'multiline':False]['text':'      The list_p parser generator can be used','line_number':325,'multiline':False]['text':'        - by itself for parsing comma separated lists without item formatting','line_number':326,'multiline':False]['text':'      or','line_number':327,'multiline':False]['text':'        - for generating list parsers with auxiliary parser parameters','line_number':328,'multiline':False]['text':'          for the 'item', 'delim' and 'end' subsequences.','line_number':329,'multiline':False]['text':'      (see comment above)','line_number':330,'multiline':False]['text':'','line_number':331,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':332,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':335,'multiline':False]['text':' namespace BOOST_SPIRIT_CLASSIC_NS','line_number':338,'multiline':False]