['text':'=============================================================================
    Copyright (c) 1998-2003 Joel de Guzman
    http://spirit.sourceforge.net/

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]['text':'  forward declaration','line_number':22,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':'  Parser categories','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'      Helper template classes to distinguish different types of','line_number':28,'multiline':False]['text':'      parsers. The following categories are the most generic. More','line_number':29,'multiline':False]['text':'      specific types may inherit from these. Each parser has a typedef','line_number':30,'multiline':False]['text':'      parser_category_t that defines its category. By default, if one','line_number':31,'multiline':False]['text':'      is not specified, it will inherit from the base parser class','line_number':32,'multiline':False]['text':'      which typedefs its parser_category_t as plain_parser_category.','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':'          - plain parser has nothing special','line_number':35,'multiline':False]['text':'          - binary parser has subject a and b (e.g. alternative)','line_number':36,'multiline':False]['text':'          - unary parser has single subject  (e.g. kleene star)','line_number':37,'multiline':False]['text':'          - action parser has an attached action parser','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':40,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':'  parser_result metafunction','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':'      Given a scanner type ScannerT and a parser type ParserT, the','line_number':50,'multiline':False]['text':'      parser_result metafunction provides the actual result of the','line_number':51,'multiline':False]['text':'      parser.','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':'  Usage:','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':'      typename parser_result<ParserT, ScannerT>::type','line_number':56,'multiline':False]['text':'','line_number':57,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':58,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':'  parser class','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':'      This class is a protocol base class for all parsers. This is','line_number':70,'multiline':False]['text':'      essentially an interface contract. The parser class does not','line_number':71,'multiline':False]['text':'      really know how to parse anything but instead relies on the','line_number':72,'multiline':False]['text':'      template parameter DerivedT (which obviously is assumed to be a','line_number':73,'multiline':False]['text':'      subclass) to do the actual parsing.','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':'      Concrete sub-classes inheriting from parser must have a','line_number':76,'multiline':False]['text':'      corresponding member function parse(...) compatible with the','line_number':77,'multiline':False]['text':'      conceptual Interface:','line_number':78,'multiline':False]['text':'','line_number':79,'multiline':False]['text':'          template <typename ScannerT>','line_number':80,'multiline':False]['text':'          RT parse(ScannerT const& scan) const;','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':'      where RT is the desired return type of the parser and ScannerT','line_number':83,'multiline':False]['text':'      scan is the scanner (see scanner.hpp).','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':'      Concrete sub-classes inheriting from parser in most cases need to','line_number':86,'multiline':False]['text':'      have a nested meta-function result that returns the result type','line_number':87,'multiline':False]['text':'      of the parser's parse member function, given a scanner type. The','line_number':88,'multiline':False]['text':'      meta-function has the form:','line_number':89,'multiline':False]['text':'','line_number':90,'multiline':False]['text':'          template <typename ScannerT>','line_number':91,'multiline':False]['text':'          struct result','line_number':92,'multiline':False]['text':'          {','line_number':93,'multiline':False]['text':'              typedef RT type;','line_number':94,'multiline':False]['text':'          };','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':'      where RT is the desired return type of the parser. This is','line_number':97,'multiline':False]['text':'      usually, but not always, dependent on the template parameter','line_number':98,'multiline':False]['text':'      ScannerT. If a parser does not supply a result metafunction, a','line_number':99,'multiline':False]['text':'      default is provided by the base parser class.','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':'      The parser's derived() member function returns a reference to the','line_number':102,'multiline':False]['text':'      parser as its derived object.','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':'      An operator[] is provided. The operator returns a semantic action','line_number':105,'multiline':False]['text':'      handler (see actions.hpp).','line_number':106,'multiline':False]['text':'','line_number':107,'multiline':False]['text':'      Each parser has a typedef embed_t. This typedef specifies how a','line_number':108,'multiline':False]['text':'      parser is embedded in a composite (see composite.hpp). By','line_number':109,'multiline':False]['text':'      default, if one is not specified, the parser will be embedded by','line_number':110,'multiline':False]['text':'      value. That is, a copy of the parser is placed as a member','line_number':111,'multiline':False]['text':'      variable of the composite. Most parsers are embedded by value. In','line_number':112,'multiline':False]['text':'      certain situations however, this is not desirable or possible.','line_number':113,'multiline':False]['text':'','line_number':114,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':115,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':'  parse_info','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':'      Results returned by the free parse functions:','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':'      stop:   points to the final parse position (i.e parsing','line_number':153,'multiline':False]['text':'              processed the input up to this point).','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':'      hit:    true if parsing is successful. This may be full:','line_number':156,'multiline':False]['text':'              the parser consumed all the input, or partial:','line_number':157,'multiline':False]['text':'              the parser consumed only a portion of the input.','line_number':158,'multiline':False]['text':'','line_number':159,'multiline':False]['text':'      full:   true when we have a full hit (i.e the parser','line_number':160,'multiline':False]['text':'              consumed all the input.','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':'      length: The number of characters consumed by the parser.','line_number':163,'multiline':False]['text':'              This is valid only if we have a successful hit','line_number':164,'multiline':False]['text':'              (either partial or full).','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':167,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':194,'multiline':False]['text':'','line_number':195,'multiline':False]['text':'  Generic parse function','line_number':196,'multiline':False]['text':'','line_number':197,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':198,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':206,'multiline':False]['text':'','line_number':207,'multiline':False]['text':'  Parse function for null terminated strings','line_number':208,'multiline':False]['text':'','line_number':209,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':210,'multiline':False]['text':' namespace BOOST_SPIRIT_CLASSIC_NS','line_number':219,'multiline':False]