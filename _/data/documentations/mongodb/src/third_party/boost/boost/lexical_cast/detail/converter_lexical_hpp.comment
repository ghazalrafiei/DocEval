['text':' Copyright Kevlin Henney, 2000-2005.','line_number':1,'multiline':False]['text':' Copyright Alexander Nasonov, 2006-2010.','line_number':2,'multiline':False]['text':' Copyright Antony Polukhin, 2011-2022.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' what:  lexical_cast custom keyword cast','line_number':9,'multiline':False]['text':' who:   contributed by Kevlin Henney,','line_number':10,'multiline':False]['text':'        enhanced with contributions from Terje Slettebo,','line_number':11,'multiline':False]['text':'        with additional fixes and suggestions from Gennaro Prota,','line_number':12,'multiline':False]['text':'        Beman Dawes, Dave Abrahams, Daryle Walker, Peter Dimov,','line_number':13,'multiline':False]['text':'        Alexander Nasonov, Antony Polukhin, Justin Viiret, Michael Hofmann,','line_number':14,'multiline':False]['text':'        Cheng Yang, Matthew Bradbury, David W. Birdsall, Pavel Korzh and other Boosters','line_number':15,'multiline':False]['text':' when:  November 2000, March 2003, June 2005, June 2006, March 2011 - 2014','line_number':16,'multiline':False]['text':' normalize_single_byte_char<Char>','line_number':58,'multiline':False]['text':' Converts signed/unsigned char to char','line_number':60,'multiline':False]['text':' deduce_character_type_later<T>','line_number':80,'multiline':False]['text':' Helper type, meaning that stram character for T must be deduced','line_number':82,'multiline':False]['text':' at Stage 2 (See deduce_source_char<T> and deduce_target_char<T>)','line_number':83,'multiline':False]['text':' stream_char_common<T>','line_number':87,'multiline':False]['text':' Selectors to choose stream character type (common for Source and Target)','line_number':89,'multiline':False]['text':' Returns one of char, wchar_t, char16_t, char32_t or deduce_character_type_later<T> types','line_number':90,'multiline':False]['text':' Executed on Stage 1 (See deduce_source_char<T> and deduce_target_char<T>)','line_number':91,'multiline':False]['text':' deduce_source_char_impl<T>','line_number':183,'multiline':False]['text':' If type T is `deduce_character_type_later` type, then tries to deduce','line_number':185,'multiline':False]['text':' character type using boost::has_left_shift<T> metafunction.','line_number':186,'multiline':False]['text':' Otherwise supplied type T is a character type, that must be normalized','line_number':187,'multiline':False]['text':' using normalize_single_byte_char<Char>.','line_number':188,'multiline':False]['text':' Executed at Stage 2  (See deduce_source_char<T> and deduce_target_char<T>)','line_number':189,'multiline':False]['text':' deduce_target_char_impl<T>','line_number':216,'multiline':False]['text':' If type T is `deduce_character_type_later` type, then tries to deduce','line_number':218,'multiline':False]['text':' character type using boost::has_right_shift<T> metafunction.','line_number':219,'multiline':False]['text':' Otherwise supplied type T is a character type, that must be normalized','line_number':220,'multiline':False]['text':' using normalize_single_byte_char<Char>.','line_number':221,'multiline':False]['text':' Executed at Stage 2  (See deduce_source_char<T> and deduce_target_char<T>)','line_number':222,'multiline':False]['text':' deduce_target_char<T> and deduce_source_char<T>','line_number':249,'multiline':False]['text':' We deduce stream character types in two stages.','line_number':251,'multiline':False]['text':'','line_number':252,'multiline':False]['text':' Stage 1 is common for Target and Source. At Stage 1 we get','line_number':253,'multiline':False]['text':' non normalized character type (may contain unsigned/signed char)','line_number':254,'multiline':False]['text':' or deduce_character_type_later<T> where T is the original type.','line_number':255,'multiline':False]['text':' Stage 1 is executed by stream_char_common<T>','line_number':256,'multiline':False]['text':'','line_number':257,'multiline':False]['text':' At Stage 2 we normalize character types or try to deduce character','line_number':258,'multiline':False]['text':' type using metafunctions.','line_number':259,'multiline':False]['text':' Stage 2 is executed by deduce_target_char_impl<T> and','line_number':260,'multiline':False]['text':' deduce_source_char_impl<T>','line_number':261,'multiline':False]['text':'','line_number':262,'multiline':False]['text':' deduce_target_char<T> and deduce_source_char<T> functions combine','line_number':263,'multiline':False]['text':' both stages','line_number':264,'multiline':False]['text':' extract_char_traits template','line_number':285,'multiline':False]['text':' We are attempting to get char_traits<> from T','line_number':287,'multiline':False]['text':' template parameter. Otherwise we'll be using std::char_traits<Char>','line_number':288,'multiline':False]['text':' array_to_pointer_decay<T>','line_number':311,'multiline':False]['text':' lcast_src_length','line_number':326,'multiline':False]['text':' Return max. length of string representation of Source;','line_number':328,'multiline':False]['text':' Source type of lexical_cast.','line_number':329,'multiline':False]['text':' helper type','line_number':330,'multiline':False]['text':' Helper for integral types.','line_number':337,'multiline':False]['text':' Notes on length calculation:','line_number':338,'multiline':False]['text':' Max length for 32bit int with grouping "\1" and thousands_sep ',':','line_number':339,'multiline':False]['text':' "-2,1,4,7,4,8,3,6,4,7"','line_number':340,'multiline':False]['text':'  ^                    - is_signed','line_number':341,'multiline':False]['text':'   ^                   - 1 digit not counted by digits10','line_number':342,'multiline':False]['text':'    ^^^^^^^^^^^^^^^^^^ - digits10 * 2','line_number':343,'multiline':False]['text':'','line_number':344,'multiline':False]['text':' Constant is_specialized is used instead of constant 1','line_number':345,'multiline':False]['text':' to prevent buffer overflow in a rare case when','line_number':346,'multiline':False]['text':' <boost/limits.hpp> doesn't add missing specialization for','line_number':347,'multiline':False]['text':' numeric_limits<T> for some integral type T.','line_number':348,'multiline':False]['text':' When is_specialized is false, the whole expression is 0.','line_number':349,'multiline':False]['text':' == 1 ','line_number':358,'multiline':True]['text':' Helper for floating point types.','line_number':367,'multiline':False]['text':' -1.23456789e-123456','line_number':368,'multiline':False]['text':' ^                   sign','line_number':369,'multiline':False]['text':'  ^                  leading digit','line_number':370,'multiline':False]['text':'   ^                 decimal point','line_number':371,'multiline':False]['text':'    ^^^^^^^^         lcast_precision<Source>::value','line_number':372,'multiline':False]['text':'            ^        "e"','line_number':373,'multiline':False]['text':'             ^       exponent sign','line_number':374,'multiline':False]['text':'              ^^^^^^ exponent (assumed 6 or less digits)','line_number':375,'multiline':False]['text':' sign + leading digit + decimal point + "e" + exponent sign == 5','line_number':376,'multiline':False]['text':' #ifndef BOOST_LCAST_NO_COMPILE_TIME_PRECISION','line_number':392,'multiline':False]['text':' #ifndef BOOST_LCAST_NO_COMPILE_TIME_PRECISION','line_number':394,'multiline':False]['text':' lexical_cast_stream_traits<Source, Target>','line_number':398,'multiline':False]['text':' source is not a wide character based type','line_number':432,'multiline':False]['text':' target type is based on wide character','line_number':433,'multiline':False]['text':' if we did not get character type at stage1','line_number':441,'multiline':False]['text':' then we have no optimization for that type','line_number':442,'multiline':False]['text':' If we have an optimized conversion for','line_number':446,'multiline':False]['text':' Source, we do not need to construct stringbuf.','line_number':447,'multiline':False]['text':' Disabling ADL, by directly specifying operators.','line_number':478,'multiline':False]['text':' Disabling ADL, by directly specifying operators.','line_number':484,'multiline':False]['text':' namespace boost','line_number':493,'multiline':False]['text':' BOOST_LEXICAL_CAST_DETAIL_CONVERTER_LEXICAL_HPP','line_number':497,'multiline':False]