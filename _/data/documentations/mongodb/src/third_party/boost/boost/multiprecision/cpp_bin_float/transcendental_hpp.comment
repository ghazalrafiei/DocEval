['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2013 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]['text':'','line_number':17,'multiline':False]['text':' Taylor series for small argument, note returns exp(x) - 1:','line_number':18,'multiline':False]['text':'','line_number':19,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' This is based on MPFR's method, let:','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' n = floor(x / ln(2))','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' Then:','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':' r = x - n ln(2) : 0 <= r < ln(2)','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' We can reduce r further by dividing by 2^k, with k ~ sqrt(n),','line_number':48,'multiline':False]['text':' so if:','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' e0 = exp(r / 2^k) - 1','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' With e0 evaluated by taylor series for small arguments, then:','line_number':53,'multiline':False]['text':'','line_number':54,'multiline':False]['text':' exp(x) = 2^n (1 + e0)^2^k','line_number':55,'multiline':False]['text':'','line_number':56,'multiline':False]['text':' Note that to preserve precision we actually square (1 + e0) k times, calculating','line_number':57,'multiline':False]['text':' the result less one each time, i.e.','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':' (1 + e0)^2 - 1 = e0^2 + 2e0','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' Then add the final 1 at the end, given that e0 is small, this effectively wipes','line_number':62,'multiline':False]['text':' out the error in the last step.','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':' There are some rare cases where the multiply rounds down leaving a remainder > ln2','line_number':112,'multiline':False]['text':' See https://github.com/boostorg/multiprecision/issues/120','line_number':113,'multiline':False]['text':' There are some very rare cases where arg/ln2 is an integer, and the subsequent multiply','line_number':119,'multiline':False]['text':' rounds up, in that situation t ends up negative at this point which breaks our invariants below:','line_number':120,'multiline':False]['text':' The result will necessarily oveflow:','line_number':129,'multiline':False]['text':'','line_number':141,'multiline':False]['text':' Square 1 + res k times:','line_number':142,'multiline':False]['text':'','line_number':143,'multiline':False]['text':' namespace boost::multiprecision::backends','line_number':155,'multiline':False]