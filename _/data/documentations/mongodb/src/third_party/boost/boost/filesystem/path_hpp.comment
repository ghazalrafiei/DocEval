['text':'  filesystem path.hpp  ---------------------------------------------------------------//','line_number':1,'multiline':False]['text':'  Copyright Vladimir Prus 2002','line_number':3,'multiline':False]['text':'  Copyright Beman Dawes 2002-2005, 2009','line_number':4,'multiline':False]['text':'  Copyright Andrey Semashev 2021','line_number':5,'multiline':False]['text':'  Distributed under the Boost Software License, Version 1.0.','line_number':7,'multiline':False]['text':'  See http://www.boost.org/LICENSE_1_0.txt','line_number':8,'multiline':False]['text':'  Library home page: http://www.boost.org/libs/filesystem','line_number':10,'multiline':False]['text':'  path::stem(), extension(), and replace_extension() are based on','line_number':12,'multiline':False]['text':'  basename(), extension(), and change_extension() from the original','line_number':13,'multiline':False]['text':'  filesystem/convenience.hpp header by Vladimir Prus.','line_number':14,'multiline':False]['text':' includes <cwchar>','line_number':21,'multiline':False]['text':' for mbstate_t','line_number':34,'multiline':False]['text':' must be the last #include','line_number':41,'multiline':False]['text':' intentionally don't use filesystem::detail to not bring internal Boost.Filesystem functions into ADL via path_constants','line_number':48,'multiline':False]['text':' A struct that denotes a contiguous range of characters in a string. A lightweight alternative to string_view.','line_number':72,'multiline':False]['text':' defined(BOOST_WINDOWS_API)','line_number':87,'multiline':False]['text':' defined(BOOST_WINDOWS_API)','line_number':92,'multiline':False]['text':' defined(BOOST_WINDOWS_API)','line_number':110,'multiline':False]['text':' defined(BOOST_WINDOWS_API)','line_number':117,'multiline':False]['text':' namespace path_detail','line_number':124,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':126,'multiline':False]['text':'                                                                                    //','line_number':127,'multiline':False]['text':'                                    class path                                      //','line_number':128,'multiline':False]['text':'                                                                                    //','line_number':129,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':130,'multiline':False]['text':'  value_type is the character type used by the operating system API to','line_number':142,'multiline':False]['text':'  represent paths.','line_number':143,'multiline':False]['text':'  ----- character encoding conversions -----','line_number':149,'multiline':False]['text':'  Following the principle of least astonishment, path input arguments','line_number':151,'multiline':False]['text':'  passed to or obtained from the operating system via objects of','line_number':152,'multiline':False]['text':'  class path behave as if they were directly passed to or','line_number':153,'multiline':False]['text':'  obtained from the O/S API, unless conversion is explicitly requested.','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':'  POSIX specfies that path strings are passed unchanged to and from the','line_number':156,'multiline':False]['text':'  API. Note that this is different from the POSIX command line utilities,','line_number':157,'multiline':False]['text':'  which convert according to a locale.','line_number':158,'multiline':False]['text':'','line_number':159,'multiline':False]['text':'  Thus for POSIX, char strings do not undergo conversion.  wchar_t strings','line_number':160,'multiline':False]['text':'  are converted to/from char using the path locale or, if a conversion','line_number':161,'multiline':False]['text':'  argument is given, using a conversion object modeled on','line_number':162,'multiline':False]['text':'  std::wstring_convert.','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':'  The path locale, which is global to the thread, can be changed by the','line_number':165,'multiline':False]['text':'  imbue() function. It is initialized to an implementation defined locale.','line_number':166,'multiline':False]['text':'','line_number':167,'multiline':False]['text':'  For Windows, wchar_t strings do not undergo conversion. char strings','line_number':168,'multiline':False]['text':'  are converted using the "ANSI" or "OEM" code pages, as determined by','line_number':169,'multiline':False]['text':'  the AreFileApisANSI() function, or, if a conversion argument is given,','line_number':170,'multiline':False]['text':'  using a conversion object modeled on std::wstring_convert.','line_number':171,'multiline':False]['text':'','line_number':172,'multiline':False]['text':'  See m_pathname comments for further important rationale.','line_number':173,'multiline':False]['text':'  TODO: rules needed for operating systems that use / or .','line_number':175,'multiline':False]['text':'  differently, or format directory paths differently from file paths.','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':'  **********************************************************************************','line_number':178,'multiline':False]['text':'','line_number':179,'multiline':False]['text':'  More work needed: How to handle an operating system that may have','line_number':180,'multiline':False]['text':'  slash characters or dot characters in valid filenames, either because','line_number':181,'multiline':False]['text':'  it doesn't follow the POSIX standard, or because it allows MBCS','line_number':182,'multiline':False]['text':'  filename encodings that may contain slash or dot characters. For','line_number':183,'multiline':False]['text':'  example, ISO/IEC 2022 (JIS) encoding which allows switching to','line_number':184,'multiline':False]['text':'  JIS x0208-1983 encoding. A valid filename in this set of encodings is','line_number':185,'multiline':False]['text':'  0x1B 0x24 0x42 [switch to X0208-1983] 0x24 0x2F [U+304F Kiragana letter KU]','line_number':186,'multiline':False]['text':'                                             ^^^^','line_number':187,'multiline':False]['text':'  Note that 0x2F is the ASCII slash character','line_number':188,'multiline':False]['text':'','line_number':189,'multiline':False]['text':'  **********************************************************************************','line_number':190,'multiline':False]['text':'  Supported source arguments: half-open iterator range, container, c-array,','line_number':192,'multiline':False]['text':'  and single pointer to null terminated string.','line_number':193,'multiline':False]['text':'  All source arguments except pointers to null terminated byte strings support','line_number':195,'multiline':False]['text':'  multi-byte character strings which may have embedded nulls. Embedded null','line_number':196,'multiline':False]['text':'  support is required for some Asian languages on Windows.','line_number':197,'multiline':False]['text':'  "const codecvt_type& cvt=codecvt()" default arguments are not used because this','line_number':199,'multiline':False]['text':'  limits the impact of locale("") initialization failures on POSIX systems to programs','line_number':200,'multiline':False]['text':'  that actually depend on locale(""). It further ensures that exceptions thrown','line_number':201,'multiline':False]['text':'  as a result of such failues occur after main() has started, so can be caught.','line_number':202,'multiline':False]['text':'  -----  constructors  -----','line_number':204,'multiline':False]['text':'  As of October 2015 the interaction between noexcept and =default is so troublesome','line_number':220,'multiline':False]['text':'  for VC++, GCC, and probably other compilers, that =default is not used with noexcept','line_number':221,'multiline':False]['text':'  functions. GCC is not even consistent for the same release on different platforms.','line_number':222,'multiline':False]['text':' convert requires contiguous string, so copy','line_number':289,'multiline':False]['text':' convert requires contiguous string, so copy','line_number':302,'multiline':False]['text':'  -----  assignments  -----','line_number':308,'multiline':False]['text':' We need to explicitly define copy assignment as otherwise it will be implicitly defined as deleted because there is move assignment','line_number':310,'multiline':False]['text':'  -----  concatenation  -----','line_number':431,'multiline':False]['text':'  -----  appends  -----','line_number':565,'multiline':False]['text':'  if a separator is added, it is the preferred separator for the platform;','line_number':567,'multiline':False]['text':'  slash for POSIX, backslash for Windows','line_number':568,'multiline':False]['text':'  -----  modifiers  -----','line_number':690,'multiline':False]['text':' No effect on POSIX','line_number':696,'multiline':False]['text':' BOOST_WINDOWS_API','line_number':699,'multiline':False]['text':' change slashes to backslashes','line_number':700,'multiline':False]['text':'  -----  observers  -----','line_number':711,'multiline':False]['text':'  For operating systems that format file paths differently than directory','line_number':713,'multiline':False]['text':'  paths, return values from observers are formatted as file names unless there','line_number':714,'multiline':False]['text':'  is a trailing separator, in which case returns are formatted as directory','line_number':715,'multiline':False]['text':'  paths. POSIX and Windows make no such distinction.','line_number':716,'multiline':False]['text':'  Implementations are permitted to return const values or const references.','line_number':718,'multiline':False]['text':'  The string or path returned by an observer are specified as being formatted','line_number':720,'multiline':False]['text':'  as "native" or "generic".','line_number':721,'multiline':False]['text':'','line_number':722,'multiline':False]['text':'  For POSIX, these are all the same format; slashes and backslashes are as input and','line_number':723,'multiline':False]['text':'  are not modified.','line_number':724,'multiline':False]['text':'','line_number':725,'multiline':False]['text':'  For Windows,   native:    as input; slashes and backslashes are not modified;','line_number':726,'multiline':False]['text':'                            this is the format of the internally stored string.','line_number':727,'multiline':False]['text':'                 generic:   backslashes are converted to slashes','line_number':728,'multiline':False]['text':'  -----  native format observers  -----','line_number':730,'multiline':False]['text':'  string_type is std::wstring, so there is no conversion','line_number':758,'multiline':False]['text':' BOOST_POSIX_API','line_number':761,'multiline':False]['text':'  string_type is std::string, so there is no conversion','line_number':762,'multiline':False]['text':'  -----  generic format observers  -----','line_number':782,'multiline':False]['text':'  Experimental generic function returning generic formatted path (i.e. separators','line_number':784,'multiline':False]['text':'  are forward slashes). Motivation: simpler than a family of generic_*string','line_number':785,'multiline':False]['text':'  functions.','line_number':786,'multiline':False]['text':' BOOST_POSIX_API','line_number':804,'multiline':False]['text':'  On POSIX-like systems, the generic format is the same as the native format','line_number':805,'multiline':False]['text':'  -----  compare  -----','line_number':812,'multiline':False]['text':' generic, lexicographical','line_number':814,'multiline':False]['text':'  -----  decomposition  -----','line_number':821,'multiline':False]['text':' returns 0 or 1 element path even on POSIX, root_name() is non-empty() for network paths','line_number':824,'multiline':False]['text':' returns 0 or 1 element path','line_number':827,'multiline':False]['text':' returns 0 or 1 element path','line_number':844,'multiline':False]['text':' returns 0 or 1 element path','line_number':845,'multiline':False]['text':' returns 0 or 1 element path','line_number':846,'multiline':False]['text':'  -----  query  -----','line_number':848,'multiline':False]['text':' Windows CE has no root name (aka drive letters)','line_number':864,'multiline':False]['text':'  -----  lexical operations  -----','line_number':872,'multiline':False]['text':'  -----  iterators  -----','line_number':882,'multiline':False]['text':'  -----  static member functions  -----','line_number':895,'multiline':False]['text':'  -----  deprecated functions  -----','line_number':900,'multiline':False]['text':'  recently deprecated functions supplied by default','line_number':903,'multiline':False]['text':'  deprecated functions with enough signature or semantic changes that they are','line_number':920,'multiline':False]['text':'  not supplied by default','line_number':921,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':930,'multiline':False]['text':'                            class path private members                                //','line_number':931,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':932,'multiline':False]['text':'  Returns: If separator is to be appended, m_pathname.size() before append. Otherwise 0.','line_number':969,'multiline':False]['text':'  Note: An append is never performed if size()==0, so a returned 0 is unambiguous.','line_number':970,'multiline':False]['text':'
     * m_pathname has the type, encoding, and format required by the native
     * operating system. Thus for POSIX and Windows there is no conversion for
     * passing m_pathname.c_str() to the O/S API or when obtaining a path from the
     * O/S API. POSIX encoding is unspecified other than for dot and slash
     * characters; POSIX just treats paths as a sequence of bytes. Windows
     * encoding is UCS-2 or UTF-16 depending on the version.
     ','line_number':983,'multiline':True]['text':' Windows: as input; backslashes NOT converted to slashes,','line_number':991,'multiline':False]['text':' slashes NOT converted to backslashes','line_number':992,'multiline':False]['text':' namespace detail','line_number':1000,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1006,'multiline':False]['text':'                             class path::iterator                                   //','line_number':1007,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1008,'multiline':False]['text':' current element','line_number':1040,'multiline':False]['text':' path being iterated over','line_number':1042,'multiline':False]['text':' position of m_element in m_path_ptr->m_pathname.','line_number':1044,'multiline':False]['text':' if m_element is implicit dot, m_pos is the','line_number':1045,'multiline':False]['text':' position of the last separator in the path.','line_number':1046,'multiline':False]['text':' end() iterator is indicated by','line_number':1047,'multiline':False]['text':' m_pos == m_path_ptr->m_pathname.size()','line_number':1048,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1052,'multiline':False]['text':'                         class path::reverse_iterator                               //','line_number':1053,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1054,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1099,'multiline':False]['text':'                                                                                    //','line_number':1100,'multiline':False]['text':'                              non-member functions                                  //','line_number':1101,'multiline':False]['text':'                                                                                    //','line_number':1102,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1103,'multiline':False]['text':'  std::lexicographical_compare would infinitely recurse because path iterators','line_number':1105,'multiline':False]['text':'  yield paths, so provide a path aware version','line_number':1106,'multiline':False]['text':' TODO: why do == and != have additional overloads, but the others don't?','line_number':1162,'multiline':False]['text':' Note: Declared as a template to delay binding to Boost.ContainerHash functions and make the dependency optional','line_number':1181,'multiline':False]['text':' BOOST_POSIX_API','line_number':1190,'multiline':False]['text':'  inserters and extractors','line_number':1215,'multiline':False]['text':'    use boost::io::quoted() to handle spaces in paths','line_number':1216,'multiline':False]['text':'    use '&' as escape character to ease use for Windows paths','line_number':1217,'multiline':False]['text':'  name_checks','line_number':1236,'multiline':False]['text':'  These functions are holdovers from version 1. It isn't clear they have much','line_number':1238,'multiline':False]['text':'  usefulness, or how to generalize them for later versions.','line_number':1239,'multiline':False]['text':'  For POSIX, is_directory_separator() and is_element_separator() are identical since','line_number':1250,'multiline':False]['text':'  a forward slash is the only valid directory separator and also the only valid','line_number':1251,'multiline':False]['text':'  element separator. For Windows, forward slash and back slash are the possible','line_number':1252,'multiline':False]['text':'  directory separators, but colon (example: "c:foo") is also an element separator.','line_number':1253,'multiline':False]['text':' namespace detail','line_number':1272,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1274,'multiline':False]['text':'                  class path miscellaneous function implementations                 //','line_number':1275,'multiline':False]['text':'------------------------------------------------------------------------------------//','line_number':1276,'multiline':False]['text':' implicit dot is tricky, so actually call filename(); see path::filename() example','line_number':1289,'multiline':False]['text':' in reference.html','line_number':1290,'multiline':False]['text':' use detail::is_element_separator() rather than detail::is_directory_separator','line_number':1298,'multiline':False]['text':' to deal with "c:.." edge case on Windows when ':' acts as a separator','line_number':1299,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':1302,'multiline':False]['text':'                     class path member template specializations                       //','line_number':1303,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':1304,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':1354,'multiline':False]['text':'                     path_traits convert function implementations                     //','line_number':1355,'multiline':False]['text':'                        requiring path::codecvt() be visable                          //','line_number':1356,'multiline':False]['text':'--------------------------------------------------------------------------------------//','line_number':1357,'multiline':False]['text':'  without codecvt','line_number':1359,'multiline':False]['text':' 0 for null terminated MBCS','line_number':1362,'multiline':False]['text':' 0 for null terminated MBCS','line_number':1369,'multiline':False]['text':' namespace path_traits','line_number':1387,'multiline':False]['text':' namespace filesystem','line_number':1388,'multiline':False]['text':' namespace boost','line_number':1389,'multiline':False]['text':'----------------------------------------------------------------------------//','line_number':1391,'multiline':False]['text':' BOOST_FILESYSTEM_PATH_HPP','line_number':1395,'multiline':False]