['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2011-2013. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See http://www.boost.org/libs/container for documentation.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]['text':'! <b>Remark</b>: if a specialization constructible_with_allocator_suffix<X>::value is true, indicates that T may be constructed','line_number':20,'multiline':False]['text':'! with an allocator as its last constructor argument.  Ideally, all constructors of T (including the','line_number':21,'multiline':False]['text':'! copy and move constructors) should have a variant that accepts a final argument of','line_number':22,'multiline':False]['text':'! allocator_type.','line_number':23,'multiline':False]['text':'!','line_number':24,'multiline':False]['text':'! <b>Requires</b>: if a specialization constructible_with_allocator_suffix<X>::value is true, T must have a nested type,','line_number':25,'multiline':False]['text':'! allocator_type and at least one constructor for which allocator_type is the last','line_number':26,'multiline':False]['text':'! parameter.  If not all constructors of T can be called with a final allocator_type argument,','line_number':27,'multiline':False]['text':'! and if T is used in a context where a container must call such a constructor, then the program is','line_number':28,'multiline':False]['text':'! ill-formed.','line_number':29,'multiline':False]['text':'!','line_number':30,'multiline':False]['text':'! <code>','line_number':31,'multiline':False]['text':'!  template <class T, class Allocator = allocator<T> >','line_number':32,'multiline':False]['text':'!  class Z {','line_number':33,'multiline':False]['text':'!    public:','line_number':34,'multiline':False]['text':'!      typedef Allocator allocator_type;','line_number':35,'multiline':False]['text':'!','line_number':36,'multiline':False]['text':'!    // Default constructor with optional allocator suffix','line_number':37,'multiline':False]['text':'!    Z(const allocator_type& a = allocator_type());','line_number':38,'multiline':False]['text':'!','line_number':39,'multiline':False]['text':'!    // Copy constructor and allocator-extended copy constructor','line_number':40,'multiline':False]['text':'!    Z(const Z& zz);','line_number':41,'multiline':False]['text':'!    Z(const Z& zz, const allocator_type& a);','line_number':42,'multiline':False]['text':'! };','line_number':43,'multiline':False]['text':'!','line_number':44,'multiline':False]['text':'! // Specialize trait for class template Z','line_number':45,'multiline':False]['text':'! template <class T, class Allocator = allocator<T> >','line_number':46,'multiline':False]['text':'! struct constructible_with_allocator_suffix<Z<T,Allocator> >','line_number':47,'multiline':False]['text':'! { static const bool value = true;  };','line_number':48,'multiline':False]['text':'! </code>','line_number':49,'multiline':False]['text':'!','line_number':50,'multiline':False]['text':'! <b>Note</b>: This trait is a workaround inspired by "N2554: The Scoped A Model (Rev 2)"','line_number':51,'multiline':False]['text':'! (Pablo Halpern, 2008-02-29) to backport the scoped allocator model to C++03, as','line_number':52,'multiline':False]['text':'! in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments.','line_number':53,'multiline':False]['text':'! Applications aiming portability with several compilers should always define this trait.','line_number':54,'multiline':False]['text':'!','line_number':55,'multiline':False]['text':'! In conforming C++11 compilers or compilers supporting SFINAE expressions','line_number':56,'multiline':False]['text':'! (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used','line_number':57,'multiline':False]['text':'! to detect if a type should be constructed with suffix or prefix allocator arguments.','line_number':58,'multiline':False]['text':'! <b>Remark</b>: if a specialization constructible_with_allocator_prefix<X>::value is true, indicates that T may be constructed','line_number':63,'multiline':False]['text':'! with allocator_arg and T::allocator_type as its first two constructor arguments.','line_number':64,'multiline':False]['text':'! Ideally, all constructors of T (including the copy and move constructors) should have a variant','line_number':65,'multiline':False]['text':'! that accepts these two initial arguments.','line_number':66,'multiline':False]['text':'!','line_number':67,'multiline':False]['text':'! <b>Requires</b>: specialization constructible_with_allocator_prefix<X>::value is true, T must have a nested type,','line_number':68,'multiline':False]['text':'! allocator_type and at least one constructor for which allocator_arg_t is the first','line_number':69,'multiline':False]['text':'! parameter and allocator_type is the second parameter.  If not all constructors of T can be','line_number':70,'multiline':False]['text':'! called with these initial arguments, and if T is used in a context where a container must call such','line_number':71,'multiline':False]['text':'! a constructor, then the program is ill-formed.','line_number':72,'multiline':False]['text':'!','line_number':73,'multiline':False]['text':'! <code>','line_number':74,'multiline':False]['text':'! template <class T, class Allocator = allocator<T> >','line_number':75,'multiline':False]['text':'! class Y {','line_number':76,'multiline':False]['text':'!    public:','line_number':77,'multiline':False]['text':'!       typedef Allocator allocator_type;','line_number':78,'multiline':False]['text':'!','line_number':79,'multiline':False]['text':'!       // Default constructor with and allocator-extended default constructor','line_number':80,'multiline':False]['text':'!       Y();','line_number':81,'multiline':False]['text':'!       Y(allocator_arg_t, const allocator_type& a);','line_number':82,'multiline':False]['text':'!','line_number':83,'multiline':False]['text':'!       // Copy constructor and allocator-extended copy constructor','line_number':84,'multiline':False]['text':'!       Y(const Y& yy);','line_number':85,'multiline':False]['text':'!       Y(allocator_arg_t, const allocator_type& a, const Y& yy);','line_number':86,'multiline':False]['text':'!','line_number':87,'multiline':False]['text':'!       // Variadic constructor and allocator-extended variadic constructor','line_number':88,'multiline':False]['text':'!       template<class ...Args> Y(Args&& args...);','line_number':89,'multiline':False]['text':'!       template<class ...Args>','line_number':90,'multiline':False]['text':'!       Y(allocator_arg_t, const allocator_type& a, BOOST_FWD_REF(Args)... args);','line_number':91,'multiline':False]['text':'! };','line_number':92,'multiline':False]['text':'!','line_number':93,'multiline':False]['text':'! // Specialize trait for class template Y','line_number':94,'multiline':False]['text':'! template <class T, class Allocator = allocator<T> >','line_number':95,'multiline':False]['text':'! struct constructible_with_allocator_prefix<Y<T,Allocator> >','line_number':96,'multiline':False]['text':'! { static const bool value = true;  };','line_number':97,'multiline':False]['text':'!','line_number':98,'multiline':False]['text':'! </code>','line_number':99,'multiline':False]['text':'!','line_number':100,'multiline':False]['text':'! <b>Note</b>: This trait is a workaround inspired by "N2554: The Scoped Allocator Model (Rev 2)"','line_number':101,'multiline':False]['text':'! (Pablo Halpern, 2008-02-29) to backport the scoped allocator model to C++03, as','line_number':102,'multiline':False]['text':'! in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments.','line_number':103,'multiline':False]['text':'! Applications aiming portability with several compilers should always define this trait.','line_number':104,'multiline':False]['text':'!','line_number':105,'multiline':False]['text':'! In conforming C++11 compilers or compilers supporting SFINAE expressions','line_number':106,'multiline':False]['text':'! (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used','line_number':107,'multiline':False]['text':'! to detect if a type should be constructed with suffix or prefix allocator arguments.','line_number':108,'multiline':False]['text':' Use SFINAE (Substitution Failure Is Not An Error) to detect the','line_number':120,'multiline':False]['text':' presence of an 'allocator_type' nested type convertilble from Allocator.','line_number':121,'multiline':False]['text':' Match this function if T::allocator_type exists and is','line_number':126,'multiline':False]['text':' implicitly convertible from Allocator','line_number':127,'multiline':False]['text':' Match this function if T::allocator_type exists and it's type is `erased_type`.','line_number':131,'multiline':False]['text':' Match this function if TypeT::allocator_type does not exist or is','line_number':138,'multiline':False]['text':' not convertible from Allocator.','line_number':139,'multiline':False]['text':' Declared but not defined','line_number':142,'multiline':False]['text':'namespace dtl {','line_number':148,'multiline':False]['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':150,'multiline':False]['text':'! <b>Remark</b>: Automatically detects whether T has a nested allocator_type that is convertible from','line_number':152,'multiline':False]['text':'! Allocator. Meets the BinaryTypeTrait requirements ([meta.rqmts] 20.4.1). A program may','line_number':153,'multiline':False]['text':'! specialize this type to define uses_allocator<X>::value as true for a T of user-defined type if T does not','line_number':154,'multiline':False]['text':'! have a nested allocator_type but is nonetheless constructible using the specified Allocator where either:','line_number':155,'multiline':False]['text':'! the first argument of a constructor has type allocator_arg_t and the second argument has type Alloc or','line_number':156,'multiline':False]['text':'! the last argument of a constructor has type Alloc.','line_number':157,'multiline':False]['text':'!','line_number':158,'multiline':False]['text':'! <b>Result</b>: uses_allocator<T, Allocator>::value== true if a type T::allocator_type','line_number':159,'multiline':False]['text':'! exists and either is_convertible<Alloc, T::allocator_type>::value != false or T::allocator_type','line_number':160,'multiline':False]['text':'! is an alias `erased_type`. False otherwise.','line_number':161,'multiline':False]['text':'namespace boost::container','line_number':167,'multiline':False]['text':'BOOST_CONTAINER_USES_ALLOCATOR_HPP','line_number':169,'multiline':False]