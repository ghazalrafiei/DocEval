['text':'  (C) Copyright John Maddock 2000.','line_number':1,'multiline':False]['text':'  Use, modification and distribution are subject to the Boost Software License,','line_number':2,'multiline':False]['text':'  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at','line_number':3,'multiline':False]['text':'  http://www.boost.org/LICENSE_1_0.txt).','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':'  See http://www.boost.org/libs/type_traits for most recent version including documentation.','line_number':6,'multiline':False]['text':' size_t','line_number':15,'multiline':False]['text':' alignment is sensitive to packing','line_number':20,'multiline':False]['text':' namespace detail','line_number':78,'multiline':False]['text':'','line_number':116,'multiline':False]['text':' MSVC supports types which have alignments greater than the normal','line_number':117,'multiline':False]['text':' maximum: these are used for example in the types __m64 and __m128','line_number':118,'multiline':False]['text':' to provide types with alignment requirements which match the SSE','line_number':119,'multiline':False]['text':' registers.  Therefore we extend type_with_alignment<> to support','line_number':120,'multiline':False]['text':' such types, however, we have to be careful to use a builtin type','line_number':121,'multiline':False]['text':' whenever possible otherwise we break previously working code:','line_number':122,'multiline':False]['text':' see https://lists.boost.org/Archives/boost/2014/03/212391.php','line_number':123,'multiline':False]['text':' for an example and test case.  Thus types like a8 below will','line_number':124,'multiline':False]['text':' be used *only* if the existing implementation can't provide a type','line_number':125,'multiline':False]['text':' with suitable alignment.  This does mean however, that type_with_alignment<>','line_number':126,'multiline':False]['text':' may return a type which cannot be passed through a function call','line_number':127,'multiline':False]['text':' by value (and neither can any type containing such a type like','line_number':128,'multiline':False]['text':' Boost.Optional).  However, this only happens when we have no choice ','line_number':129,'multiline':False]['text':' in the matter because no other "ordinary" type is available.','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'','line_number':210,'multiline':False]['text':' Borland specific version, we have this for two reasons:','line_number':211,'multiline':False]['text':' 1) The version above doesn't always compile (with the new test cases for example)','line_number':212,'multiline':False]['text':' 2) Because of Borlands #pragma option we can create types with alignments that are','line_number':213,'multiline':False]['text':'    greater that the largest aligned builtin type.','line_number':214,'multiline':False]['text':'#if ! BOOST_WORKAROUND(BOOST_CODEGEARC, BOOST_TESTED_AT(0x610))','line_number':230,'multiline':False]['text':'#endif','line_number':235,'multiline':False]['text':' We should never get to here, but if we do use the maximally','line_number':239,'multiline':False]['text':' aligned type:','line_number':240,'multiline':False]['text':' BOOST_STATIC_ASSERT(0);','line_number':241,'multiline':False]['text':' namespace boost','line_number':252,'multiline':False]['text':' BOOST_TT_TYPE_WITH_ALIGNMENT_INCLUDED','line_number':258,'multiline':False]