['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2012-20 John Maddock. ','line_number':2,'multiline':False]['text':'  Copyright 2019-20 Christopher Kormanyos. ','line_number':3,'multiline':False]['text':'  Copyright 2019-20 Madhur Chauhan. ','line_number':4,'multiline':False]['text':'  Distributed under the Boost Software License, Version 1.0.','line_number':5,'multiline':False]['text':'  (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':' Comparison operators for cpp_int_backend:','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' conditional expression is constant','line_number':23,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' Multiplication by a single limb:','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' resize_for_carry forces a resize of the underlying buffer only if a previous request','line_number':70,'multiline':False]['text':' for "required" elements could possibly have failed, *and* we have checking enabled.','line_number':71,'multiline':False]['text':' This will cause an overflow error inside resize():','line_number':72,'multiline':False]['text':'','line_number':73,'multiline':False]['text':'result','line_number':75,'multiline':True]['text':'required','line_number':75,'multiline':True]['text':'','line_number':83,'multiline':False]['text':' Minimum number of limbs required for Karatsuba to be worthwhile:','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':'','line_number':91,'multiline':False]['text':' Core (recursive) Karatsuba multiplication, all the storage required is allocated upfront and ','line_number':92,'multiline':False]['text':' passed down the stack in this routine.  Note that all the cpp_int_backend's must be the same type','line_number':93,'multiline':False]['text':' and full variable precision.  Karatsuba really doesn't play nice with fixed-size integers.  If necessary','line_number':94,'multiline':False]['text':' fixed precision integers will get aliased as variable-precision types before this is called.','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':'','line_number':108,'multiline':False]['text':' Termination condition: if either argument is smaller than karatsuba_cutoff','line_number':109,'multiline':False]['text':' then schoolboy multiplication will be faster:','line_number':110,'multiline':False]['text':'','line_number':111,'multiline':False]['text':'','line_number':117,'multiline':False]['text':' Partitioning size: split the larger of a and b into 2 halves','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':'','line_number':121,'multiline':False]['text':' Partition a and b into high and low parts.','line_number':122,'multiline':False]['text':' ie write a, b as a = a_h * 2^n + a_l, b = b_h * 2^n + b_l','line_number':123,'multiline':False]['text':'','line_number':124,'multiline':False]['text':' We could copy the high and low parts into new variables, but we'll','line_number':125,'multiline':False]['text':' use aliasing to reference the internal limbs of a and b.  There is one wart here:','line_number':126,'multiline':False]['text':' if a and b are mismatched in size, then n may be larger than the smaller','line_number':127,'multiline':False]['text':' of a and b.  In that situation the high part is zero, and we have no limbs','line_number':128,'multiline':False]['text':' to alias, so instead alias a local variable.','line_number':129,'multiline':False]['text':' This raises 2 questions:','line_number':130,'multiline':False]['text':' * Is this the best way to partition a and b?','line_number':131,'multiline':False]['text':' * Since we have one high part zero, the arithmetic simplifies considerably, ','line_number':132,'multiline':False]['text':'   so should we have a special routine for this?','line_number':133,'multiline':False]['text':' ','line_number':134,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' The basis for the Karatsuba algorithm is as follows:','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' let                x = a_h * b_ h','line_number':147,'multiline':False]['text':'                    y = a_l * b_l','line_number':148,'multiline':False]['text':'                    z = (a_h + a_l)*(b_h + b_l) - x - y','line_number':149,'multiline':False]['text':' and therefore  a * b = x * (2 ^ (2 * n))+ z * (2 ^ n) + y','line_number':150,'multiline':False]['text':'','line_number':151,'multiline':False]['text':' Begin by allocating our temporaries, these alias the memory already allocated in the shared storage:','line_number':152,'multiline':False]['text':'','line_number':153,'multiline':False]['text':'','line_number':157,'multiline':False]['text':' Now we want:','line_number':158,'multiline':False]['text':'','line_number':159,'multiline':False]['text':' result = | a_h*b_h  | a_l*b_l |','line_number':160,'multiline':False]['text':' (bits)              <-- 2*n -->','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':' We create aliases for the low and high parts of result, and multiply directly into them:','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':'','line_number':167,'multiline':False]['text':' low part of result is a_l * b_l:','line_number':168,'multiline':False]['text':'','line_number':169,'multiline':False]['text':'','line_number':171,'multiline':False]['text':' We haven't zeroed out memory in result, so set to zero any unused limbs,','line_number':172,'multiline':False]['text':' if a_l and b_l have mostly random bits then nothing happens here, but if','line_number':173,'multiline':False]['text':' one is zero or nearly so, then a memset might be faster... it's not clear','line_number':174,'multiline':False]['text':' that it's worth the extra logic though (and is darn hard to measure','line_number':175,'multiline':False]['text':' what the "average" case is).','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' Set the high part of result to a_h * b_h:','line_number':181,'multiline':False]['text':'','line_number':182,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' Now calculate (a_h+a_l)*(b_h+b_l):','line_number':187,'multiline':False]['text':'','line_number':188,'multiline':False]['text':' t1 = (a_h+a_l)*(b_h+b_l)','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' There is now a slight deviation from Karatsuba, we want to subtract','line_number':193,'multiline':False]['text':' a_l*b_l + a_h*b_h from t1, but rather than use an addition and a subtraction','line_number':194,'multiline':False]['text':' plus one temporary, we'll use 2 subtractions.  On the minus side, a subtraction','line_number':195,'multiline':False]['text':' is on average slightly slower than an addition, but we save a temporary (ie memory)','line_number':196,'multiline':False]['text':' and also hammer the same piece of memory over and over rather than 2 disparate','line_number':197,'multiline':False]['text':' memory regions.  Overall it seems to be a slight win.','line_number':198,'multiline':False]['text':'','line_number':199,'multiline':False]['text':'','line_number':202,'multiline':False]['text':' The final step is to left shift t1 by n bits and add to the result.','line_number':203,'multiline':False]['text':' Rather than do an actual left shift, we can simply alias the result','line_number':204,'multiline':False]['text':' and add to the alias:','line_number':205,'multiline':False]['text':'','line_number':206,'multiline':False]['text':'','line_number':209,'multiline':False]['text':' Free up storage for use by sister branches to this one:','line_number':210,'multiline':False]['text':'','line_number':211,'multiline':False]['text':' ','line_number':219,'multiline':False]['text':' This estimates how much memory we will need based on','line_number':220,'multiline':False]['text':' s-limb multiplication.  In an ideal world the number of limbs','line_number':221,'multiline':False]['text':' would halve with each recursion, and our storage requirements','line_number':222,'multiline':False]['text':' would be 4s in the limit, and rather less in practice since','line_number':223,'multiline':False]['text':' we bail out long before we reach one limb.  In the real world','line_number':224,'multiline':False]['text':' we don't quite halve s in each recursion, so this is an heuristic','line_number':225,'multiline':False]['text':' which over-estimates how much we need.  We could compute an exact','line_number':226,'multiline':False]['text':' value, but it would be rather time consuming.','line_number':227,'multiline':False]['text':'','line_number':228,'multiline':False]['text':'','line_number':231,'multiline':False]['text':' There are 2 entry point routines for Karatsuba multiplication:','line_number':232,'multiline':False]['text':' one for variable precision types, and one for fixed precision types.','line_number':233,'multiline':False]['text':' These are responsible for allocating all the storage required for the recursive','line_number':234,'multiline':False]['text':' routines above, and are always at the outermost level.','line_number':235,'multiline':False]['text':'','line_number':236,'multiline':False]['text':' Normal variable precision case comes first:','line_number':237,'multiline':False]['text':'','line_number':238,'multiline':False]['text':'','line_number':252,'multiline':False]['text':' Special case: if we don't need too much memory, we can use stack based storage','line_number':253,'multiline':False]['text':' and save a call to the allocator, this allows us to use Karatsuba multiply','line_number':254,'multiline':False]['text':' at lower limb counts than would otherwise be possible:','line_number':255,'multiline':False]['text':'','line_number':256,'multiline':False]['text':'','line_number':275,'multiline':False]['text':' Now comes the fixed precision case.','line_number':276,'multiline':False]['text':' In fact Karatsuba doesn't really work with fixed precision since the logic','line_number':277,'multiline':False]['text':' requires that we calculate all the bits of the result (especially in the','line_number':278,'multiline':False]['text':' temporaries used internally).  So... we'll convert all the arguments','line_number':279,'multiline':False]['text':' to variable precision types by aliasing them, this also','line_number':280,'multiline':False]['text':' reduce the number of template instantations:','line_number':281,'multiline':False]['text':'','line_number':282,'multiline':False]['text':' Result is large enough for all the bits of the result, so we can use aliasing:','line_number':293,'multiline':False]['text':'','line_number':302,'multiline':False]['text':' Not enough bit in result for the answer, so we must use a temporary','line_number':303,'multiline':False]['text':' and then truncate (ie modular arithmetic):','line_number':304,'multiline':False]['text':'','line_number':305,'multiline':False]['text':'','line_number':309,'multiline':False]['text':' If there is truncation, and result is a checked type then this will throw:','line_number':310,'multiline':False]['text':'','line_number':311,'multiline':False]['text':'','line_number':322,'multiline':False]['text':' Variable precision, mixed arguments, just alias and forward:','line_number':323,'multiline':False]['text':'','line_number':324,'multiline':False]['text':' ','line_number':346,'multiline':False]['text':' see PR #182','line_number':347,'multiline':False]['text':' Comba Multiplier - based on Paul Comba's','line_number':348,'multiline':False]['text':' Exponentiation cryptosystems on the IBM PC, 1990','line_number':349,'multiline':False]['text':'','line_number':350,'multiline':False]['text':' min(i+1, bs-j);','line_number':365,'multiline':False]['text':' Uses simple (O(n^2)) multiplication when the limbs are less','line_number':400,'multiline':False]['text':' otherwise switches to karatsuba algorithm based on experimental value (~40 limbs)','line_number':401,'multiline':False]['text':'','line_number':402,'multiline':False]['text':' Trivial cases first:','line_number':403,'multiline':False]['text':'','line_number':404,'multiline':False]['text':'','line_number':457,'multiline':False]['text':' Set the sign of the result:','line_number':458,'multiline':False]['text':'','line_number':459,'multiline':False]['text':' ','line_number':477,'multiline':False]['text':' Comba Multiplier might not be efficient because of less efficient assembly','line_number':478,'multiline':False]['text':' by the compiler as of 09/01/2020 (DD/MM/YY). See PR #182','line_number':479,'multiline':False]['text':' Till then this will lay dormant :(','line_number':480,'multiline':False]['text':'','line_number':481,'multiline':False]['text':' May throw if checking is enabled','line_number':511,'multiline':False]['text':' ifdef(BOOST_MP_COMBA) ends','line_number':521,'multiline':False]['text':'','line_number':524,'multiline':False]['text':' Set the sign of the result:','line_number':525,'multiline':False]['text':'','line_number':526,'multiline':False]['text':'','line_number':653,'multiline':False]['text':' Now over again for trivial cpp_int's:','line_number':654,'multiline':False]['text':'','line_number':655,'multiline':False]['text':'','line_number':704,'multiline':False]['text':' Special routines for multiplying two integers to obtain a multiprecision result:','line_number':705,'multiline':False]['text':'','line_number':706,'multiline':False]['text':' namespace boost::multiprecision::backends','line_number':846,'multiline':False]