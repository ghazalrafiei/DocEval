['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'/ \file regex_token_iterator.hpp','line_number':2,'multiline':False]['text':'/ Contains the definition of regex_token_iterator, and STL-compatible iterator','line_number':3,'multiline':False]['text':'/ for tokenizing a string using a regular expression.','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':6,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':7,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':' MS compatible compilers support #pragma once','line_number':13,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////','line_number':28,'multiline':False]['text':' regex_token_iterator_impl','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' so that people can specify sub-match indices inline with','line_number':109,'multiline':False]['text':' string literals, like "\1\2\3", leave off the trailing '\0'','line_number':110,'multiline':False]['text':' namespace detail','line_number':127,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////','line_number':129,'multiline':False]['text':' regex_token_iterator','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'/ INTERNAL ONLY','line_number':143,'multiline':False]['text':'/ \post \c *this is the end of sequence iterator.','line_number':146,'multiline':False]['text':'/ \param begin The beginning of the character range to search.','line_number':152,'multiline':False]['text':'/ \param end The end of the character range to search.','line_number':153,'multiline':False]['text':'/ \param rex The regex pattern to search for.','line_number':154,'multiline':False]['text':'/ \pre \c [begin,end) is a valid range.','line_number':155,'multiline':False]['text':'/ \param begin The beginning of the character range to search.','line_number':171,'multiline':False]['text':'/ \param end The end of the character range to search.','line_number':172,'multiline':False]['text':'/ \param rex The regex pattern to search for.','line_number':173,'multiline':False]['text':'/ \param args A let() expression with argument bindings for semantic actions.','line_number':174,'multiline':False]['text':'/ \pre \c [begin,end) is a valid range.','line_number':175,'multiline':False]['text':'/ \param begin The beginning of the character range to search.','line_number':194,'multiline':False]['text':'/ \param end The end of the character range to search.','line_number':195,'multiline':False]['text':'/ \param rex The regex pattern to search for.','line_number':196,'multiline':False]['text':'/ \param subs A range of integers designating sub-matches to be treated as tokens.','line_number':197,'multiline':False]['text':'/ \param flags Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.)','line_number':198,'multiline':False]['text':'/ \pre \c [begin,end) is a valid range.','line_number':199,'multiline':False]['text':'/ \pre \c subs is either an integer greater or equal to -1,','line_number':200,'multiline':False]['text':'/     or else an array or non-empty \c std::vector\<\> of such integers.','line_number':201,'multiline':False]['text':'/ \param begin The beginning of the character range to search.','line_number':220,'multiline':False]['text':'/ \param end The end of the character range to search.','line_number':221,'multiline':False]['text':'/ \param rex The regex pattern to search for.','line_number':222,'multiline':False]['text':'/ \param subs A range of integers designating sub-matches to be treated as tokens.','line_number':223,'multiline':False]['text':'/ \param args A let() expression with argument bindings for semantic actions.','line_number':224,'multiline':False]['text':'/ \param flags Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.)','line_number':225,'multiline':False]['text':'/ \pre \c [begin,end) is a valid range.','line_number':226,'multiline':False]['text':'/ \pre \c subs is either an integer greater or equal to -1,','line_number':227,'multiline':False]['text':'/     or else an array or non-empty \c std::vector\<\> of such integers.','line_number':228,'multiline':False]['text':'/ \post <tt>*this == that</tt>','line_number':249,'multiline':False]['text':' COW','line_number':251,'multiline':False]['text':'/ \post <tt>*this == that</tt>','line_number':255,'multiline':False]['text':' COW','line_number':258,'multiline':False]['text':'/ If N == -1 then sets *this equal to the end of sequence iterator.','line_number':287,'multiline':False]['text':'/ Otherwise if N+1 \< subs.size(), then increments N and sets result equal to','line_number':288,'multiline':False]['text':'/ ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())).','line_number':289,'multiline':False]['text':'/ Otherwise if what.prefix().first != what[0].second and if the element match_prev_avail is','line_number':290,'multiline':False]['text':'/ not set in flags then sets it. Then locates the next match as if by calling','line_number':291,'multiline':False]['text':'/ regex_search(what[0].second, end, what, *pre, flags), with the following variation:','line_number':292,'multiline':False]['text':'/ in the event that the previous match found was of zero length (what[0].length() == 0)','line_number':293,'multiline':False]['text':'/ then attempts to find a non-zero length match starting at what[0].second, only if that','line_number':294,'multiline':False]['text':'/ fails and provided what[0].second != suffix().second does it look for a (possibly zero','line_number':295,'multiline':False]['text':'/ length) match starting from what[0].second + 1.  If such a match is found then sets N','line_number':296,'multiline':False]['text':'/ equal to zero, and sets result equal to','line_number':297,'multiline':False]['text':'/ ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())).','line_number':298,'multiline':False]['text':'/ Otherwise if no further matches were found, then let last_end be the endpoint of the last','line_number':299,'multiline':False]['text':'/ match that was found. Then if last_end != end and subs[0] == -1 sets N equal to -1 and','line_number':300,'multiline':False]['text':'/ sets result equal to value_type(last_end, end). Otherwise sets *this equal to the end','line_number':301,'multiline':False]['text':'/ of sequence iterator.','line_number':302,'multiline':False]['text':' un-share the implementation','line_number':305,'multiline':False]['text':'/ INTERNAL ONLY','line_number':319,'multiline':False]['text':' only copy the match_results struct if we have to. Note: if the next call','line_number':337,'multiline':False]['text':' to impl_->next() will return false or call regex_search, we don't need to','line_number':338,'multiline':False]['text':' copy the match_results struct.','line_number':339,'multiline':False]['text':' BUGBUG This is expensive -- it causes the sequence_stack to be cleared.','line_number':342,'multiline':False]['text':' Find a better way','line_number':343,'multiline':False]['text':' At the very least, copy the action args','line_number':348,'multiline':False]['text':'/ INTERNAL ONLY','line_number':357,'multiline':False]['text':' namespace boost::xpressive','line_number':370,'multiline':False]