['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2005-2012. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See http://www.boost.org/libs/interprocess for documentation.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]['text':' container/detail','line_number':42,'multiline':False]['text':' std','line_number':45,'multiline':False]['text':'std::size_t','line_number':46,'multiline':False]['text':'!\file','line_number':53,'multiline':False]['text':'!Describes the object placed in a memory segment that provides','line_number':54,'multiline':False]['text':'!named object allocation capabilities for single-segment and','line_number':55,'multiline':False]['text':'!multi-segment allocations.','line_number':56,'multiline':False]['text':'!This object is the public base class of segment manager.','line_number':61,'multiline':False]['text':'!This class only depends on the memory allocation algorithm','line_number':62,'multiline':False]['text':'!and implements all the allocation features not related','line_number':63,'multiline':False]['text':'!to named or unique objects.','line_number':64,'multiline':False]['text':'!','line_number':65,'multiline':False]['text':'!Storing a reference to segment_manager forces','line_number':66,'multiline':False]['text':'!the holder class to be dependent on index types and character types.','line_number':67,'multiline':False]['text':'!When such dependence is not desirable and only anonymous and raw','line_number':68,'multiline':False]['text':'!allocations are needed, segment_manager_base is the correct answer.','line_number':69,'multiline':False]['text':'Experimental. Don't use','line_number':82,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':87,'multiline':False]['text':'!This constant indicates the payload size','line_number':89,'multiline':False]['text':'!associated with each allocation of the memory algorithm','line_number':90,'multiline':False]['text':'!Constructor of the segment_manager_base','line_number':93,'multiline':False]['text':'!','line_number':94,'multiline':False]['text':'!"size" is the size of the memory segment where','line_number':95,'multiline':False]['text':'!the basic segment manager is being constructed.','line_number':96,'multiline':False]['text':'!','line_number':97,'multiline':False]['text':'!"reserved_bytes" is the number of bytes','line_number':98,'multiline':False]['text':'!after the end of the memory algorithm object itself','line_number':99,'multiline':False]['text':'!that the memory algorithm will exclude from','line_number':100,'multiline':False]['text':'!dynamic allocation','line_number':101,'multiline':False]['text':'!','line_number':102,'multiline':False]['text':'!Can throw','line_number':103,'multiline':False]['text':'!Returns the size of the memory','line_number':110,'multiline':False]['text':'!segment','line_number':111,'multiline':False]['text':'!Returns the number of free bytes of the memory','line_number':115,'multiline':False]['text':'!segment','line_number':116,'multiline':False]['text':'!Obtains the minimum size needed by','line_number':120,'multiline':False]['text':'!the segment manager','line_number':121,'multiline':False]['text':'!Allocates nbytes bytes. This function is only used in','line_number':125,'multiline':False]['text':'!single-segment management. Never throws','line_number':126,'multiline':False]['text':'!Returns a reference to the internal memory algorithm.','line_number':130,'multiline':False]['text':'!This function is useful for custom memory algorithms that','line_number':131,'multiline':False]['text':'!need additional configuration options after construction. Never throws.','line_number':132,'multiline':False]['text':'!This function should be only used by advanced users.','line_number':133,'multiline':False]['text':'!Returns a const reference to the internal memory algorithm.','line_number':137,'multiline':False]['text':'!This function is useful for custom memory algorithms that','line_number':138,'multiline':False]['text':'!need additional configuration options after construction. Never throws.','line_number':139,'multiline':False]['text':'!This function should be only used by advanced users.','line_number':140,'multiline':False]['text':'Experimental. Dont' use.','line_number':146,'multiline':False]['text':'!Allocates n_elements of elem_bytes bytes.','line_number':147,'multiline':False]['text':'!Throws bad_alloc on failure. chain.size() is not increased on failure.','line_number':148,'multiline':False]['text':'!Allocates n_elements, each one of element_lengths[i]*sizeof_element bytes.','line_number':158,'multiline':False]['text':'!Throws bad_alloc on failure. chain.size() is not increased on failure.','line_number':159,'multiline':False]['text':'!Allocates n_elements of elem_bytes bytes.','line_number':169,'multiline':False]['text':'!Non-throwing version. chain.size() is not increased on failure.','line_number':170,'multiline':False]['text':'!Allocates n_elements, each one of','line_number':174,'multiline':False]['text':'!element_lengths[i]*sizeof_element bytes.','line_number':175,'multiline':False]['text':'!Non-throwing version. chain.size() is not increased on failure.','line_number':176,'multiline':False]['text':'!Deallocates all elements contained in chain.','line_number':180,'multiline':False]['text':'!Never throws.','line_number':181,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':185,'multiline':False]['text':'!Allocates nbytes bytes. Throws boost::interprocess::bad_alloc','line_number':187,'multiline':False]['text':'!on failure','line_number':188,'multiline':False]['text':'!Allocates nbytes bytes. This function is only used in','line_number':197,'multiline':False]['text':'!single-segment management. Never throws','line_number':198,'multiline':False]['text':'!Allocates nbytes bytes. This function is only used in','line_number':202,'multiline':False]['text':'!single-segment management. Throws bad_alloc when fails','line_number':203,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':236,'multiline':False]['text':'!Deallocates the bytes allocated with allocate/allocate_many()','line_number':238,'multiline':False]['text':'!pointed by addr','line_number':239,'multiline':False]['text':'!Increases managed memory in extra_size bytes more. This only works','line_number':243,'multiline':False]['text':'!with single-segment management.','line_number':244,'multiline':False]['text':'!Decreases managed memory to the minimum. This only works','line_number':248,'multiline':False]['text':'!with single-segment management.','line_number':249,'multiline':False]['text':'!Returns the result of "all_memory_deallocated()" function','line_number':253,'multiline':False]['text':'!of the used memory algorithm','line_number':254,'multiline':False]['text':'!Returns the result of "check_sanity()" function','line_number':258,'multiline':False]['text':'!of the used memory algorithm','line_number':259,'multiline':False]['text':'!Writes to zero free memory (memory not yet allocated)','line_number':263,'multiline':False]['text':'!of the memory algorithm','line_number':264,'multiline':False]['text':'!Returns the size of the buffer previously allocated pointed by ptr','line_number':268,'multiline':False]['text':'Allocate memory','line_number':284,'multiline':False]['text':'Check if there is enough memory','line_number':287,'multiline':False]['text':'Build scoped ptr to avoid leaks with constructor exception','line_number':297,'multiline':False]['text':'Now construct the header','line_number':300,'multiline':False]['text':'avoid gcc warning','line_number':302,'multiline':False]['text':'Now call constructors','line_number':305,'multiline':False]['text':'All constructors successful, we don't want erase memory','line_number':308,'multiline':False]['text':'!Calls the destructor and makes an anonymous deallocate','line_number':313,'multiline':False]['text':'Get control data from associated with this object','line_number':317,'multiline':False]['text':'-------------------------------','line_number':321,'multiline':False]['text':'scoped_lock<rmutex> guard(m_header);','line_number':322,'multiline':False]['text':'-------------------------------','line_number':323,'multiline':False]['text':'This is not an anonymous object, the pointer is wrong!','line_number':326,'multiline':False]['text':'Call destructors and free memory','line_number':330,'multiline':False]['text':'Build scoped ptr to avoid leaks with destructor exception','line_number':331,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':336,'multiline':False]['text':'!This object is placed in the beginning of memory segment and','line_number':339,'multiline':False]['text':'!implements the allocation (named or anonymous) of portions','line_number':340,'multiline':False]['text':'!of the segment. This object contains two indexes that','line_number':341,'multiline':False]['text':'!maintain an association between a name and a portion of the segment.','line_number':342,'multiline':False]['text':'!','line_number':343,'multiline':False]['text':'!The first index contains the mappings for normal named objects using the','line_number':344,'multiline':False]['text':'!char type specified in the template parameter.','line_number':345,'multiline':False]['text':'!','line_number':346,'multiline':False]['text':'!The second index contains the association for unique instances. The key will','line_number':347,'multiline':False]['text':'!be the const char * returned from type_info.name() function for the unique','line_number':348,'multiline':False]['text':'!type to be constructed.','line_number':349,'multiline':False]['text':'!','line_number':350,'multiline':False]['text':'!segment_manager<CharType, MemoryAlgorithm, IndexType> inherits publicly','line_number':351,'multiline':False]['text':'!from segment_manager_base<MemoryAlgorithm> and inherits from it','line_number':352,'multiline':False]['text':'!many public functions related to anonymous object and raw memory allocation.','line_number':353,'multiline':False]['text':'!See segment_manager_base reference to know about those functions.','line_number':354,'multiline':False]['text':'Non-copyable','line_number':362,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':367,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':400,'multiline':False]['text':'!Constructor proxy object definition helper class','line_number':411,'multiline':False]['text':'!Constructor proxy object definition helper class','line_number':418,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':425,'multiline':False]['text':'!Constructor of the segment manager','line_number':427,'multiline':False]['text':'!"size" is the size of the memory segment where','line_number':428,'multiline':False]['text':'!the segment manager is being constructed.','line_number':429,'multiline':False]['text':'!Can throw','line_number':430,'multiline':False]['text':'Check EBO is applied, it's required','line_number':436,'multiline':False]['text':'!Tries to find a previous named/unique allocation. Returns the address','line_number':445,'multiline':False]['text':'!and the object count. On failure the first member of the','line_number':446,'multiline':False]['text':'!returned pair is 0.','line_number':447,'multiline':False]['text':'!Tries to find a previous named/unique allocation. Returns the address','line_number':452,'multiline':False]['text':'!and the object count. On failure the first member of the','line_number':453,'multiline':False]['text':'!returned pair is 0. This search is not mutex-protected!','line_number':454,'multiline':False]['text':'!Use it only inside atomic_func() calls, where the internal mutex','line_number':455,'multiline':False]['text':'!is guaranteed to be locked.','line_number':456,'multiline':False]['text':'!Returns throwing "construct" proxy','line_number':461,'multiline':False]['text':'!object','line_number':462,'multiline':False]['text':'!Returns throwing "search or construct" proxy','line_number':468,'multiline':False]['text':'!object','line_number':469,'multiline':False]['text':'!Returns no throwing "construct" proxy','line_number':474,'multiline':False]['text':'!object','line_number':475,'multiline':False]['text':'!Returns no throwing "search or construct"','line_number':481,'multiline':False]['text':'!proxy object','line_number':482,'multiline':False]['text':'!Returns throwing "construct from iterators" proxy object','line_number':488,'multiline':False]['text':'!Returns throwing "search or construct from iterators"','line_number':494,'multiline':False]['text':'!proxy object','line_number':495,'multiline':False]['text':'!Returns no throwing "construct from iterators"','line_number':501,'multiline':False]['text':'!proxy object','line_number':502,'multiline':False]['text':'!Returns no throwing "search or construct from iterators"','line_number':508,'multiline':False]['text':'!proxy object','line_number':509,'multiline':False]['text':'!Calls object function blocking recursive interprocess_mutex and guarantees that','line_number':515,'multiline':False]['text':'!no new named_alloc or destroy will be executed by any process while','line_number':516,'multiline':False]['text':'!executing the object function call','line_number':517,'multiline':False]['text':'!Tries to calls a functor guaranteeing that no new construction, search or','line_number':522,'multiline':False]['text':'!destruction will be executed by any process while executing the object','line_number':523,'multiline':False]['text':'!function call. If the atomic function can't be immediatelly executed','line_number':524,'multiline':False]['text':'!because the internal mutex is already locked, returns false.','line_number':525,'multiline':False]['text':'!If the functor throws, this function throws.','line_number':526,'multiline':False]['text':'!Destroys a previously created named/unique instance.','line_number':540,'multiline':False]['text':'!Returns false if the object was not present.','line_number':541,'multiline':False]['text':'!Destroys an anonymous, unique or named object','line_number':558,'multiline':False]['text':'!using its address','line_number':559,'multiline':False]['text':'If T is void transform it to char','line_number':563,'multiline':False]['text':'!Returns the name of an object created with construct/find_or_construct','line_number':569,'multiline':False]['text':'!functions. Does not throw','line_number':570,'multiline':False]['text':'!Returns the length of an object created with construct/find_or_construct','line_number':575,'multiline':False]['text':'!functions. Does not throw.','line_number':576,'multiline':False]['text':'!Returns is the the name of an object created with construct/find_or_construct','line_number':581,'multiline':False]['text':'!functions. Does not throw','line_number':582,'multiline':False]['text':'!Preallocates needed index resources to optimize the','line_number':587,'multiline':False]['text':'!creation of "num" named objects in the managed memory segment.','line_number':588,'multiline':False]['text':'!Can throw boost::interprocess::bad_alloc if there is no enough memory.','line_number':589,'multiline':False]['text':'-------------------------------','line_number':592,'multiline':False]['text':'-------------------------------','line_number':594,'multiline':False]['text':'!Preallocates needed index resources to optimize the','line_number':598,'multiline':False]['text':'!creation of "num" unique objects in the managed memory segment.','line_number':599,'multiline':False]['text':'!Can throw boost::interprocess::bad_alloc if there is no enough memory.','line_number':600,'multiline':False]['text':'-------------------------------','line_number':603,'multiline':False]['text':'-------------------------------','line_number':605,'multiline':False]['text':'!Calls shrink_to_fit in both named and unique object indexes','line_number':609,'multiline':False]['text':'!to try to free unused memory from those indexes.','line_number':610,'multiline':False]['text':'-------------------------------','line_number':613,'multiline':False]['text':'-------------------------------','line_number':615,'multiline':False]['text':'!Returns the number of named objects stored in','line_number':620,'multiline':False]['text':'!the segment.','line_number':621,'multiline':False]['text':'-------------------------------','line_number':624,'multiline':False]['text':'-------------------------------','line_number':626,'multiline':False]['text':'!Returns the number of unique objects stored in','line_number':630,'multiline':False]['text':'!the segment.','line_number':631,'multiline':False]['text':'-------------------------------','line_number':634,'multiline':False]['text':'-------------------------------','line_number':636,'multiline':False]['text':'!Obtains the minimum size needed by the','line_number':640,'multiline':False]['text':'!segment manager','line_number':641,'multiline':False]['text':'!Returns a constant iterator to the beginning of the information about','line_number':645,'multiline':False]['text':'!the named allocations performed in this segment manager','line_number':646,'multiline':False]['text':'!Returns a constant iterator to the end of the information about','line_number':653,'multiline':False]['text':'!the named allocations performed in this segment manager','line_number':654,'multiline':False]['text':'!Returns a constant iterator to the beginning of the information about','line_number':661,'multiline':False]['text':'!the unique allocations performed in this segment manager','line_number':662,'multiline':False]['text':'!Returns a constant iterator to the end of the information about','line_number':669,'multiline':False]['text':'!the unique allocations performed in this segment manager','line_number':670,'multiline':False]['text':'!This is the default allocator to allocate types T','line_number':677,'multiline':False]['text':'!from this managed segment','line_number':678,'multiline':False]['text':'!Returns an instance of the default allocator for type T','line_number':685,'multiline':False]['text':'!initialized that allocates memory from this segment manager.','line_number':686,'multiline':False]['text':'!This is the default deleter to delete types T','line_number':692,'multiline':False]['text':'!from this managed segment.','line_number':693,'multiline':False]['text':'!Returns an instance of the default deleter for type T','line_number':700,'multiline':False]['text':'!that will delete an object constructed in this segment manager.','line_number':701,'multiline':False]['text':'!Generic named/anonymous new function. Offers all the possibilities,','line_number':709,'multiline':False]['text':'!such as throwing, search before creating, and the constructor is','line_number':710,'multiline':False]['text':'!encapsulated in an object function.','line_number':711,'multiline':False]['text':'!Tries to find a previous named allocation. Returns the address','line_number':724,'multiline':False]['text':'!and the object count. On failure the first member of the','line_number':725,'multiline':False]['text':'!returned pair is 0.','line_number':726,'multiline':False]['text':'The name can't be null, no anonymous object can be found by name','line_number':730,'multiline':False]['text':'!Tries to find a previous unique allocation. Returns the address','line_number':745,'multiline':False]['text':'!and the object count. On failure the first member of the','line_number':746,'multiline':False]['text':'!returned pair is 0.','line_number':747,'multiline':False]['text':'Security overflow check','line_number':761,'multiline':False]['text':'This type is unknown, bad pointer passed to this function!','line_number':801,'multiline':False]['text':'!Returns the name of an object created with construct/find_or_construct','line_number':807,'multiline':False]['text':'!functions. Does not throw','line_number':808,'multiline':False]['text':'Sanity checks','line_number':819,'multiline':False]['text':'Get header','line_number':827,'multiline':False]['text':'!Returns is the the name of an object created with construct/find_or_construct','line_number':832,'multiline':False]['text':'!functions. Does not throw','line_number':833,'multiline':False]['text':'Get header','line_number':836,'multiline':False]['text':'Get the number of bytes until the end of (*this)','line_number':843,'multiline':False]['text':'beginning in the end of the segment_manager_base_t base.','line_number':844,'multiline':False]['text':'-------------------------------','line_number':859,'multiline':False]['text':'-------------------------------','line_number':861,'multiline':False]['text':'Find name in index','line_number':862,'multiline':False]['text':'Initialize return values','line_number':867,'multiline':False]['text':'If found, assign values','line_number':871,'multiline':False]['text':'Get header','line_number':873,'multiline':False]['text':'Sanity check','line_number':876,'multiline':False]['text':'-------------------------------','line_number':897,'multiline':False]['text':'-------------------------------','line_number':899,'multiline':False]['text':'Find name in index','line_number':900,'multiline':False]['text':'Initialize return values','line_number':903,'multiline':False]['text':'If found, assign values','line_number':907,'multiline':False]['text':'Get header','line_number':909,'multiline':False]['text':'Sanity check','line_number':913,'multiline':False]['text':'-------------------------------','line_number':957,'multiline':False]['text':'-------------------------------','line_number':959,'multiline':False]['text':'Find name in index','line_number':960,'multiline':False]['text':'If not found, return false','line_number':965,'multiline':False]['text':'This name is not present in the index, wrong pointer or name!','line_number':967,'multiline':False]['text':'BOOST_ASSERT(0);','line_number':968,'multiline':False]['text':'Sanity check','line_number':978,'multiline':False]['text':'Erase node from index','line_number':982,'multiline':False]['text':'Destroy the headers','line_number':985,'multiline':False]['text':'Call destructors and free memory','line_number':989,'multiline':False]['text':'-------------------------------','line_number':1007,'multiline':False]['text':'-------------------------------','line_number':1009,'multiline':False]['text':'Try to find the name in the index','line_number':1010,'multiline':False]['text':'If not found, return false','line_number':1014,'multiline':False]['text':'This name is not present in the index, wrong pointer or name!','line_number':1016,'multiline':False]['text':'BOOST_ASSERT(0);','line_number':1017,'multiline':False]['text':'Get allocation parameters','line_number':1032,'multiline':False]['text':'Check if the distance between the name pointer and the memory pointer','line_number':1038,'multiline':False]['text':'is correct (this can detect incorrect type in destruction)','line_number':1039,'multiline':False]['text':'Sanity check','line_number':1043,'multiline':False]['text':'Erase node from index','line_number':1048,'multiline':False]['text':'Destroy the header','line_number':1051,'multiline':False]['text':'Call destructors and free memory','line_number':1065,'multiline':False]['text':'-------------------------------','line_number':1091,'multiline':False]['text':'-------------------------------','line_number':1093,'multiline':False]['text':'Insert the node. This can throw.','line_number':1094,'multiline':False]['text':'First, we want to know if the key is already present before','line_number':1095,'multiline':False]['text':'we allocate any memory, and if the key is not present, we','line_number':1096,'multiline':False]['text':'want to allocate all memory in a single buffer that will','line_number':1097,'multiline':False]['text':'contain the name and the user buffer.','line_number':1098,'multiline':False]['text':'','line_number':1099,'multiline':False]['text':'Since equal_range(key) + insert(hint, value) approach is','line_number':1100,'multiline':False]['text':'quite inefficient in container implementations','line_number':1101,'multiline':False]['text':'(they re-test if the position is correct), I've chosen','line_number':1102,'multiline':False]['text':'to insert the node, do an ugly un-const cast and modify','line_number':1103,'multiline':False]['text':'the key (which is a smart pointer) to an equivalent one','line_number':1104,'multiline':False]['text':'Ignore exceptions','line_number':1114,'multiline':False]['text':'If found and this is find or construct, return data','line_number':1124,'multiline':False]['text':'else return null','line_number':1125,'multiline':False]['text':'Allocates buffer for name + data, this can throw (it hurts)','line_number':1138,'multiline':False]['text':'Check if there is enough memory','line_number':1141,'multiline':False]['text':'Now construct the intrusive hook plus the header','line_number':1153,'multiline':False]['text':'avoid gcc warning','line_number':1156,'multiline':False]['text':'Copy name to memory segment and insert data','line_number':1159,'multiline':False]['text':'Now commit the insertion using previous context data','line_number':1164,'multiline':False]['text':'Ignore exceptions','line_number':1167,'multiline':False]['text':'Avoid constructions if constructor is trivial','line_number':1175,'multiline':False]['text':'Build scoped ptr to avoid leaks with constructor exception','line_number':1176,'multiline':False]['text':'Initialize the node value_eraser to erase inserted node','line_number':1180,'multiline':False]['text':'if something goes wrong. This will be executed *before*','line_number':1181,'multiline':False]['text':'the memory allocation as the intrusive value is built in that','line_number':1182,'multiline':False]['text':'memory','line_number':1183,'multiline':False]['text':'Construct array, this can throw','line_number':1186,'multiline':False]['text':'Release rollbacks since construction was successful','line_number':1189,'multiline':False]['text':'!Generic named new function for','line_number':1195,'multiline':False]['text':'!named functions','line_number':1196,'multiline':False]['text':'-------------------------------','line_number':1219,'multiline':False]['text':'-------------------------------','line_number':1221,'multiline':False]['text':'Insert the node. This can throw.','line_number':1222,'multiline':False]['text':'First, we want to know if the key is already present before','line_number':1223,'multiline':False]['text':'we allocate any memory, and if the key is not present, we','line_number':1224,'multiline':False]['text':'want to allocate all memory in a single buffer that will','line_number':1225,'multiline':False]['text':'contain the name and the user buffer.','line_number':1226,'multiline':False]['text':'','line_number':1227,'multiline':False]['text':'Since equal_range(key) + insert(hint, value) approach is','line_number':1228,'multiline':False]['text':'quite inefficient in container implementations','line_number':1229,'multiline':False]['text':'(they re-test if the position is correct), I've chosen','line_number':1230,'multiline':False]['text':'to insert the node, do an ugly un-const cast and modify','line_number':1231,'multiline':False]['text':'the key (which is a smart pointer) to an equivalent one','line_number':1232,'multiline':False]['text':'Ignore exceptions','line_number':1237,'multiline':False]['text':'If found and this is find or construct, return data','line_number':1247,'multiline':False]['text':'else return null','line_number':1248,'multiline':False]['text':'Initialize the node value_eraser to erase inserted node','line_number':1257,'multiline':False]['text':'if something goes wrong','line_number':1258,'multiline':False]['text':'Allocates buffer for name + data, this can throw (it hurts)','line_number':1261,'multiline':False]['text':'Allocate and construct the headers','line_number':1265,'multiline':False]['text':'avoid gcc warning','line_number':1292,'multiline':False]['text':'Copy name to memory segment and insert data','line_number':1295,'multiline':False]['text':'Do the ugly cast, please mama, forgive me!','line_number':1299,'multiline':False]['text':'This new key points to an identical string, so it must have the','line_number':1300,'multiline':False]['text':'same position than the overwritten key according to the predicate','line_number':1301,'multiline':False]['text':'Build scoped ptr to avoid leaks with constructor exception','line_number':1305,'multiline':False]['text':'Construct array, this can throw','line_number':1309,'multiline':False]['text':'All constructors successful, we don't want to release memory','line_number':1312,'multiline':False]['text':'Release node v_eraser since construction was successful','line_number':1315,'multiline':False]['text':'!Returns the this pointer','line_number':1321,'multiline':False]['text':'!This struct includes needed data and derives from','line_number':1336,'multiline':False]['text':'!rmutex to allow EBO when using null interprocess_mutex','line_number':1337,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':1350,'multiline':False]['text':'namespace boost { namespace interprocess','line_number':1354,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_SEGMENT_MANAGER_HPP','line_number':1358,'multiline':False]