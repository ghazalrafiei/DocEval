['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Pablo Halpern 2009. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2011-2014. Distributed under the Boost','line_number':9,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':10,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':11,'multiline':False]['text':'','line_number':12,'multiline':False]['text':' See http://www.boost.org/libs/intrusive for documentation.','line_number':13,'multiline':False]['text':'','line_number':14,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':15,'multiline':False]['text':'namespace detail {','line_number':53,'multiline':False]['text':'! pointer_traits is the implementation of C++11 std::pointer_traits class with some','line_number':56,'multiline':False]['text':'! extensions like castings.','line_number':57,'multiline':False]['text':'!','line_number':58,'multiline':False]['text':'! pointer_traits supplies a uniform interface to certain attributes of pointer-like types.','line_number':59,'multiline':False]['text':'!','line_number':60,'multiline':False]['text':'! <b>Note</b>: When defining a custom family of pointers or references to be used with BI','line_number':61,'multiline':False]['text':'! library, make sure the public static conversion functions accessed through','line_number':62,'multiline':False]['text':'! the `pointer_traits` interface (`*_cast_from` and `pointer_to`) can','line_number':63,'multiline':False]['text':'! properly convert between const and nonconst referred member types','line_number':64,'multiline':False]['text':'! <b>without the use of implicit constructor calls</b>. It is suggested these','line_number':65,'multiline':False]['text':'! conversions be implemented as function templates, where the template','line_number':66,'multiline':False]['text':'! argument is the type of the object being converted from.','line_number':67,'multiline':False]['text':'!The pointer type','line_number':72,'multiline':False]['text':'!queried by this pointer_traits instantiation','line_number':73,'multiline':False]['text':'!Ptr::element_type if such a type exists; otherwise, T if Ptr is a class','line_number':76,'multiline':False]['text':'!template instantiation of the form SomePointer<T, Args>, where Args is zero or','line_number':77,'multiline':False]['text':'!more type arguments ; otherwise , the specialization is ill-formed.','line_number':78,'multiline':False]['text':'!Ptr::difference_type if such a type exists; otherwise,','line_number':81,'multiline':False]['text':'!std::ptrdiff_t.','line_number':82,'multiline':False]['text':'!Ptr::rebind<U> if such a type exists; otherwise, SomePointer<U, Args> if Ptr is','line_number':85,'multiline':False]['text':'!a class template instantiation of the form SomePointer<T, Args>, where Args is zero or','line_number':86,'multiline':False]['text':'!more type arguments ; otherwise, the instantiation of rebind is ill-formed.','line_number':87,'multiline':False]['text':'!','line_number':88,'multiline':False]['text':'!For portable code for C++03 and C++11, <pre>typename rebind_pointer<U>::type</pre>','line_number':89,'multiline':False]['text':'!shall be used instead of rebind<U> to obtain a pointer to U.','line_number':90,'multiline':False]['text':'!Ptr::reference if such a type exists (non-standard extension); otherwise, element_type &','line_number':93,'multiline':False]['text':'!','line_number':94,'multiline':False]['text':'','line_number':98,'multiline':False]['text':'','line_number':102,'multiline':False]['text':'','line_number':114,'multiline':False]['text':'#if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)','line_number':123,'multiline':False]['text':'! <b>Remark</b>: If element_type is (possibly cv-qualified) void, r type is unspecified; otherwise,','line_number':125,'multiline':False]['text':'!   it is element_type &.','line_number':126,'multiline':False]['text':'!','line_number':127,'multiline':False]['text':'! <b>Returns</b>: A dereferenceable pointer to r obtained by calling Ptr::pointer_to(reference).','line_number':128,'multiline':False]['text':'!   Non-standard extension: If such function does not exist, returns pointer(addressof(r));','line_number':129,'multiline':False]['text':'!','line_number':130,'multiline':False]['text':'! <b>Note</b>: For non-conforming compilers only the existence of a member function called','line_number':131,'multiline':False]['text':'!   <code>pointer_to</code> is checked.','line_number':132,'multiline':False]['text':'Non-standard extension, it does not require Ptr::pointer_to. If not present','line_number':135,'multiline':False]['text':'tries to converts &r to pointer.','line_number':136,'multiline':False]['text':'! <b>Remark</b>: Non-standard extension.','line_number':144,'multiline':False]['text':'!','line_number':145,'multiline':False]['text':'! <b>Returns</b>: A dereferenceable pointer to r obtained by calling the static template function','line_number':146,'multiline':False]['text':'!   Ptr::static_cast_from(UPpr/const UPpr &).','line_number':147,'multiline':False]['text':'!   If such function does not exist, returns pointer_to(static_cast<element_type&>(*uptr))','line_number':148,'multiline':False]['text':'!','line_number':149,'multiline':False]['text':'! <b>Note</b>: For non-conforming compilers only the existence of a member function called','line_number':150,'multiline':False]['text':'!   <code>static_cast_from</code> is checked.','line_number':151,'multiline':False]['text':'! <b>Remark</b>: Non-standard extension.','line_number':165,'multiline':False]['text':'!','line_number':166,'multiline':False]['text':'! <b>Returns</b>: A dereferenceable pointer to r obtained by calling the static template function','line_number':167,'multiline':False]['text':'!   Ptr::const_cast_from<UPtr>(UPpr/const UPpr &).','line_number':168,'multiline':False]['text':'!   If such function does not exist, returns pointer_to(const_cast<element_type&>(*uptr))','line_number':169,'multiline':False]['text':'!','line_number':170,'multiline':False]['text':'! <b>Note</b>: For non-conforming compilers only the existence of a member function called','line_number':171,'multiline':False]['text':'!   <code>const_cast_from</code> is checked.','line_number':172,'multiline':False]['text':'! <b>Remark</b>: Non-standard extension.','line_number':186,'multiline':False]['text':'!','line_number':187,'multiline':False]['text':'! <b>Returns</b>: A dereferenceable pointer to r obtained by calling the static template function','line_number':188,'multiline':False]['text':'!   Ptr::dynamic_cast_from<UPtr>(UPpr/const UPpr &).','line_number':189,'multiline':False]['text':'!   If such function does not exist, returns pointer_to(*dynamic_cast<element_type*>(&*uptr))','line_number':190,'multiline':False]['text':'!','line_number':191,'multiline':False]['text':'! <b>Note</b>: For non-conforming compilers only the existence of a member function called','line_number':192,'multiline':False]['text':'!   <code>dynamic_cast_from</code> is checked.','line_number':193,'multiline':False]['text':'/@cond','line_number':207,'multiline':False]['text':'priv_to_raw_pointer','line_number':209,'multiline':False]['text':'priv_pointer_to','line_number':219,'multiline':False]['text':'priv_static_cast_from','line_number':226,'multiline':False]['text':'priv_const_cast_from','line_number':235,'multiline':False]['text':'priv_dynamic_cast_from','line_number':244,'multiline':False]['text':'/@endcond','line_number':252,'multiline':False]['text':'/@cond','line_number':255,'multiline':False]['text':' Remove cv qualification from Ptr parameter to pointer_traits:','line_number':257,'multiline':False]['text':' Remove reference from Ptr parameter to pointer_traits:','line_number':264,'multiline':False]['text':'/@endcond','line_number':268,'multiline':False]['text':'! Specialization of pointer_traits for raw pointers','line_number':270,'multiline':False]['text':'!','line_number':271,'multiline':False]['text':'!typedef for <pre>U *</pre>','line_number':282,'multiline':False]['text':'!','line_number':283,'multiline':False]['text':'!For portable code for C++03 and C++11, <pre>typename rebind_pointer<U>::type</pre>','line_number':284,'multiline':False]['text':'!shall be used instead of rebind<U> to obtain a pointer to U.','line_number':285,'multiline':False]['text':'! <b>Returns</b>: addressof(r)','line_number':297,'multiline':False]['text':'!','line_number':298,'multiline':False]['text':'! <b>Returns</b>: static_cast<pointer>(uptr)','line_number':302,'multiline':False]['text':'!','line_number':303,'multiline':False]['text':'! <b>Returns</b>: const_cast<pointer>(uptr)','line_number':308,'multiline':False]['text':'!','line_number':309,'multiline':False]['text':'! <b>Returns</b>: dynamic_cast<pointer>(uptr)','line_number':314,'multiline':False]['text':'!','line_number':315,'multiline':False]['text':'namespace container {','line_number':321,'multiline':False]['text':'namespace boost {','line_number':322,'multiline':False]['text':' ! defined(BOOST_INTRUSIVE_POINTER_TRAITS_HPP)','line_number':326,'multiline':False]