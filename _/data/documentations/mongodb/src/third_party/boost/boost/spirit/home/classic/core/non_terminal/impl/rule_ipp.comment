['text':'=============================================================================
    Copyright (c) 1998-2003 Joel de Guzman
    http://spirit.sourceforge.net/

    Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':29,'multiline':False]['text':' BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1','line_number':44,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':46,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':'  rule_base class','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':'      The rule_base class implements the basic plumbing for rules','line_number':96,'multiline':False]['text':'      minus the storage mechanism. It is up to the derived class','line_number':97,'multiline':False]['text':'      to actually store the definition somewhere. The rule_base','line_number':98,'multiline':False]['text':'      class assumes that the derived class provides a get() function','line_number':99,'multiline':False]['text':'      that will return a pointer to a parser. The get() function','line_number':100,'multiline':False]['text':'      may return NULL. See rule below for details.','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':'      <<< For framework use only. Not for public consumption. >>>','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':105,'multiline':False]['text':' derived class','line_number':107,'multiline':False]['text':' how derived class is embedded','line_number':108,'multiline':False]['text':' see rule class','line_number':109,'multiline':False]['text':' see rule class','line_number':110,'multiline':False]['text':' see rule class','line_number':111,'multiline':False]['text':' forward declaration','line_number':113,'multiline':False]['text':' YUCK!','line_number':118,'multiline':False]['text':' derived class','line_number':138,'multiline':False]['text':' how derived class is embedded','line_number':139,'multiline':False]['text':' see rule class','line_number':140,'multiline':False]['text':' see rule class','line_number':141,'multiline':False]['text':' see rule class','line_number':142,'multiline':False]['text':'  MWCW 8.3 needs this cast to be done through a pointer,','line_number':183,'multiline':False]['text':'  not a reference. Otherwise, it will silently construct','line_number':184,'multiline':False]['text':'  a temporary, causing an infinite runtime recursion.','line_number':185,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':203,'multiline':False]['text':'','line_number':204,'multiline':False]['text':'  abstract_parser class','line_number':205,'multiline':False]['text':'','line_number':206,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':207,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':221,'multiline':False]['text':'','line_number':222,'multiline':False]['text':'  concrete_parser class','line_number':223,'multiline':False]['text':'','line_number':224,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':225,'multiline':False]['text':'assignment operator could not be generated','line_number':228,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':258,'multiline':False]['text':'','line_number':259,'multiline':False]['text':'  This generates partial specializations for the class','line_number':260,'multiline':False]['text':'','line_number':261,'multiline':False]['text':'          abstract_parser','line_number':262,'multiline':False]['text':'','line_number':263,'multiline':False]['text':'  with an increasing number of different ScannerT template parameters','line_number':264,'multiline':False]['text':'  and corresponding do_parse_virtual function declarations for each','line_number':265,'multiline':False]['text':'  of the different required scanner types:','line_number':266,'multiline':False]['text':'','line_number':267,'multiline':False]['text':'      template <typename ScannerT0, ..., typename AttrT>','line_number':268,'multiline':False]['text':'      struct abstract_parser<scanner_list<ScannerT0, ...>, AttrT>','line_number':269,'multiline':False]['text':'      {','line_number':270,'multiline':False]['text':'          abstract_parser() {}','line_number':271,'multiline':False]['text':'          virtual ~abstract_parser() {}','line_number':272,'multiline':False]['text':'','line_number':273,'multiline':False]['text':'          virtual typename match_result<ScannerT0, AttrT>::type','line_number':274,'multiline':False]['text':'          do_parse_virtual(ScannerT0 const &scan) const = 0;','line_number':275,'multiline':False]['text':'','line_number':276,'multiline':False]['text':'          virtual abstract_parser*','line_number':277,'multiline':False]['text':'          clone() const = 0;','line_number':278,'multiline':False]['text':'','line_number':279,'multiline':False]['text':'          ...','line_number':280,'multiline':False]['text':'      };','line_number':281,'multiline':False]['text':'','line_number':282,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':283,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':318,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':320,'multiline':False]['text':'','line_number':321,'multiline':False]['text':'  This generates partial specializations for the class','line_number':322,'multiline':False]['text':'','line_number':323,'multiline':False]['text':'          concrete_parser','line_number':324,'multiline':False]['text':'','line_number':325,'multiline':False]['text':'  with an increasing number of different ScannerT template parameters','line_number':326,'multiline':False]['text':'  and corresponding do_parse_virtual function declarations for each','line_number':327,'multiline':False]['text':'  of the different required scanner types:','line_number':328,'multiline':False]['text':'','line_number':329,'multiline':False]['text':'      template <','line_number':330,'multiline':False]['text':'          typename ParserT, typename ScannerT0, ..., typename AttrT','line_number':331,'multiline':False]['text':'      >','line_number':332,'multiline':False]['text':'      struct concrete_parser<','line_number':333,'multiline':False]['text':'          ParserT, scanner_list<ScannerT0, ...>, AttrT','line_number':334,'multiline':False]['text':'      >','line_number':335,'multiline':False]['text':'      :   public abstract_parser<scanner_list<ScannerT0, ...>, AttrT>','line_number':336,'multiline':False]['text':'      {','line_number':337,'multiline':False]['text':'          concrete_parser(ParserT const& p_) : p(p_) {}','line_number':338,'multiline':False]['text':'          virtual ~concrete_parser() {}','line_number':339,'multiline':False]['text':'','line_number':340,'multiline':False]['text':'          virtual typename match_result<ScannerT0, AttrT>::type','line_number':341,'multiline':False]['text':'          do_parse_virtual(ScannerT0 const &scan) const','line_number':342,'multiline':False]['text':'          { return p.parse(scan); }','line_number':343,'multiline':False]['text':'','line_number':344,'multiline':False]['text':'          virtual abstract_parser<scanner_list<ScannerT0, ...>, AttrT>*','line_number':345,'multiline':False]['text':'          clone() const','line_number':346,'multiline':False]['text':'          {','line_number':347,'multiline':False]['text':'              return new concrete_parser(p);','line_number':348,'multiline':False]['text':'          }','line_number':349,'multiline':False]['text':'','line_number':350,'multiline':False]['text':'          ...','line_number':351,'multiline':False]['text':'','line_number':352,'multiline':False]['text':'          typename ParserT::embed_t p;','line_number':353,'multiline':False]['text':'      };','line_number':354,'multiline':False]['text':'','line_number':355,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':356,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////','line_number':410,'multiline':False]['text':' BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1','line_number':412,'multiline':False]['text':' namespace impl','line_number':414,'multiline':False]['text':' namespace boost::spirit','line_number':418,'multiline':False]