['text':'','line_number':1,'multiline':False]['text':'  Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':'  Distributed under the Boost Software License, Version 1.0. (See','line_number':4,'multiline':False]['text':'  accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]['text':'  http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':'/','line_number':20,'multiline':False]['text':'/ \brief This namespace provides various utility function useful for Boost.Locale backends','line_number':21,'multiline':False]['text':'/ implementations','line_number':22,'multiline':False]['text':'/','line_number':23,'multiline':False]['text':'/','line_number':26,'multiline':False]['text':'/ \brief Return default system locale name in POSIX format.','line_number':27,'multiline':False]['text':'/','line_number':28,'multiline':False]['text':'/ This function tries to detect the locale using, LC_CTYPE, LC_ALL and LANG environment','line_number':29,'multiline':False]['text':'/ variables in this order and if all of them unset, in POSIX platforms it returns "C"','line_number':30,'multiline':False]['text':'/ ','line_number':31,'multiline':False]['text':'/ On Windows additionally to check the above environment variables, this function','line_number':32,'multiline':False]['text':'/ tries to creates locale name from ISO-339 and ISO-3199 country codes defined','line_number':33,'multiline':False]['text':'/ for user default locale.','line_number':34,'multiline':False]['text':'/ If \a use_utf8_on_windows is true it sets the encoding to UTF-8, otherwise, if system','line_number':35,'multiline':False]['text':'/ locale supports ANSI code-page it defines the ANSI encoding like windows-1252, otherwise it fall-backs','line_number':36,'multiline':False]['text':'/ to UTF-8 encoding if ANSI code-page is not available.','line_number':37,'multiline':False]['text':'/','line_number':38,'multiline':False]['text':'/','line_number':42,'multiline':False]['text':'/ \brief Installs information facet to locale in based on locale name \a name','line_number':43,'multiline':False]['text':'/','line_number':44,'multiline':False]['text':'/ This function installs boost::locale::info facet into the locale \a in and returns','line_number':45,'multiline':False]['text':'/ newly created locale.','line_number':46,'multiline':False]['text':'/','line_number':47,'multiline':False]['text':'/ Note: all information is based only on parsing of string \a name;','line_number':48,'multiline':False]['text':'/','line_number':49,'multiline':False]['text':'/ The name has following format: language[_COUNTRY][.encoding][\@variant]','line_number':50,'multiline':False]['text':'/ Where language is ISO-639 language code like "en" or "ru", COUNTRY is ISO-3166','line_number':51,'multiline':False]['text':'/ country identifier like "US" or "RU". the Encoding is a charracter set name','line_number':52,'multiline':False]['text':'/ like UTF-8 or ISO-8859-1. Variant is backend specific variant like \c euro or','line_number':53,'multiline':False]['text':'/ calendar=hebrew.','line_number':54,'multiline':False]['text':'/','line_number':55,'multiline':False]['text':'/ If some parameters are missing they are specified as blanks, default encoding','line_number':56,'multiline':False]['text':'/ is assumed to be US-ASCII and missing language is assumed to be "C"','line_number':57,'multiline':False]['text':'/','line_number':58,'multiline':False]['text':'/','line_number':63,'multiline':False]['text':'/ \brief This class represent a simple stateless converter from UCS-4 and to UCS-4 for','line_number':64,'multiline':False]['text':'/  each single code point','line_number':65,'multiline':False]['text':'/','line_number':66,'multiline':False]['text':'/ This class is used for creation of std::codecvt facet for converting utf-16/utf-32 encoding','line_number':67,'multiline':False]['text':'/ to encoding supported by this converter','line_number':68,'multiline':False]['text':'/','line_number':69,'multiline':False]['text':'/ Please note, this converter should be fully stateless. Fully stateless means it should','line_number':70,'multiline':False]['text':'/ never assume that it is called in any specific order on the text. Even if the','line_number':71,'multiline':False]['text':'/ encoding itself seems to be stateless like windows-1255 or shift-jis, some','line_number':72,'multiline':False]['text':'/ encoders (most notably iconv) can actually compose several code-point into one or','line_number':73,'multiline':False]['text':'/ decompose them in case composite characters are found. So be very careful when implementing','line_number':74,'multiline':False]['text':'/ these converters for certain character set.','line_number':75,'multiline':False]['text':'/','line_number':76,'multiline':False]['text':'/','line_number':80,'multiline':False]['text':'/ This value should be returned when an illegal input sequence or code-point is observed:','line_number':81,'multiline':False]['text':'/ For example if a UCS-32 code-point is in the range reserved for UTF-16 surrogates','line_number':82,'multiline':False]['text':'/ or an invalid UTF-8 sequence is found','line_number':83,'multiline':False]['text':'/','line_number':84,'multiline':False]['text':'/','line_number':87,'multiline':False]['text':'/ This value is returned in following cases: The of incomplete input sequence was found or ','line_number':88,'multiline':False]['text':'/ insufficient output buffer was provided so complete output could not be written.','line_number':89,'multiline':False]['text':'/','line_number':90,'multiline':False]['text':'/','line_number':96,'multiline':False]['text':'/ Return the maximal length that one Unicode code-point can be converted to, for example','line_number':97,'multiline':False]['text':'/ for UTF-8 it is 4, for Shift-JIS it is 2 and ISO-8859-1 is 1','line_number':98,'multiline':False]['text':'/','line_number':99,'multiline':False]['text':'/','line_number':104,'multiline':False]['text':'/ Returns true if calling the functions from_unicode, to_unicode, and max_len is thread safe.','line_number':105,'multiline':False]['text':'/','line_number':106,'multiline':False]['text':'/ Rule of thumb: if this class' implementation uses simple tables that are unchanged','line_number':107,'multiline':False]['text':'/ or is purely algorithmic like UTF-8 - so it does not share any mutable bit for','line_number':108,'multiline':False]['text':'/ independent to_unicode, from_unicode calls, you may set it to true, otherwise,','line_number':109,'multiline':False]['text':'/ for example if you use iconv_t descriptor or UConverter as conversion object return false,','line_number':110,'multiline':False]['text':'/ and this object will be cloned for each use.','line_number':111,'multiline':False]['text':'/','line_number':112,'multiline':False]['text':'/','line_number':117,'multiline':False]['text':'/ Create a polymorphic copy of this object, usually called only if is_thread_safe() return false','line_number':118,'multiline':False]['text':'/','line_number':119,'multiline':False]['text':'/','line_number':126,'multiline':False]['text':'/ Convert a single character starting at begin and ending at most at end to Unicode code-point.','line_number':127,'multiline':False]['text':'/','line_number':128,'multiline':False]['text':'/ if valid input sequence found in [\a begin,\a code_point_end) such as \a begin < \a code_point_end && \a code_point_end <= \a end','line_number':129,'multiline':False]['text':'/ it is converted to its Unicode code point equivalent, \a begin is set to \a code_point_end','line_number':130,'multiline':False]['text':'/','line_number':131,'multiline':False]['text':'/ if incomplete input sequence found in [\a begin,\a end), i.e. there my be such \a code_point_end that \a code_point_end > \a end','line_number':132,'multiline':False]['text':'/ and [\a begin, \a code_point_end) would be valid input sequence, then \a incomplete is returned begin stays unchanged, for example','line_number':133,'multiline':False]['text':'/ for UTF-8 conversion a *begin = 0xc2, \a begin +1 = \a end is such situation.','line_number':134,'multiline':False]['text':'/','line_number':135,'multiline':False]['text':'/ if invalid input sequence found, i.e. there is a sequence [\a begin, \a code_point_end) such as \a code_point_end <= \a end','line_number':136,'multiline':False]['text':'/ that is illegal for this encoding, \a illegal is returned and begin stays unchanged. For example if *begin = 0xFF and begin < end','line_number':137,'multiline':False]['text':'/ for UTF-8, then \a illegal is returned.','line_number':138,'multiline':False]['text':'/ ','line_number':139,'multiline':False]['text':'/','line_number':140,'multiline':False]['text':'/','line_number':152,'multiline':False]['text':'/ Convert a single code-point \a u into encoding and store it in [begin,end) range.','line_number':153,'multiline':False]['text':'/','line_number':154,'multiline':False]['text':'/ If u is invalid Unicode code-point, or it can not be mapped correctly to represented character set,','line_number':155,'multiline':False]['text':'/ \a illegal should be returned','line_number':156,'multiline':False]['text':'/','line_number':157,'multiline':False]['text':'/ If u can be converted to a sequence of bytes c1, ... , cN (1<= N <= max_len() ) then','line_number':158,'multiline':False]['text':'/ ','line_number':159,'multiline':False]['text':'/ -# If end - begin >= N, c1, ... cN are written starting at begin and N is returned','line_number':160,'multiline':False]['text':'/ -# If end - begin < N, incomplete is returned, it is unspecified what would be','line_number':161,'multiline':False]['text':'/    stored in bytes in range [begin,end)','line_number':162,'multiline':False]['text':'/','line_number':176,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between UTF-8 and','line_number':177,'multiline':False]['text':'/ unicode code points','line_number':178,'multiline':False]['text':'/','line_number':179,'multiline':False]['text':'/','line_number':181,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between single byte','line_number':182,'multiline':False]['text':'/ character encodings like ISO-8859-1, koi8-r, windows-1255 and Unicode code points,','line_number':183,'multiline':False]['text':'/ ','line_number':184,'multiline':False]['text':'/ If \a encoding is not supported, empty pointer is returned. You should check if','line_number':185,'multiline':False]['text':'/ std::auto_ptr<base_converter>::get() != 0','line_number':186,'multiline':False]['text':'/','line_number':187,'multiline':False]['text':'/','line_number':191,'multiline':False]['text':'/ Install codecvt facet into locale \a in and return new locale that is based on \a in and uses new','line_number':192,'multiline':False]['text':'/ facet.','line_number':193,'multiline':False]['text':'/','line_number':194,'multiline':False]['text':'/ codecvt facet would convert between narrow and wide/char16_t/char32_t encodings using \a cvt converter.','line_number':195,'multiline':False]['text':'/ If \a cvt is null pointer, always failure conversion would be used that fails on every first input or output.','line_number':196,'multiline':False]['text':'/ ','line_number':197,'multiline':False]['text':'/ Note: the codecvt facet handles both UTF-16 and UTF-32 wide encodings, it knows to break and join','line_number':198,'multiline':False]['text':'/ Unicode code-points above 0xFFFF to and from surrogate pairs correctly. \a cvt should be unaware','line_number':199,'multiline':False]['text':'/ of wide encoding type','line_number':200,'multiline':False]['text':'/','line_number':201,'multiline':False]['text':'/','line_number':207,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between UTF-8 and','line_number':208,'multiline':False]['text':'/ unicode code points','line_number':209,'multiline':False]['text':'/','line_number':210,'multiline':False]['text':'/','line_number':212,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between single byte','line_number':213,'multiline':False]['text':'/ character encodings like ISO-8859-1, koi8-r, windows-1255 and Unicode code points,','line_number':214,'multiline':False]['text':'/ ','line_number':215,'multiline':False]['text':'/ If \a encoding is not supported, empty pointer is returned. You should check if','line_number':216,'multiline':False]['text':'/ std::unique_ptr<base_converter>::get() != 0','line_number':217,'multiline':False]['text':'/','line_number':218,'multiline':False]['text':'/','line_number':221,'multiline':False]['text':'/ Install codecvt facet into locale \a in and return new locale that is based on \a in and uses new','line_number':222,'multiline':False]['text':'/ facet.','line_number':223,'multiline':False]['text':'/','line_number':224,'multiline':False]['text':'/ codecvt facet would convert between narrow and wide/char16_t/char32_t encodings using \a cvt converter.','line_number':225,'multiline':False]['text':'/ If \a cvt is null pointer, always failure conversion would be used that fails on every first input or output.','line_number':226,'multiline':False]['text':'/ ','line_number':227,'multiline':False]['text':'/ Note: the codecvt facet handles both UTF-16 and UTF-32 wide encodings, it knows to break and join','line_number':228,'multiline':False]['text':'/ Unicode code-points above 0xFFFF to and from surrogate pairs correctly. \a cvt should be unaware','line_number':229,'multiline':False]['text':'/ of wide encoding type','line_number':230,'multiline':False]['text':'/','line_number':231,'multiline':False]['text':'/','line_number':236,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between UTF-8 and','line_number':237,'multiline':False]['text':'/ unicode code points','line_number':238,'multiline':False]['text':'/','line_number':239,'multiline':False]['text':'/','line_number':241,'multiline':False]['text':'/ This function creates a \a base_converter that can be used for conversion between single byte','line_number':242,'multiline':False]['text':'/ character encodings like ISO-8859-1, koi8-r, windows-1255 and Unicode code points,','line_number':243,'multiline':False]['text':'/ ','line_number':244,'multiline':False]['text':'/ If \a encoding is not supported, empty pointer is returned. You should check if','line_number':245,'multiline':False]['text':'/ std::unique_ptr<base_converter>::get() != 0','line_number':246,'multiline':False]['text':'/','line_number':247,'multiline':False]['text':'/','line_number':250,'multiline':False]['text':'/ Install codecvt facet into locale \a in and return new locale that is based on \a in and uses new','line_number':251,'multiline':False]['text':'/ facet.','line_number':252,'multiline':False]['text':'/','line_number':253,'multiline':False]['text':'/ codecvt facet would convert between narrow and wide/char16_t/char32_t encodings using \a cvt converter.','line_number':254,'multiline':False]['text':'/ If \a cvt is null pointer, always failure conversion would be used that fails on every first input or output.','line_number':255,'multiline':False]['text':'/ ','line_number':256,'multiline':False]['text':'/ Note: the codecvt facet handles both UTF-16 and UTF-32 wide encodings, it knows to break and join','line_number':257,'multiline':False]['text':'/ Unicode code-points above 0xFFFF to and from surrogate pairs correctly. \a cvt should be unaware','line_number':258,'multiline':False]['text':'/ of wide encoding type','line_number':259,'multiline':False]['text':'/','line_number':260,'multiline':False]['text':'/ ownership of cvt is transfered ','line_number':261,'multiline':False]['text':'/','line_number':262,'multiline':False]['text':'/ ','line_number':266,'multiline':False]['text':'/ Install utf8 codecvt to UTF-16 or UTF-32 into locale \a in and return','line_number':267,'multiline':False]['text':'/ new locale that is based on \a in and uses new facet. ','line_number':268,'multiline':False]['text':'/ ','line_number':269,'multiline':False]['text':'/','line_number':273,'multiline':False]['text':'/ This function installs codecvt that can be used for conversion between single byte','line_number':274,'multiline':False]['text':'/ character encodings like ISO-8859-1, koi8-r, windows-1255 and Unicode code points,','line_number':275,'multiline':False]['text':'/ ','line_number':276,'multiline':False]['text':'/ Throws boost::locale::conv::invalid_charset_error if the chacater set is not supported or isn't single byte character','line_number':277,'multiline':False]['text':'/ set','line_number':278,'multiline':False]['text':' util','line_number':281,'multiline':False]['text':' locale ','line_number':282,'multiline':False]['text':' boost','line_number':283,'multiline':False]['text':' vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4','line_number':286,'multiline':False]