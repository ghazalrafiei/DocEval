['text':'','line_number':1,'multiline':False]['text':' Copyright 2012-2022 Antony Polukhin.','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See accompanying','line_number':4,'multiline':False]['text':' file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'/ \file boost/type_index.hpp','line_number':11,'multiline':False]['text':'/ \brief Includes minimal set of headers required to use the Boost.TypeIndex library.','line_number':12,'multiline':False]['text':'/','line_number':13,'multiline':False]['text':'/ By inclusion of this file most optimal type index classes will be included and used ','line_number':14,'multiline':False]['text':'/ as a boost::typeindex::type_index and boost::typeindex::type_info.','line_number':15,'multiline':False]['text':'/ \def BOOST_TYPE_INDEX_FUNCTION_SIGNATURE','line_number':56,'multiline':False]['text':'/ BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by boost::typeindex::ctti_type_index class to','line_number':57,'multiline':False]['text':'/ deduce the name of a type. If your compiler is not recognized','line_number':58,'multiline':False]['text':'/ by the TypeIndex library and you wish to work with boost::typeindex::ctti_type_index, you may','line_number':59,'multiline':False]['text':'/ define this macro by yourself.','line_number':60,'multiline':False]['text':'/','line_number':61,'multiline':False]['text':'/ BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro','line_number':62,'multiline':False]['text':'/ that outputs the \b whole function signature \b including \b template \b parameters.','line_number':63,'multiline':False]['text':'/','line_number':64,'multiline':False]['text':'/ If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined,','line_number':65,'multiline':False]['text':'/ then a compile-time error will arise at any attempt to use boost::typeindex::ctti_type_index classes.','line_number':66,'multiline':False]['text':'/','line_number':67,'multiline':False]['text':'/ See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING','line_number':68,'multiline':False]['text':'/ for an information of how to tune the implementation to make a nice pretty_name() output.','line_number':69,'multiline':False]['text':'/ \def BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING','line_number':72,'multiline':False]['text':'/ This is a helper macro for making correct pretty_names() with RTTI off.','line_number':73,'multiline':False]['text':'/','line_number':74,'multiline':False]['text':'/ BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to','line_number':75,'multiline':False]['text':'/ '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a','line_number':76,'multiline':False]['text':'/ support for compilers, that by default are not recognized by TypeIndex library.','line_number':77,'multiline':False]['text':'/','line_number':78,'multiline':False]['text':'/ \b Example:','line_number':79,'multiline':False]['text':'/','line_number':80,'multiline':False]['text':'/ Imagine the situation when','line_number':81,'multiline':False]['text':'/ \code boost::typeindex::ctti_type_index::type_id<int>().pretty_name() \endcode','line_number':82,'multiline':False]['text':'/ returns the following string:','line_number':83,'multiline':False]['text':'/ \code "static const char *boost::detail::ctti<int>::n() [T = int]" \endcode','line_number':84,'multiline':False]['text':'/ and \code boost::typeindex::ctti_type_index::type_id<short>().pretty_name() \endcode returns the following:','line_number':85,'multiline':False]['text':'/ \code "static const char *boost::detail::ctti<short>::n() [T = short]" \endcode','line_number':86,'multiline':False]['text':'/','line_number':87,'multiline':False]['text':'/ As we may see first 39 characters are "static const char *boost::detail::ctti<" and they do not depend on','line_number':88,'multiline':False]['text':'/ the type T. After first 39 characters we have a human readable type name which is duplicated at the end','line_number':89,'multiline':False]['text':'/ of a string. String always ends on ']', which consumes 1 character.','line_number':90,'multiline':False]['text':'/','line_number':91,'multiline':False]['text':'/ Now if we define `BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING` to','line_number':92,'multiline':False]['text':'/ `(39, 1, false, "")` we'll be getting \code "int>::n() [T = int" \endcode','line_number':93,'multiline':False]['text':'/ for `boost::typeindex::ctti_type_index::type_id<int>().pretty_name()` and \code "short>::n() [T = short" \endcode','line_number':94,'multiline':False]['text':'/ for `boost::typeindex::ctti_type_index::type_id<short>().pretty_name()`.','line_number':95,'multiline':False]['text':'/','line_number':96,'multiline':False]['text':'/ Now we need to take additional care of the characters that go before the last mention of our type. We'll','line_number':97,'multiline':False]['text':'/ do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = "','line_number':98,'multiline':False]['text':'/ itself:','line_number':99,'multiline':False]['text':'/','line_number':100,'multiline':False]['text':'/ \code (39, 1, true, "T = ") \endcode','line_number':101,'multiline':False]['text':'/','line_number':102,'multiline':False]['text':'/ In case of GCC or Clang command line we need to add the following line while compiling all the sources:','line_number':103,'multiline':False]['text':'/','line_number':104,'multiline':False]['text':'/ \code','line_number':105,'multiline':False]['text':'/ -DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'','line_number':106,'multiline':False]['text':'/ \endcode','line_number':107,'multiline':False]['text':'/ \param begin_skip How many characters must be skipped at the beginning of the type holding string.','line_number':108,'multiline':False]['text':'/ Must be a compile time constant.','line_number':109,'multiline':False]['text':'/ \param end_skip How many characters must be skipped at the end of the type holding string.','line_number':110,'multiline':False]['text':'/ Must be a compile time constant.','line_number':111,'multiline':False]['text':'/ \param runtime_skip Do we need additional checks at runtime to cut off the more characters.','line_number':112,'multiline':False]['text':'/ Must be `true` or `false`.','line_number':113,'multiline':False]['text':'/ \param runtime_skip_until Skip all the characters before the following string (including the string itself).','line_number':114,'multiline':False]['text':'/ Must be a compile time array of characters.','line_number':115,'multiline':False]['text':'/','line_number':116,'multiline':False]['text':'/ See [RTTI emulation limitations](boost_typeindex/rtti_emulation_limitations.html) for more info.','line_number':117,'multiline':False]['text':'/ Depending on a compiler flags, optimal implementation of type_index will be used ','line_number':121,'multiline':False]['text':'/ as a default boost::typeindex::type_index.','line_number':122,'multiline':False]['text':'/','line_number':123,'multiline':False]['text':'/ Could be a boost::typeindex::stl_type_index, boost::typeindex::ctti_type_index or ','line_number':124,'multiline':False]['text':'/ user defined type_index class.','line_number':125,'multiline':False]['text':'/','line_number':126,'multiline':False]['text':'/ \b See boost::typeindex::type_index_facade for a full description of type_index functions.','line_number':127,'multiline':False]['text':' Nothing to do','line_number':130,'multiline':False]['text':'/ Depending on a compiler flags, optimal implementation of type_info will be used ','line_number':137,'multiline':False]['text':'/ as a default boost::typeindex::type_info.','line_number':138,'multiline':False]['text':'/','line_number':139,'multiline':False]['text':'/ Could be a std::type_info, boost::typeindex::detail::ctti_data or ','line_number':140,'multiline':False]['text':'/ some user defined class.','line_number':141,'multiline':False]['text':'/','line_number':142,'multiline':False]['text':'/ type_info \b is \b not copyable or default constructible. It is \b not assignable too!','line_number':143,'multiline':False]['text':'/ \def BOOST_TYPE_INDEX_USER_TYPEINDEX','line_number':148,'multiline':False]['text':'/ BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file','line_number':149,'multiline':False]['text':'/ with user provided implementation of type_index.','line_number':150,'multiline':False]['text':'/','line_number':151,'multiline':False]['text':'/ See [Making a custom type_index](boost_typeindex/making_a_custom_type_index.html) section','line_number':152,'multiline':False]['text':'/ of documentation for usage example.','line_number':153,'multiline':False]['text':'/ \def BOOST_TYPE_INDEX_REGISTER_CLASS','line_number':157,'multiline':False]['text':'/ BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI.','line_number':158,'multiline':False]['text':'/ Put this macro into the public section of polymorphic class to allow runtime type detection.','line_number':159,'multiline':False]['text':'/','line_number':160,'multiline':False]['text':'/ Depending on the typeid() availability this macro will expand to nothing or to virtual helper function','line_number':161,'multiline':False]['text':'/ `virtual const type_info& boost_type_info_type_id_runtime_() const noexcept`.','line_number':162,'multiline':False]['text':'/','line_number':163,'multiline':False]['text':'/ \b Example:','line_number':164,'multiline':False]['text':'/ \code','line_number':165,'multiline':False]['text':'/ class A {','line_number':166,'multiline':False]['text':'/ public:','line_number':167,'multiline':False]['text':'/     BOOST_TYPE_INDEX_REGISTER_CLASS','line_number':168,'multiline':False]['text':'/     virtual ~A(){}','line_number':169,'multiline':False]['text':'/ };','line_number':170,'multiline':False]['text':'/','line_number':171,'multiline':False]['text':'/ struct B: public A {','line_number':172,'multiline':False]['text':'/     BOOST_TYPE_INDEX_REGISTER_CLASS','line_number':173,'multiline':False]['text':'/ };','line_number':174,'multiline':False]['text':'/','line_number':175,'multiline':False]['text':'/ struct C: public B {','line_number':176,'multiline':False]['text':'/     BOOST_TYPE_INDEX_REGISTER_CLASS','line_number':177,'multiline':False]['text':'/ };','line_number':178,'multiline':False]['text':'/','line_number':179,'multiline':False]['text':'/ ...','line_number':180,'multiline':False]['text':'/','line_number':181,'multiline':False]['text':'/ C c1;','line_number':182,'multiline':False]['text':'/ A* pc1 = &c1;','line_number':183,'multiline':False]['text':'/ assert(boost::typeindex::type_id<C>() == boost::typeindex::type_id_runtime(*pc1));','line_number':184,'multiline':False]['text':'/ \endcode','line_number':185,'multiline':False]['text':'/ \def BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY','line_number':188,'multiline':False]['text':'/ BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing','line_number':189,'multiline':False]['text':'/ RTTI on/off modules. See','line_number':190,'multiline':False]['text':'/ [Mixing sources with RTTI on and RTTI off](boost_typeindex/mixing_sources_with_rtti_on_and_.html)','line_number':191,'multiline':False]['text':'/ section of documentation for more info.','line_number':192,'multiline':False]['text':' defined(BOOST_TYPE_INDEX_DOXYGEN_INVOKED)','line_number':195,'multiline':False]['text':'/ Function to get boost::typeindex::type_index for a type T.','line_number':198,'multiline':False]['text':'/ Removes const, volatile && and & modifiers from T.','line_number':199,'multiline':False]['text':'/','line_number':200,'multiline':False]['text':'/ \b Example:','line_number':201,'multiline':False]['text':'/ \code','line_number':202,'multiline':False]['text':'/ type_index ti = type_id<int&>();','line_number':203,'multiline':False]['text':'/ std::cout << ti.pretty_name();  // Outputs 'int'','line_number':204,'multiline':False]['text':'/ \endcode','line_number':205,'multiline':False]['text':'/','line_number':206,'multiline':False]['text':'/ \tparam T Type for which type_index must be created.','line_number':207,'multiline':False]['text':'/ \throw Nothing.','line_number':208,'multiline':False]['text':'/ \return boost::typeindex::type_index with information about the specified type T.','line_number':209,'multiline':False]['text':'/ Function for constructing boost::typeindex::type_index instance for type T. ','line_number':215,'multiline':False]['text':'/ Does not remove const, volatile, & and && modifiers from T.','line_number':216,'multiline':False]['text':'/','line_number':217,'multiline':False]['text':'/ If T has no const, volatile, & and && modifiers, then returns exactly ','line_number':218,'multiline':False]['text':'/ the same result as in case of calling `type_id<T>()`.','line_number':219,'multiline':False]['text':'/','line_number':220,'multiline':False]['text':'/ \b Example:','line_number':221,'multiline':False]['text':'/ \code','line_number':222,'multiline':False]['text':'/ type_index ti = type_id_with_cvr<int&>();','line_number':223,'multiline':False]['text':'/ std::cout << ti.pretty_name();  // Outputs 'int&'','line_number':224,'multiline':False]['text':'/ \endcode','line_number':225,'multiline':False]['text':'/','line_number':226,'multiline':False]['text':'/ \tparam T Type for which type_index must be created.','line_number':227,'multiline':False]['text':'/ \throw Nothing.','line_number':228,'multiline':False]['text':'/ \return boost::typeindex::type_index with information about the specified type T.','line_number':229,'multiline':False]['text':'/ Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index.','line_number':235,'multiline':False]['text':'/','line_number':236,'multiline':False]['text':'/ Returns runtime information about specified type.','line_number':237,'multiline':False]['text':'/','line_number':238,'multiline':False]['text':'/ \b Requirements: RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS.','line_number':239,'multiline':False]['text':'/','line_number':240,'multiline':False]['text':'/ \b Example:','line_number':241,'multiline':False]['text':'/ \code','line_number':242,'multiline':False]['text':'/ struct Base { virtual ~Base(){} };','line_number':243,'multiline':False]['text':'/ struct Derived: public Base  {};','line_number':244,'multiline':False]['text':'/ ...','line_number':245,'multiline':False]['text':'/ Derived d;','line_number':246,'multiline':False]['text':'/ Base& b = d;','line_number':247,'multiline':False]['text':'/ type_index ti = type_id_runtime(b);','line_number':248,'multiline':False]['text':'/ std::cout << ti.pretty_name();  // Outputs 'Derived'','line_number':249,'multiline':False]['text':'/ \endcode','line_number':250,'multiline':False]['text':'/','line_number':251,'multiline':False]['text':'/ \param runtime_val Variable which runtime type must be returned.','line_number':252,'multiline':False]['text':'/ \throw Nothing.','line_number':253,'multiline':False]['text':'/ \return boost::typeindex::type_index with information about the specified variable.','line_number':254,'multiline':False]['text':' namespace boost::typeindex','line_number':260,'multiline':False]['text':' BOOST_TYPE_INDEX_HPP','line_number':264,'multiline':False]