['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2005-2012. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See http://www.boost.org/libs/interprocess for documentation.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]['text':' interprocess/detail','line_number':25,'multiline':False]['text':'#ifdef BOOST_INTERPROCESS_PERFECT_FORWARDING','line_number':34,'multiline':False]['text':'!\file','line_number':39,'multiline':False]['text':'!Describes a proxy class that implements named allocation syntax.','line_number':40,'multiline':False]['text':'!Describes a proxy class that implements named','line_number':104,'multiline':False]['text':'!allocation syntax.','line_number':105,'multiline':False]['text':'segment manager to construct the object','line_number':107,'multiline':False]['text':'type of object to build','line_number':108,'multiline':False]['text':'passing parameters are normal object or iterators?','line_number':109,'multiline':False]['text':'This operator allows --> named_new("Name")[3]; <-- syntax','line_number':135,'multiline':False]['text':'#ifdef BOOST_INTERPROCESS_PERFECT_FORWARDING','line_number':140,'multiline':False]['text':'//////////////////////////////////////////////////////////////','line_number':142,'multiline':False]['text':'    What the macro should generate (n == 2):','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':'    template<class T, bool is_iterator, class P1, class P2>','line_number':145,'multiline':False]['text':'    struct Ctor2Arg','line_number':146,'multiline':False]['text':'      :  public placement_destroy<T>','line_number':147,'multiline':False]['text':'    {','line_number':148,'multiline':False]['text':'       typedef bool_<is_iterator> IsIterator;','line_number':149,'multiline':False]['text':'       typedef Ctor2Arg self_t;','line_number':150,'multiline':False]['text':'','line_number':151,'multiline':False]['text':'       void do_increment(false_)','line_number':152,'multiline':False]['text':'       { ++m_p1; ++m_p2;  }','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':'       void do_increment(true_){}','line_number':155,'multiline':False]['text':'','line_number':156,'multiline':False]['text':'       self_t& operator++()','line_number':157,'multiline':False]['text':'       {','line_number':158,'multiline':False]['text':'          this->do_increment(IsIterator());','line_number':159,'multiline':False]['text':'          return *this;','line_number':160,'multiline':False]['text':'       }','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':'       self_t  operator++(int) {  return ++*this;   *this;  }','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':'       Ctor2Arg(const P1 &p1, const P2 &p2)','line_number':165,'multiline':False]['text':'          : p1((P1 &)p_1), p2((P2 &)p_2) {}','line_number':166,'multiline':False]['text':'','line_number':167,'multiline':False]['text':'       void construct(void *mem)','line_number':168,'multiline':False]['text':'       {  new((void*)object)T(m_p1, m_p2); }','line_number':169,'multiline':False]['text':'','line_number':170,'multiline':False]['text':'       virtual void construct_n(void *mem','line_number':171,'multiline':False]['text':'                                , std::size_t num','line_number':172,'multiline':False]['text':'                                , std::size_t &constructed)','line_number':173,'multiline':False]['text':'       {','line_number':174,'multiline':False]['text':'          T* memory      = static_cast<T*>(mem);','line_number':175,'multiline':False]['text':'          for(constructed = 0; constructed < num; ++constructed){','line_number':176,'multiline':False]['text':'             this->construct(memory++, IsIterator());','line_number':177,'multiline':False]['text':'             this->do_increment(IsIterator());','line_number':178,'multiline':False]['text':'          }','line_number':179,'multiline':False]['text':'       }','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':'       private:','line_number':182,'multiline':False]['text':'       void construct(void *mem, true_)','line_number':183,'multiline':False]['text':'       {  new((void*)mem)T(*m_p1, *m_p2); }','line_number':184,'multiline':False]['text':'','line_number':185,'multiline':False]['text':'       void construct(void *mem, false_)','line_number':186,'multiline':False]['text':'       {  new((void*)mem)T(m_p1, m_p2); }','line_number':187,'multiline':False]['text':'','line_number':188,'multiline':False]['text':'       P1 &m_p1; P2 &m_p2;','line_number':189,'multiline':False]['text':'    };','line_number':190,'multiline':False]['text':'//////////////////////////////////////////////////////////////','line_number':191,'multiline':False]['text':'!','line_number':214,'multiline':False]['text':'!','line_number':245,'multiline':False]['text':'!Describes a proxy class that implements named','line_number':249,'multiline':False]['text':'!allocation syntax.','line_number':250,'multiline':False]['text':'segment manager to construct the object','line_number':252,'multiline':False]['text':'type of object to build','line_number':253,'multiline':False]['text':'passing parameters are normal object or iterators?','line_number':254,'multiline':False]['text':'','line_number':283,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////','line_number':287,'multiline':False]['text':'             What the macro should generate (n == 2)','line_number':288,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////','line_number':289,'multiline':False]['text':'','line_number':290,'multiline':False]['text':' template <class P1, class P2>','line_number':291,'multiline':False]['text':' T *operator()(P1 &p1, P2 &p2) const','line_number':292,'multiline':False]['text':' {','line_number':293,'multiline':False]['text':'    typedef CtorArg2','line_number':294,'multiline':False]['text':'       <T, is_iterator, P1, P2>','line_number':295,'multiline':False]['text':'       ctor_obj_t;','line_number':296,'multiline':False]['text':'    ctor_obj_t ctor_obj(p1, p2);','line_number':297,'multiline':False]['text':'','line_number':298,'multiline':False]['text':'    return mp_mngr->template generic_construct<T>','line_number':299,'multiline':False]['text':'       (mp_name, m_num, m_find, m_dothrow, ctor_obj);','line_number':300,'multiline':False]['text':' }','line_number':301,'multiline':False]['text':'','line_number':302,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////','line_number':303,'multiline':False]['text':'This operator allows --> named_new("Name")[3]; <-- syntax','line_number':305,'multiline':False]['text':'#ifdef BOOST_INTERPROCESS_PERFECT_FORWARDING','line_number':310,'multiline':False]['text':'namespace boost { namespace interprocess { namespace ipcdetail {','line_number':312,'multiline':False]['text':'#ifndef BOOST_INTERPROCESS_NAMED_PROXY_HPP','line_number':316,'multiline':False]