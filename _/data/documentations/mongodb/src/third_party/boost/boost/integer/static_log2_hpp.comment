['text':' -------------- Boost static_log2.hpp header file  ----------------------- //','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':'                 Copyright (C) 2001 Daryle Walker.','line_number':3,'multiline':False]['text':'                 Copyright (C) 2003 Vesa Karvonen.','line_number':4,'multiline':False]['text':'                 Copyright (C) 2003 Gennaro Prota.','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'     Distributed under the Boost Software License, Version 1.0.','line_number':7,'multiline':False]['text':'        (See accompanying file LICENSE_1_0.txt or copy at','line_number':8,'multiline':False]['text':'              https://www.boost.org/LICENSE_1_0.txt)','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':'         ---------------------------------------------------','line_number':11,'multiline':False]['text':'       See https://www.boost.org/libs/integer for documentation.','line_number':12,'multiline':False]['text':' ------------------------------------------------------------------------- //','line_number':13,'multiline':False]['text':' choose_initial_n<>','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' Recursively doubles its integer argument, until it','line_number':30,'multiline':False]['text':' becomes >= of the "width" (C99, 6.2.6.2p4) of','line_number':31,'multiline':False]['text':' static_log2_argument_type.','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':' Used to get the maximum power of two less then the width.','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' Example: if on your platform argument_type has 48 value','line_number':36,'multiline':False]['text':'          bits it yields n=32.','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' It's easy to prove that, starting from such a value','line_number':39,'multiline':False]['text':' of n, the core algorithm works correctly for any width','line_number':40,'multiline':False]['text':' of static_log2_argument_type and that recursion always','line_number':41,'multiline':False]['text':' terminates with x = 1 and n = 0 (see the algorithm's','line_number':42,'multiline':False]['text':' invariant).','line_number':43,'multiline':False]['text':' start computing from n_zero - must be a power of two','line_number':66,'multiline':False]['text':' static_log2_impl<>','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':' * Invariant:','line_number':72,'multiline':False]['text':'                 2n','line_number':73,'multiline':False]['text':'  1 <= x && x < 2    at the start of each recursion','line_number':74,'multiline':False]['text':'                     (see also choose_initial_n<>)','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' * Type requirements:','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':'   argument_type maybe any unsigned type with at least n_zero + 1','line_number':79,'multiline':False]['text':'   value bits. (Note: If larger types will be standardized -e.g.','line_number':80,'multiline':False]['text':'   unsigned long long- then the argument_type typedef can be','line_number':81,'multiline':False]['text':'   changed without affecting the rest of the code.)','line_number':82,'multiline':False]['text':'','line_number':83,'multiline':False]['text':' x >= 2**n ?','line_number':88,'multiline':False]['text':' detail','line_number':102,'multiline':False]['text':' --------------------------------------','line_number':106,'multiline':False]['text':' static_log2<x>','line_number':107,'multiline':False]['text':' ----------------------------------------','line_number':108,'multiline':False]['text':' include guard','line_number':126,'multiline':False]