['text':'
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * Copyright (c) 2009 Helge Bahmann
 * Copyright (c) 2012 Tim Blechmann
 * Copyright (c) 2014 - 2018 Andrey Semashev
 ','line_number':1,'multiline':True]['text':'!
 * \file   atomic/detail/ops_gcc_x86_dcas.hpp
 *
 * This header contains implementation of the double-width CAS primitive for x86.
 ','line_number':10,'multiline':True]['text':' Note: In the 32-bit PIC code guarded with BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX below we have to avoid using memory','line_number':34,'multiline':False]['text':' operand constraints because the compiler may choose to use ebx as the base register for that operand. At least, clang','line_number':35,'multiline':False]['text':' is known to do that. For this reason we have to pre-compute a pointer to storage and pass it in edi. For the same reason','line_number':36,'multiline':False]['text':' we cannot save ebx to the stack with a mov instruction, so we use esi as a scratch register and restore it afterwards.','line_number':37,'multiline':False]['text':' Alternatively, we could push/pop the register to the stack, but exchanging the registers is faster.','line_number':38,'multiline':False]['text':' The need to pass a pointer in edi is a bit wasteful because normally the memory operand would use a base pointer','line_number':39,'multiline':False]['text':' with an offset (e.g. `this` + offset). But unfortunately, there seems to be no way around it.','line_number':40,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':106,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':118,'multiline':False]['text':' Note that despite const qualification cmpxchg8b below may issue a store to the storage. The storage value','line_number':161,'multiline':False]['text':' will not change, but this prevents the storage to reside in read-only memory.','line_number':162,'multiline':False]['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':168,'multiline':False]['text':' Also we don't care for ebx and ecx values, they just have to be equal to eax and edx before cmpxchg8b.','line_number':169,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':181,'multiline':False]['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':183,'multiline':False]['text':' Also we don't care for ebx and ecx values, they just have to be equal to eax and edx before cmpxchg8b.','line_number':184,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':195,'multiline':False]['text':' Clang cannot allocate eax:edx register pairs but it has sync intrinsics','line_number':206,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':225,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':236,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':240,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':252,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':261,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':265,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':298,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':316,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':317,'multiline':False]['text':' MinGW gcc up to 4.6 has problems with allocating registers in the asm blocks below','line_number':320,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':357,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':373,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':374,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_HAS_CMPXCHG8B)','line_number':378,'multiline':False]['text':' Note that despite const qualification cmpxchg16b below may issue a store to the storage. The storage value','line_number':409,'multiline':False]['text':' will not change, but this prevents the storage to reside in read-only memory.','line_number':410,'multiline':False]['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':416,'multiline':False]['text':' Also we don't care for rbx and rcx values, they just have to be equal to rax and rdx before cmpxchg16b.','line_number':417,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':432,'multiline':False]['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':436,'multiline':False]['text':' Also we don't care for rbx and rcx values, they just have to be equal to rax and rdx before cmpxchg16b.','line_number':437,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':450,'multiline':False]['text':' Clang cannot allocate rax:rdx register pairs but it has sync intrinsics','line_number':458,'multiline':False]['text':' Some compilers can't allocate rax:rdx register pair either but also don't support 128-bit __sync_val_compare_and_swap','line_number':465,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':478,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':490,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':499,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':503,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':531,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':546,'multiline':False]['text':' defined(BOOST_ATOMIC_DETAIL_X86_HAS_CMPXCHG16B)','line_number':550,'multiline':False]['text':' namespace detail','line_number':552,'multiline':False]['text':' namespace atomics','line_number':553,'multiline':False]['text':' namespace boost','line_number':554,'multiline':False]['text':' BOOST_ATOMIC_DETAIL_OPS_GCC_X86_DCAS_HPP_INCLUDED_','line_number':556,'multiline':False]