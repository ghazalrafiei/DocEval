['text':'  Copyright John Maddock 2006-7, 2013-20.','line_number':1,'multiline':False]['text':'  Copyright Paul A. Bristow 2007, 2013-14.','line_number':2,'multiline':False]['text':'  Copyright Nikhar Agrawal 2013-14','line_number':3,'multiline':False]['text':'  Copyright Christopher Kormanyos 2013-14, 2020','line_number':4,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':6,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':7,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':' unreachable code (return after domain_error throw).','line_number':44,'multiline':False]['text':' conditional expression is constant.','line_number':45,'multiline':False]['text':' unreferenced formal parameter.','line_number':46,'multiline':False]['text':' Several variables made comments,','line_number':47,'multiline':False]['text':' but some difficulty as whether referenced on not may depend on macro values.','line_number':48,'multiline':False]['text':' So to be safe, 4100 warnings suppressed.','line_number':49,'multiline':False]['text':' TODO - revisit this?','line_number':50,'multiline':False]['text':' Oh dear can't cast T to int!','line_number':66,'multiline':False]['text':' Ad hoc function calculates x * sin(pi * x),','line_number':80,'multiline':False]['text':' taking extra care near when x is near a whole number.','line_number':81,'multiline':False]['text':' template <class T> T sinpx(T z)','line_number':105,'multiline':False]['text':'','line_number':106,'multiline':False]['text':' tgamma(z), with Lanczos support:','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':' shift z to > 1:','line_number':145,'multiline':False]['text':' we're going to overflow unless this is done with care:','line_number':173,'multiline':False]['text':'','line_number':197,'multiline':False]['text':' lgamma(z) with Lanczos support:','line_number':198,'multiline':False]['text':'','line_number':199,'multiline':False]['text':' reflection formula:','line_number':220,'multiline':False]['text':' taking the log of tgamma reduces the error, no danger of overflow here:','line_number':260,'multiline':False]['text':' regular evaluation:','line_number':265,'multiline':False]['text':'','line_number':269,'multiline':False]['text':' Only add on the lanczos sum part if we're going to need it:','line_number':270,'multiline':False]['text':'','line_number':271,'multiline':False]['text':'','line_number':281,'multiline':False]['text':' Incomplete gamma functions follow:','line_number':282,'multiline':False]['text':'','line_number':283,'multiline':False]['text':' Multiply result by z^a * e^-z to get the full','line_number':309,'multiline':False]['text':' upper incomplete integral.  Divide by tgamma(z)','line_number':310,'multiline':False]['text':' to normalise.','line_number':311,'multiline':False]['text':' Multiply result by ((z^a) * (e^-z) / a) to get the full','line_number':337,'multiline':False]['text':' lower incomplete integral. Then divide by tgamma(a)','line_number':338,'multiline':False]['text':' to get the normalised value.','line_number':339,'multiline':False]['text':'','line_number':348,'multiline':False]['text':' Fully generic tgamma and lgamma use Stirling's approximation','line_number':349,'multiline':False]['text':' with Bernoulli numbers.','line_number':350,'multiline':False]['text':'','line_number':351,'multiline':False]['text':' Find the high index n for Bn to produce the desired precision in Stirling's calculation.','line_number':359,'multiline':False]['text':' The following code sequence has been modified','line_number':376,'multiline':False]['text':' within the context of issue 396.','line_number':377,'multiline':False]['text':' The calculation of the test-variable limit has now','line_number':379,'multiline':False]['text':' been protected against overflow/underflow dangers.','line_number':380,'multiline':False]['text':' The previous line looked like this and did, in fact,','line_number':382,'multiline':False]['text':' underflow ldexp when using certain multiprecision types.','line_number':383,'multiline':False]['text':' const float limit = std::ceil(std::pow(1.0f / std::ldexp(1.0f, 1-boost::math::tools::digits<T>()), 1.0f / 20.0f));','line_number':385,'multiline':False]['text':' The new safe version of the limit check is now here.','line_number':387,'multiline':False]['text':'','line_number':401,'multiline':False]['text':' Calculates tgamma(z) / (z/e)^z','line_number':402,'multiline':False]['text':' Requires that our argument is large enough for Sterling's approximation to hold.','line_number':403,'multiline':False]['text':' Used internally when combining gamma's of similar magnitude without logarithms.','line_number':404,'multiline':False]['text':'','line_number':405,'multiline':False]['text':' Perform the Bernoulli series expansion of Stirling's approximation.','line_number':408,'multiline':False]['text':' We have reached the desired precision in Stirling's expansion.','line_number':429,'multiline':False]['text':' Adding additional terms to the sum of this divergent asymptotic','line_number':430,'multiline':False]['text':' expansion will not improve the result.','line_number':431,'multiline':False]['text':' Break from the loop.','line_number':433,'multiline':False]['text':' Sanity check for divergence:','line_number':441,'multiline':False]['text':' Complete Stirling's approximation.','line_number':448,'multiline':False]['text':' Forward declaration of the lgamma_imp template specialization.','line_number':453,'multiline':False]['text':' Check if the argument of tgamma is identically zero.','line_number':464,'multiline':False]['text':' Special case handling of small factorials:','line_number':474,'multiline':False]['text':' Make a local, unsigned copy of the input argument.','line_number':480,'multiline':False]['text':' Special case for ultra-small z:','line_number':483,'multiline':False]['text':' Scale the argument up for the calculation of lgamma,','line_number':496,'multiline':False]['text':' and use downward recursion later for the final result.','line_number':497,'multiline':False]['text':' Rescale the result using downward recursion if necessary.','line_number':527,'multiline':False]['text':' The order of divides is important, if we keep subtracting 1 from zz','line_number':530,'multiline':False]['text':' we DO NOT get back to z (cancellation error).  Further if z < epsilon','line_number':531,'multiline':False]['text':' we would end up dividing by zero.  Also in order to prevent spurious','line_number':532,'multiline':False]['text':' overflow with the first division, we must save dividing by |z| till last,','line_number':533,'multiline':False]['text':' so the optimal order of divides is z+1, z+2, z+3...z+n_recur-1,z.','line_number':534,'multiline':False]['text':' Return the result, accounting for possible negative arguments.','line_number':544,'multiline':False]['text':' Provide special error analysis for:','line_number':547,'multiline':False]['text':' * arguments in the neighborhood of a negative integer','line_number':548,'multiline':False]['text':' * arguments exactly equal to a negative integer.','line_number':549,'multiline':False]['text':' Check if the argument of tgamma is exactly equal to a negative integer.','line_number':551,'multiline':False]['text':'','line_number':581,'multiline':False]['text':' This is for the multiprecision case where there is','line_number':582,'multiline':False]['text':' no lanczos support, use a taylor series at z = 1,','line_number':583,'multiline':False]['text':' see https://www.wolframalpha.com/input/?i=taylor+series+lgamma(x)+at+x+%3D+1','line_number':584,'multiline':False]['text':'','line_number':585,'multiline':False]['text':' ADL of std names','line_number':586,'multiline':False]['text':' Check if the argument of lgamma is identically zero.','line_number':614,'multiline':False]['text':' Special case handling of small factorials:','line_number':628,'multiline':False]['text':' Make a local, unsigned copy of the input argument.','line_number':636,'multiline':False]['text':' Here we simply take the logarithm of tgamma(). This is somewhat','line_number':645,'multiline':False]['text':' inefficient, but simple. The rationale is that the argument here','line_number':646,'multiline':False]['text':' is relatively small and overflow is not expected to be likely.','line_number':647,'multiline':False]['text':' Reflection formula may fail if z is very close to zero, let the series','line_number':660,'multiline':False]['text':' expansion for tgamma close to zero do the work:','line_number':661,'multiline':False]['text':' No issue with spurious overflow in reflection formula, ','line_number':668,'multiline':False]['text':' just fall through to regular code:','line_number':669,'multiline':False]['text':' Perform the Bernoulli series expansion of Stirling's approximation.','line_number':680,'multiline':False]['text':' Provide special error analysis if the argument is exactly','line_number':689,'multiline':False]['text':' equal to a negative integer.','line_number':690,'multiline':False]['text':' Check if the argument of lgamma is exactly equal to a negative integer.','line_number':692,'multiline':False]['text':'','line_number':717,'multiline':False]['text':' This helper calculates tgamma(dz+1)-1 without cancellation errors,','line_number':718,'multiline':False]['text':' used by the upper incomplete gamma with z < 1:','line_number':719,'multiline':False]['text':'','line_number':720,'multiline':False]['text':' Best method is simply to subtract 1 from tgamma:','line_number':739,'multiline':False]['text':' Use expm1 on lgamma:','line_number':745,'multiline':False]['text':' Use expm1 on lgamma:','line_number':755,'multiline':False]['text':' Best method is simply to subtract 1 from tgamma:','line_number':761,'multiline':False]['text':' ADL of std names','line_number':774,'multiline':False]['text':'','line_number':783,'multiline':False]['text':' Series representation for upper fraction when z is small:','line_number':784,'multiline':False]['text':'','line_number':785,'multiline':False]['text':'','line_number':806,'multiline':False]['text':' calculate power term prefix (z^a)(e^-z) used in the non-normalised','line_number':807,'multiline':False]['text':' incomplete gammas:','line_number':808,'multiline':False]['text':'','line_number':809,'multiline':False]['text':'','line_number':850,'multiline':False]['text':' This error handling isn't very good: it happens after the fact','line_number':851,'multiline':False]['text':' rather than before it...','line_number':852,'multiline':False]['text':'','line_number':853,'multiline':False]['text':'','line_number':859,'multiline':False]['text':' Compute (z^a)(e^-z)/tgamma(a)','line_number':860,'multiline':False]['text':' most if the error occurs in this function:','line_number':861,'multiline':False]['text':'','line_number':862,'multiline':False]['text':'','line_number':875,'multiline':False]['text':' We have to treat a < 1 as a special case because our Lanczos','line_number':876,'multiline':False]['text':' approximations are optimised against the factorials with a > 1,','line_number':877,'multiline':False]['text':' and for high precision types especially (128-bit reals for example)','line_number':878,'multiline':False]['text':' very small values of a can give rather erroneous results for gamma','line_number':879,'multiline':False]['text':' unless we do this:','line_number':880,'multiline':False]['text':'','line_number':881,'multiline':False]['text':' TODO: is this still required?  Lanczos approx should be better now?','line_number':882,'multiline':False]['text':'','line_number':883,'multiline':False]['text':' Oh dear, have to use logs, should be free of cancellation errors though:','line_number':886,'multiline':False]['text':' direct calculation, no danger of overflow as gamma(a) < 1/a','line_number':891,'multiline':False]['text':' for small a.','line_number':892,'multiline':False]['text':' special case for large a and a ~ z.','line_number':898,'multiline':False]['text':'','line_number':904,'multiline':False]['text':' general case.','line_number':905,'multiline':False]['text':' direct computation is most accurate, but use various fallbacks','line_number':906,'multiline':False]['text':' for different parts of the problem domain:','line_number':907,'multiline':False]['text':'','line_number':908,'multiline':False]['text':' compute square root of the result and then square it:','line_number':916,'multiline':False]['text':' compute the 4th root of the result then square it twice:','line_number':922,'multiline':False]['text':'','line_number':944,'multiline':False]['text':' And again, without Lanczos support:','line_number':945,'multiline':False]['text':'','line_number':946,'multiline':False]['text':' No overflow possible since the power terms tend to unity as a,z -> 0','line_number':954,'multiline':False]['text':' The result is probably zero, but we need to be sure:','line_number':964,'multiline':False]['text':'','line_number':971,'multiline':False]['text':' Usual case is to calculate the prefix at a+shift and recurse down','line_number':972,'multiline':False]['text':' to the value we want:','line_number':973,'multiline':False]['text':'','line_number':974,'multiline':False]['text':' ','line_number':989,'multiline':False]['text':' We failed, most probably we have z << 1, try again, this time','line_number':990,'multiline':False]['text':' we calculate z^a e^-z / tgamma(a+shift), combining power terms','line_number':991,'multiline':False]['text':' as we go.  And again recurse down to the result.','line_number':992,'multiline':False]['text':'','line_number':993,'multiline':False]['text':' We have no test case that gets here, most likely the type T','line_number':1000,'multiline':False]['text':' has a high precision but low exponent range:','line_number':1001,'multiline':False]['text':'','line_number':1013,'multiline':False]['text':' Upper gamma fraction for very small a:','line_number':1014,'multiline':False]['text':'','line_number':1015,'multiline':False]['text':' ADL of std functions.','line_number':1019,'multiline':False]['text':'','line_number':1020,'multiline':False]['text':' Compute the full upper fraction (Q) when a is very small:','line_number':1021,'multiline':False]['text':'','line_number':1022,'multiline':False]['text':'','line_number':1042,'multiline':False]['text':' Upper gamma fraction for integer a:','line_number':1043,'multiline':False]['text':'','line_number':1044,'multiline':False]['text':'','line_number':1048,'multiline':False]['text':' Calculates normalised Q when a is an integer:','line_number':1049,'multiline':False]['text':'','line_number':1050,'multiline':False]['text':'','line_number':1070,'multiline':False]['text':' Upper gamma fraction for half integer a:','line_number':1071,'multiline':False]['text':'','line_number':1072,'multiline':False]['text':'','line_number':1076,'multiline':False]['text':' Calculates normalised Q when a is a half-integer:','line_number':1077,'multiline':False]['text':'','line_number':1078,'multiline':False]['text':' We'll be dividing by x later, so calculate derivative * x:','line_number':1102,'multiline':False]['text':'','line_number':1107,'multiline':False]['text':' Asymptotic approximation for large argument, see: https://dlmf.nist.gov/8.11#E2','line_number':1108,'multiline':False]['text':'','line_number':1109,'multiline':False]['text':'','line_number':1138,'multiline':False]['text':' Main incomplete gamma entry point, handles all four incomplete gamma's:','line_number':1139,'multiline':False]['text':'','line_number':1140,'multiline':False]['text':' Just to avoid warning C4701: potentially uninitialized local variable 'result' used','line_number':1155,'multiline':False]['text':'','line_number':1159,'multiline':False]['text':' When we're computing the non-normalized incomplete gamma','line_number':1160,'multiline':False]['text':' and a is large the result is rather hard to compute unless','line_number':1161,'multiline':False]['text':' we use logs.  There are really two options - if x is a long','line_number':1162,'multiline':False]['text':' way from a in value then we can reliably use methods 2 and 4','line_number':1163,'multiline':False]['text':' below in logarithmic form and go straight to the result.','line_number':1164,'multiline':False]['text':' Otherwise we let the regularized gamma take the strain','line_number':1165,'multiline':False]['text':' (the result is unlikely to underflow in the central region anyway)','line_number':1166,'multiline':False]['text':' and combine with lgamma in the hopes that we get a finite result.','line_number':1167,'multiline':False]['text':'','line_number':1168,'multiline':False]['text':' This is method 4 below, done in logs:','line_number':1171,'multiline':False]['text':' This is method 2 below, done in logs:','line_number':1179,'multiline':False]['text':' Try http://functions.wolfram.com/06.06.06.0039.01','line_number':1193,'multiline':False]['text':' This is method 2 below, done in logs, we're really outside the','line_number':1201,'multiline':False]['text':' range of this method, but since the result is almost certainly','line_number':1202,'multiline':False]['text':' infinite, we should probably be OK:','line_number':1203,'multiline':False]['text':' calculate Q via finite sum:','line_number':1240,'multiline':False]['text':' calculate Q via finite sum for half integer a:','line_number':1246,'multiline':False]['text':' calculate Q via asymptotic approximation:','line_number':1256,'multiline':False]['text':'','line_number':1262,'multiline':False]['text':' Changeover criterion chosen to give a changeover at Q ~ 0.33','line_number':1263,'multiline':False]['text':'','line_number':1264,'multiline':False]['text':'','line_number':1276,'multiline':False]['text':' Changover here occurs when P ~ 0.75 or Q ~ 0.25:','line_number':1277,'multiline':False]['text':'','line_number':1278,'multiline':False]['text':'','line_number':1290,'multiline':False]['text':' Begin by testing whether we're in the "bad" zone','line_number':1291,'multiline':False]['text':' where the result will be near 0.5 and the usual','line_number':1292,'multiline':False]['text':' series and continued fractions are slow to converge:','line_number':1293,'multiline':False]['text':'','line_number':1294,'multiline':False]['text':'','line_number':1301,'multiline':False]['text':' This limit is chosen so that we use Temme's expansion','line_number':1302,'multiline':False]['text':' only if the result would be larger than about 10^-6.','line_number':1303,'multiline':False]['text':' Below that the regular series and continued fractions','line_number':1304,'multiline':False]['text':' converge OK, and if we use Temme's method we get increasing','line_number':1305,'multiline':False]['text':' errors from the dominant erfc term as it's (inexact) argument','line_number':1306,'multiline':False]['text':' increases in magnitude.','line_number':1307,'multiline':False]['text':'','line_number':1308,'multiline':False]['text':' Note in this zone we can't use Temme's expansion for ','line_number':1314,'multiline':False]['text':' types longer than an 80-bit real:','line_number':1315,'multiline':False]['text':' it would require too many terms in the polynomials.','line_number':1316,'multiline':False]['text':'','line_number':1327,'multiline':False]['text':' Regular case where the result will not be too close to 0.5.','line_number':1328,'multiline':False]['text':'','line_number':1329,'multiline':False]['text':' Changeover here occurs at P ~ Q ~ 0.5','line_number':1330,'multiline':False]['text':' Note that series computation of P is about x2 faster than continued fraction','line_number':1331,'multiline':False]['text':' calculation of Q, so try and use the CF only when really necessary, especially','line_number':1332,'multiline':False]['text':' for small x.','line_number':1333,'multiline':False]['text':'','line_number':1334,'multiline':False]['text':' Compute P:','line_number':1367,'multiline':False]['text':'','line_number':1373,'multiline':False]['text':' If we're going to be inverting the result then we can','line_number':1374,'multiline':False]['text':' reduce the number of series evaluations by quite','line_number':1375,'multiline':False]['text':' a few iterations if we set an initial value for the','line_number':1376,'multiline':False]['text':' series sum based on what we'll end up subtracting it from','line_number':1377,'multiline':False]['text':' at the end.','line_number':1378,'multiline':False]['text':' Have to be careful though that this optimization doesn't ','line_number':1379,'multiline':False]['text':' lead to spurious numeric overflow.  Note that the','line_number':1380,'multiline':False]['text':' scary/expensive overflow checks below are more often','line_number':1381,'multiline':False]['text':' than not bypassed in practice for "sensible" input','line_number':1382,'multiline':False]['text':' values:','line_number':1383,'multiline':False]['text':'','line_number':1384,'multiline':False]['text':' Compute Q:','line_number':1415,'multiline':False]['text':' Compute Q:','line_number':1426,'multiline':False]['text':'','line_number':1436,'multiline':False]['text':' Use compile time dispatch to the appropriate','line_number':1437,'multiline':False]['text':' Temme asymptotic expansion.  This may be dead code','line_number':1438,'multiline':False]['text':' if T does not have numeric limits support, or has','line_number':1439,'multiline':False]['text':' too many digits for the most precise version of','line_number':1440,'multiline':False]['text':' these expansions, in that case we'll be calling','line_number':1441,'multiline':False]['text':' an empty function.','line_number':1442,'multiline':False]['text':'','line_number':1443,'multiline':False]['text':' x is so small that P is necessarily very small too,','line_number':1462,'multiline':False]['text':' use http://functions.wolfram.com/GammaBetaErf/GammaRegularized/06/01/05/01/01/','line_number':1463,'multiline':False]['text':' x is large,','line_number':1484,'multiline':False]['text':' Compute Q:','line_number':1485,'multiline':False]['text':'','line_number':1505,'multiline':False]['text':' Need to convert prefix term to derivative:','line_number':1506,'multiline':False]['text':'','line_number':1507,'multiline':False]['text':' overflow, just return an arbitrarily large value:','line_number':1510,'multiline':False]['text':'','line_number':1520,'multiline':False]['text':' Ratios of two gamma functions:','line_number':1521,'multiline':False]['text':'','line_number':1522,'multiline':False]['text':'','line_number':1529,'multiline':False]['text':' We get spurious numeric overflow unless we're very careful, this','line_number':1530,'multiline':False]['text':' can occur either inside Lanczos::lanczos_sum(z) or in the','line_number':1531,'multiline':False]['text':' final combination of terms, to avoid this, split the product up','line_number':1532,'multiline':False]['text':' into 2 (or 3) parts:','line_number':1533,'multiline':False]['text':'','line_number':1534,'multiline':False]['text':' G(z) / G(L) = 1 / (z * G(L)) ; z < eps, L = z + delta = delta','line_number':1535,'multiline':False]['text':'    z * G(L) = z * G(lim) * (G(L)/G(lim)) ; lim = largest factorial','line_number':1536,'multiline':False]['text':'','line_number':1537,'multiline':False]['text':' We have:','line_number':1556,'multiline':False]['text':' result = exp((constants::half<T>() - z) * boost::math::log1p(delta / zgh, pol));','line_number':1557,'multiline':False]['text':' 0.5 - z == -z','line_number':1558,'multiline':False]['text':' log1p(delta / zgh) = delta / zgh = delta / z','line_number':1559,'multiline':False]['text':' multiplying we get -delta.','line_number':1560,'multiline':False]['text':' from the pow formula below... but this may actually be wrong, we just can't really calculate it :(','line_number':1564,'multiline':False]['text':' Split the calculation up to avoid spurious overflow:','line_number':1577,'multiline':False]['text':'','line_number':1583,'multiline':False]['text':' And again without Lanczos support this time:','line_number':1584,'multiline':False]['text':'','line_number':1585,'multiline':False]['text':'','line_number':1591,'multiline':False]['text':' We adjust z and delta so that both z and z+delta are large enough for','line_number':1592,'multiline':False]['text':' Sterling's approximation to hold.  We can then calculate the ratio','line_number':1593,'multiline':False]['text':' for the adjusted values, and rescale back down to z and z+delta.','line_number':1594,'multiline':False]['text':'','line_number':1595,'multiline':False]['text':' Get the required shifts first:','line_number':1596,'multiline':False]['text':'','line_number':1597,'multiline':False]['text':'','line_number':1606,'multiline':False]['text':' If the shifts are zero, then we can just combine scaled tgamma's','line_number':1607,'multiline':False]['text':' and combine the remaining terms:','line_number':1608,'multiline':False]['text':'','line_number':1609,'multiline':False]['text':'','line_number':1618,'multiline':False]['text':' We're going to have to rescale first, get the adjusted z and delta values,','line_number':1619,'multiline':False]['text':' plus the ratio for the adjusted values:','line_number':1620,'multiline':False]['text':'','line_number':1621,'multiline':False]['text':'','line_number':1625,'multiline':False]['text':' Use gamma recurrence relations to get back to the original','line_number':1626,'multiline':False]['text':' z and z+delta:','line_number':1627,'multiline':False]['text':'','line_number':1628,'multiline':False]['text':' This isn't very sophisticated, or accurate, but it does work:','line_number':1649,'multiline':False]['text':'','line_number':1657,'multiline':False]['text':' Both z and delta are integers, see if we can just use table lookup','line_number':1658,'multiline':False]['text':' of the factorials to get the result:','line_number':1659,'multiline':False]['text':'','line_number':1660,'multiline':False]['text':'','line_number':1668,'multiline':False]['text':' delta is a small integer, we can use a finite product:','line_number':1669,'multiline':False]['text':'','line_number':1670,'multiline':False]['text':' Special case for denorms...Ugh.','line_number':1712,'multiline':False]['text':' Rather than subtracting values, lets just call the gamma functions directly:','line_number':1719,'multiline':False]['text':' We need to sidestep on x as well, otherwise we'll underflow','line_number':1727,'multiline':False]['text':' before we get to factor in the prefix term:','line_number':1728,'multiline':False]['text':'','line_number':1738,'multiline':False]['text':' result is almost certainly going to underflow to zero, try logs just in case:','line_number':1739,'multiline':False]['text':'','line_number':1740,'multiline':False]['text':' We need to sidestep on y as well, otherwise we'll overflow','line_number':1747,'multiline':False]['text':' before we get to factor in the prefix term:','line_number':1748,'multiline':False]['text':'','line_number':1758,'multiline':False]['text':' Result will almost certainly overflow, try logs just in case:','line_number':1759,'multiline':False]['text':'','line_number':1760,'multiline':False]['text':'','line_number':1763,'multiline':False]['text':' Regular case, x and y both large and similar in magnitude:','line_number':1764,'multiline':False]['text':'','line_number':1765,'multiline':False]['text':'','line_number':1773,'multiline':False]['text':' Usual error checks first:','line_number':1774,'multiline':False]['text':'','line_number':1775,'multiline':False]['text':'','line_number':1780,'multiline':False]['text':' Now special cases:','line_number':1781,'multiline':False]['text':'','line_number':1782,'multiline':False]['text':'','line_number':1788,'multiline':False]['text':' Normal case:','line_number':1789,'multiline':False]['text':'','line_number':1790,'multiline':False]['text':' overflow:','line_number':1795,'multiline':False]['text':' Underflow in calculation, use logs instead:','line_number':1800,'multiline':False]['text':' pol ','line_number':1812,'multiline':True]['text':' If std::numeric_limits<T>::digits is zero, we must not call','line_number':1848,'multiline':False]['text':' our initialization code here as the precision presumably','line_number':1849,'multiline':False]['text':' varies at runtime, and will not have been set yet.  Plus the','line_number':1850,'multiline':False]['text':' code requiring initialization isn't called when digits == 0.','line_number':1851,'multiline':False]['text':' typedef typename lanczos::lanczos<value_type, Policy>::type evaluation_type;','line_number':1921,'multiline':False]['text':' namespace detail','line_number':1945,'multiline':False]['text':' pol ','line_number':1997,'multiline':True]['text':'','line_number':2020,'multiline':False]['text':' Full upper incomplete gamma:','line_number':2021,'multiline':False]['text':'','line_number':2022,'multiline':False]['text':'','line_number':2027,'multiline':False]['text':' Type T2 could be a policy object, or a value, select the ','line_number':2028,'multiline':False]['text':' right overload based on T2:','line_number':2029,'multiline':False]['text':'','line_number':2030,'multiline':False]['text':'','line_number':2040,'multiline':False]['text':' Full lower incomplete gamma:','line_number':2041,'multiline':False]['text':'','line_number':2042,'multiline':False]['text':' typedef typename lanczos::lanczos<value_type, Policy>::type evaluation_type;','line_number':2050,'multiline':False]['text':'','line_number':2071,'multiline':False]['text':' Regularised upper incomplete gamma:','line_number':2072,'multiline':False]['text':'','line_number':2073,'multiline':False]['text':' pol ','line_number':2076,'multiline':True]['text':' typedef typename lanczos::lanczos<value_type, Policy>::type evaluation_type;','line_number':2081,'multiline':False]['text':'','line_number':2102,'multiline':False]['text':' Regularised lower incomplete gamma:','line_number':2103,'multiline':False]['text':'','line_number':2104,'multiline':False]['text':' typedef typename lanczos::lanczos<value_type, Policy>::type evaluation_type;','line_number':2112,'multiline':False]['text':' ratios of gamma functions:','line_number':2134,'multiline':False]['text':' pol ','line_number':2137,'multiline':True]['text':' namespace math','line_number':2202,'multiline':False]['text':' namespace boost','line_number':2203,'multiline':False]['text':' BOOST_MATH_SF_GAMMA_HPP','line_number':2213,'multiline':False]