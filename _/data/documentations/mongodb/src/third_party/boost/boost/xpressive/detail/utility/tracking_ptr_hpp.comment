['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':' tracking_ptr.hpp','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':4,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':5,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]['text':' MS compatible compilers support #pragma once','line_number':11,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':42,'multiline':False]['text':' weak_iterator','line_number':43,'multiline':False]['text':'  steps through a set of weak_ptr, converts to shared_ptrs on the fly and','line_number':44,'multiline':False]['text':'  removes from the set the weak_ptrs that have expired.','line_number':45,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':110,'multiline':False]['text':' filter_self','line_number':111,'multiline':False]['text':'  for use with a filter_iterator to filter a node out of a list of dependencies','line_number':112,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':133,'multiline':False]['text':' swap without bringing in std::swap -- must be found by ADL.','line_number':134,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':141,'multiline':False]['text':' enable_reference_tracking','line_number':142,'multiline':False]['text':'   inherit from this type to enable reference tracking for a type. You can','line_number':143,'multiline':False]['text':'   then use tracking_ptr (below) as a holder for derived objects.','line_number':144,'multiline':False]['text':'','line_number':145,'multiline':False]['text':' called automatically as a result of a tracking_copy(). Must be called explicitly','line_number':166,'multiline':False]['text':' if you change the references without calling tracking_copy().','line_number':167,'multiline':False]['text':' add "this" as a dependency to all the references','line_number':170,'multiline':False]['text':' notify our dependencies that we have new references','line_number':172,'multiline':False]['text':' avoid some unbounded memory growth in certain circumstances by','line_number':178,'multiline':False]['text':' opportunistically removing stale dependencies from "that"','line_number':179,'multiline':False]['text':' add "that" as a reference','line_number':181,'multiline':False]['text':' also inherit that's references','line_number':183,'multiline':False]['text':'{{AFX_DEBUG','line_number':207,'multiline':False]['text':'}}AFX_DEBUG','line_number':215,'multiline':False]['text':' for each reference, add this as a dependency','line_number':271,'multiline':False]['text':' called whenever this regex object changes (i.e., is assigned to). it walks','line_number':278,'multiline':False]['text':' the list of dependent regexes and updates *their* lists of references,','line_number':279,'multiline':False]['text':' thereby spreading out the reference counting responsibility evenly.','line_number':280,'multiline':False]['text':' never add ourself as a dependency','line_number':292,'multiline':False]['text':' add dep as a dependency','line_number':295,'multiline':False]['text':' also inherit dep's dependencies','line_number':302,'multiline':False]['text':'{{AFX_DEBUG','line_number':318,'multiline':False]['text':'}}AFX_DEBUG','line_number':322,'multiline':False]['text':'{{AFX_DEBUG','line_number':342,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':344,'multiline':False]['text':' dump_','line_number':345,'multiline':False]['text':'','line_number':346,'multiline':False]['text':' ericne, 27/nov/05: CW9_4 doesn't like if(shared_ptr x = y)','line_number':363,'multiline':False]['text':'}}AFX_DEBUG','line_number':373,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':375,'multiline':False]['text':' tracking_ptr','line_number':376,'multiline':False]['text':'   holder for a reference-tracked type. Does cycle-breaking, lazy initialization','line_number':377,'multiline':False]['text':'   and copy-on-write. TODO: implement move semantics.','line_number':378,'multiline':False]['text':'','line_number':379,'multiline':False]['text':' Note: the copy-and-swap idiom doesn't work here if has_deps_()==true','line_number':399,'multiline':False]['text':' because it invalidates references to the element_type object.','line_number':400,'multiline':False]['text':' deep copy, forks data if necessary','line_number':407,'multiline':False]['text':' shallow, copy-on-write','line_number':412,'multiline':False]['text':' NOTE: this does *not* do tracking. Can't provide a non-throwing swap that tracks references','line_number':423,'multiline':False]['text':' throw()','line_number':424,'multiline':False]['text':' calling this forces this->impl_ to fork.','line_number':429,'multiline':False]['text':' smart-pointer operators','line_number':439,'multiline':False]['text':' Since this does not un-share the data, it returns a ptr-to-const','line_number':463,'multiline':False]['text':' Since this does not un-share the data, it returns a ref-to-const','line_number':469,'multiline':False]['text':' calling this forces impl_ to fork.','line_number':477,'multiline':False]['text':' does anybody have a dependency on us?','line_number':491,'multiline':False]['text':' mutable to allow lazy initialization','line_number':497,'multiline':False]['text':' namespace boost::xpressive::detail','line_number':501,'multiline':False]