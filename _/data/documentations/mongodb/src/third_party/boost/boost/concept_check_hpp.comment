['text':'','line_number':1,'multiline':False]['text':' (C) Copyright Jeremy Siek 2000.','line_number':2,'multiline':False]['text':' Copyright 2002 The Trustees of Indiana University.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' Revision History:','line_number':9,'multiline':False]['text':'   05 May   2001: Workarounds for HP aCC from Thomas Matelich. (Jeremy Siek)','line_number':10,'multiline':False]['text':'   02 April 2001: Removed limits header altogether. (Jeremy Siek)','line_number':11,'multiline':False]['text':'   01 April 2001: Modified to use new <boost/limits.hpp> header. (JMaddock)','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' See http://www.boost.org/libs/concept_check for documentation.','line_number':15,'multiline':False]['text':' default constructor could not be generated','line_number':36,'multiline':False]['text':' object 'class' can never be instantiated - user-defined constructor required','line_number':37,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' Backward compatibility','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':'','line_number':67,'multiline':False]['text':' Begin concept definitions','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':'===========================================================================','line_number':132,'multiline':False]['text':' Basic Concepts','line_number':133,'multiline':False]['text':' require default constructor','line_number':138,'multiline':False]['text':' back_insert_iterator broken for VC++ STL','line_number':146,'multiline':False]['text':' require assignment operator','line_number':147,'multiline':False]['text':' back_insert_iterator broken for VC++ STL','line_number':153,'multiline':False]['text':' const required for argument to assignment','line_number':154,'multiline':False]['text':' require copy constructor','line_number':168,'multiline':False]['text':' require address of operator','line_number':169,'multiline':False]['text':' require const copy constructor','line_number':175,'multiline':False]['text':' require const address of operator','line_number':176,'multiline':False]['text':' The SGI STL version of Assignable requires copy constructor and operator=','line_number':183,'multiline':False]['text':' back_insert_iterator broken for VC++ STL','line_number':188,'multiline':False]['text':' require assignment operator','line_number':189,'multiline':False]['text':' back_insert_iterator broken for VC++ STL','line_number':197,'multiline':False]['text':' const required for argument to assignment','line_number':198,'multiline':False]['text':' The C++ standard requirements for many concepts talk about return','line_number':216,'multiline':False]['text':' types that must be "convertible to bool".  The problem with this','line_number':217,'multiline':False]['text':' requirement is that it leaves the door open for evil proxies that','line_number':218,'multiline':False]['text':' define things like operator|| with strange return types.  Two','line_number':219,'multiline':False]['text':' possible solutions are:','line_number':220,'multiline':False]['text':' 1) require the return type to be exactly bool','line_number':221,'multiline':False]['text':' 2) stay with convertible to bool, and also','line_number':222,'multiline':False]['text':'    specify stuff about all the logical operators.','line_number':223,'multiline':False]['text':' For now we just test for convertible to bool.','line_number':224,'multiline':False]['text':' This is equivalent to SGI STL's LessThanComparable.','line_number':250,'multiline':False]['text':'===========================================================================','line_number':296,'multiline':False]['text':' Function Object Concepts','line_number':297,'multiline':False]['text':' Do we really want a reference here?','line_number':306,'multiline':False]['text':' "priming the pump" this way keeps msvc6 happy (ICE)','line_number':326,'multiline':False]['text':' Declare a dummy constructor to make gcc happy.','line_number':338,'multiline':False]['text':' It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.','line_number':339,'multiline':False]['text':' (warning: non-static reference "const double& boost::UnaryFunction<YourClassHere>::arg"','line_number':340,'multiline':False]['text':' in class without a constructor [-Wuninitialized])','line_number':341,'multiline':False]['text':' require operator()','line_number':356,'multiline':False]['text':' Declare a dummy constructor to make gcc happy.','line_number':367,'multiline':False]['text':' It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.','line_number':368,'multiline':False]['text':' (warning: non-static reference "const double& boost::BinaryFunction<YourClassHere>::arg"','line_number':369,'multiline':False]['text':' in class without a constructor [-Wuninitialized])','line_number':370,'multiline':False]['text':' require operator() returning bool','line_number':382,'multiline':False]['text':' Declare a dummy constructor to make gcc happy.','line_number':387,'multiline':False]['text':' It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.','line_number':388,'multiline':False]['text':' (warning: non-static reference "const double& boost::UnaryPredicate<YourClassHere>::arg"','line_number':389,'multiline':False]['text':' in class without a constructor [-Wuninitialized])','line_number':390,'multiline':False]['text':' require operator() returning bool','line_number':401,'multiline':False]['text':' Declare a dummy constructor to make gcc happy.','line_number':406,'multiline':False]['text':' It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.','line_number':407,'multiline':False]['text':' (warning: non-static reference "const double& boost::BinaryPredicate<YourClassHere>::arg"','line_number':408,'multiline':False]['text':' in class without a constructor [-Wuninitialized])','line_number':409,'multiline':False]['text':' use this when functor is used inside a container class like std::set','line_number':417,'multiline':False]['text':' operator() must be a const member function','line_number':426,'multiline':False]['text':' Declare a dummy constructor to make gcc happy.','line_number':431,'multiline':False]['text':' It seems the compiler can not generate a sensible constructor when this is instantiated with a reference type.','line_number':432,'multiline':False]['text':' (warning: non-static reference "const double& boost::Const_BinaryPredicate<YourClassHere>::arg"','line_number':433,'multiline':False]['text':' in class without a constructor [-Wuninitialized])','line_number':434,'multiline':False]['text':'===========================================================================','line_number':499,'multiline':False]['text':' Iterator Concepts','line_number':500,'multiline':False]['text':' require dereference operator','line_number':518,'multiline':False]['text':' require preincrement operator','line_number':519,'multiline':False]['text':' require postincrement operator','line_number':520,'multiline':False]['text':' require preincrement operator','line_number':531,'multiline':False]['text':' require postincrement operator','line_number':532,'multiline':False]['text':' require postincrement and assignment','line_number':533,'multiline':False]['text':' require postincrement and assignment','line_number':562,'multiline':False]['text':' require predecrement operator','line_number':578,'multiline':False]['text':' require postdecrement operator','line_number':579,'multiline':False]['text':' require postdecrement and assignment','line_number':591,'multiline':False]['text':' require assignment addition operator','line_number':608,'multiline':False]['text':' require addition with difference type','line_number':609,'multiline':False]['text':' require assignment subtraction operator','line_number':610,'multiline':False]['text':' require subtraction with difference type','line_number':611,'multiline':False]['text':' require difference operator','line_number':612,'multiline':False]['text':' require element access operator','line_number':613,'multiline':False]['text':' require element access and assignment','line_number':628,'multiline':False]['text':'===========================================================================','line_number':635,'multiline':False]['text':' Container s','line_number':636,'multiline':False]['text':' A Sequence is inherently mutable','line_number':809,'multiline':False]['text':' Matt Austern's book puts DefaultConstructible here, the C++','line_number':812,'multiline':False]['text':' standard places it in Container --JGS','line_number':813,'multiline':False]['text':' ... so why aren't we following the standard?  --DWA','line_number':814,'multiline':False]['text':' Redundant with the base concept, but it helps below.','line_number':906,'multiline':False]['text':' HashedAssociativeContainer','line_number':1035,'multiline':False]['text':' typedef typename C::pointer pointer;','line_number':1063,'multiline':False]['text':' namespace boost','line_number':1073,'multiline':False]['text':' BOOST_CONCEPT_CHECKS_HPP','line_number':1081,'multiline':False]