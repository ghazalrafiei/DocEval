['text':'  Copyright John Maddock 2006.','line_number':1,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':' Temporary until lexical cast fixed.','line_number':14,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' This is the only way we can avoid','line_number':29,'multiline':False]['text':' warning: non-standard suffix on floating constant [-Wpedantic]','line_number':30,'multiline':False]['text':' when building with -Wall -pedantic.  Neither __extension__','line_number':31,'multiline':False]['text':' nor #pragma diagnostic ignored work :(','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':' Forward declarations:','line_number':39,'multiline':False]['text':' Definitions:','line_number':43,'multiline':False]['text':'','line_number':697,'multiline':False]['text':' If you're foolish enough to instantiate factorial','line_number':698,'multiline':False]['text':' on an integer type then you end up here.  But this code is','line_number':699,'multiline':False]['text':' only intended for (fixed precision) multiprecision types.','line_number':700,'multiline':False]['text':' ','line_number':701,'multiline':False]['text':' Note, factorial<unsigned int>(n) is not implemented','line_number':702,'multiline':False]['text':' because it would overflow integral type T for too small n','line_number':703,'multiline':False]['text':' to be useful. Use instead a floating-point type,','line_number':704,'multiline':False]['text':' and convert to an unsigned type if essential, for example:','line_number':705,'multiline':False]['text':' unsigned int nfac = static_cast<unsigned int>(factorial<double>(n));','line_number':706,'multiline':False]['text':' See factorial documentation for more detail.','line_number':707,'multiline':False]['text':'','line_number':708,'multiline':False]['text':' We rely on C++11 thread safe initialization here:','line_number':711,'multiline':False]['text':'','line_number':822,'multiline':False]['text':' If you're foolish enough to instantiate factorial','line_number':823,'multiline':False]['text':' on an integer type then you end up here.  But this code is','line_number':824,'multiline':False]['text':' only intended for (variable precision) multiprecision types.','line_number':825,'multiline':False]['text':' ','line_number':826,'multiline':False]['text':' Note, factorial<unsigned int>(n) is not implemented','line_number':827,'multiline':False]['text':' because it would overflow integral type T for too small n','line_number':828,'multiline':False]['text':' to be useful. Use instead a floating-point type,','line_number':829,'multiline':False]['text':' and convert to an unsigned type if essential, for example:','line_number':830,'multiline':False]['text':' unsigned int nfac = static_cast<unsigned int>(factorial<double>(n));','line_number':831,'multiline':False]['text':' See factorial documentation for more detail.','line_number':832,'multiline':False]['text':'','line_number':833,'multiline':False]['text':'','line_number':939,'multiline':False]['text':' we rely on C++11 thread safe initialization in the event that we have no thread locals:','line_number':940,'multiline':False]['text':'','line_number':941,'multiline':False]['text':' namespace math','line_number':1015,'multiline':False]['text':' namespace boost','line_number':1016,'multiline':False]['text':' BOOST_MATH_SP_UC_FACTORIALS_HPP','line_number':1018,'multiline':False]