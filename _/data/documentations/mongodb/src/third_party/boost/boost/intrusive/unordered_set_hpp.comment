['text':'///////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Olaf Krzikalla 2004-2006.','line_number':3,'multiline':False]['text':' (C) Copyright Ion Gaztanaga  2006-2014','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0.','line_number':6,'multiline':False]['text':'    (See accompanying file LICENSE_1_0.txt or copy at','line_number':7,'multiline':False]['text':'          http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' See http://www.boost.org/libs/intrusive for documentation.','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':'///////////////////////////////////////////////////////////////////////////','line_number':12,'multiline':False]['text':'! The class template unordered_set is an intrusive container, that mimics most of','line_number':29,'multiline':False]['text':'! the interface of std::tr1::unordered_set as described in the C++ TR1.','line_number':30,'multiline':False]['text':'!','line_number':31,'multiline':False]['text':'! unordered_set is a semi-intrusive container: each object to be stored in the','line_number':32,'multiline':False]['text':'! container must contain a proper hook, but the container also needs','line_number':33,'multiline':False]['text':'! additional auxiliary memory to work: unordered_set needs a pointer to an array','line_number':34,'multiline':False]['text':'! of type `bucket_type` to be passed in the constructor. This bucket array must','line_number':35,'multiline':False]['text':'! have at least the same lifetime as the container. This makes the use of','line_number':36,'multiline':False]['text':'! unordered_set more complicated than purely intrusive containers.','line_number':37,'multiline':False]['text':'! `bucket_type` is default-constructible, copyable and assignable','line_number':38,'multiline':False]['text':'!','line_number':39,'multiline':False]['text':'! The template parameter \c T is the type to be managed by the container.','line_number':40,'multiline':False]['text':'! The user can specify additional options and if no options are provided','line_number':41,'multiline':False]['text':'! default options are used.','line_number':42,'multiline':False]['text':'!','line_number':43,'multiline':False]['text':'! The container supports the following options:','line_number':44,'multiline':False]['text':'! \c base_hook<>/member_hook<>/value_traits<>,','line_number':45,'multiline':False]['text':'! \c constant_time_size<>, \c size_type<>, \c hash<> and \c equal<>','line_number':46,'multiline':False]['text':'! \c bucket_traits<>, \c power_2_buckets<> and \c cache_begin<>.','line_number':47,'multiline':False]['text':'!','line_number':48,'multiline':False]['text':'! unordered_set only provides forward iterators but it provides 4 iterator types:','line_number':49,'multiline':False]['text':'! iterator and const_iterator to navigate through the whole container and','line_number':50,'multiline':False]['text':'! local_iterator and const_local_iterator to navigate through the values','line_number':51,'multiline':False]['text':'! stored in a single bucket. Local iterators are faster and smaller.','line_number':52,'multiline':False]['text':'!','line_number':53,'multiline':False]['text':'! It's not recommended to use non constant-time size unordered_sets because several','line_number':54,'multiline':False]['text':'! key functions, like "empty()", become non-constant time functions. Non','line_number':55,'multiline':False]['text':'! constant-time size unordered_sets are mainly provided to support auto-unlink hooks.','line_number':56,'multiline':False]['text':'!','line_number':57,'multiline':False]['text':'! unordered_set, unlike std::unordered_set, does not make automatic rehashings nor','line_number':58,'multiline':False]['text':'! offers functions related to a load factor. Rehashing can be explicitly requested','line_number':59,'multiline':False]['text':'! and the user must provide a new bucket array that will be used from that moment.','line_number':60,'multiline':False]['text':'!','line_number':61,'multiline':False]['text':'! Since no automatic rehashing is done, iterators are never invalidated when','line_number':62,'multiline':False]['text':'! inserting or erasing elements. Iterators are only invalidated when rehasing.','line_number':63,'multiline':False]['text':'/ @cond','line_number':72,'multiline':False]['text':'! This class is','line_number':86,'multiline':False]['text':'! movable','line_number':87,'multiline':False]['text':'/ @endcond','line_number':91,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable(const bucket_traits &,const hasher &,const key_equal &,const value_traits &)','line_number':122,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable(bool,Iterator,Iterator,const bucket_traits &,const hasher &,const key_equal &,const value_traits &)','line_number':130,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable(hashtable&&)','line_number':141,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::operator=(hashtable&&)','line_number':146,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::~hashtable()','line_number':151,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin()','line_number':154,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin()const','line_number':157,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cbegin()const','line_number':160,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end()','line_number':163,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end()const','line_number':166,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cend()const','line_number':169,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hash_function()const','line_number':172,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::key_eq()const','line_number':175,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::empty()const','line_number':178,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::size()const','line_number':181,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable','line_number':184,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clone_from(const hashtable&,Cloner,Disposer)','line_number':187,'multiline':False]['text':'#ifdef BOOST_INTRUSIVE_DOXYGEN_INVOKED','line_number':195,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clone_from(hashtable&&,Cloner,Disposer)','line_number':197,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_unique(reference)','line_number':202,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_unique(Iterator,Iterator)','line_number':206,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_unique_check(const key_type&,insert_commit_data&)','line_number':211,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_unique_check(const KeyType&,KeyHasher,KeyEqual,insert_commit_data&)','line_number':215,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_unique_commit','line_number':221,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const_iterator)','line_number':227,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const_iterator,const_iterator)','line_number':230,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const key_type &)','line_number':233,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const KeyType&,KeyHasher,KeyEqual)','line_number':236,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const_iterator,Disposer)','line_number':240,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const_iterator,const_iterator,Disposer)','line_number':246,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const key_type &,Disposer)','line_number':250,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const KeyType&,KeyHasher,KeyEqual,Disposer)','line_number':254,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clear','line_number':258,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clear_and_dispose','line_number':261,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const key_type &)const','line_number':265,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const KeyType&,KeyHasher,KeyEqual)const','line_number':268,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const key_type &)','line_number':272,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const KeyType &,KeyHasher,KeyEqual)','line_number':275,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const key_type &)const','line_number':279,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const KeyType &,KeyHasher,KeyEqual)const','line_number':282,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const key_type&)','line_number':287,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const KeyType &,KeyHasher,KeyEqual)','line_number':291,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const key_type&)const','line_number':296,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const KeyType &,KeyHasher,KeyEqual)const','line_number':301,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::iterator_to(reference)','line_number':308,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::iterator_to(const_reference)const','line_number':311,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::s_local_iterator_to(reference)','line_number':314,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::s_local_iterator_to(const_reference)','line_number':317,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::local_iterator_to(reference)','line_number':320,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::local_iterator_to(const_reference)','line_number':323,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_count','line_number':326,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_size','line_number':329,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket(const key_type&)const','line_number':332,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket(const KeyType&,KeyHasher)const','line_number':335,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_pointer','line_number':339,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin(size_type)','line_number':342,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin(size_type)const','line_number':345,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cbegin(size_type)const','line_number':348,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end(size_type)','line_number':351,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end(size_type)const','line_number':354,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cend(size_type)const','line_number':357,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::rehash(const bucket_traits &)','line_number':360,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::full_rehash','line_number':363,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::incremental_rehash(bool)','line_number':366,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::incremental_rehash(const bucket_traits &)','line_number':369,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::split_count','line_number':372,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::suggested_upper_bucket_count','line_number':375,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::suggested_lower_bucket_count','line_number':378,'multiline':False]['text':'   #ifdef BOOST_INTRUSIVE_DOXYGEN_INVOKED','line_number':381,'multiline':False]['text':'Find each element of x in y','line_number':388,'multiline':False]['text':'! Helper metafunction to define an \c unordered_set that yields to the same type when the','line_number':413,'multiline':False]['text':'! same options (either explicitly or implicitly) are used.','line_number':414,'multiline':False]['text':'/ @cond','line_number':427,'multiline':False]['text':'/ @endcond','line_number':458,'multiline':False]['text':'Assert if passed value traits are compatible with the type','line_number':487,'multiline':False]['text':'! The class template unordered_multiset is an intrusive container, that mimics most of','line_number':539,'multiline':False]['text':'! the interface of std::tr1::unordered_multiset as described in the C++ TR1.','line_number':540,'multiline':False]['text':'!','line_number':541,'multiline':False]['text':'! unordered_multiset is a semi-intrusive container: each object to be stored in the','line_number':542,'multiline':False]['text':'! container must contain a proper hook, but the container also needs','line_number':543,'multiline':False]['text':'! additional auxiliary memory to work: unordered_multiset needs a pointer to an array','line_number':544,'multiline':False]['text':'! of type `bucket_type` to be passed in the constructor. This bucket array must','line_number':545,'multiline':False]['text':'! have at least the same lifetime as the container. This makes the use of','line_number':546,'multiline':False]['text':'! unordered_multiset more complicated than purely intrusive containers.','line_number':547,'multiline':False]['text':'! `bucket_type` is default-constructible, copyable and assignable','line_number':548,'multiline':False]['text':'!','line_number':549,'multiline':False]['text':'! The template parameter \c T is the type to be managed by the container.','line_number':550,'multiline':False]['text':'! The user can specify additional options and if no options are provided','line_number':551,'multiline':False]['text':'! default options are used.','line_number':552,'multiline':False]['text':'!','line_number':553,'multiline':False]['text':'! The container supports the following options:','line_number':554,'multiline':False]['text':'! \c base_hook<>/member_hook<>/value_traits<>,','line_number':555,'multiline':False]['text':'! \c constant_time_size<>, \c size_type<>, \c hash<> and \c equal<>','line_number':556,'multiline':False]['text':'! \c bucket_traits<>, \c power_2_buckets<> and \c cache_begin<>.','line_number':557,'multiline':False]['text':'!','line_number':558,'multiline':False]['text':'! unordered_multiset only provides forward iterators but it provides 4 iterator types:','line_number':559,'multiline':False]['text':'! iterator and const_iterator to navigate through the whole container and','line_number':560,'multiline':False]['text':'! local_iterator and const_local_iterator to navigate through the values','line_number':561,'multiline':False]['text':'! stored in a single bucket. Local iterators are faster and smaller.','line_number':562,'multiline':False]['text':'!','line_number':563,'multiline':False]['text':'! It's not recommended to use non constant-time size unordered_multisets because several','line_number':564,'multiline':False]['text':'! key functions, like "empty()", become non-constant time functions. Non','line_number':565,'multiline':False]['text':'! constant-time size unordered_multisets are mainly provided to support auto-unlink hooks.','line_number':566,'multiline':False]['text':'!','line_number':567,'multiline':False]['text':'! unordered_multiset, unlike std::unordered_set, does not make automatic rehashings nor','line_number':568,'multiline':False]['text':'! offers functions related to a load factor. Rehashing can be explicitly requested','line_number':569,'multiline':False]['text':'! and the user must provide a new bucket array that will be used from that moment.','line_number':570,'multiline':False]['text':'!','line_number':571,'multiline':False]['text':'! Since no automatic rehashing is done, iterators are never invalidated when','line_number':572,'multiline':False]['text':'! inserting or erasing elements. Iterators are only invalidated when rehasing.','line_number':573,'multiline':False]['text':'/ @cond','line_number':582,'multiline':False]['text':'/ @endcond','line_number':585,'multiline':False]['text':'Movable','line_number':587,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable(const bucket_traits &,const hasher &,const key_equal &,const value_traits &)','line_number':620,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable(bool,Iterator,Iterator,const bucket_traits &,const hasher &,const key_equal &,const value_traits &)','line_number':628,'multiline':False]['text':'! <b>Effects</b>: to-do','line_number':639,'multiline':False]['text':'!','line_number':640,'multiline':False]['text':'! <b>Effects</b>: to-do','line_number':645,'multiline':False]['text':'!','line_number':646,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::~hashtable()','line_number':652,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin()','line_number':655,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin()const','line_number':658,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cbegin()const','line_number':661,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end()','line_number':664,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end()const','line_number':667,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cend()const','line_number':670,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hash_function()const','line_number':673,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::key_eq()const','line_number':676,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::empty()const','line_number':679,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::size()const','line_number':682,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::hashtable','line_number':685,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clone_from(const hashtable&,Cloner,Disposer)','line_number':688,'multiline':False]['text':'   #ifdef BOOST_INTRUSIVE_DOXYGEN_INVOKED','line_number':696,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clone_from(hashtable&&,Cloner,Disposer)','line_number':698,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_equal(reference)','line_number':703,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::insert_equal(Iterator,Iterator)','line_number':707,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const_iterator)','line_number':714,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const_iterator,const_iterator)','line_number':717,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const key_type &)','line_number':720,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase(const KeyType&,KeyHasher,KeyEqual)','line_number':723,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const_iterator,Disposer)','line_number':727,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const_iterator,const_iterator,Disposer)','line_number':733,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const key_type &,Disposer)','line_number':737,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::erase_and_dispose(const KeyType&,KeyHasher,KeyEqual,Disposer)','line_number':741,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clear','line_number':745,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::clear_and_dispose','line_number':748,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const key_type &)const','line_number':752,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const KeyType&,KeyHasher,KeyEqual)const','line_number':755,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const key_type &)','line_number':759,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const KeyType &,KeyHasher,KeyEqual)','line_number':762,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::count(const key_type &)const','line_number':766,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::find(const KeyType &,KeyHasher,KeyEqual)const','line_number':769,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const key_type&)','line_number':773,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const KeyType &,KeyHasher,KeyEqual)','line_number':776,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const key_type&)const','line_number':780,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::equal_range(const KeyType &,KeyHasher,KeyEqual)const','line_number':784,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::iterator_to(reference)','line_number':789,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::iterator_to(const_reference)const','line_number':792,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::s_local_iterator_to(reference)','line_number':795,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::s_local_iterator_to(const_reference)','line_number':798,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::local_iterator_to(reference)','line_number':801,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::local_iterator_to(const_reference)','line_number':804,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_count','line_number':807,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_size','line_number':810,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket(const key_type&)const','line_number':813,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket(const KeyType&,KeyHasher)const','line_number':816,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::bucket_pointer','line_number':820,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin(size_type)','line_number':823,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::begin(size_type)const','line_number':826,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cbegin(size_type)const','line_number':829,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end(size_type)','line_number':832,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::end(size_type)const','line_number':835,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::cend(size_type)const','line_number':838,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::rehash(const bucket_traits &)','line_number':841,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::full_rehash','line_number':844,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::incremental_rehash(bool)','line_number':847,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::incremental_rehash(const bucket_traits &)','line_number':850,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::split_count','line_number':853,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::suggested_upper_bucket_count','line_number':856,'multiline':False]['text':'! @copydoc ::boost::intrusive::hashtable::suggested_lower_bucket_count','line_number':859,'multiline':False]['text':'   #ifdef BOOST_INTRUSIVE_DOXYGEN_INVOKED','line_number':862,'multiline':False]['text':'! Helper metafunction to define an \c unordered_multiset that yields to the same type when the','line_number':865,'multiline':False]['text':'! same options (either explicitly or implicitly) are used.','line_number':866,'multiline':False]['text':'/ @cond','line_number':879,'multiline':False]['text':'/ @endcond','line_number':910,'multiline':False]['text':'Assert if passed value traits are compatible with the type','line_number':938,'multiline':False]['text':'namespace intrusive','line_number':989,'multiline':False]['text':'namespace boost','line_number':990,'multiline':False]['text':'BOOST_INTRUSIVE_UNORDERED_SET_HPP','line_number':994,'multiline':False]