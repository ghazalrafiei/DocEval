['text':'  (C) Copyright John Maddock 2006.','line_number':1,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':' test for multiprecision types in complex Newton','line_number':12,'multiline':False]['text':' Use ADL to find the right overload for get:','line_number':43,'multiline':False]['text':' Use ADL to find the right overload for get:','line_number':51,'multiline':False]['text':' Rely on ADL to find the correct overload of get:','line_number':61,'multiline':False]['text':' this must be the first iteration, pretend that we had a','line_number':89,'multiline':False]['text':' previous one at either min or max:','line_number':90,'multiline':False]['text':' we've crossed over so move in opposite direction to last step:','line_number':104,'multiline':False]['text':' move in same direction as last step:','line_number':116,'multiline':False]['text':' namespace','line_number':128,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' Error checking:','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':'','line_number':161,'multiline':False]['text':' Three function invocations so far:','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':'','line_number':235,'multiline':False]['text':' We use these to sanity check that we do actually bracket a root,','line_number':236,'multiline':False]['text':' we update these to the function value when we update the endpoints','line_number':237,'multiline':False]['text':' of the range.  Then, provided at some point we update both endpoints','line_number':238,'multiline':False]['text':' checking that max_range_f * min_range_f <= 0 verifies there is a root','line_number':239,'multiline':False]['text':' to be found somewhere.  Note that if there is no root, and we approach ','line_number':240,'multiline':False]['text':' a local minima, then the derivative will go to zero, and hence the next','line_number':241,'multiline':False]['text':' step will jump out of bounds (or at least past the minima), so this','line_number':242,'multiline':False]['text':' check *should* happen in pathological cases.','line_number':243,'multiline':False]['text':'','line_number':244,'multiline':False]['text':' Oops zero derivative!!!','line_number':265,'multiline':False]['text':' Last two steps haven't converged.','line_number':277,'multiline':False]['text':' Protect against huge jumps!','line_number':281,'multiline':False]['text':'delta = sign(delta) * result; // Protect against huge jumps! Failed for negative result. https://github.com/boostorg/math/issues/216','line_number':282,'multiline':False]['text':' reset delta1/2 so we don't take this branch next time round:','line_number':286,'multiline':False]['text':' Update brackets:','line_number':306,'multiline':False]['text':'','line_number':317,'multiline':False]['text':' Sanity check that we bracket the root:','line_number':318,'multiline':False]['text':'','line_number':319,'multiline':False]['text':'x','line_number':347,'multiline':True]['text':' possible overflow, use Newton step:','line_number':359,'multiline':False]['text':'','line_number':375,'multiline':False]['text':' Move guess towards max until we bracket the root, updating min and max as we go:','line_number':376,'multiline':False]['text':'','line_number':377,'multiline':False]['text':' There must be a change of sign!','line_number':390,'multiline':False]['text':'','line_number':399,'multiline':False]['text':' If min and max are negative we have to divide to head towards max:','line_number':400,'multiline':False]['text':'','line_number':401,'multiline':False]['text':' There must be a change of sign!','line_number':409,'multiline':False]['text':'','line_number':430,'multiline':False]['text':' Move guess towards min until we bracket the root, updating min and max as we go:','line_number':431,'multiline':False]['text':'','line_number':432,'multiline':False]['text':' There must be a change of sign!','line_number':446,'multiline':False]['text':'','line_number':455,'multiline':False]['text':' If min and max are negative we have to multiply to head towards min:','line_number':456,'multiline':False]['text':'','line_number':457,'multiline':False]['text':' There must be a change of sign!','line_number':465,'multiline':False]['text':' arbitrarily large delta','line_number':501,'multiline':False]['text':'','line_number':511,'multiline':False]['text':' We use these to sanity check that we do actually bracket a root,','line_number':512,'multiline':False]['text':' we update these to the function value when we update the endpoints','line_number':513,'multiline':False]['text':' of the range.  Then, provided at some point we update both endpoints','line_number':514,'multiline':False]['text':' checking that max_range_f * min_range_f <= 0 verifies there is a root','line_number':515,'multiline':False]['text':' to be found somewhere.  Note that if there is no root, and we approach ','line_number':516,'multiline':False]['text':' a local minima, then the derivative will go to zero, and hence the next','line_number':517,'multiline':False]['text':' step will jump out of bounds (or at least past the minima), so this','line_number':518,'multiline':False]['text':' check *should* happen in pathological cases.','line_number':519,'multiline':False]['text':'','line_number':520,'multiline':False]['text':' Oops zero derivative!!!','line_number':541,'multiline':False]['text':' Oh dear, we have a problem as Newton and Halley steps','line_number':551,'multiline':False]['text':' disagree about which way we should move.  Probably','line_number':552,'multiline':False]['text':' there is cancelation error in the calculation of the','line_number':553,'multiline':False]['text':' Halley step, or else the derivatives are so small','line_number':554,'multiline':False]['text':' that their values are basically trash.  We will move','line_number':555,'multiline':False]['text':' in the direction indicated by a Newton step, but','line_number':556,'multiline':False]['text':' by no more than twice the current guess value, otherwise','line_number':557,'multiline':False]['text':' we can jump way out of bounds if we're not careful.','line_number':558,'multiline':False]['text':' See https://svn.boost.org/trac/boost/ticket/8314.','line_number':559,'multiline':False]['text':' last two steps haven't converged.','line_number':574,'multiline':False]['text':' protect against huge jumps!','line_number':577,'multiline':False]['text':' reset delta2 so that this branch will *not* be taken on the','line_number':578,'multiline':False]['text':' next iteration:','line_number':579,'multiline':False]['text':' check for out of bounds step:','line_number':588,'multiline':False]['text':' Only a small out of bounds step, lets assume that the result','line_number':599,'multiline':False]['text':' is probably approximately at min:','line_number':600,'multiline':False]['text':' only take this branch once!','line_number':603,'multiline':False]['text':' Only a small out of bounds step, lets assume that the result','line_number':625,'multiline':False]['text':' is probably approximately at min:','line_number':626,'multiline':False]['text':' only take this branch once!','line_number':629,'multiline':False]['text':' update brackets:','line_number':644,'multiline':False]['text':'','line_number':655,'multiline':False]['text':' Sanity check that we bracket the root:','line_number':656,'multiline':False]['text':'','line_number':657,'multiline':False]['text':' T second_order_root_finder','line_number':672,'multiline':False]['text':' check second derivative doesn't over compensate:','line_number':700,'multiline':False]['text':' fall back to Newton iteration.','line_number':705,'multiline':False]['text':'','line_number':724,'multiline':False]['text':' These two are the old spelling of this function, retained for backwards compatibility just in case:','line_number':725,'multiline':False]['text':'','line_number':726,'multiline':False]['text':'
   * Why do we set the default maximum number of iterations to the number of digits in the type?
   * Because for double roots, the number of digits increases linearly with the number of iterations,
   * so this default should recover full precision even in this somewhat pathological case.
   * For isolated roots, the problem is so rapidly convergent that this doesn't matter at all.
   ','line_number':741,'multiline':True]['text':' z0, z1, and z2 cannot be the same, in case we immediately need to resort to Muller's Method:','line_number':754,'multiline':False]['text':' Muller's method. Notation follows Numerical Recipes, 9.5.2:','line_number':763,'multiline':False]['text':' See: https://math.stackexchange.com/questions/3017766/constructing-newton-iteration-converging-to-non-root','line_number':796,'multiline':False]['text':' If f' is continuous, then convergence of x_n -> x* implies f(x*) = 0.','line_number':797,'multiline':False]['text':' This condition approximates this convergence condition by requiring three consecutive iterates to be clustered.','line_number':798,'multiline':False]['text':' The idea is that if we can get abs(f) < eps, we should, but if we go through all these iterations','line_number':809,'multiline':False]['text':' and abs(f) < sqrt(eps), then roundoff error simply does not allow that we can evaluate f to < eps','line_number':810,'multiline':False]['text':' This is somewhat awkward as it isn't scale invariant, but using the Daubechies coefficient example code,','line_number':811,'multiline':False]['text':' I found this condition generates correct roots, whereas the scale invariant condition discussed here:','line_number':812,'multiline':False]['text':' https://scicomp.stackexchange.com/questions/30597/defining-a-condition-number-and-termination-criteria-for-newtons-method','line_number':813,'multiline':False]['text':' allows nonroots to be passed off as roots.','line_number':814,'multiline':False]['text':' https://stackoverflow.com/questions/48979861/numerically-stable-method-for-solving-quadratic-equations/50065711','line_number':828,'multiline':False]['text':' Is there a sane way to flush very small negative values to zero?','line_number':886,'multiline':False]['text':' If there is I don't know of it.','line_number':887,'multiline':False]['text':' There's no fma for complex types:','line_number':923,'multiline':False]['text':' Most likely the type is a boost.multiprecision.','line_number':928,'multiline':False]['text':'There is no fma for multiprecision, and in addition it doesn't seem to be useful, so revert to the naive computation.','line_number':929,'multiline':False]['text':' namespace detail','line_number':967,'multiline':False]['text':' namespace tools','line_number':978,'multiline':False]['text':' namespace math','line_number':979,'multiline':False]['text':' namespace boost','line_number':980,'multiline':False]['text':' BOOST_MATH_TOOLS_NEWTON_SOLVER_HPP','line_number':982,'multiline':False]