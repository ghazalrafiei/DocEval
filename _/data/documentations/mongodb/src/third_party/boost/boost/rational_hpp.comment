['text':'  Boost rational.hpp header file  ------------------------------------------//','line_number':1,'multiline':False]['text':'  (C) Copyright Paul Moore 1999. Permission to copy, use, modify, sell and','line_number':3,'multiline':False]['text':'  distribute this software is granted provided this copyright notice appears','line_number':4,'multiline':False]['text':'  in all copies. This software is provided "as is" without express or','line_number':5,'multiline':False]['text':'  implied warranty, and with no claim as to its suitability for any purpose.','line_number':6,'multiline':False]['text':' boostinspect:nolicense (don't complain about the lack of a Boost license)','line_number':8,'multiline':False]['text':' (Paul Moore hasn't been in contact for years, so there's no way to change the','line_number':9,'multiline':False]['text':' license.)','line_number':10,'multiline':False]['text':'  See http://www.boost.org/libs/rational for documentation.','line_number':12,'multiline':False]['text':'  Credits:','line_number':14,'multiline':False]['text':'  Thanks to the boost mailing list in general for useful comments.','line_number':15,'multiline':False]['text':'  Particular contributions included:','line_number':16,'multiline':False]['text':'    Andrew D Jewell, for reminding me to take care to avoid overflow','line_number':17,'multiline':False]['text':'    Ed Brey, for many comments, including picking up on some dreadful typos','line_number':18,'multiline':False]['text':'    Stephen Silver contributed the test suite and comments on user-defined','line_number':19,'multiline':False]['text':'    IntType','line_number':20,'multiline':False]['text':'    Nickolay Mladenov, for the implementation of operator+=','line_number':21,'multiline':False]['text':'  Revision History','line_number':23,'multiline':False]['text':'  12 Nov 20  Fix operators to work with C++20 rules (Glen Joseph Fernandes)','line_number':24,'multiline':False]['text':'  02 Sep 13  Remove unneeded forward declarations; tweak private helper','line_number':25,'multiline':False]['text':'             function (Daryle Walker)','line_number':26,'multiline':False]['text':'  30 Aug 13  Improve exception safety of "assign"; start modernizing I/O code','line_number':27,'multiline':False]['text':'             (Daryle Walker)','line_number':28,'multiline':False]['text':'  27 Aug 13  Add cross-version constructor template, plus some private helper','line_number':29,'multiline':False]['text':'             functions; add constructor to exception class to take custom','line_number':30,'multiline':False]['text':'             messages (Daryle Walker)','line_number':31,'multiline':False]['text':'  25 Aug 13  Add constexpr qualification wherever possible (Daryle Walker)','line_number':32,'multiline':False]['text':'  05 May 12  Reduced use of implicit gcd (Mario Lang)','line_number':33,'multiline':False]['text':'  05 Nov 06  Change rational_cast to not depend on division between different','line_number':34,'multiline':False]['text':'             types (Daryle Walker)','line_number':35,'multiline':False]['text':'  04 Nov 06  Off-load GCD and LCM to Boost.Integer; add some invariant checks;','line_number':36,'multiline':False]['text':'             add std::numeric_limits<> requirement to help GCD (Daryle Walker)','line_number':37,'multiline':False]['text':'  31 Oct 06  Recoded both operator< to use round-to-negative-infinity','line_number':38,'multiline':False]['text':'             divisions; the rational-value version now uses continued fraction','line_number':39,'multiline':False]['text':'             expansion to avoid overflows, for bug #798357 (Daryle Walker)','line_number':40,'multiline':False]['text':'  20 Oct 06  Fix operator bool_type for CW 8.3 (Joaquín M López Muñoz)','line_number':41,'multiline':False]['text':'  18 Oct 06  Use EXPLICIT_TEMPLATE_TYPE helper macros from Boost.Config','line_number':42,'multiline':False]['text':'             (Joaquín M López Muñoz)','line_number':43,'multiline':False]['text':'  27 Dec 05  Add Boolean conversion operator (Daryle Walker)','line_number':44,'multiline':False]['text':'  28 Sep 02  Use _left versions of operators from operators.hpp','line_number':45,'multiline':False]['text':'  05 Jul 01  Recode gcd(), avoiding std::swap (Helmut Zeisel)','line_number':46,'multiline':False]['text':'  03 Mar 01  Workarounds for Intel C++ 5.0 (David Abrahams)','line_number':47,'multiline':False]['text':'  05 Feb 01  Update operator>> to tighten up input syntax','line_number':48,'multiline':False]['text':'  05 Feb 01  Final tidy up of gcd code prior to the new release','line_number':49,'multiline':False]['text':'  27 Jan 01  Recode abs() without relying on abs(IntType)','line_number':50,'multiline':False]['text':'  21 Jan 01  Include Nickolay Mladenov's operator+= algorithm,','line_number':51,'multiline':False]['text':'             tidy up a number of areas, use newer features of operators.hpp','line_number':52,'multiline':False]['text':'             (reduces space overhead to zero), add operator!,','line_number':53,'multiline':False]['text':'             introduce explicit mixed-mode arithmetic operations','line_number':54,'multiline':False]['text':'  12 Jan 01  Include fixes to handle a user-defined IntType better','line_number':55,'multiline':False]['text':'  19 Nov 00  Throw on divide by zero in operator /= (John (EBo) David)','line_number':56,'multiline':False]['text':'  23 Jun 00  Incorporate changes from Mark Rodgers for Borland C++','line_number':57,'multiline':False]['text':'  22 Jun 00  Change _MSC_VER to BOOST_MSVC so other compilers are not','line_number':58,'multiline':False]['text':'             affected (Beman Dawes)','line_number':59,'multiline':False]['text':'   6 Mar 00  Fix operator-= normalization, #include <string> (Jens Maurer)','line_number':60,'multiline':False]['text':'  14 Dec 99  Modifications based on comments from the boost list','line_number':61,'multiline':False]['text':'  09 Dec 99  Initial Version (Paul Moore)','line_number':62,'multiline':False]['text':' for BOOST_NO_STDC_NAMESPACE, BOOST_MSVC, etc','line_number':67,'multiline':False]['text':' for std::setw','line_number':69,'multiline':False]['text':' for std::noskipws, streamsize','line_number':70,'multiline':False]['text':' for std::istream','line_number':71,'multiline':False]['text':' for std::ostream','line_number':72,'multiline':False]['text':' for std::ostringstream','line_number':73,'multiline':False]['text':' for NULL','line_number':75,'multiline':False]['text':' for std::domain_error','line_number':76,'multiline':False]['text':' for std::string implicit constructor','line_number':77,'multiline':False]['text':' for std::abs','line_number':78,'multiline':False]['text':' for boost::call_traits','line_number':79,'multiline':False]['text':' for BOOST_WORKAROUND','line_number':80,'multiline':False]['text':' for BOOST_ASSERT','line_number':81,'multiline':False]['text':' for boost::integer::gcd, lcm','line_number':82,'multiline':False]['text':' for std::numeric_limits','line_number':83,'multiline':False]['text':' for BOOST_STATIC_ASSERT','line_number':84,'multiline':False]['text':' Control whether depreciated GCD and LCM functions are included (default: yes)','line_number':92,'multiline':False]['text':' Defer to the version in Boost.Integer','line_number':103,'multiline':False]['text':' Defer to the version in Boost.Integer','line_number':110,'multiline':False]['text':' BOOST_CONTROL_RATIONAL_HAS_GCD','line_number':113,'multiline':False]['text':' Class-wide pre-conditions','line_number':167,'multiline':False]['text':' Helper types','line_number':170,'multiline':False]['text':' Component type','line_number':177,'multiline':False]['text':', typename enable_if_c<!is_array<T>::value>::type>','line_number':183,'multiline':False]['text':' Default copy constructor and assignment are fine','line_number':208,'multiline':False]['text':' Add assignment from IntType','line_number':210,'multiline':False]['text':' Assign in place','line_number':216,'multiline':False]['text':'','line_number':224,'multiline':False]['text':' The following overloads should probably *not* be provided - ','line_number':225,'multiline':False]['text':' but are provided for backwards compatibity reasons only.','line_number':226,'multiline':False]['text':' These allow for construction/assignment from types that','line_number':227,'multiline':False]['text':' are wider than IntType only if there is an implicit','line_number':228,'multiline':False]['text':' conversion from T to IntType, they will throw a bad_rational','line_number':229,'multiline':False]['text':' if the conversion results in loss of precision or undefined behaviour.','line_number':230,'multiline':False]['text':'','line_number':231,'multiline':False]['text':', typename enable_if_c<!is_array<T>::value>::type>','line_number':232,'multiline':False]['text':' Access to representation','line_number':280,'multiline':False]['text':' Arithmetic assignment operators','line_number':286,'multiline':False]['text':' Avoid overflow and preserve normalization','line_number':307,'multiline':False]['text':' Avoid repeated construction','line_number':316,'multiline':False]['text':' Avoid overflow and preserve normalization','line_number':322,'multiline':False]['text':' Increment and decrement','line_number':335,'multiline':False]['text':' Operator not','line_number':352,'multiline':False]['text':' Boolean conversion','line_number':356,'multiline':False]['text':' The "ISO C++ Template Parser" option in CW 8.3 chokes on the','line_number':359,'multiline':False]['text':' following, hence we selectively disable that option for the','line_number':360,'multiline':False]['text':' offending memfun.','line_number':361,'multiline':False]['text':' Comparison operators','line_number':372,'multiline':False]['text':' Avoid repeated construction','line_number':381,'multiline':False]['text':' Break value into mixed-fraction form, w/ always-nonnegative remainder','line_number':384,'multiline':False]['text':' Compare with just the quotient, since the remainder always bumps the','line_number':389,'multiline':False]['text':' value up.  [Since q = floor(n/d), and if n/d < i then q < i, if n/d == i','line_number':390,'multiline':False]['text':' then q == i, if n/d == i + r/d then q == i, and if n/d >= i + 1 then','line_number':391,'multiline':False]['text':' q >= i + 1 > i; therefore n/d < i iff q < i.]','line_number':392,'multiline':False]['text':' Implementation - numerator and denominator (normalized).','line_number':407,'multiline':False]['text':' Other possibilities - separate whole-part, or sign, fields?','line_number':408,'multiline':False]['text':' Helper functions','line_number':412,'multiline':False]['text':' Representation note: Fractions are kept in normalized form at all','line_number':422,'multiline':False]['text':' times. normalized form is defined as gcd(num,den) == 1 and den > 0.','line_number':423,'multiline':False]['text':' In particular, note that the implementation of abs() below relies','line_number':424,'multiline':False]['text':' on den always being positive.','line_number':425,'multiline':False]['text':'','line_number':436,'multiline':False]['text':' Conversion checks:','line_number':437,'multiline':False]['text':'','line_number':438,'multiline':False]['text':' (1) From an unsigned type with more digits than IntType:','line_number':439,'multiline':False]['text':'','line_number':440,'multiline':False]['text':'','line_number':446,'multiline':False]['text':' (2) From a signed type with more digits than IntType, and IntType also signed:','line_number':447,'multiline':False]['text':'','line_number':448,'multiline':False]['text':' Note that this check assumes IntType has a 2's complement representation,','line_number':452,'multiline':False]['text':' we don't want to try to convert a std::numeric_limits<IntType>::min() to','line_number':453,'multiline':False]['text':' a T because that conversion may not be allowed (this happens when IntType','line_number':454,'multiline':False]['text':' is from Boost.Multiprecision).','line_number':455,'multiline':False]['text':'','line_number':458,'multiline':False]['text':' (3) From a signed type with more digits than IntType, and IntType unsigned:','line_number':459,'multiline':False]['text':'','line_number':460,'multiline':False]['text':'','line_number':466,'multiline':False]['text':' (4) From a signed type with fewer digits than IntType, and IntType unsigned:','line_number':467,'multiline':False]['text':'','line_number':468,'multiline':False]['text':'','line_number':474,'multiline':False]['text':' (5) From an unsigned type with fewer digits than IntType, and IntType signed:','line_number':475,'multiline':False]['text':'','line_number':476,'multiline':False]['text':'','line_number':482,'multiline':False]['text':' (6) From an unsigned type with fewer digits than IntType, and IntType unsigned:','line_number':483,'multiline':False]['text':'','line_number':484,'multiline':False]['text':'','line_number':490,'multiline':False]['text':' (7) From an signed type with fewer digits than IntType, and IntType signed:','line_number':491,'multiline':False]['text':'','line_number':492,'multiline':False]['text':' Unary plus and minus','line_number':500,'multiline':False]['text':' Arithmetic assignment operators','line_number':515,'multiline':False]['text':' This calculation avoids overflow, and minimises the number of expensive','line_number':519,'multiline':False]['text':' calculations. Thanks to Nickolay Mladenov for this algorithm.','line_number':520,'multiline':False]['text':'','line_number':521,'multiline':False]['text':' Proof:','line_number':522,'multiline':False]['text':' We have to compute a/b + c/d, where gcd(a,b)=1 and gcd(b,c)=1.','line_number':523,'multiline':False]['text':' Let g = gcd(b,d), and b = b1*g, d=d1*g. Then gcd(b1,d1)=1','line_number':524,'multiline':False]['text':'','line_number':525,'multiline':False]['text':' The result is (a*d1 + c*b1) / (b1*d1*g).','line_number':526,'multiline':False]['text':' Now we have to normalize this ratio.','line_number':527,'multiline':False]['text':' Let's assume h | gcd((a*d1 + c*b1), (b1*d1*g)), and h > 1','line_number':528,'multiline':False]['text':' If h | b1 then gcd(h,d1)=1 and hence h|(a*d1+c*b1) => h|a.','line_number':529,'multiline':False]['text':' But since gcd(a,b1)=1 we have h=1.','line_number':530,'multiline':False]['text':' Similarly h|d1 leads to h=1.','line_number':531,'multiline':False]['text':' So we have that h | gcd((a*d1 + c*b1) , (b1*d1*g)) => h|g','line_number':532,'multiline':False]['text':' Finally we have gcd((a*d1 + c*b1), (b1*d1*g)) = gcd((a*d1 + c*b1), g)','line_number':533,'multiline':False]['text':' Which proves that instead of normalizing the result, it is better to','line_number':534,'multiline':False]['text':' divide num and den by gcd((a*d1 + c*b1), g)','line_number':535,'multiline':False]['text':' Protect against self-modification','line_number':537,'multiline':False]['text':' = b1 from the calculations above','line_number':542,'multiline':False]['text':' Protect against self-modification','line_number':554,'multiline':False]['text':' This calculation avoids overflow, and minimises the number of expensive','line_number':558,'multiline':False]['text':' calculations. It corresponds exactly to the += case above','line_number':559,'multiline':False]['text':' Protect against self-modification','line_number':573,'multiline':False]['text':' Avoid overflow and preserve normalization','line_number':577,'multiline':False]['text':' Protect against self-modification','line_number':588,'multiline':False]['text':' Avoid repeated construction','line_number':592,'multiline':False]['text':' Trap division by zero','line_number':595,'multiline':False]['text':' Avoid overflow and preserve normalization','line_number':601,'multiline':False]['text':'','line_number':615,'multiline':False]['text':' Non-member operators: previously these were provided by Boost.Operator, but these had a number of','line_number':616,'multiline':False]['text':' drawbacks, most notably, that in order to allow inter-operability with IntType code such as this:','line_number':617,'multiline':False]['text':'','line_number':618,'multiline':False]['text':' rational<int> r(3);','line_number':619,'multiline':False]['text':' assert(r == 3.5); // compiles and passes!!','line_number':620,'multiline':False]['text':'','line_number':621,'multiline':False]['text':' Happens to be allowed as well :-(','line_number':622,'multiline':False]['text':'','line_number':623,'multiline':False]['text':' There are three possible cases for each operator:','line_number':624,'multiline':False]['text':' 1) rational op rational.','line_number':625,'multiline':False]['text':' 2) rational op integer','line_number':626,'multiline':False]['text':' 3) integer op rational','line_number':627,'multiline':False]['text':' Cases (1) and (2) are folded into the one function.','line_number':628,'multiline':False]['text':'','line_number':629,'multiline':False]['text':' Comparison operators','line_number':782,'multiline':False]['text':' Avoid repeated construction','line_number':787,'multiline':False]['text':' This should really be a class-wide invariant.  The reason for these','line_number':790,'multiline':False]['text':' checks is that for 2's complement systems, INT_MIN has no corresponding','line_number':791,'multiline':False]['text':' positive, so negating it during normalization keeps it INT_MIN, which','line_number':792,'multiline':False]['text':' is bad for later calculations that assume a positive denominator.','line_number':793,'multiline':False]['text':' Determine relative order by expanding each value to its simple continued','line_number':797,'multiline':False]['text':' fraction representation using the Euclidian GCD algorithm.','line_number':798,'multiline':False]['text':' Normalize negative moduli by repeatedly adding the (positive) denominator','line_number':806,'multiline':False]['text':' and decrementing the quotient.  Later cycles should have all positive','line_number':807,'multiline':False]['text':' values, so this only has to be done for the first cycle.  (The rules of','line_number':808,'multiline':False]['text':' C++ require a nonnegative quotient & remainder for a nonnegative dividend','line_number':809,'multiline':False]['text':' & positive divisor.)','line_number':810,'multiline':False]['text':' Loop through and compare each variable's continued-fraction components','line_number':814,'multiline':False]['text':' The quotients of the current cycle are the continued-fraction','line_number':817,'multiline':False]['text':' components.  Comparing two c.f. is comparing their sequences,','line_number':818,'multiline':False]['text':' stopping at the first difference.','line_number':819,'multiline':False]['text':' Since reciprocation changes the relative order of two variables,','line_number':822,'multiline':False]['text':' and c.f. use reciprocals, the less/greater-than test reverses','line_number':823,'multiline':False]['text':' after each index.  (Start w/ non-reversed @ whole-number place.)','line_number':824,'multiline':False]['text':' Prepare the next cycle','line_number':828,'multiline':False]['text':' At least one variable's c.f. expansion has ended','line_number':833,'multiline':False]['text':' Compare infinity-valued components for otherwise equal sequences','line_number':843,'multiline':False]['text':' Both remainders are zero, so the next (and subsequent) c.f.','line_number':846,'multiline':False]['text':' components for both sequences are infinity.  Therefore, the sequences','line_number':847,'multiline':False]['text':' and their corresponding values are equal.','line_number':848,'multiline':False]['text':' Exactly one of the remainders is zero, so all following c.f.','line_number':857,'multiline':False]['text':' components of that variable are infinity, while the other variable','line_number':858,'multiline':False]['text':' has a finite next c.f. component.  So that other variable has the','line_number':859,'multiline':False]['text':' lesser value (modulo the reversal flag!).','line_number':860,'multiline':False]['text':' Invariant check','line_number':875,'multiline':False]['text':' Normalisation','line_number':884,'multiline':False]['text':' Avoid repeated construction','line_number':888,'multiline':False]['text':' Handle the case of zero separately, to avoid division by zero','line_number':894,'multiline':False]['text':' Ensure that the denominator is positive','line_number':909,'multiline':False]['text':' A utility class to reset the format flags for an istream at end','line_number':921,'multiline':False]['text':' of scope, even in case of exceptions','line_number':922,'multiline':False]['text':' old GNU c++ lib has no ios_base','line_number':927,'multiline':False]['text':' Input and output','line_number':932,'multiline':False]['text':' normalization fail','line_number':951,'multiline':False]['text':' don't throw ios_base::failure...','line_number':953,'multiline':False]['text':' ...but the original exception instead','line_number':955,'multiline':False]['text':' ELSE: suppress the exception, use just error flags','line_number':956,'multiline':False]['text':' Add manipulators for output format?','line_number':967,'multiline':False]['text':' The slash directly precedes the denominator, which has no prefixes.','line_number':971,'multiline':False]['text':' The numerator holds the showpos, internal, and showbase flags.','line_number':980,'multiline':False]['text':' BOOST_NO_IOSTREAM','line_number':992,'multiline':False]['text':' Type conversion','line_number':994,'multiline':False]['text':' Do not use any abs() defined on IntType - it isn't worth it, given the','line_number':1002,'multiline':False]['text':' difficulties involved (Koenig lookup required, there may not *be* an abs()','line_number':1003,'multiline':False]['text':' defined, etc etc).','line_number':1004,'multiline':False]['text':' namespace integer','line_number':1042,'multiline':False]['text':' namespace boost','line_number':1044,'multiline':False]['text':' BOOST_RATIONAL_HPP','line_number':1046,'multiline':False]