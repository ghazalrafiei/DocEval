['text':' MS compatible compilers support #pragma once','line_number':4,'multiline':False]['text':'///////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8','line_number':17,'multiline':False]['text':' iserializer.hpp: interface for serialization system.','line_number':18,'multiline':False]['text':' (C) Copyright 2002 Robert Ramey - http://www.rrsd.com .','line_number':20,'multiline':False]['text':' Use, modification and distribution is subject to the Boost Software','line_number':21,'multiline':False]['text':' License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at','line_number':22,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':23,'multiline':False]['text':'  See http://www.boost.org for updates, documentation, and revision history.','line_number':25,'multiline':False]['text':' for placement new','line_number':27,'multiline':False]['text':' size_t, NULL','line_number':28,'multiline':False]['text':' namespace std','line_number':35,'multiline':False]['text':' the following is need only for dynamic cast of polymorphic pointers','line_number':86,'multiline':False]['text':' namespace serialization','line_number':100,'multiline':False]['text':' an accessor to permit friend access to archives.  Needed because','line_number':104,'multiline':False]['text':' some compilers don't handle friend templates completely','line_number':105,'multiline':False]['text':'const','line_number':125,'multiline':True]['text':' flags ','line_number':146,'multiline':True]['text':' note: we now comment this out. Before we permited archive','line_number':172,'multiline':False]['text':' version # to be very large.  Now we don't.  To permit','line_number':173,'multiline':False]['text':' readers of these old archives, we have to suppress this','line_number':174,'multiline':False]['text':' code.  Perhaps in the future we might re-enable it but','line_number':175,'multiline':False]['text':' permit its suppression with a runtime switch.','line_number':176,'multiline':False]['text':' trap case where the program cannot handle the current version','line_number':178,'multiline':False]['text':' make sure call is routed through the higest interface that might','line_number':187,'multiline':False]['text':' be specialized by the user.','line_number':188,'multiline':False]['text':' the purpose of this code is to allocate memory for an object','line_number':201,'multiline':False]['text':' without requiring the constructor to be called.  Presumably','line_number':202,'multiline':False]['text':' the allocated object will be subsequently initialized with','line_number':203,'multiline':False]['text':' "placement new".','line_number':204,'multiline':False]['text':' note: we have the boost type trait has_new_operator but we','line_number':205,'multiline':False]['text':' have no corresponding has_delete_operator.  So we presume','line_number':206,'multiline':False]['text':' that the former being true would imply that the a delete','line_number':207,'multiline':False]['text':' operator is also defined for the class T.','line_number':208,'multiline':False]['text':' boost::has_new_operator< T > doesn't work on these compilers','line_number':212,'multiline':False]['text':' This doesn't handle operator new overload for class T','line_number':214,'multiline':False]['text':' note: we presume that a true value for has_new_operator','line_number':222,'multiline':False]['text':' implies the existence of a class specific delete operator as well','line_number':223,'multiline':False]['text':' as a class specific new operator.','line_number':224,'multiline':False]['text':' if compilation fails here, the likely cause that the class','line_number':230,'multiline':False]['text':' T has a class specific new operator but no class specific','line_number':231,'multiline':False]['text':' delete operator which matches the following signature.','line_number':232,'multiline':False]['text':' note that this solution addresses the issue that two','line_number':233,'multiline':False]['text':' possible signatures.  But it doesn't address the possibility','line_number':234,'multiline':False]['text':' that the class might have class specific new with NO','line_number':235,'multiline':False]['text':' class specific delete at all.  Patches (compatible with','line_number':236,'multiline':False]['text':' C++03) welcome!','line_number':237,'multiline':False]['text':' Note: I'm reliance upon automatic conversion from T * to void * here','line_number':246,'multiline':False]['text':' this should alway be a singleton so make the constructor protected','line_number':311,'multiline':False]['text':' note: BOOST_DLLEXPORT is so that code for polymorphic class','line_number':320,'multiline':False]['text':' serialized only through base class won't get optimized out','line_number':321,'multiline':False]['text':' note that the above will throw std::bad_alloc if the allocation','line_number':332,'multiline':False]['text':' fails so we don't have to address this contingency here.','line_number':333,'multiline':False]['text':' catch exception during load_construct_data so that we don't','line_number':335,'multiline':False]['text':' automatically delete the t which is most likely not fully','line_number':336,'multiline':False]['text':' constructed','line_number':337,'multiline':False]['text':' this addresses an obscure situation that occurs when','line_number':339,'multiline':False]['text':' load_constructor de-serializes something through a pointer.','line_number':340,'multiline':False]['text':' if we get here the load_construct failed.  The heap_allocation','line_number':349,'multiline':False]['text':' will be automatically deleted so we don't have to do anything','line_number':350,'multiline':False]['text':' special here.','line_number':351,'multiline':False]['text':' note this bounces the call right back to the archive','line_number':381,'multiline':False]['text':' with no runtime overhead','line_number':382,'multiline':False]['text':' note this bounces the call right back to the archive','line_number':389,'multiline':False]['text':' with no runtime overhead','line_number':390,'multiline':False]['text':' short cut to user's serializer','line_number':394,'multiline':False]['text':' make sure call is routed through the higest interface that might','line_number':395,'multiline':False]['text':' be specialized by the user.','line_number':396,'multiline':False]['text':' note this save class information including version','line_number':405,'multiline':False]['text':' and serialization level to the archive','line_number':406,'multiline':False]['text':'if(0 == (ar.get_flags() & no_tracking))','line_number':423,'multiline':False]['text':'else','line_number':425,'multiline':False]['text':'    load_only::invoke(ar, t);','line_number':426,'multiline':False]['text':' if its primitive','line_number':433,'multiline':False]['text':' else','line_number':439,'multiline':False]['text':' class info / version','line_number':441,'multiline':False]['text':' do standard load','line_number':446,'multiline':False]['text':' else','line_number':448,'multiline':False]['text':' no tracking','line_number':450,'multiline':False]['text':' do a fast load','line_number':455,'multiline':False]['text':' else','line_number':457,'multiline':False]['text':' do a fast load only tracking is turned off','line_number':458,'multiline':False]['text':' ar ','line_number':472,'multiline':True]['text':' it has? to be polymorphic','line_number':473,'multiline':False]['text':'t','line_number':488,'multiline':True]['text':' there should never be any need to load an abstract polymorphic','line_number':489,'multiline':False]['text':' class pointer.  Inhibiting code generation for this','line_number':490,'multiline':False]['text':' permits abstract base classes to be used - note: exception','line_number':491,'multiline':False]['text':' virtual serialize functions used for plug-ins','line_number':492,'multiline':False]['text':' tweak the pointer back to the base class','line_number':508,'multiline':False]['text':' t ','line_number':527,'multiline':True]['text':' note major hack here !!!','line_number':544,'multiline':False]['text':' I tried every way to convert Tptr &t (where Tptr might','line_number':545,'multiline':False]['text':' include const) to void * &.  This is the only way','line_number':546,'multiline':False]['text':' I could make it work. RR','line_number':547,'multiline':False]['text':' if the pointer isn't that of the base class','line_number':552,'multiline':False]['text':' convert integers to correct enum to load','line_number':563,'multiline':False]['text':' convert integers to correct enum to load','line_number':576,'multiline':False]['text':' determine number of elements in the array. Consider the','line_number':577,'multiline':False]['text':' fact that some machines will align elements on boundaries','line_number':578,'multiline':False]['text':' other than characters.','line_number':579,'multiline':False]['text':' explict template arguments to pass intel C++ compiler','line_number':592,'multiline':False]['text':' detail','line_number':603,'multiline':False]['text':' if this assertion trips. It means we're trying to load a','line_number':607,'multiline':False]['text':' const object with a compiler that doesn't have correct','line_number':608,'multiline':False]['text':' function template ordering.  On other compilers, this is','line_number':609,'multiline':False]['text':' handled below.','line_number':610,'multiline':False]['text':'else','line_number':615,'multiline':False]['text':'else','line_number':618,'multiline':False]['text':'else','line_number':621,'multiline':False]['text':' namespace archive','line_number':629,'multiline':False]['text':' namespace boost','line_number':630,'multiline':False]['text':' BOOST_ARCHIVE_DETAIL_ISERIALIZER_HPP','line_number':632,'multiline':False]