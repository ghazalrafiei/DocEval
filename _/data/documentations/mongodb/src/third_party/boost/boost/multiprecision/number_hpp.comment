['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2011 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':' stream operators','line_number':19,'multiline':False]['text':' EOF','line_number':20,'multiline':False]['text':' isspace','line_number':21,'multiline':False]['text':' std::hash','line_number':22,'multiline':False]['text':' warning C4127: conditional expression is constant','line_number':36,'multiline':False]['text':' warning C4714: function marked as __forceinline not inlined','line_number':37,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' Conversions from unscoped enum's are implicit:','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':'','line_number':98,'multiline':False]['text':' Conversions from scoped enum's are explicit:','line_number':99,'multiline':False]['text':'','line_number':100,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' Attempt a generic interconvertion:','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' Copy precision options from this type to component_type:','line_number':221,'multiline':False]['text':' precision guards:','line_number':223,'multiline':False]['text':' Copy precision options from this type to component_type:','line_number':234,'multiline':False]['text':' precision guards:','line_number':236,'multiline':False]['text':'','line_number':242,'multiline':False]['text':' Support for new types in C++17','line_number':243,'multiline':False]['text':'','line_number':244,'multiline':False]['text':'','line_number':297,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':298,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':299,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':300,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':301,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':302,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':303,'multiline':False]['text':' to longer build and possibly link times.','line_number':304,'multiline':False]['text':'','line_number':305,'multiline':False]['text':'','line_number':323,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':324,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':325,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':326,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':327,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':328,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':329,'multiline':False]['text':' to longer build and possibly link times.','line_number':330,'multiline':False]['text':'','line_number':331,'multiline':False]['text':'','line_number':400,'multiline':False]['text':' Attempt a generic interconvertion:','line_number':401,'multiline':False]['text':'','line_number':402,'multiline':False]['text':'','line_number':406,'multiline':False]['text':' If the current precision of *this differs from that of value v, then we','line_number':407,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':408,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':409,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':410,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':411,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':412,'multiline':False]['text':' to longer build and possibly link times.','line_number':413,'multiline':False]['text':'','line_number':414,'multiline':False]['text':'','line_number':428,'multiline':False]['text':' No preicsion guard here, we already have one in operator=','line_number':429,'multiline':False]['text':'','line_number':430,'multiline':False]['text':'','line_number':437,'multiline':False]['text':' No precision guard as assign has one already:','line_number':438,'multiline':False]['text':'','line_number':439,'multiline':False]['text':' rvalues:','line_number':443,'multiline':False]['text':'','line_number':470,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':471,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':472,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':473,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':474,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':475,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':476,'multiline':False]['text':' to longer build and possibly link times.','line_number':477,'multiline':False]['text':'','line_number':478,'multiline':False]['text':' Create a copy if e contains this, but not if we're just doing a','line_number':493,'multiline':False]['text':'    x += x','line_number':494,'multiline':False]['text':'','line_number':511,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':512,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':513,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':514,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':515,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':516,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':517,'multiline':False]['text':' to longer build and possibly link times.','line_number':518,'multiline':False]['text':'','line_number':519,'multiline':False]['text':'','line_number':529,'multiline':False]['text':' Fused multiply-add:','line_number':530,'multiline':False]['text':'','line_number':531,'multiline':False]['text':'','line_number':542,'multiline':False]['text':' If the current precision of *this differs from that of value v, then we','line_number':543,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':544,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':545,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':546,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':547,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':548,'multiline':False]['text':' to longer build and possibly link times.','line_number':549,'multiline':False]['text':'','line_number':550,'multiline':False]['text':'','line_number':566,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':567,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':568,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':569,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':570,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':571,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':572,'multiline':False]['text':' to longer build and possibly link times.','line_number':573,'multiline':False]['text':'','line_number':574,'multiline':False]['text':' Create a copy if e contains this:','line_number':589,'multiline':False]['text':'','line_number':607,'multiline':False]['text':' If the current precision of *this differs from that of value v, then we','line_number':608,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':609,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':610,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':611,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':612,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':613,'multiline':False]['text':' to longer build and possibly link times.','line_number':614,'multiline':False]['text':'','line_number':615,'multiline':False]['text':'','line_number':632,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':633,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':634,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':635,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':636,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':637,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':638,'multiline':False]['text':' to longer build and possibly link times.','line_number':639,'multiline':False]['text':'','line_number':640,'multiline':False]['text':'','line_number':650,'multiline':False]['text':' Fused multiply-subtract:','line_number':651,'multiline':False]['text':'','line_number':652,'multiline':False]['text':'','line_number':661,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':662,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':663,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':664,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':665,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':666,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':667,'multiline':False]['text':' to longer build and possibly link times.','line_number':668,'multiline':False]['text':'','line_number':669,'multiline':False]['text':' Create a temporary if the RHS references *this, but not','line_number':684,'multiline':False]['text':' if we're just doing an   x *= x;','line_number':685,'multiline':False]['text':'','line_number':703,'multiline':False]['text':' If the current precision of *this differs from that of value v, then we','line_number':704,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':705,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':706,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':707,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':708,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':709,'multiline':False]['text':' to longer build and possibly link times.','line_number':710,'multiline':False]['text':'','line_number':711,'multiline':False]['text':'','line_number':728,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':729,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':730,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':731,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':732,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':733,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':734,'multiline':False]['text':' to longer build and possibly link times.','line_number':735,'multiline':False]['text':'','line_number':736,'multiline':False]['text':' Create a temporary if the RHS references *this:','line_number':751,'multiline':False]['text':'','line_number':773,'multiline':False]['text':' These operators are *not* proto-ized.','line_number':774,'multiline':False]['text':' The issue is that the increment/decrement must happen','line_number':775,'multiline':False]['text':' even if the result of the operator *is never used*.','line_number':776,'multiline':False]['text':' Possibly we could modify our expression wrapper to','line_number':777,'multiline':False]['text':' execute the increment/decrement on destruction, but','line_number':778,'multiline':False]['text':' correct implementation will be tricky, so defered for now...','line_number':779,'multiline':False]['text':'','line_number':780,'multiline':False]['text':'','line_number':832,'multiline':False]['text':' If the current precision of *this differs from that of expression e, then we','line_number':833,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':834,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':835,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':836,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':837,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':838,'multiline':False]['text':' to longer build and possibly link times.','line_number':839,'multiline':False]['text':'','line_number':840,'multiline':False]['text':' Create a temporary if the RHS references *this:','line_number':855,'multiline':False]['text':'','line_number':873,'multiline':False]['text':' If the current precision of *this differs from that of value v, then we','line_number':874,'multiline':False]['text':' create a temporary (which will have the correct precision thanks to precision_guard)','line_number':875,'multiline':False]['text':' and then move the result into *this.  In C++17 we add a leading "if constexpr"','line_number':876,'multiline':False]['text':' which causes this code to be eliminated in the common case that this type is','line_number':877,'multiline':False]['text':' not actually variable precision.  Pre C++17 this code should still be mostly','line_number':878,'multiline':False]['text':' optimised away, but we can't prevent instantiation of the dead code leading','line_number':879,'multiline':False]['text':' to longer build and possibly link times.','line_number':880,'multiline':False]['text':'','line_number':881,'multiline':False]['text':' Create a temporary if the RHS references *this, but not','line_number':905,'multiline':False]['text':' if we're just doing an   x &= x;','line_number':906,'multiline':False]['text':' Create a temporary if the RHS references *this, but not','line_number':940,'multiline':False]['text':' if we're just doing an   x |= x;','line_number':941,'multiline':False]['text':'','line_number':996,'multiline':False]['text':' swap:','line_number':997,'multiline':False]['text':'','line_number':998,'multiline':False]['text':'','line_number':1003,'multiline':False]['text':' Zero and sign:','line_number':1004,'multiline':False]['text':'','line_number':1005,'multiline':False]['text':'','line_number':1016,'multiline':False]['text':' String conversion functions:','line_number':1017,'multiline':False]['text':'','line_number':1018,'multiline':False]['text':'version','line_number':1026,'multiline':True]['text':'','line_number':1057,'multiline':False]['text':' Use in boolean context, and explicit conversion operators:','line_number':1058,'multiline':False]['text':'','line_number':1059,'multiline':False]['text':'','line_number':1073,'multiline':False]['text':' Default precision:','line_number':1074,'multiline':False]['text':'','line_number':1075,'multiline':False]['text':'','line_number':1101,'multiline':False]['text':' Variable precision options:','line_number':1102,'multiline':False]['text':' ','line_number':1103,'multiline':False]['text':'','line_number':1120,'multiline':False]['text':' Comparison:','line_number':1121,'multiline':False]['text':'','line_number':1122,'multiline':False]['text':'','line_number':1142,'multiline':False]['text':' Direct access to the underlying backend:','line_number':1143,'multiline':False]['text':'','line_number':1144,'multiline':False]['text':'','line_number':1152,'multiline':False]['text':' Complex number real and imag:','line_number':1153,'multiline':False]['text':'','line_number':1154,'multiline':False]['text':' The result of the expression isn't the same type as this -','line_number':1193,'multiline':False]['text':' create a temporary result and assign it to *this:','line_number':1194,'multiline':False]['text':' The result of the expression isn't the same type as this -','line_number':1203,'multiline':False]['text':' create a temporary result and assign it to *this:','line_number':1204,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1286,'multiline':False]['text':' Ignore the right node, it's *this, just add the left:','line_number':1291,'multiline':False]['text':' br is always false, but if bl is true we must take the this branch:','line_number':1295,'multiline':False]['text':' Ignore the left node, it's *this, just subtract the right:','line_number':1324,'multiline':False]['text':' Ignore the right node, it's *this, just subtract the left and negate the result:','line_number':1329,'multiline':False]['text':' br is always false, but if bl is true we must take the this branch:','line_number':1334,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1364,'multiline':False]['text':' Ignore the right node, it's *this, just add the left:','line_number':1369,'multiline':False]['text':' br is always false, but if bl is true we must take the this branch:','line_number':1373,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1394,'multiline':False]['text':'','line_number':1411,'multiline':False]['text':' This operation is only valid for integer backends:','line_number':1412,'multiline':False]['text':'','line_number':1413,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1424,'multiline':False]['text':'','line_number':1450,'multiline':False]['text':' This operation is only valid for integer backends:','line_number':1451,'multiline':False]['text':'','line_number':1452,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1466,'multiline':False]['text':'','line_number':1495,'multiline':False]['text':' This operation is only valid for integer backends:','line_number':1496,'multiline':False]['text':'','line_number':1497,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1511,'multiline':False]['text':'','line_number':1540,'multiline':False]['text':' This operation is only valid for integer backends:','line_number':1541,'multiline':False]['text':'','line_number':1542,'multiline':False]['text':' Ignore the left node, it's *this, just add the right:','line_number':1556,'multiline':False]['text':' We can only shift by an integer value, not an arbitrary expression:','line_number':1599,'multiline':False]['text':' We can only shift by an integer value, not an arbitrary expression:','line_number':1613,'multiline':False]['text':'t2','line_number':1765,'multiline':True]['text':'t3','line_number':1776,'multiline':True]['text':'','line_number':1919,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':1920,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':1921,'multiline':False]['text':'','line_number':1922,'multiline':False]['text':'','line_number':1941,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':1942,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':1943,'multiline':False]['text':'','line_number':1944,'multiline':False]['text':'','line_number':1979,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':1980,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':1981,'multiline':False]['text':'','line_number':1982,'multiline':False]['text':'','line_number':1992,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':1993,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':1994,'multiline':False]['text':'','line_number':1995,'multiline':False]['text':'','line_number':2005,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':2006,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':2007,'multiline':False]['text':'','line_number':2008,'multiline':False]['text':'','line_number':2018,'multiline':False]['text':' This rearrangement is disabled for integer types, the test on sizeof(Exp) is simply to make','line_number':2019,'multiline':False]['text':' the disable_if dependent on the template argument (the size of 1 can never occur in practice).','line_number':2020,'multiline':False]['text':'','line_number':2021,'multiline':False]['text':' Tests if the expression contains a reference to *this:','line_number':2136,'multiline':False]['text':' Test if the expression is a reference to *this:','line_number':2169,'multiline':False]['text':'','line_number':2202,'multiline':False]['text':' These shouldn't really need to be public, or even member functions, but it makes implementing','line_number':2203,'multiline':False]['text':' the non-member operators way easier if they are:','line_number':2204,'multiline':False]['text':'','line_number':2205,'multiline':False]['text':'','line_number':2252,'multiline':False]['text':' What follows is the input streaming code: this is not "proper" iostream code at all','line_number':2253,'multiline':False]['text':' but that's fiendishly hard to write when dealing with multiple backends all','line_number':2254,'multiline':False]['text':' with different requirements... yes we could deligate this to the backend author...','line_number':2255,'multiline':False]['text':' but we really want backends to be EASY to write!','line_number':2256,'multiline':False]['text':' For now just pull in all the characters that could possibly form the number','line_number':2257,'multiline':False]['text':' and let the backend's string parser make use of it.  This fixes most use cases','line_number':2258,'multiline':False]['text':' including CSV type formats such as those used by the Random lib.','line_number':2259,'multiline':False]['text':'','line_number':2260,'multiline':False]['text':' end of file:','line_number':2273,'multiline':False]['text':' Invalid numeric character, stop reading:','line_number':2279,'multiline':False]['text':'is.rdbuf()->sputbackc(static_cast<char>(c));','line_number':2280,'multiline':False]['text':' namespace detail','line_number':2295,'multiline':False]['text':'','line_number':2338,'multiline':False]['text':' Boost.Hash support, just call hash_value for the backend, which may or may not be supported:','line_number':2339,'multiline':False]['text':'','line_number':2340,'multiline':False]['text':' namespace detail','line_number':2356,'multiline':False]['text':' namespace multiprecision','line_number':2358,'multiline':False]['text':' namespace multiprecision','line_number':2436,'multiline':False]['text':' namespace boost','line_number':2442,'multiline':False]['text':' namespace std','line_number':2462,'multiline':False]