['text':'///////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga  2007-2021','line_number':3,'multiline':False]['text':' (C) Copyright Daniel Steck   2021','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0.','line_number':6,'multiline':False]['text':'    (See accompanying file LICENSE_1_0.txt or copy at','line_number':7,'multiline':False]['text':'          http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' See http://www.boost.org/libs/intrusive for documentation.','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':'///////////////////////////////////////////////////////////////////////////','line_number':12,'multiline':False]['text':'/ @cond','line_number':35,'multiline':False]['text':'! This type is the information that will be filled by insert_unique_check','line_number':37,'multiline':False]['text':' namespace detail','line_number':98,'multiline':False]['text':'/ @endcond','line_number':100,'multiline':False]['text':'!   This is an implementation of a binary search tree.','line_number':104,'multiline':False]['text':'!   A node in the search tree has references to its children and its parent. This','line_number':105,'multiline':False]['text':'!   is to allow traversal of the whole tree from a given node making the','line_number':106,'multiline':False]['text':'!   implementation of iterator a pointer to a node.','line_number':107,'multiline':False]['text':'!   At the top of the tree a node is used specially. This node's parent pointer','line_number':108,'multiline':False]['text':'!   is pointing to the root of the tree. Its left pointer points to the','line_number':109,'multiline':False]['text':'!   leftmost node in the tree and the right pointer to the rightmost one.','line_number':110,'multiline':False]['text':'!   This node is used to represent the end-iterator.','line_number':111,'multiline':False]['text':'!','line_number':112,'multiline':False]['text':'!                                            +---------+','line_number':113,'multiline':False]['text':'!       header------------------------------>|         |','line_number':114,'multiline':False]['text':'!                                            |         |','line_number':115,'multiline':False]['text':'!                   +----------(left)--------|         |--------(right)---------+','line_number':116,'multiline':False]['text':'!                   |                        +---------+                        |','line_number':117,'multiline':False]['text':'!                   |                             |                             |','line_number':118,'multiline':False]['text':'!                   |                             | (parent)                    |','line_number':119,'multiline':False]['text':'!                   |                             |                             |','line_number':120,'multiline':False]['text':'!                   |                             |                             |','line_number':121,'multiline':False]['text':'!                   |                        +---------+                        |','line_number':122,'multiline':False]['text':'!    root of tree ..|......................> |         |                        |','line_number':123,'multiline':False]['text':'!                   |                        |    D    |                        |','line_number':124,'multiline':False]['text':'!                   |                        |         |                        |','line_number':125,'multiline':False]['text':'!                   |                +-------+---------+-------+                |','line_number':126,'multiline':False]['text':'!                   |                |                         |                |','line_number':127,'multiline':False]['text':'!                   |                |                         |                |','line_number':128,'multiline':False]['text':'!                   |                |                         |                |','line_number':129,'multiline':False]['text':'!                   |                |                         |                |','line_number':130,'multiline':False]['text':'!                   |                |                         |                |','line_number':131,'multiline':False]['text':'!                   |          +---------+                 +---------+          |','line_number':132,'multiline':False]['text':'!                   |          |         |                 |         |          |','line_number':133,'multiline':False]['text':'!                   |          |    B    |                 |    F    |          |','line_number':134,'multiline':False]['text':'!                   |          |         |                 |         |          |','line_number':135,'multiline':False]['text':'!                   |       +--+---------+--+           +--+---------+--+       |','line_number':136,'multiline':False]['text':'!                   |       |               |           |               |       |','line_number':137,'multiline':False]['text':'!                   |       |               |           |               |       |','line_number':138,'multiline':False]['text':'!                   |       |               |           |               |       |','line_number':139,'multiline':False]['text':'!                   |   +---+-----+   +-----+---+   +---+-----+   +-----+---+   |','line_number':140,'multiline':False]['text':'!                   +-->|         |   |         |   |         |   |         |<--+','line_number':141,'multiline':False]['text':'!                       |    A    |   |    C    |   |    E    |   |    G    |','line_number':142,'multiline':False]['text':'!                       |         |   |         |   |         |   |         |','line_number':143,'multiline':False]['text':'!                       +---------+   +---------+   +---------+   +---------+','line_number':144,'multiline':False]['text':'!','line_number':145,'multiline':False]['text':'! bstree_algorithms is configured with a NodeTraits class, which encapsulates the','line_number':146,'multiline':False]['text':'! information about the node to be manipulated. NodeTraits must support the','line_number':147,'multiline':False]['text':'! following interface:','line_number':148,'multiline':False]['text':'!','line_number':149,'multiline':False]['text':'! <b>Typedefs</b>:','line_number':150,'multiline':False]['text':'!','line_number':151,'multiline':False]['text':'! <tt>node</tt>: The type of the node that forms the binary search tree','line_number':152,'multiline':False]['text':'!','line_number':153,'multiline':False]['text':'! <tt>node_ptr</tt>: A pointer to a node','line_number':154,'multiline':False]['text':'!','line_number':155,'multiline':False]['text':'! <tt>const_node_ptr</tt>: A pointer to a const node','line_number':156,'multiline':False]['text':'!','line_number':157,'multiline':False]['text':'! <b>Static functions</b>:','line_number':158,'multiline':False]['text':'!','line_number':159,'multiline':False]['text':'! <tt>static node_ptr get_parent(const_node_ptr n);</tt>','line_number':160,'multiline':False]['text':'!','line_number':161,'multiline':False]['text':'! <tt>static void set_parent(node_ptr n, node_ptr parent);</tt>','line_number':162,'multiline':False]['text':'!','line_number':163,'multiline':False]['text':'! <tt>static node_ptr get_left(const_node_ptr n);</tt>','line_number':164,'multiline':False]['text':'!','line_number':165,'multiline':False]['text':'! <tt>static void set_left(node_ptr n, node_ptr left);</tt>','line_number':166,'multiline':False]['text':'!','line_number':167,'multiline':False]['text':'! <tt>static node_ptr get_right(const_node_ptr n);</tt>','line_number':168,'multiline':False]['text':'!','line_number':169,'multiline':False]['text':'! <tt>static void set_right(node_ptr n, node_ptr right);</tt>','line_number':170,'multiline':False]['text':'/ @cond','line_number':182,'multiline':False]['text':'/ @endcond','line_number':206,'multiline':False]['text':'! <b>Requires</b>: 'header' is the header node of a tree.','line_number':209,'multiline':False]['text':'!','line_number':210,'multiline':False]['text':'! <b>Effects</b>: Returns the first node of the tree, the header if the tree is empty.','line_number':211,'multiline':False]['text':'!','line_number':212,'multiline':False]['text':'! <b>Complexity</b>: Constant time.','line_number':213,'multiline':False]['text':'!','line_number':214,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':215,'multiline':False]['text':'! <b>Requires</b>: 'header' is the header node of a tree.','line_number':219,'multiline':False]['text':'!','line_number':220,'multiline':False]['text':'! <b>Effects</b>: Returns the header of the tree.','line_number':221,'multiline':False]['text':'!','line_number':222,'multiline':False]['text':'! <b>Complexity</b>: Constant time.','line_number':223,'multiline':False]['text':'!','line_number':224,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':225,'multiline':False]['text':'! <b>Requires</b>: 'header' is the header node of a tree.','line_number':229,'multiline':False]['text':'!','line_number':230,'multiline':False]['text':'! <b>Effects</b>: Returns the root of the tree if any, header otherwise','line_number':231,'multiline':False]['text':'!','line_number':232,'multiline':False]['text':'! <b>Complexity</b>: Constant time.','line_number':233,'multiline':False]['text':'!','line_number':234,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':235,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node of the tree or a node initialized','line_number':242,'multiline':False]['text':'!   by init(...) or init_node.','line_number':243,'multiline':False]['text':'!','line_number':244,'multiline':False]['text':'! <b>Effects</b>: Returns true if the node is initialized by init() or init_node().','line_number':245,'multiline':False]['text':'!','line_number':246,'multiline':False]['text':'! <b>Complexity</b>: Constant time.','line_number':247,'multiline':False]['text':'!','line_number':248,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':249,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node of the tree or a header node.','line_number':254,'multiline':False]['text':'!','line_number':255,'multiline':False]['text':'! <b>Effects</b>: Returns the header of the tree.','line_number':256,'multiline':False]['text':'!','line_number':257,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':258,'multiline':False]['text':'!','line_number':259,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':260,'multiline':False]['text':'! <b>Requires</b>: node1 and node2 can't be header nodes','line_number':264,'multiline':False]['text':'!  of two trees.','line_number':265,'multiline':False]['text':'!','line_number':266,'multiline':False]['text':'! <b>Effects</b>: Swaps two nodes. After the function node1 will be inserted','line_number':267,'multiline':False]['text':'!   in the position node2 before the function. node2 will be inserted in the','line_number':268,'multiline':False]['text':'!   position node1 had before the function.','line_number':269,'multiline':False]['text':'!','line_number':270,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':271,'multiline':False]['text':'!','line_number':272,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':273,'multiline':False]['text':'!','line_number':274,'multiline':False]['text':'! <b>Note</b>: This function will break container ordering invariants if','line_number':275,'multiline':False]['text':'!   node1 and node2 are not equivalent according to the ordering rules.','line_number':276,'multiline':False]['text':'!','line_number':277,'multiline':False]['text':'!Experimental function','line_number':278,'multiline':False]['text':'! <b>Requires</b>: node1 and node2 can't be header nodes','line_number':288,'multiline':False]['text':'!  of two trees with header header1 and header2.','line_number':289,'multiline':False]['text':'!','line_number':290,'multiline':False]['text':'! <b>Effects</b>: Swaps two nodes. After the function node1 will be inserted','line_number':291,'multiline':False]['text':'!   in the position node2 before the function. node2 will be inserted in the','line_number':292,'multiline':False]['text':'!   position node1 had before the function.','line_number':293,'multiline':False]['text':'!','line_number':294,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':295,'multiline':False]['text':'!','line_number':296,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':297,'multiline':False]['text':'!','line_number':298,'multiline':False]['text':'! <b>Note</b>: This function will break container ordering invariants if','line_number':299,'multiline':False]['text':'!   node1 and node2 are not equivalent according to the ordering rules.','line_number':300,'multiline':False]['text':'!','line_number':301,'multiline':False]['text':'!Experimental function','line_number':302,'multiline':False]['text':'node1 and node2 must not be header nodes','line_number':308,'multiline':False]['text':'BOOST_INTRUSIVE_INVARIANT_ASSERT((header1 != node1 && header2 != node2));','line_number':309,'multiline':False]['text':'Update header1 if necessary','line_number':311,'multiline':False]['text':'Update header2 if necessary','line_number':324,'multiline':False]['text':'If both nodes are from the same tree','line_number':338,'multiline':False]['text':'Update header if necessary','line_number':339,'multiline':False]['text':'Adjust data in nodes to be swapped','line_number':361,'multiline':False]['text':'so that final link swap works as expected','line_number':362,'multiline':False]['text':'Now swap all the links','line_number':385,'multiline':False]['text':'swap left link','line_number':387,'multiline':False]['text':'swap right link','line_number':391,'multiline':False]['text':'swap parent link','line_number':395,'multiline':False]['text':'Now adjust child nodes for newly inserted node 1','line_number':400,'multiline':False]['text':'Now adjust child nodes for newly inserted node 2','line_number':407,'multiline':False]['text':'Finally adjust parent nodes','line_number':415,'multiline':False]['text':' special logic for the case where the nodes are siblings','line_number':417,'multiline':False]['text':'The header has been already updated so avoid it','line_number':423,'multiline':False]['text':'The header has been already updated so avoid it','line_number':433,'multiline':False]['text':'! <b>Requires</b>: node_to_be_replaced must be inserted in a tree','line_number':445,'multiline':False]['text':'!   and new_node must not be inserted in a tree.','line_number':446,'multiline':False]['text':'!','line_number':447,'multiline':False]['text':'! <b>Effects</b>: Replaces node_to_be_replaced in its position in the','line_number':448,'multiline':False]['text':'!   tree with new_node. The tree does not need to be rebalanced','line_number':449,'multiline':False]['text':'!','line_number':450,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':451,'multiline':False]['text':'!','line_number':452,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':453,'multiline':False]['text':'!','line_number':454,'multiline':False]['text':'! <b>Note</b>: This function will break container ordering invariants if','line_number':455,'multiline':False]['text':'!   new_node is not equivalent to node_to_be_replaced according to the','line_number':456,'multiline':False]['text':'!   ordering rules. This function is faster than erasing and inserting','line_number':457,'multiline':False]['text':'!   the node, since no rebalancing and comparison is needed. Experimental function','line_number':458,'multiline':False]['text':'! <b>Requires</b>: node_to_be_replaced must be inserted in a tree','line_number':464,'multiline':False]['text':'!   with header "header" and new_node must not be inserted in a tree.','line_number':465,'multiline':False]['text':'!','line_number':466,'multiline':False]['text':'! <b>Effects</b>: Replaces node_to_be_replaced in its position in the','line_number':467,'multiline':False]['text':'!   tree with new_node. The tree does not need to be rebalanced','line_number':468,'multiline':False]['text':'!','line_number':469,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':470,'multiline':False]['text':'!','line_number':471,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':472,'multiline':False]['text':'!','line_number':473,'multiline':False]['text':'! <b>Note</b>: This function will break container ordering invariants if','line_number':474,'multiline':False]['text':'!   new_node is not equivalent to node_to_be_replaced according to the','line_number':475,'multiline':False]['text':'!   ordering rules. This function is faster than erasing and inserting','line_number':476,'multiline':False]['text':'!   the node, since no rebalancing or comparison is needed. Experimental function','line_number':477,'multiline':False]['text':'Update header if necessary','line_number':482,'multiline':False]['text':'Now set data from the original node','line_number':495,'multiline':False]['text':'Now adjust adjacent nodes for newly inserted node','line_number':501,'multiline':False]['text':'The header has been already updated so avoid it','line_number':509,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node from the tree except the header.','line_number':521,'multiline':False]['text':'!','line_number':522,'multiline':False]['text':'! <b>Effects</b>: Returns the next node of the tree.','line_number':523,'multiline':False]['text':'!','line_number':524,'multiline':False]['text':'! <b>Complexity</b>: Average constant time.','line_number':525,'multiline':False]['text':'!','line_number':526,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':527,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node from the tree except the leftmost node.','line_number':530,'multiline':False]['text':'!','line_number':531,'multiline':False]['text':'! <b>Effects</b>: Returns the previous node of the tree.','line_number':532,'multiline':False]['text':'!','line_number':533,'multiline':False]['text':'! <b>Complexity</b>: Average constant time.','line_number':534,'multiline':False]['text':'!','line_number':535,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':536,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node of a tree but not the header.','line_number':539,'multiline':False]['text':'!','line_number':540,'multiline':False]['text':'! <b>Effects</b>: Returns the minimum node of the subtree starting at p.','line_number':541,'multiline':False]['text':'!','line_number':542,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic to the size of the subtree.','line_number':543,'multiline':False]['text':'!','line_number':544,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':545,'multiline':False]['text':'! <b>Requires</b>: 'node' is a node of a tree but not the header.','line_number':548,'multiline':False]['text':'!','line_number':549,'multiline':False]['text':'! <b>Effects</b>: Returns the maximum node of the subtree starting at p.','line_number':550,'multiline':False]['text':'!','line_number':551,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic to the size of the subtree.','line_number':552,'multiline':False]['text':'!','line_number':553,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':554,'multiline':False]['text':'! <b>Requires</b>: 'node' must not be part of any tree.','line_number':558,'multiline':False]['text':'!','line_number':559,'multiline':False]['text':'! <b>Effects</b>: After the function unique(node) == true.','line_number':560,'multiline':False]['text':'!','line_number':561,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':562,'multiline':False]['text':'!','line_number':563,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':564,'multiline':False]['text':'!','line_number':565,'multiline':False]['text':'! <b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree.','line_number':566,'multiline':False]['text':'! <b>Effects</b>: Returns true if node is in the same state as if called init(node)','line_number':574,'multiline':False]['text':'!','line_number':575,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':576,'multiline':False]['text':'!','line_number':577,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':578,'multiline':False]['text':'! <b>Requires</b>: node must not be part of any tree.','line_number':586,'multiline':False]['text':'!','line_number':587,'multiline':False]['text':'! <b>Effects</b>: Initializes the header to represent an empty tree.','line_number':588,'multiline':False]['text':'!   unique(header) == true.','line_number':589,'multiline':False]['text':'!','line_number':590,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':591,'multiline':False]['text':'!','line_number':592,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':593,'multiline':False]['text':'!','line_number':594,'multiline':False]['text':'! <b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree.','line_number':595,'multiline':False]['text':'! <b>Requires</b>: "disposer" must be an object function','line_number':603,'multiline':False]['text':'!   taking a node_ptr parameter and shouldn't throw.','line_number':604,'multiline':False]['text':'!','line_number':605,'multiline':False]['text':'! <b>Effects</b>: Empties the target tree calling','line_number':606,'multiline':False]['text':'!   <tt>void disposer::operator()(node_ptr)</tt> for every node of the tree','line_number':607,'multiline':False]['text':'!    except the header.','line_number':608,'multiline':False]['text':'!','line_number':609,'multiline':False]['text':'! <b>Complexity</b>: Linear to the number of element of the source tree plus the.','line_number':610,'multiline':False]['text':'!   number of elements of tree target tree when calling this function.','line_number':611,'multiline':False]['text':'!','line_number':612,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':613,'multiline':False]['text':'! <b>Requires</b>: header is the header of a tree.','line_number':624,'multiline':False]['text':'!','line_number':625,'multiline':False]['text':'! <b>Effects</b>: Unlinks the leftmost node from the tree, and','line_number':626,'multiline':False]['text':'!   updates the header link to the new leftmost node.','line_number':627,'multiline':False]['text':'!','line_number':628,'multiline':False]['text':'! <b>Complexity</b>: Average complexity is constant time.','line_number':629,'multiline':False]['text':'!','line_number':630,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':631,'multiline':False]['text':'!','line_number':632,'multiline':False]['text':'! <b>Notes</b>: This function breaks the tree and the tree can','line_number':633,'multiline':False]['text':'!   only be used for more unlink_leftmost_without_rebalance calls.','line_number':634,'multiline':False]['text':'!   This function is normally used to achieve a step by step','line_number':635,'multiline':False]['text':'!   controlled destruction of the tree.','line_number':636,'multiline':False]['text':'! <b>Requires</b>: node is a node of the tree but it's not the header.','line_number':667,'multiline':False]['text':'!','line_number':668,'multiline':False]['text':'! <b>Effects</b>: Returns the number of nodes of the subtree.','line_number':669,'multiline':False]['text':'!','line_number':670,'multiline':False]['text':'! <b>Complexity</b>: Linear time.','line_number':671,'multiline':False]['text':'!','line_number':672,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':673,'multiline':False]['text':'! <b>Requires</b>: header1 and header2 must be the header nodes','line_number':683,'multiline':False]['text':'!  of two trees.','line_number':684,'multiline':False]['text':'!','line_number':685,'multiline':False]['text':'! <b>Effects</b>: Swaps two trees. After the function header1 will contain','line_number':686,'multiline':False]['text':'!   links to the second tree and header2 will have links to the first tree.','line_number':687,'multiline':False]['text':'!','line_number':688,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':689,'multiline':False]['text':'!','line_number':690,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':691,'multiline':False]['text':'Parent swap','line_number':699,'multiline':False]['text':'Left swap','line_number':703,'multiline':False]['text':'Right swap','line_number':707,'multiline':False]['text':'Now test parent','line_number':712,'multiline':False]['text':'! <b>Requires</b>: p is a node of a tree.','line_number':733,'multiline':False]['text':'!','line_number':734,'multiline':False]['text':'! <b>Effects</b>: Returns true if p is the header of the tree.','line_number':735,'multiline':False]['text':'!','line_number':736,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':737,'multiline':False]['text':'!','line_number':738,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':739,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':743,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':744,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':745,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':746,'multiline':False]['text':'!','line_number':747,'multiline':False]['text':'! <b>Effects</b>: Returns a node_ptr to the first element that is equivalent to','line_number':748,'multiline':False]['text':'!   "key" according to "comp" or "header" if that element does not exist.','line_number':749,'multiline':False]['text':'!','line_number':750,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':751,'multiline':False]['text':'!','line_number':752,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':753,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':763,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':764,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':765,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':766,'multiline':False]['text':'!   'lower_key' must not be greater than 'upper_key' according to 'comp'. If','line_number':767,'multiline':False]['text':'!   'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.','line_number':768,'multiline':False]['text':'!','line_number':769,'multiline':False]['text':'! <b>Effects</b>: Returns an a pair with the following criteria:','line_number':770,'multiline':False]['text':'!','line_number':771,'multiline':False]['text':'!   first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise','line_number':772,'multiline':False]['text':'!','line_number':773,'multiline':False]['text':'!   second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise','line_number':774,'multiline':False]['text':'!','line_number':775,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':776,'multiline':False]['text':'!','line_number':777,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':778,'multiline':False]['text':'!','line_number':779,'multiline':False]['text':'! <b>Note</b>: This function can be more efficient than calling upper_bound','line_number':780,'multiline':False]['text':'!   and lower_bound for lower_key and upper_key.','line_number':781,'multiline':False]['text':'!','line_number':782,'multiline':False]['text':'! <b>Note</b>: Experimental function, the interface might change.','line_number':783,'multiline':False]['text':'If x is less than lower_key the target','line_number':797,'multiline':False]['text':'range is on the right part','line_number':798,'multiline':False]['text':'Check for invalid input range','line_number':800,'multiline':False]['text':'If the upper_key is less than x, the target','line_number':804,'multiline':False]['text':'range is on the left part','line_number':805,'multiline':False]['text':'x is inside the bounded range(lower_key <= x <= upper_key),','line_number':811,'multiline':False]['text':'so we must split lower and upper searches','line_number':812,'multiline':False]['text':'','line_number':813,'multiline':False]['text':'Sanity check: if lower_key and upper_key are equal, then both left_closed and right_closed can't be false','line_number':814,'multiline':False]['text':'If left_closed, then comp(x, lower_key) is already the lower_bound','line_number':818,'multiline':False]['text':'condition so we save one comparison and go to the next level','line_number':819,'multiline':False]['text':'following traditional lower_bound algo','line_number':820,'multiline':False]['text':'If left-open, comp(x, lower_key) is not the upper_bound algo','line_number':822,'multiline':False]['text':'condition so we must recheck current 'x' node with upper_bound algo','line_number':823,'multiline':False]['text':'If right_closed, then comp(upper_key, x) is already the upper_bound','line_number':827,'multiline':False]['text':'condition so we can save one comparison and go to the next level','line_number':828,'multiline':False]['text':'following lower_bound algo','line_number':829,'multiline':False]['text':'If right-open, comp(upper_key, x) is not the lower_bound algo','line_number':831,'multiline':False]['text':'condition so we must recheck current 'x' node with lower_bound algo','line_number':832,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':840,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':841,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':842,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':843,'multiline':False]['text':'!','line_number':844,'multiline':False]['text':'! <b>Effects</b>: Returns the number of elements with a key equivalent to "key"','line_number':845,'multiline':False]['text':'!   according to "comp".','line_number':846,'multiline':False]['text':'!','line_number':847,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':848,'multiline':False]['text':'!','line_number':849,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':850,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':864,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':865,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':866,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':867,'multiline':False]['text':'!','line_number':868,'multiline':False]['text':'! <b>Effects</b>: Returns an a pair of node_ptr delimiting a range containing','line_number':869,'multiline':False]['text':'!   all elements that are equivalent to "key" according to "comp" or an','line_number':870,'multiline':False]['text':'!   empty range that indicates the position where those elements would be','line_number':871,'multiline':False]['text':'!   if there are no equivalent elements.','line_number':872,'multiline':False]['text':'!','line_number':873,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':874,'multiline':False]['text':'!','line_number':875,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':876,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':884,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':885,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':886,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':887,'multiline':False]['text':'!','line_number':888,'multiline':False]['text':'! <b>Effects</b>: Returns an a pair of node_ptr delimiting a range containing','line_number':889,'multiline':False]['text':'!   the first element that is equivalent to "key" according to "comp" or an','line_number':890,'multiline':False]['text':'!   empty range that indicates the position where that element would be','line_number':891,'multiline':False]['text':'!   if there are no equivalent elements.','line_number':892,'multiline':False]['text':'!','line_number':893,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':894,'multiline':False]['text':'!','line_number':895,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':896,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':909,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':910,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':911,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':912,'multiline':False]['text':'!','line_number':913,'multiline':False]['text':'! <b>Effects</b>: Returns a node_ptr to the first element that is','line_number':914,'multiline':False]['text':'!   not less than "key" according to "comp" or "header" if that element does','line_number':915,'multiline':False]['text':'!   not exist.','line_number':916,'multiline':False]['text':'!','line_number':917,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':918,'multiline':False]['text':'!','line_number':919,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':920,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':928,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':929,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':930,'multiline':False]['text':'!   the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.','line_number':931,'multiline':False]['text':'!','line_number':932,'multiline':False]['text':'! <b>Effects</b>: Returns a node_ptr to the first element that is greater','line_number':933,'multiline':False]['text':'!   than "key" according to "comp" or "header" if that element does not exist.','line_number':934,'multiline':False]['text':'!','line_number':935,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':936,'multiline':False]['text':'!','line_number':937,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':938,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':946,'multiline':False]['text':'!   "commit_data" must have been obtained from a previous call to','line_number':947,'multiline':False]['text':'!   "insert_unique_check". No objects should have been inserted or erased','line_number':948,'multiline':False]['text':'!   from the set between the "insert_unique_check" that filled "commit_data"','line_number':949,'multiline':False]['text':'!   and the call to "insert_commit".','line_number':950,'multiline':False]['text':'!','line_number':951,'multiline':False]['text':'!','line_number':952,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node in the set using the information obtained','line_number':953,'multiline':False]['text':'!   from the "commit_data" that a previous "insert_check" filled.','line_number':954,'multiline':False]['text':'!','line_number':955,'multiline':False]['text':'! <b>Complexity</b>: Constant time.','line_number':956,'multiline':False]['text':'!','line_number':957,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':958,'multiline':False]['text':'!','line_number':959,'multiline':False]['text':'! <b>Notes</b>: This function has only sense if a "insert_unique_check" has been','line_number':960,'multiline':False]['text':'!   previously executed to fill "commit_data". No value should be inserted or','line_number':961,'multiline':False]['text':'!   erased between the "insert_check" and "insert_commit" calls.','line_number':962,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':967,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':968,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':969,'multiline':False]['text':'!   the tree. NodePtrCompare compares KeyType with a node_ptr.','line_number':970,'multiline':False]['text':'!','line_number':971,'multiline':False]['text':'! <b>Effects</b>: Checks if there is an equivalent node to "key" in the','line_number':972,'multiline':False]['text':'!   tree according to "comp" and obtains the needed information to realize','line_number':973,'multiline':False]['text':'!   a constant-time node insertion if there is no equivalent node.','line_number':974,'multiline':False]['text':'!','line_number':975,'multiline':False]['text':'! <b>Returns</b>: If there is an equivalent value','line_number':976,'multiline':False]['text':'!   returns a pair containing a node_ptr to the already present node','line_number':977,'multiline':False]['text':'!   and false. If there is not equivalent key can be inserted returns true','line_number':978,'multiline':False]['text':'!   in the returned pair's boolean and fills "commit_data" that is meant to','line_number':979,'multiline':False]['text':'!   be used with the "insert_commit" function to achieve a constant-time','line_number':980,'multiline':False]['text':'!   insertion function.','line_number':981,'multiline':False]['text':'!','line_number':982,'multiline':False]['text':'! <b>Complexity</b>: Average complexity is at most logarithmic.','line_number':983,'multiline':False]['text':'!','line_number':984,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':985,'multiline':False]['text':'!','line_number':986,'multiline':False]['text':'! <b>Notes</b>: This function is used to improve performance when constructing','line_number':987,'multiline':False]['text':'!   a node is expensive and the user does not want to have two equivalent nodes','line_number':988,'multiline':False]['text':'!   in the tree: if there is an equivalent value','line_number':989,'multiline':False]['text':'!   the constructed object must be discarded. Many times, the part of the','line_number':990,'multiline':False]['text':'!   node that is used to impose the order is much cheaper to construct','line_number':991,'multiline':False]['text':'!   than the node and this function offers the possibility to use that part','line_number':992,'multiline':False]['text':'!   to check if the insertion will be successful.','line_number':993,'multiline':False]['text':'!','line_number':994,'multiline':False]['text':'!   If the check is successful, the user can construct the node and use','line_number':995,'multiline':False]['text':'!   "insert_commit" to insert the node in constant-time. This gives a total','line_number':996,'multiline':False]['text':'!   logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).','line_number':997,'multiline':False]['text':'!','line_number':998,'multiline':False]['text':'!   "commit_data" remains valid for a subsequent "insert_unique_commit" only','line_number':999,'multiline':False]['text':'!   if no more objects are inserted or erased from the set.','line_number':1000,'multiline':False]['text':'Find the upper bound, cache the previous value and if we should','line_number':1016,'multiline':False]['text':'store it in the left or right node','line_number':1017,'multiline':False]['text':'Since we've found the upper bound there is no other value with the same key if:','line_number':1029,'multiline':False]['text':'    - There is no previous node','line_number':1030,'multiline':False]['text':'    - The previous node is less than the key','line_number':1031,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':1040,'multiline':False]['text':'!   KeyNodePtrCompare is a function object that induces a strict weak','line_number':1041,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':1042,'multiline':False]['text':'!   the tree. NodePtrCompare compares KeyType with a node_ptr.','line_number':1043,'multiline':False]['text':'!   "hint" is node from the "header"'s tree.','line_number':1044,'multiline':False]['text':'!','line_number':1045,'multiline':False]['text':'! <b>Effects</b>: Checks if there is an equivalent node to "key" in the','line_number':1046,'multiline':False]['text':'!   tree according to "comp" using "hint" as a hint to where it should be','line_number':1047,'multiline':False]['text':'!   inserted and obtains the needed information to realize','line_number':1048,'multiline':False]['text':'!   a constant-time node insertion if there is no equivalent node.','line_number':1049,'multiline':False]['text':'!   If "hint" is the upper_bound the function has constant time','line_number':1050,'multiline':False]['text':'!   complexity (two comparisons in the worst case).','line_number':1051,'multiline':False]['text':'!','line_number':1052,'multiline':False]['text':'! <b>Returns</b>: If there is an equivalent value','line_number':1053,'multiline':False]['text':'!   returns a pair containing a node_ptr to the already present node','line_number':1054,'multiline':False]['text':'!   and false. If there is not equivalent key can be inserted returns true','line_number':1055,'multiline':False]['text':'!   in the returned pair's boolean and fills "commit_data" that is meant to','line_number':1056,'multiline':False]['text':'!   be used with the "insert_commit" function to achieve a constant-time','line_number':1057,'multiline':False]['text':'!   insertion function.','line_number':1058,'multiline':False]['text':'!','line_number':1059,'multiline':False]['text':'! <b>Complexity</b>: Average complexity is at most logarithmic, but it is','line_number':1060,'multiline':False]['text':'!   amortized constant time if new_node should be inserted immediately before "hint".','line_number':1061,'multiline':False]['text':'!','line_number':1062,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':1063,'multiline':False]['text':'!','line_number':1064,'multiline':False]['text':'! <b>Notes</b>: This function is used to improve performance when constructing','line_number':1065,'multiline':False]['text':'!   a node is expensive and the user does not want to have two equivalent nodes','line_number':1066,'multiline':False]['text':'!   in the tree: if there is an equivalent value','line_number':1067,'multiline':False]['text':'!   the constructed object must be discarded. Many times, the part of the','line_number':1068,'multiline':False]['text':'!   node that is used to impose the order is much cheaper to construct','line_number':1069,'multiline':False]['text':'!   than the node and this function offers the possibility to use that part','line_number':1070,'multiline':False]['text':'!   to check if the insertion will be successful.','line_number':1071,'multiline':False]['text':'!','line_number':1072,'multiline':False]['text':'!   If the check is successful, the user can construct the node and use','line_number':1073,'multiline':False]['text':'!   "insert_commit" to insert the node in constant-time. This gives a total','line_number':1074,'multiline':False]['text':'!   logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).','line_number':1075,'multiline':False]['text':'!','line_number':1076,'multiline':False]['text':'!   "commit_data" remains valid for a subsequent "insert_unique_commit" only','line_number':1077,'multiline':False]['text':'!   if no more objects are inserted or erased from the set.','line_number':1078,'multiline':False]['text':'hint must be bigger than the key','line_number':1088,'multiline':False]['text':'Previous value should be less than the key','line_number':1091,'multiline':False]['text':'Hint was wrong, use hintless insertion','line_number':1101,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':1105,'multiline':False]['text':'!   NodePtrCompare is a function object that induces a strict weak','line_number':1106,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':1107,'multiline':False]['text':'!   the tree. NodePtrCompare compares two node_ptrs. "hint" is node from','line_number':1108,'multiline':False]['text':'!   the "header"'s tree.','line_number':1109,'multiline':False]['text':'!','line_number':1110,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree, using "hint" as a hint to','line_number':1111,'multiline':False]['text':'!   where it will be inserted. If "hint" is the upper_bound','line_number':1112,'multiline':False]['text':'!   the insertion takes constant time (two comparisons in the worst case).','line_number':1113,'multiline':False]['text':'!','line_number':1114,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic in general, but it is amortized','line_number':1115,'multiline':False]['text':'!   constant time if new_node is inserted immediately before "hint".','line_number':1116,'multiline':False]['text':'!','line_number':1117,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':1118,'multiline':False]['text':'! <b>Requires</b>: "h" must be the header node of a tree.','line_number':1133,'multiline':False]['text':'!   NodePtrCompare is a function object that induces a strict weak','line_number':1134,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':1135,'multiline':False]['text':'!   the tree. NodePtrCompare compares two node_ptrs.','line_number':1136,'multiline':False]['text':'!','line_number':1137,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree before the upper bound','line_number':1138,'multiline':False]['text':'!   according to "comp".','line_number':1139,'multiline':False]['text':'!','line_number':1140,'multiline':False]['text':'! <b>Complexity</b>: Average complexity for insert element is at','line_number':1141,'multiline':False]['text':'!   most logarithmic.','line_number':1142,'multiline':False]['text':'!','line_number':1143,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':1144,'multiline':False]['text':'! <b>Requires</b>: "h" must be the header node of a tree.','line_number':1159,'multiline':False]['text':'!   NodePtrCompare is a function object that induces a strict weak','line_number':1160,'multiline':False]['text':'!   ordering compatible with the strict weak ordering used to create the','line_number':1161,'multiline':False]['text':'!   the tree. NodePtrCompare compares two node_ptrs.','line_number':1162,'multiline':False]['text':'!','line_number':1163,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree before the lower bound','line_number':1164,'multiline':False]['text':'!   according to "comp".','line_number':1165,'multiline':False]['text':'!','line_number':1166,'multiline':False]['text':'! <b>Complexity</b>: Average complexity for insert element is at','line_number':1167,'multiline':False]['text':'!   most logarithmic.','line_number':1168,'multiline':False]['text':'!','line_number':1169,'multiline':False]['text':'! <b>Throws</b>: If "comp" throws.','line_number':1170,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':1185,'multiline':False]['text':'!   "pos" must be a valid iterator or header (end) node.','line_number':1186,'multiline':False]['text':'!   "pos" must be an iterator pointing to the successor to "new_node"','line_number':1187,'multiline':False]['text':'!   once inserted according to the order of already inserted nodes. This function does not','line_number':1188,'multiline':False]['text':'!   check "pos" and this precondition must be guaranteed by the caller.','line_number':1189,'multiline':False]['text':'!','line_number':1190,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree before "pos".','line_number':1191,'multiline':False]['text':'!','line_number':1192,'multiline':False]['text':'! <b>Complexity</b>: Constant-time.','line_number':1193,'multiline':False]['text':'!','line_number':1194,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1195,'multiline':False]['text':'!','line_number':1196,'multiline':False]['text':'! <b>Note</b>: If "pos" is not the successor of the newly inserted "new_node"','line_number':1197,'multiline':False]['text':'! tree invariants might be broken.','line_number':1198,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':1212,'multiline':False]['text':'!   "new_node" must be, according to the used ordering no less than the','line_number':1213,'multiline':False]['text':'!   greatest inserted key.','line_number':1214,'multiline':False]['text':'!','line_number':1215,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree before "pos".','line_number':1216,'multiline':False]['text':'!','line_number':1217,'multiline':False]['text':'! <b>Complexity</b>: Constant-time.','line_number':1218,'multiline':False]['text':'!','line_number':1219,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1220,'multiline':False]['text':'!','line_number':1221,'multiline':False]['text':'! <b>Note</b>: If "new_node" is less than the greatest inserted key','line_number':1222,'multiline':False]['text':'! tree invariants are broken. This function is slightly faster than','line_number':1223,'multiline':False]['text':'! using "insert_before".','line_number':1224,'multiline':False]['text':'! <b>Requires</b>: "header" must be the header node of a tree.','line_number':1237,'multiline':False]['text':'!   "new_node" must be, according to the used ordering, no greater than the','line_number':1238,'multiline':False]['text':'!   lowest inserted key.','line_number':1239,'multiline':False]['text':'!','line_number':1240,'multiline':False]['text':'! <b>Effects</b>: Inserts new_node into the tree before "pos".','line_number':1241,'multiline':False]['text':'!','line_number':1242,'multiline':False]['text':'! <b>Complexity</b>: Constant-time.','line_number':1243,'multiline':False]['text':'!','line_number':1244,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1245,'multiline':False]['text':'!','line_number':1246,'multiline':False]['text':'! <b>Note</b>: If "new_node" is greater than the lowest inserted key','line_number':1247,'multiline':False]['text':'! tree invariants are broken. This function is slightly faster than','line_number':1248,'multiline':False]['text':'! using "insert_before".','line_number':1249,'multiline':False]['text':'! <b>Requires</b>: 'node' can't be a header node.','line_number':1262,'multiline':False]['text':'!','line_number':1263,'multiline':False]['text':'! <b>Effects</b>: Calculates the depth of a node: the depth of a','line_number':1264,'multiline':False]['text':'! node is the length (number of edges) of the path from the root','line_number':1265,'multiline':False]['text':'! to that node. (The root node is at depth 0.)','line_number':1266,'multiline':False]['text':'!','line_number':1267,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic to the number of nodes in the tree.','line_number':1268,'multiline':False]['text':'!','line_number':1269,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1270,'multiline':False]['text':'! <b>Requires</b>: "cloner" must be a function','line_number':1282,'multiline':False]['text':'!   object taking a node_ptr and returning a new cloned node of it. "disposer" must','line_number':1283,'multiline':False]['text':'!   take a node_ptr and shouldn't throw.','line_number':1284,'multiline':False]['text':'!','line_number':1285,'multiline':False]['text':'! <b>Effects</b>: First empties target tree calling','line_number':1286,'multiline':False]['text':'!   <tt>void disposer::operator()(node_ptr)</tt> for every node of the tree','line_number':1287,'multiline':False]['text':'!    except the header.','line_number':1288,'multiline':False]['text':'!','line_number':1289,'multiline':False]['text':'!   Then, duplicates the entire tree pointed by "source_header" cloning each','line_number':1290,'multiline':False]['text':'!   source node with <tt>node_ptr Cloner::operator()(node_ptr)</tt> to obtain','line_number':1291,'multiline':False]['text':'!   the nodes of the target tree. If "cloner" throws, the cloned target nodes','line_number':1292,'multiline':False]['text':'!   are disposed using <tt>void disposer(node_ptr )</tt>.','line_number':1293,'multiline':False]['text':'!','line_number':1294,'multiline':False]['text':'! <b>Complexity</b>: Linear to the number of element of the source tree plus the','line_number':1295,'multiline':False]['text':'!   number of elements of tree target tree when calling this function.','line_number':1296,'multiline':False]['text':'!','line_number':1297,'multiline':False]['text':'! <b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed.','line_number':1298,'multiline':False]['text':'Now update header node','line_number':1311,'multiline':False]['text':'! <b>Requires</b>: header must be the header of a tree, z a node','line_number':1317,'multiline':False]['text':'!    of that tree and z != header.','line_number':1318,'multiline':False]['text':'!','line_number':1319,'multiline':False]['text':'! <b>Effects</b>: Erases node "z" from the tree with header "header".','line_number':1320,'multiline':False]['text':'!','line_number':1321,'multiline':False]['text':'! <b>Complexity</b>: Amortized constant time.','line_number':1322,'multiline':False]['text':'!','line_number':1323,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1324,'multiline':False]['text':'! <b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2','line_number':1331,'multiline':False]['text':'!   respectively, z a non-header node of tree1. NodePtrCompare is the comparison','line_number':1332,'multiline':False]['text':'!   function of tree1..','line_number':1333,'multiline':False]['text':'!','line_number':1334,'multiline':False]['text':'! <b>Effects</b>: Transfers node "z" from tree1 to tree2 if tree1 does not contain','line_number':1335,'multiline':False]['text':'!   a node that is equivalent to z.','line_number':1336,'multiline':False]['text':'!','line_number':1337,'multiline':False]['text':'! <b>Returns</b>: True if the node was trasferred, false otherwise.','line_number':1338,'multiline':False]['text':'!','line_number':1339,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':1340,'multiline':False]['text':'!','line_number':1341,'multiline':False]['text':'! <b>Throws</b>: If the comparison throws.','line_number':1342,'multiline':False]['text':'! <b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2','line_number':1351,'multiline':False]['text':'!   respectively, z a non-header node of tree1. NodePtrCompare is the comparison','line_number':1352,'multiline':False]['text':'!   function of tree1..','line_number':1353,'multiline':False]['text':'!','line_number':1354,'multiline':False]['text':'! <b>Effects</b>: Transfers node "z" from tree1 to tree2.','line_number':1355,'multiline':False]['text':'!','line_number':1356,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':1357,'multiline':False]['text':'!','line_number':1358,'multiline':False]['text':'! <b>Throws</b>: If the comparison throws.','line_number':1359,'multiline':False]['text':'! <b>Requires</b>: node is a tree node but not the header.','line_number':1368,'multiline':False]['text':'!','line_number':1369,'multiline':False]['text':'! <b>Effects</b>: Unlinks the node and rebalances the tree.','line_number':1370,'multiline':False]['text':'!','line_number':1371,'multiline':False]['text':'! <b>Complexity</b>: Average complexity is constant time.','line_number':1372,'multiline':False]['text':'!','line_number':1373,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1374,'multiline':False]['text':'! <b>Requires</b>: header must be the header of a tree.','line_number':1385,'multiline':False]['text':'!','line_number':1386,'multiline':False]['text':'! <b>Effects</b>: Rebalances the tree.','line_number':1387,'multiline':False]['text':'!','line_number':1388,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1389,'multiline':False]['text':'!','line_number':1390,'multiline':False]['text':'! <b>Complexity</b>: Linear.','line_number':1391,'multiline':False]['text':'! <b>Requires</b>: old_root is a node of a tree. It shall not be null.','line_number':1400,'multiline':False]['text':'!','line_number':1401,'multiline':False]['text':'! <b>Effects</b>: Rebalances the subtree rooted at old_root.','line_number':1402,'multiline':False]['text':'!','line_number':1403,'multiline':False]['text':'! <b>Returns</b>: The new root of the subtree.','line_number':1404,'multiline':False]['text':'!','line_number':1405,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1406,'multiline':False]['text':'!','line_number':1407,'multiline':False]['text':'! <b>Complexity</b>: Linear.','line_number':1408,'multiline':False]['text':'Taken from:','line_number':1411,'multiline':False]['text':'"Tree rebalancing in optimal time and space"','line_number':1412,'multiline':False]['text':'Quentin F. Stout and Bette L. Warren','line_number':1413,'multiline':False]['text':'To avoid irregularities in the algorithm (old_root can be a','line_number':1415,'multiline':False]['text':'left or right child or even the root of the tree) just put the','line_number':1416,'multiline':False]['text':'root as the right child of its parent. Before doing this backup','line_number':1417,'multiline':False]['text':'information to restore the original relationship after','line_number':1418,'multiline':False]['text':'the algorithm is applied.','line_number':1419,'multiline':False]['text':'Get root info','line_number':1423,'multiline':False]['text':'Recover root','line_number':1434,'multiline':False]['text':'! <b>Effects</b>: Asserts the integrity of the container with additional checks provided by the user.','line_number':1449,'multiline':False]['text':'!','line_number':1450,'multiline':False]['text':'! <b>Requires</b>: header must be the header of a tree.','line_number':1451,'multiline':False]['text':'!','line_number':1452,'multiline':False]['text':'! <b>Complexity</b>: Linear time.','line_number':1453,'multiline':False]['text':'!','line_number':1454,'multiline':False]['text':'! <b>Note</b>: The method might not have effect when asserts are turned off (e.g., with NDEBUG).','line_number':1455,'multiline':False]['text':'!   Experimental function, interface might change in future versions.','line_number':1456,'multiline':False]['text':' check left&right header pointers','line_number':1462,'multiline':False]['text':' check parent pointer of root node','line_number':1467,'multiline':False]['text':' check subtree from root','line_number':1469,'multiline':False]['text':' check left&right header pointers','line_number':1471,'multiline':False]['text':' x might be null.','line_number':1514,'multiline':False]['text':' z has exactly one non-null child. y == z.','line_number':1516,'multiline':False]['text':' x is not null.','line_number':1517,'multiline':False]['text':'make y != z','line_number':1520,'multiline':False]['text':' y = find z's successor','line_number':1521,'multiline':False]['text':' x might be null.','line_number':1523,'multiline':False]['text':'has two children and y is the minimum of z','line_number':1530,'multiline':False]['text':'y is z's successor and it has a null left child.','line_number':1531,'multiline':False]['text':'x is the right child of y (it can be null)','line_number':1532,'multiline':False]['text':'Relink y in place of z and link x with y's old parent','line_number':1533,'multiline':False]['text':'Link y with the right tree of z','line_number':1537,'multiline':False]['text':'Link x with y's old parent (y must be a left child)','line_number':1540,'multiline':False]['text':'Since y was the successor and not the right child of z, it must be a left child','line_number':1545,'multiline':False]['text':'y was the right child of y so no need to fix x's position','line_number':1548,'multiline':False]['text':' z has zero or one child, x is one child (it can be null)','line_number':1554,'multiline':False]['text':'Just link x to z's parent','line_number':1555,'multiline':False]['text':'Now update leftmost/rightmost in case z was one of them','line_number':1561,'multiline':False]['text':'z_left must be null because z is the leftmost','line_number':1563,'multiline':False]['text':' makes leftmost == header if z == root','line_number':1566,'multiline':False]['text':'z_right must be null because z is the rightmost','line_number':1570,'multiline':False]['text':' makes rightmost == header if z == root','line_number':1573,'multiline':False]['text':'If z had 0/1 child, y == z and one of its children (and maybe null)','line_number':1578,'multiline':False]['text':'If z had 2 children, y is the successor of z and x is the right child of y','line_number':1579,'multiline':False]['text':'If z had 0/1 child, x_parent is the new parent of the old right child of y (z's successor)','line_number':1582,'multiline':False]['text':'If z had 2 children, x_parent is the new parent of y (z_parent)','line_number':1583,'multiline':False]['text':'! <b>Requires</b>: node is a node of the tree but it's not the header.','line_number':1588,'multiline':False]['text':'!','line_number':1589,'multiline':False]['text':'! <b>Effects</b>: Returns the number of nodes of the subtree.','line_number':1590,'multiline':False]['text':'!','line_number':1591,'multiline':False]['text':'! <b>Complexity</b>: Linear time.','line_number':1592,'multiline':False]['text':'!','line_number':1593,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1594,'multiline':False]['text':'! <b>Requires</b>: p is a node of a tree.','line_number':1631,'multiline':False]['text':'!','line_number':1632,'multiline':False]['text':'! <b>Effects</b>: Returns true if p is a left child.','line_number':1633,'multiline':False]['text':'!','line_number':1634,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':1635,'multiline':False]['text':'!','line_number':1636,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1637,'multiline':False]['text':'! <b>Requires</b>: p is a node of a tree.','line_number':1641,'multiline':False]['text':'!','line_number':1642,'multiline':False]['text':'! <b>Effects</b>: Returns true if p is a right child.','line_number':1643,'multiline':False]['text':'!','line_number':1644,'multiline':False]['text':'! <b>Complexity</b>: Constant.','line_number':1645,'multiline':False]['text':'!','line_number':1646,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1647,'multiline':False]['text':'/ @cond','line_number':1704,'multiline':False]['text':'/ @endcond','line_number':1706,'multiline':False]['text':'Check if commit_data has not been initialized by a insert_unique_check call.','line_number':1770,'multiline':False]['text':'Fix header and own's parent data when replacing x with own, providing own's old data with parent','line_number':1793,'multiline':False]['text':' rotate p to left (no header and p's parent fixup)','line_number':1804,'multiline':False]['text':' rotate p to left (with header and p's parent fixup)','line_number':1816,'multiline':False]['text':' rotate p to right (no header and p's parent fixup)','line_number':1825,'multiline':False]['text':' rotate p to right (with header and p's parent fixup)','line_number':1837,'multiline':False]['text':'Inspired by LibAVL:','line_number':1850,'multiline':False]['text':'It uses a clever optimization for trees with parent pointers.','line_number':1851,'multiline':False]['text':'No parent pointer is updated when transforming a tree to a vine as','line_number':1852,'multiline':False]['text':'most of them will be overriten during compression rotations.','line_number':1853,'multiline':False]['text':'A final pass must be made after the rebalancing to updated those','line_number':1854,'multiline':False]['text':'pointers not updated by tree_to_vine + compression calls','line_number':1855,'multiline':False]['text':'move vine-tail down one','line_number':1860,'multiline':False]['text':'rotate','line_number':1865,'multiline':False]['text':'compress "count" spine nodes in the tree with pseudo-root scanner','line_number':1877,'multiline':False]['text':'Avoid setting the parent of child_right','line_number':1881,'multiline':False]['text':'create deepest leaves','line_number':1896,'multiline':False]['text':'Update parents of nodes still in the in the original vine line','line_number':1903,'multiline':False]['text':'as those have not been updated by subtree_to_vine or compress_subtree','line_number':1904,'multiline':False]['text':'! <b>Requires</b>: "n" must be a node inserted in a tree.','line_number':1912,'multiline':False]['text':'!','line_number':1913,'multiline':False]['text':'! <b>Effects</b>: Returns a pointer to the header node of the tree.','line_number':1914,'multiline':False]['text':'!','line_number':1915,'multiline':False]['text':'! <b>Complexity</b>: Logarithmic.','line_number':1916,'multiline':False]['text':'!','line_number':1917,'multiline':False]['text':'! <b>Throws</b>: Nothing.','line_number':1918,'multiline':False]['text':'We'll calculate leftmost and rightmost nodes while iterating','line_number':1947,'multiline':False]['text':'We'll calculate leftmost and rightmost nodes while iterating','line_number':1951,'multiline':False]['text':'First set the subroot','line_number':1955,'multiline':False]['text':'First clone left nodes','line_number':1962,'multiline':False]['text':'Clone and mark as leaf','line_number':1967,'multiline':False]['text':'Insert left','line_number':1971,'multiline':False]['text':'Update leftmost','line_number':1974,'multiline':False]['text':'Then clone right nodes','line_number':1978,'multiline':False]['text':'Clone and mark as leaf','line_number':1983,'multiline':False]['text':'Insert right','line_number':1987,'multiline':False]['text':'Update rightmost','line_number':1990,'multiline':False]['text':'If not, go up','line_number':1993,'multiline':False]['text':'Branch completed, go up searching more nodes to clone','line_number':1998,'multiline':False]['text':' Right rotation','line_number':2016,'multiline':False]['text':'/ @cond','line_number':2082,'multiline':False]['text':'/ @endcond','line_number':2096,'multiline':False]['text':'namespace intrusive','line_number':2098,'multiline':False]['text':'namespace boost','line_number':2099,'multiline':False]['text':'BOOST_INTRUSIVE_BSTREE_ALGORITHMS_HPP','line_number':2103,'multiline':False]