['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2020 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]['text':'','line_number':21,'multiline':False]['text':' Each backend need to declare 3 type lists which declare the types','line_number':22,'multiline':False]['text':' with which this can interoperate.  These lists must at least contain','line_number':23,'multiline':False]['text':' the widest type in each category - so "long long" must be the final','line_number':24,'multiline':False]['text':' type in the signed_types list for example.  Any narrower types if not','line_number':25,'multiline':False]['text':' present in the list will get promoted to the next wider type that is','line_number':26,'multiline':False]['text':' in the list whenever mixed arithmetic involving that type is encountered.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' We must have a default constructor:','line_number':76,'multiline':False]['text':' Optional constructors, we can make this type slightly more efficient','line_number':83,'multiline':False]['text':' by providing constructors from any type we can handle natively.','line_number':84,'multiline':False]['text':' These will also cause number<> to be implicitly constructible','line_number':85,'multiline':False]['text':' from these types unless we make such constructors explicit.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':'','line_number':92,'multiline':False]['text':' Pass-through 2-arg construction of components:','line_number':93,'multiline':False]['text':'','line_number':94,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' In the absense of converting constructors, operator= takes the strain.','line_number':120,'multiline':False]['text':' In addition to the usual suspects, there must be one operator= for each type','line_number':121,'multiline':False]['text':' listed in signed_types, unsigned_types, and float_types plus a string constructor.','line_number':122,'multiline':False]['text':'','line_number':123,'multiline':False]['text':' saved for later','line_number':141,'multiline':False]['text':'','line_number':226,'multiline':False]['text':' We format the string ourselves so we can match what GMP's mpq type does:','line_number':227,'multiline':False]['text':'','line_number':228,'multiline':False]['text':' both zero.','line_number':250,'multiline':False]['text':'','line_number':279,'multiline':False]['text':' Comparison with arithmetic types, default just constructs a temporary:','line_number':280,'multiline':False]['text':'','line_number':281,'multiline':False]['text':'  Note: construct directly from i if supported.','line_number':286,'multiline':False]['text':' Saving','line_number':299,'multiline':False]['text':' Loading','line_number':307,'multiline':False]['text':'version','line_number':315,'multiline':True]['text':' BOOST_MP_STANDALONE','line_number':321,'multiline':False]['text':'','line_number':327,'multiline':False]['text':' Helpers:','line_number':328,'multiline':False]['text':'','line_number':329,'multiline':False]['text':'','line_number':343,'multiline':False]['text':' Required non-members:','line_number':344,'multiline':False]['text':'','line_number':345,'multiline':False]['text':'','line_number':371,'multiline':False]['text':' Conversions:','line_number':372,'multiline':False]['text':'','line_number':373,'multiline':False]['text':'','line_number':377,'multiline':False]['text':' The generic conversion is as good as anything we can write here:','line_number':378,'multiline':False]['text':'','line_number':379,'multiline':False]['text':'','line_number':403,'multiline':False]['text':' Hashing support, not strictly required, but it is used in our tests:','line_number':404,'multiline':False]['text':'','line_number':405,'multiline':False]['text':'','line_number':414,'multiline':False]['text':' assign_components:','line_number':415,'multiline':False]['text':'','line_number':416,'multiline':False]['text':'','line_number':437,'multiline':False]['text':' Again for arithmetic types, overload for whatever arithmetic types are directly supported:','line_number':438,'multiline':False]['text':'','line_number':439,'multiline':False]['text':'','line_number':460,'multiline':False]['text':' Optional comparison operators:','line_number':461,'multiline':False]['text':'','line_number':462,'multiline':False]['text':'','line_number':500,'multiline':False]['text':' Arithmetic operations, starting with addition:','line_number':501,'multiline':False]['text':'','line_number':502,'multiline':False]['text':'','line_number':516,'multiline':False]['text':' There is no need to re-normalize here, we have ','line_number':517,'multiline':False]['text':' (a + bm) / b','line_number':518,'multiline':False]['text':' and gcd(a + bm, b) = gcd(a, b) = 1','line_number':519,'multiline':False]['text':'','line_number':520,'multiline':False]['text':'
   eval_gcd(t, result.num(), result.denom());
   if (!eval_eq(t, rational_adaptor<Backend>::one()) != 0)
   {
      Backend t2;
      eval_divide(t2, result.num(), t);
      t2.swap(result.num());
      eval_divide(t2, result.denom(), t);
      t2.swap(result.denom());
   }
   ','line_number':521,'multiline':True]['text':'','line_number':556,'multiline':False]['text':' Let  a = an/ad','line_number':557,'multiline':False]['text':'      b = bn/bd','line_number':558,'multiline':False]['text':'      g = gcd(ad, bd)','line_number':559,'multiline':False]['text':' result = rn/rd','line_number':560,'multiline':False]['text':'','line_number':561,'multiline':False]['text':' Then:','line_number':562,'multiline':False]['text':' rn = an * (bd/g) + bn * (ad/g)','line_number':563,'multiline':False]['text':' rd = ad * (bd/g)','line_number':564,'multiline':False]['text':'    = (ad/g) * (bd/g) * g','line_number':565,'multiline':False]['text':'','line_number':566,'multiline':False]['text':' And the whole thing can then be rescaled by','line_number':567,'multiline':False]['text':'      gcd(rn, g)','line_number':568,'multiline':False]['text':'','line_number':569,'multiline':False]['text':'','line_number':571,'multiline':False]['text':' Begin by getting the gcd of the 2 denominators:','line_number':572,'multiline':False]['text':'','line_number':573,'multiline':False]['text':'','line_number':575,'multiline':False]['text':' Do we have gcd > 1:','line_number':576,'multiline':False]['text':'','line_number':577,'multiline':False]['text':'','line_number':580,'multiline':False]['text':' Scale the denominators by gcd, and put the results in t1 and t2:','line_number':581,'multiline':False]['text':'','line_number':582,'multiline':False]['text':'','line_number':585,'multiline':False]['text':' multiply the numerators by the scale denominators and put the results in t3, t4:','line_number':586,'multiline':False]['text':'','line_number':587,'multiline':False]['text':'','line_number':590,'multiline':False]['text':' Add them up:','line_number':591,'multiline':False]['text':'','line_number':592,'multiline':False]['text':'','line_number':597,'multiline':False]['text':' Get the gcd of gcd and our numerator (t3):','line_number':598,'multiline':False]['text':'','line_number':599,'multiline':False]['text':'','line_number':608,'multiline':False]['text':' Uncommon case where gcd is not 1, divide the numerator','line_number':609,'multiline':False]['text':' and the denominator terms by the new gcd.  Note we perform division','line_number':610,'multiline':False]['text':' on the existing gcd value as this is the smallest of the 3 denominator','line_number':611,'multiline':False]['text':' terms we'll be multiplying together, so there's a good chance it's a','line_number':612,'multiline':False]['text':' single limb value already:','line_number':613,'multiline':False]['text':'','line_number':614,'multiline':False]['text':'','line_number':623,'multiline':False]['text':' Most common case (approx 60%) where gcd is one:','line_number':624,'multiline':False]['text':'','line_number':625,'multiline':False]['text':'','line_number':674,'multiline':False]['text':' There is no need to re-normalize here, we have ','line_number':675,'multiline':False]['text':' (a + bm) / b','line_number':676,'multiline':False]['text':' and gcd(a + bm, b) = gcd(a, b) = 1','line_number':677,'multiline':False]['text':'','line_number':678,'multiline':False]['text':'','line_number':693,'multiline':False]['text':' Multiplication:','line_number':694,'multiline':False]['text':'','line_number':695,'multiline':False]['text':'','line_number':708,'multiline':False]['text':' Unit gcd's are the most likely case:','line_number':709,'multiline':False]['text':'','line_number':710,'multiline':False]['text':'','line_number':742,'multiline':False]['text':' We may have b_denom negative if this is actually division, if so just correct things now:','line_number':743,'multiline':False]['text':'','line_number':744,'multiline':False]['text':' squaring, gcd's are 1:','line_number':759,'multiline':False]['text':'','line_number':921,'multiline':False]['text':' Division:','line_number':922,'multiline':False]['text':'','line_number':923,'multiline':False]['text':' Huh? Really?','line_number':937,'multiline':False]['text':'','line_number':1131,'multiline':False]['text':' Increment and decrement:','line_number':1132,'multiline':False]['text':'','line_number':1133,'multiline':False]['text':'','line_number':1147,'multiline':False]['text':' abs:','line_number':1148,'multiline':False]['text':'','line_number':1149,'multiline':False]['text':' namespace backends','line_number':1158,'multiline':False]['text':'','line_number':1160,'multiline':False]['text':' Import the backend into this namespace:','line_number':1161,'multiline':False]['text':'','line_number':1162,'multiline':False]['text':'','line_number':1164,'multiline':False]['text':' Define a category for this number type, one of:','line_number':1165,'multiline':False]['text':' ','line_number':1166,'multiline':False]['text':'    number_kind_integer','line_number':1167,'multiline':False]['text':'    number_kind_floating_point','line_number':1168,'multiline':False]['text':'    number_kind_rational','line_number':1169,'multiline':False]['text':'    number_kind_fixed_point','line_number':1170,'multiline':False]['text':'    number_kind_complex','line_number':1171,'multiline':False]['text':'','line_number':1172,'multiline':False]['text':' namespace boost::multiprecision','line_number':1203,'multiline':False]['text':' namespace std','line_number':1232,'multiline':False]