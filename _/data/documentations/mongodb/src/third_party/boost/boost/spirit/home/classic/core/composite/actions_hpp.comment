['text':'=============================================================================
    Copyright (c) 1998-2003 Joel de Guzman
    http://spirit.sourceforge.net/

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]['text':'assignment operator could not be generated','line_number':22,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':'  action class','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':'      The action class binds a parser with a user defined semantic','line_number':29,'multiline':False]['text':'      action. Instances of action are never created manually. Instead,','line_number':30,'multiline':False]['text':'      action objects are typically created indirectly through','line_number':31,'multiline':False]['text':'      expression templates of the form:','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':'          p[f]','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':'      where p is a parser and f is a function or functor. The semantic','line_number':36,'multiline':False]['text':'      action may be a function or a functor. When the parser is','line_number':37,'multiline':False]['text':'      successful, the actor calls the scanner's action_policy policy','line_number':38,'multiline':False]['text':'      (see scanner.hpp):','line_number':39,'multiline':False]['text':'','line_number':40,'multiline':False]['text':'          scan.do_action(actor, attribute, first, last);','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':'      passing in these information:','line_number':43,'multiline':False]['text':'','line_number':44,'multiline':False]['text':'          actor:        The action's function or functor','line_number':45,'multiline':False]['text':'          attribute:    The match (returned by the parser) object's','line_number':46,'multiline':False]['text':'                        attribute (see match.hpp)','line_number':47,'multiline':False]['text':'          first:        Iterator pointing to the start of the matching','line_number':48,'multiline':False]['text':'                        portion of the input','line_number':49,'multiline':False]['text':'          last:         Iterator pointing to one past the end of the','line_number':50,'multiline':False]['text':'                        matching portion of the input','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':'      It is the responsibility of the scanner's action_policy policy to','line_number':53,'multiline':False]['text':'      dispatch the function or functor as it sees fit. The expected','line_number':54,'multiline':False]['text':'      function or functor signature depends on the parser being','line_number':55,'multiline':False]['text':'      wrapped. In general, if the attribute type of the parser being','line_number':56,'multiline':False]['text':'      wrapped is a nil_t, the function or functor expect the signature:','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':'          void func(Iterator first, Iterator last); // functions','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':'          struct ftor // functors','line_number':61,'multiline':False]['text':'          {','line_number':62,'multiline':False]['text':'              void func(Iterator first, Iterator last) const;','line_number':63,'multiline':False]['text':'          };','line_number':64,'multiline':False]['text':'','line_number':65,'multiline':False]['text':'      where Iterator is the type of the iterator that is being used and','line_number':66,'multiline':False]['text':'      first and last are the iterators pointing to the matching portion','line_number':67,'multiline':False]['text':'      of the input.','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':'      If the attribute type of the parser being wrapped is not a nil_t,','line_number':70,'multiline':False]['text':'      the function or functor usually expect the signature:','line_number':71,'multiline':False]['text':'','line_number':72,'multiline':False]['text':'          void func(T val); // functions','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':'          struct ftor // functors','line_number':75,'multiline':False]['text':'          {','line_number':76,'multiline':False]['text':'              void func(T val) const;','line_number':77,'multiline':False]['text':'          };','line_number':78,'multiline':False]['text':'','line_number':79,'multiline':False]['text':'      where T is the attribute type and val is the attribute value','line_number':80,'multiline':False]['text':'      returned by the parser being wrapped.','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':83,'multiline':False]['text':' allow skipper to take effect','line_number':111,'multiline':False]['text':' namespace BOOST_SPIRIT_CLASSIC_NS','line_number':135,'multiline':False]