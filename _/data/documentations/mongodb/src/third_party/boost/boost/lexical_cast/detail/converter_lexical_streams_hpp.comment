['text':' Copyright Kevlin Henney, 2000-2005.','line_number':1,'multiline':False]['text':' Copyright Alexander Nasonov, 2006-2010.','line_number':2,'multiline':False]['text':' Copyright Antony Polukhin, 2011-2022.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' what:  lexical_cast custom keyword cast','line_number':9,'multiline':False]['text':' who:   contributed by Kevlin Henney,','line_number':10,'multiline':False]['text':'        enhanced with contributions from Terje Slettebo,','line_number':11,'multiline':False]['text':'        with additional fixes and suggestions from Gennaro Prota,','line_number':12,'multiline':False]['text':'        Beman Dawes, Dave Abrahams, Daryle Walker, Peter Dimov,','line_number':13,'multiline':False]['text':'        Alexander Nasonov, Antony Polukhin, Justin Viiret, Michael Hofmann,','line_number':14,'multiline':False]['text':'        Cheng Yang, Matthew Bradbury, David W. Birdsall, Pavel Korzh and other Boosters','line_number':15,'multiline':False]['text':' when:  November 2000, March 2003, June 2005, June 2006, March 2011 - 2014, Nowember 2016','line_number':16,'multiline':False]['text':' Getting error at this point means, that your STL library is old/lame/misconfigured.','line_number':46,'multiline':False]['text':' If nothing can be done with STL library, define BOOST_LEXICAL_CAST_ASSUME_C_LOCALE,','line_number':47,'multiline':False]['text':' but beware: lexical_cast will understand only 'C' locale delimeters and thousands','line_number':48,'multiline':False]['text':' separators.','line_number':49,'multiline':False]['text':' basic_unlockedbuf','line_number':86,'multiline':False]['text':' acts as a stream buffer which wraps around a pair of pointers','line_number':88,'multiline':False]['text':' and gives acces to internals','line_number':89,'multiline':False]['text':' optimized stream wrappers','line_number':132,'multiline':False]['text':' a result of widest_char transformation','line_number':134,'multiline':False]['text':' After the `operator <<`  finishes, `[start, finish)` is','line_number':156,'multiline':False]['text':' the range to output by `operator >>`','line_number':157,'multiline':False]['text':'*********************************** HELPER FUNCTIONS FOR OPERATORS << ( ... ) *******************************','line_number':178,'multiline':True]['text':' If you have compilation error at this point, than your STL library','line_number':226,'multiline':False]['text':' does not support such conversions. Try updating it.','line_number':227,'multiline':False]['text':'f','line_number':243,'multiline':True]['text':'begin','line_number':273,'multiline':True]['text':'*********************************** OPERATORS << ( ... ) *******************************','line_number':354,'multiline':True]['text':' Adding constness to characters. Constness does not change layout','line_number':458,'multiline':False]['text':' Making a Boost.Array from std::array','line_number':485,'multiline':False]['text':'`[start, finish)` is the range to output by `operator >>`','line_number':503,'multiline':False]['text':'*********************************** HELPER FUNCTIONS FOR OPERATORS >> ( ... ) *******************************','line_number':513,'multiline':True]['text':' We won`t use `start' any more, so no need in decrementing it after ','line_number':522,'multiline':True]['text':' We won`t use `start' any more, so no need in decrementing it after ','line_number':545,'multiline':True]['text':' Usually `istream` and `basic_istream` do not modify','line_number':583,'multiline':False]['text':' content of buffer; `buffer_t` assures that this is true','line_number':584,'multiline':False]['text':' BOOST_NO_STD_LOCALE','line_number':590,'multiline':False]['text':' BOOST_NO_STRINGSTREAM','line_number':591,'multiline':False]['text':'f','line_number':604,'multiline':True]['text':' `-1` because we need to store \0 at the end','line_number':628,'multiline':False]['text':'*********************************** OPERATORS >> ( ... ) *******************************','line_number':637,'multiline':True]['text':' Suppress warning about uninitalized variable','line_number':707,'multiline':False]['text':' Does not ends on '0' or '1'','line_number':717,'multiline':False]['text':' We may have sign at the beginning','line_number':722,'multiline':False]['text':' Skipping zeros','line_number':727,'multiline':False]['text':' Not a zero => error','line_number':730,'multiline':False]['text':' Not optimised converter','line_number':740,'multiline':False]['text':' Some compilers and libraries successfully
                 * parse 'inf', 'INFINITY', '1.0E', '1.0E-'...
                 * We are trying to provide a unified behaviour,
                 * so we just forbid such conversions (as some
                 * of the most popular compilers/libraries do)
                 * ','line_number':746,'multiline':True]['text':' 1.0e','line_number':758,'multiline':False]['text':' 1.0E','line_number':759,'multiline':False]['text':' 1.0e- or 1.0E-','line_number':760,'multiline':False]['text':' 1.0e+ or 1.0E+','line_number':761,'multiline':False]['text':' Generic istream-based algorithm.','line_number':773,'multiline':False]['text':' lcast_streambuf_for_target<InputStreamable>::value is true.','line_number':774,'multiline':False]['text':' namespace boost','line_number':781,'multiline':False]['text':' BOOST_LEXICAL_CAST_DETAIL_CONVERTER_LEXICAL_HPP','line_number':785,'multiline':False]