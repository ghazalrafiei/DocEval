['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2013 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' Generic routines for converting floating point values to and from decimal strings.','line_number':6,'multiline':False]['text':' Note that these use "naive" algorithms which result in rounding error - so they','line_number':7,'multiline':False]['text':' do not round trip to and from the string representation (but should only be out','line_number':8,'multiline':False]['text':' in the last bit).','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' Rounds up a string representation of a number at pos:','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'','line_number':89,'multiline':False]['text':' Start by figuring out the exponent:','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':'','line_number':117,'multiline':False]['text':' Make sure we're between [1,10) and adjust if not:','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':'','line_number':132,'multiline':False]['text':' Adjust the number of digits required based on formatting options:','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' Extract the digits one at a time:','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' Possibly round result:','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':' Bankers rounding:','line_number':160,'multiline':False]['text':' Input is an integer, sometimes we get a result which is not an integer here as a result of printing too','line_number':174,'multiline':False]['text':' many digits, so lets round if required:','line_number':175,'multiline':False]['text':' We may get here as a result of rounding...','line_number':182,'multiline':False]['text':' so we put less padding in the result.','line_number':188,'multiline':False]['text':'','line_number':245,'multiline':False]['text':' Grab all the leading digits before the decimal point:','line_number':246,'multiline':False]['text':'','line_number':247,'multiline':False]['text':'','line_number':257,'multiline':False]['text':' Grab everything after the point, stop when we've seen','line_number':258,'multiline':False]['text':' enough digits, even if there are actually more available:','line_number':259,'multiline':False]['text':'','line_number':260,'multiline':False]['text':'','line_number':274,'multiline':False]['text':' Parse the exponent:','line_number':275,'multiline':False]['text':'','line_number':276,'multiline':False]['text':' Scale by 10^expon, note that 10^expon can be','line_number':300,'multiline':False]['text':' outside the range of our number type, even though the','line_number':301,'multiline':False]['text':' result is within range, if that looks likely, then split','line_number':302,'multiline':False]['text':' the calculation in two:','line_number':303,'multiline':False]['text':' Unexpected input in string:','line_number':324,'multiline':False]['text':' namespace boost::multiprecision::detail','line_number':329,'multiline':False]