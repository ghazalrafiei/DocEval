['text':'  (C) Copyright John Maddock 2006.','line_number':1,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':' Conditional expression is constant','line_number':12,'multiline':False]['text':' Unreachable code: optimization warning','line_number':13,'multiline':False]['text':'','line_number':21,'multiline':False]['text':' The inverse erf and erfc functions share a common implementation,','line_number':22,'multiline':False]['text':' this version is for 80-bit long double's and smaller:','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' for ADL of std names.','line_number':28,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' Evaluate inverse erf using the rational approximation:','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':' x = p(p+10)(Y+R(p))','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' Where Y is a constant, and R(p) is optimised for a low','line_number':39,'multiline':False]['text':' absolute error compared to |Y|.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' double: Max error found: 2.001849e-18','line_number':42,'multiline':False]['text':' long double: Max error found: 1.017064e-20','line_number':43,'multiline':False]['text':' Maximum Deviation Found (actual error term at infinite precision) 8.030e-21','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' Rational approximation for 0.5 > q >= 0.25','line_number':76,'multiline':False]['text':'','line_number':77,'multiline':False]['text':' x = sqrt(-2*log(q)) / (Y + R(q))','line_number':78,'multiline':False]['text':'','line_number':79,'multiline':False]['text':' Where Y is a constant, and R(q) is optimised for a low','line_number':80,'multiline':False]['text':' absolute error compared to Y.','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':' double : Max error found: 7.403372e-17','line_number':83,'multiline':False]['text':' long double : Max error found: 6.084616e-20','line_number':84,'multiline':False]['text':' Maximum Deviation Found (error term) 4.811e-20','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':'','line_number':117,'multiline':False]['text':' For q < 0.25 we have a series of rational approximations all','line_number':118,'multiline':False]['text':' of the general form:','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':' let: x = sqrt(-log(q))','line_number':121,'multiline':False]['text':'','line_number':122,'multiline':False]['text':' Then the result is given by:','line_number':123,'multiline':False]['text':'','line_number':124,'multiline':False]['text':' x(Y+R(x-B))','line_number':125,'multiline':False]['text':'','line_number':126,'multiline':False]['text':' where Y is a constant, B is the lowest value of x for which ','line_number':127,'multiline':False]['text':' the approximation is valid, and R(x-B) is optimised for a low','line_number':128,'multiline':False]['text':' absolute error compared to Y.','line_number':129,'multiline':False]['text':'','line_number':130,'multiline':False]['text':' Note that almost all code will really go through the first','line_number':131,'multiline':False]['text':' or maybe second approximation.  After than we're dealing with very','line_number':132,'multiline':False]['text':' small input values indeed: 80 and 128 bit long double's go all the','line_number':133,'multiline':False]['text':' way down to ~ 1e-5000 so the "tail" is rather long...','line_number':134,'multiline':False]['text':'','line_number':135,'multiline':False]['text':' Max error found: 1.089051e-20','line_number':139,'multiline':False]['text':' Max error found: 8.389174e-21','line_number':170,'multiline':False]['text':' Max error found: 1.481312e-19','line_number':198,'multiline':False]['text':' Max error found: 5.697761e-20','line_number':226,'multiline':False]['text':' Max error found: 1.279746e-20','line_number':253,'multiline':False]['text':'','line_number':301,'multiline':False]['text':' Generic version, get a guess that's accurate to 64-bits (10^-19)','line_number':302,'multiline':False]['text':'','line_number':303,'multiline':False]['text':'','line_number':306,'multiline':False]['text':' If T has more bit's than 64 in it's mantissa then we need to iterate,','line_number':307,'multiline':False]['text':' otherwise we can just return the result:','line_number':308,'multiline':False]['text':'','line_number':309,'multiline':False]['text':' If std::numeric_limits<T>::digits is zero, we must not call','line_number':342,'multiline':False]['text':' our initialization code here as the precision presumably','line_number':343,'multiline':False]['text':' varies at runtime, and will not have been set yet.','line_number':344,'multiline':False]['text':' These following initializations must not be called if','line_number':351,'multiline':False]['text':' type T can not hold the relevant values without','line_number':352,'multiline':False]['text':' underflow to zero.  We check this at runtime because','line_number':353,'multiline':False]['text':' some tools such as valgrind silently change the precision','line_number':354,'multiline':False]['text':' of T at runtime, and numeric_limits basically lies!','line_number':355,'multiline':False]['text':' Some compilers choke on constants that would underflow, even in code that isn't instantiated','line_number':359,'multiline':False]['text':' so try and filter these cases out in the preprocessor:','line_number':360,'multiline':False]['text':' This needs to be non-inline to detect whether v is non zero at runtime','line_number':389,'multiline':False]['text':' rather than at compile time, only relevant when running under valgrind','line_number':390,'multiline':False]['text':' which changes long double's to double's on the fly.','line_number':391,'multiline':False]['text':' namespace detail','line_number':395,'multiline':False]['text':'','line_number':402,'multiline':False]['text':' Begin by testing for domain errors, and other special cases:','line_number':403,'multiline':False]['text':'','line_number':404,'multiline':False]['text':'','line_number':412,'multiline':False]['text':' Normalise the input, so it's in the range [0,1], we will','line_number':413,'multiline':False]['text':' negate the result if z is outside that range.  This is a simple','line_number':414,'multiline':False]['text':' application of the erfc reflection formula: erfc(-z) = 2 - erfc(z)','line_number':415,'multiline':False]['text':'','line_number':416,'multiline':False]['text':'','line_number':430,'multiline':False]['text':' A bit of meta-programming to figure out which implementation','line_number':431,'multiline':False]['text':' to use, based on the number of bits in the mantissa of T:','line_number':432,'multiline':False]['text':'','line_number':433,'multiline':False]['text':'','line_number':439,'multiline':False]['text':' Likewise use internal promotion, so we evaluate at a higher','line_number':440,'multiline':False]['text':' precision internally if it's appropriate:','line_number':441,'multiline':False]['text':'','line_number':442,'multiline':False]['text':'','line_number':453,'multiline':False]['text':' And get the result, negating where required:','line_number':454,'multiline':False]['text':'','line_number':455,'multiline':False]['text':'','line_number':465,'multiline':False]['text':' Begin by testing for domain errors, and other special cases:','line_number':466,'multiline':False]['text':'','line_number':467,'multiline':False]['text':'','line_number':477,'multiline':False]['text':' Normalise the input, so it's in the range [0,1], we will','line_number':478,'multiline':False]['text':' negate the result if z is outside that range.  This is a simple','line_number':479,'multiline':False]['text':' application of the erf reflection formula: erf(-z) = -erf(z)','line_number':480,'multiline':False]['text':'','line_number':481,'multiline':False]['text':'','line_number':495,'multiline':False]['text':' A bit of meta-programming to figure out which implementation','line_number':496,'multiline':False]['text':' to use, based on the number of bits in the mantissa of T:','line_number':497,'multiline':False]['text':'','line_number':498,'multiline':False]['text':'','line_number':504,'multiline':False]['text':' Likewise use internal promotion, so we evaluate at a higher','line_number':505,'multiline':False]['text':' precision internally if it's appropriate:','line_number':506,'multiline':False]['text':'','line_number':507,'multiline':False]['text':'','line_number':515,'multiline':False]['text':' Likewise use internal promotion, so we evaluate at a higher','line_number':516,'multiline':False]['text':' precision internally if it's appropriate:','line_number':517,'multiline':False]['text':'','line_number':518,'multiline':False]['text':'','line_number':522,'multiline':False]['text':' And get the result, negating where required:','line_number':523,'multiline':False]['text':'','line_number':524,'multiline':False]['text':' namespace math','line_number':541,'multiline':False]['text':' namespace boost','line_number':542,'multiline':False]['text':' BOOST_MATH_SF_ERF_INV_HPP','line_number':548,'multiline':False]