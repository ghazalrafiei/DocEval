['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2014-2014. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See http://www.boost.org/libs/move for documentation.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]['text':'forceinline','line_number':23,'multiline':False]['text':'For std::nullptr_t and std::size_t','line_number':31,'multiline':False]['text':'!\file','line_number':33,'multiline':False]['text':'! Describes the smart pointer unique_ptr, a drop-in replacement for std::unique_ptr,','line_number':34,'multiline':False]['text':'! usable also from C++03 compilers.','line_number':35,'multiline':False]['text':'!','line_number':36,'multiline':False]['text':'! Main differences from std::unique_ptr to avoid heavy dependencies,','line_number':37,'multiline':False]['text':'! specially in C++03 compilers:','line_number':38,'multiline':False]['text':'!   - <tt>operator < </tt> uses pointer <tt>operator < </tt>instead of <tt>std::less<common_type></tt>. ','line_number':39,'multiline':False]['text':'!      This avoids dependencies on <tt>std::common_type</tt> and <tt>std::less</tt>','line_number':40,'multiline':False]['text':'!      (<tt><type_traits>/<functional></tt> headers). In C++03 this avoid pulling Boost.Typeof and other','line_number':41,'multiline':False]['text':'!      cascading dependencies. As in all Boost platforms <tt>operator <</tt> on raw pointers and','line_number':42,'multiline':False]['text':'!      other smart pointers provides strict weak ordering in practice this should not be a problem for users.','line_number':43,'multiline':False]['text':'!   - assignable from literal 0 for compilers without nullptr','line_number':44,'multiline':False]['text':'!   - <tt>unique_ptr<T[]></tt> is constructible and assignable from <tt>unique_ptr<U[]></tt> if','line_number':45,'multiline':False]['text':'!      cv-less T and cv-less U are the same type and T is more CV qualified than U.','line_number':46,'multiline':False]['text':' @cond','line_number':49,'multiline':False]['text':'//////////////////////////////////////////','line_number':52,'multiline':False]['text':'          deleter types','line_number':53,'multiline':False]['text':'//////////////////////////////////////////','line_number':54,'multiline':False]['text':'defined(BOOST_NO_CXX11_RVALUE_REFERENCES)','line_number':66,'multiline':False]['text':'//////////////////////////////////////////','line_number':86,'multiline':False]['text':'          unique_ptr_data','line_number':87,'multiline':False]['text':'//////////////////////////////////////////','line_number':88,'multiline':False]['text':'//////////////////////////////////////////','line_number':159,'multiline':False]['text':'          is_unique_ptr_convertible','line_number':160,'multiline':False]['text':'//////////////////////////////////////////','line_number':161,'multiline':False]['text':'Although non-standard, we avoid using pointer_traits','line_number':163,'multiline':False]['text':'to avoid heavy dependencies','line_number':164,'multiline':False]['text':'//////////////////////////////////////','line_number':206,'multiline':False]['text':'//     enable_up_moveconv_assign','line_number':207,'multiline':False]['text':'//////////////////////////////////////','line_number':208,'multiline':False]['text':'//////////////////////////////////////','line_number':216,'multiline':False]['text':'//     enable_up_moveconv_assign','line_number':217,'multiline':False]['text':'//////////////////////////////////////','line_number':218,'multiline':False]['text':'//////////////////////////////////////','line_number':243,'multiline':False]['text':'//     enable_up_moveconv_constr','line_number':244,'multiline':False]['text':'//////////////////////////////////////','line_number':245,'multiline':False]['text':'Clang has some problems with is_rvalue_convertible with non-copyable types','line_number':278,'multiline':False]['text':'so use intrinsic if available','line_number':279,'multiline':False]['text':'!defined(BOOST_NO_CXX11_RVALUE_REFERENCES)','line_number':290,'multiline':False]['text':'No hope for compilers with move emulation for now. In several compilers is_convertible','line_number':291,'multiline':False]['text':' leads to errors, so just move the Deleter and see if the conversion works','line_number':292,'multiline':False]['text':'is_rvalue_convertible<E, D>::value','line_number':293,'multiline':True]['text':'namespace move_upd {','line_number':304,'multiline':False]['text':' @endcond','line_number':305,'multiline':False]['text':'! A unique pointer is an object that owns another object and','line_number':309,'multiline':False]['text':'! manages that other object through a pointer.','line_number':310,'multiline':False]['text':'! ','line_number':311,'multiline':False]['text':'! More precisely, a unique pointer is an object u that stores a pointer to a second object p and will dispose','line_number':312,'multiline':False]['text':'! of p when u is itself destroyed (e.g., when leaving block scope). In this context, u is said to own p.','line_number':313,'multiline':False]['text':'! ','line_number':314,'multiline':False]['text':'! The mechanism by which u disposes of p is known as p's associated deleter, a function object whose correct','line_number':315,'multiline':False]['text':'! invocation results in p's appropriate disposition (typically its deletion).','line_number':316,'multiline':False]['text':'! ','line_number':317,'multiline':False]['text':'! Let the notation u.p denote the pointer stored by u, and let u.d denote the associated deleter. Upon request,','line_number':318,'multiline':False]['text':'! u can reset (replace) u.p and u.d with another pointer and deleter, but must properly dispose of its owned','line_number':319,'multiline':False]['text':'! object via the associated deleter before such replacement is considered completed.','line_number':320,'multiline':False]['text':'! ','line_number':321,'multiline':False]['text':'! Additionally, u can, upon request, transfer ownership to another unique pointer u2. Upon completion of','line_number':322,'multiline':False]['text':'! such a transfer, the following postconditions hold:','line_number':323,'multiline':False]['text':'!   - u2.p is equal to the pre-transfer u.p,','line_number':324,'multiline':False]['text':'!   - u.p is equal to nullptr, and','line_number':325,'multiline':False]['text':'!   - if the pre-transfer u.d maintained state, such state has been transferred to u2.d.','line_number':326,'multiline':False]['text':'! ','line_number':327,'multiline':False]['text':'! As in the case of a reset, u2 must properly dispose of its pre-transfer owned object via the pre-transfer','line_number':328,'multiline':False]['text':'! associated deleter before the ownership transfer is considered complete.','line_number':329,'multiline':False]['text':'! ','line_number':330,'multiline':False]['text':'! Each object of a type U instantiated from the unique_ptr template specified in this subclause has the strict','line_number':331,'multiline':False]['text':'! ownership semantics, specified above, of a unique pointer. In partial satisfaction of these semantics, each','line_number':332,'multiline':False]['text':'! such U is MoveConstructible and MoveAssignable, but is not CopyConstructible nor CopyAssignable.','line_number':333,'multiline':False]['text':'! The template parameter T of unique_ptr may be an incomplete type.','line_number':334,'multiline':False]['text':'! ','line_number':335,'multiline':False]['text':'! The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing','line_number':336,'multiline':False]['text':'! ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from','line_number':337,'multiline':False]['text':'! a function.','line_number':338,'multiline':False]['text':'!','line_number':339,'multiline':False]['text':'! If T is an array type (e.g. unique_ptr<MyType[]>) the interface is slightly altered:','line_number':340,'multiline':False]['text':'!   - Pointers to types derived from T are rejected by the constructors, and by reset.','line_number':341,'multiline':False]['text':'!   - The observers <tt>operator*</tt> and <tt>operator-></tt> are not provided.','line_number':342,'multiline':False]['text':'!   - The indexing observer <tt>operator[]</tt> is provided.','line_number':343,'multiline':False]['text':'!','line_number':344,'multiline':False]['text':'! \tparam T Provides the type of the stored pointer.','line_number':345,'multiline':False]['text':'! \tparam D The deleter type:','line_number':346,'multiline':False]['text':'!   -  The default type for the template parameter D is default_delete. A client-supplied template argument','line_number':347,'multiline':False]['text':'!      D shall be a function object type, lvalue-reference to function, or lvalue-reference to function object type','line_number':348,'multiline':False]['text':'!      for which, given a value d of type D and a value ptr of type unique_ptr<T, D>::pointer, the expression','line_number':349,'multiline':False]['text':'!      d(ptr) is valid and has the effect of disposing of the pointer as appropriate for that deleter.','line_number':350,'multiline':False]['text':'!   -  If the deleter's type D is not a reference type, D shall satisfy the requirements of Destructible.','line_number':351,'multiline':False]['text':'!   -  If the type <tt>remove_reference<D>::type::pointer</tt> exists, it shall satisfy the requirements of NullablePointer.','line_number':352,'multiline':False]['text':'! If the type <tt>remove_reference<D>::type::pointer</tt> exists, then it shall be a','line_number':373,'multiline':False]['text':'! synonym for <tt>remove_reference<D>::type::pointer</tt>. Otherwise it shall be a','line_number':374,'multiline':False]['text':'! synonym for T*.','line_number':375,'multiline':False]['text':'! If T is an array type, then element_type is equal to T. Otherwise, if T is a type','line_number':377,'multiline':False]['text':'! in the form U[], element_type is equal to U.','line_number':378,'multiline':False]['text':'! <b>Requires</b>: D shall satisfy the requirements of DefaultConstructible, and','line_number':382,'multiline':False]['text':'!   that construction shall not throw an exception.','line_number':383,'multiline':False]['text':'!','line_number':384,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr object that owns nothing, value-initializing the','line_number':385,'multiline':False]['text':'!   stored pointer and the stored deleter.','line_number':386,'multiline':False]['text':'!','line_number':387,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == nullptr</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter.','line_number':388,'multiline':False]['text':'!','line_number':389,'multiline':False]['text':'! <b>Remarks</b>: If this constructor is instantiated with a pointer type or reference type','line_number':390,'multiline':False]['text':'!   for the template argument D, the program is ill-formed.   ','line_number':391,'multiline':False]['text':'If this constructor is instantiated with a pointer type or reference type','line_number':395,'multiline':False]['text':'for the template argument D, the program is ill-formed.','line_number':396,'multiline':False]['text':'! <b>Effects</b>: Same as <tt>unique_ptr()</tt> (default constructor).','line_number':401,'multiline':False]['text':'! ','line_number':402,'multiline':False]['text':'If this constructor is instantiated with a pointer type or reference type','line_number':406,'multiline':False]['text':'for the template argument D, the program is ill-formed.','line_number':407,'multiline':False]['text':'! <b>Requires</b>: D shall satisfy the requirements of DefaultConstructible, and','line_number':412,'multiline':False]['text':'!   that construction shall not throw an exception.','line_number':413,'multiline':False]['text':'!','line_number':414,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr which owns p, initializing the stored pointer ','line_number':415,'multiline':False]['text':'!   with p and value initializing the stored deleter.','line_number':416,'multiline':False]['text':'!','line_number':417,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == p</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter.','line_number':418,'multiline':False]['text':'!','line_number':419,'multiline':False]['text':'! <b>Remarks</b>: If this constructor is instantiated with a pointer type or reference type','line_number':420,'multiline':False]['text':'!   for the template argument D, the program is ill-formed.','line_number':421,'multiline':False]['text':'!   This constructor shall not participate in overload resolution unless:','line_number':422,'multiline':False]['text':'!      - If T is not an array type and Pointer is implicitly convertible to pointer.','line_number':423,'multiline':False]['text':'!      - If T is an array type and Pointer is a more CV qualified pointer to element_type.','line_number':424,'multiline':False]['text':'If T is not an array type, element_type_t<Pointer> derives from T','line_number':431,'multiline':False]['text':'it uses the default deleter and T has no virtual destructor, then you have a problem','line_number':432,'multiline':False]['text':'If this constructor is instantiated with a pointer type or reference type','line_number':435,'multiline':False]['text':'for the template argument D, the program is ill-formed.','line_number':436,'multiline':False]['text':'!The signature of this constructor depends upon whether D is a reference type.','line_number':441,'multiline':False]['text':'!   - If D is non-reference type A, then the signature is <tt>unique_ptr(pointer p, const A& d)</tt>.','line_number':442,'multiline':False]['text':'!   - If D is an lvalue-reference type A&, then the signature is <tt>unique_ptr(pointer p, A& d)</tt>.','line_number':443,'multiline':False]['text':'!   - If D is an lvalue-reference type const A&, then the signature is <tt>unique_ptr(pointer p, const A& d)</tt>.','line_number':444,'multiline':False]['text':'!','line_number':445,'multiline':False]['text':'!','line_number':446,'multiline':False]['text':'! <b>Requires</b>: Either','line_number':447,'multiline':False]['text':'!   - D is not an lvalue-reference type and d is an lvalue or const rvalue. ','line_number':448,'multiline':False]['text':'!         D shall satisfy the requirements of CopyConstructible, and the copy constructor of D','line_number':449,'multiline':False]['text':'!         shall not throw an exception. This unique_ptr will hold a copy of d.','line_number':450,'multiline':False]['text':'!   - D is an lvalue-reference type and d is an lvalue. the type which D references need not be CopyConstructible nor','line_number':451,'multiline':False]['text':'!      MoveConstructible. This unique_ptr will hold a D which refers to the lvalue d.','line_number':452,'multiline':False]['text':'!','line_number':453,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr object which owns p, initializing the stored pointer with p and','line_number':454,'multiline':False]['text':'!   initializing the deleter as described above.','line_number':455,'multiline':False]['text':'! ','line_number':456,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == p</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter. If D is a','line_number':457,'multiline':False]['text':'!   reference type then <tt>get_deleter()</tt> returns a reference to the lvalue d.','line_number':458,'multiline':False]['text':'!','line_number':459,'multiline':False]['text':'! <b>Remarks</b>: This constructor shall not participate in overload resolution unless:','line_number':460,'multiline':False]['text':'!      - If T is not an array type and Pointer is implicitly convertible to pointer.','line_number':461,'multiline':False]['text':'!      - If T is an array type and Pointer is a more CV qualified pointer to element_type.','line_number':462,'multiline':False]['text':'If T is not an array type, element_type_t<Pointer> derives from T','line_number':469,'multiline':False]['text':'it uses the default deleter and T has no virtual destructor, then you have a problem','line_number':470,'multiline':False]['text':'! <b>Effects</b>: Same effects as <tt>template<class Pointer> unique_ptr(Pointer p, deleter_arg_type1 d1)</tt>','line_number':475,'multiline':False]['text':'!   and additionally <tt>get() == nullptr</tt>','line_number':476,'multiline':False]['text':'! The signature of this constructor depends upon whether D is a reference type.','line_number':481,'multiline':False]['text':'!   - If D is non-reference type A, then the signature is <tt>unique_ptr(pointer p, A&& d)</tt>.','line_number':482,'multiline':False]['text':'!   - If D is an lvalue-reference type A&, then the signature is <tt>unique_ptr(pointer p, A&& d)</tt>.','line_number':483,'multiline':False]['text':'!   - If D is an lvalue-reference type const A&, then the signature is <tt>unique_ptr(pointer p, const A&& d)</tt>.','line_number':484,'multiline':False]['text':'!','line_number':485,'multiline':False]['text':'! <b>Requires</b>: Either','line_number':486,'multiline':False]['text':'!   - D is not an lvalue-reference type and d is a non-const rvalue. D','line_number':487,'multiline':False]['text':'!      shall satisfy the requirements of MoveConstructible, and the move constructor','line_number':488,'multiline':False]['text':'!      of D shall not throw an exception. This unique_ptr will hold a value move constructed from d.','line_number':489,'multiline':False]['text':'!   - D is an lvalue-reference type and d is an rvalue, the program is ill-formed.','line_number':490,'multiline':False]['text':'!','line_number':491,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr object which owns p, initializing the stored pointer with p and','line_number':492,'multiline':False]['text':'!   initializing the deleter as described above.','line_number':493,'multiline':False]['text':'! ','line_number':494,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == p</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter. If D is a','line_number':495,'multiline':False]['text':'!   reference type then <tt>get_deleter()</tt> returns a reference to the lvalue d.','line_number':496,'multiline':False]['text':'!','line_number':497,'multiline':False]['text':'! <b>Remarks</b>: This constructor shall not participate in overload resolution unless:','line_number':498,'multiline':False]['text':'!      - If T is not an array type and Pointer is implicitly convertible to pointer.','line_number':499,'multiline':False]['text':'!      - If T is an array type and Pointer is a more CV qualified pointer to element_type.','line_number':500,'multiline':False]['text':'If T is not an array type, element_type_t<Pointer> derives from T','line_number':507,'multiline':False]['text':'it uses the default deleter and T has no virtual destructor, then you have a problem','line_number':508,'multiline':False]['text':'! <b>Effects</b>: Same effects as <tt>template<class Pointer> unique_ptr(Pointer p, deleter_arg_type2 d2)</tt>','line_number':513,'multiline':False]['text':'!   and additionally <tt>get() == nullptr</tt>','line_number':514,'multiline':False]['text':'! <b>Requires</b>: If D is not a reference type, D shall satisfy the requirements of MoveConstructible.','line_number':519,'multiline':False]['text':'! Construction of the deleter from an rvalue of type D shall not throw an exception.','line_number':520,'multiline':False]['text':'! ','line_number':521,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr by transferring ownership from u to *this. If D is a reference type,','line_number':522,'multiline':False]['text':'! this deleter is copy constructed from u's deleter; otherwise, this deleter is move constructed from u's','line_number':523,'multiline':False]['text':'! deleter.','line_number':524,'multiline':False]['text':'! ','line_number':525,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get()</tt> yields the value u.get() yielded before the construction. <tt>get_deleter()</tt>','line_number':526,'multiline':False]['text':'! returns a reference to the stored deleter that was constructed from u.get_deleter(). If D is a','line_number':527,'multiline':False]['text':'! reference type then <tt>get_deleter()</tt> and <tt>u.get_deleter()</tt> both reference the same lvalue deleter.','line_number':528,'multiline':False]['text':'! <b>Requires</b>: If E is not a reference type, construction of the deleter from an rvalue of type E shall be','line_number':533,'multiline':False]['text':'!   well formed and shall not throw an exception. Otherwise, E is a reference type and construction of the','line_number':534,'multiline':False]['text':'!   deleter from an lvalue of type E shall be well formed and shall not throw an exception.','line_number':535,'multiline':False]['text':'!','line_number':536,'multiline':False]['text':'! <b>Remarks</b>: This constructor shall not participate in overload resolution unless:','line_number':537,'multiline':False]['text':'!   - <tt>unique_ptr<U, E>::pointer</tt> is implicitly convertible to pointer,','line_number':538,'multiline':False]['text':'!   - U is not an array type, and','line_number':539,'multiline':False]['text':'!   - either D is a reference type and E is the same type as D, or D is not a reference type and E is','line_number':540,'multiline':False]['text':'!      implicitly convertible to D.','line_number':541,'multiline':False]['text':'!','line_number':542,'multiline':False]['text':'! <b>Effects</b>: Constructs a unique_ptr by transferring ownership from u to *this. If E is a reference type,','line_number':543,'multiline':False]['text':'!   this deleter is copy constructed from u's deleter; otherwise, this deleter is move constructed from u's deleter.','line_number':544,'multiline':False]['text':'!','line_number':545,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get()</tt> yields the value <tt>u.get()</tt> yielded before the construction. <tt>get_deleter()</tt>','line_number':546,'multiline':False]['text':'!   returns a reference to the stored deleter that was constructed from <tt>u.get_deleter()</tt>.','line_number':547,'multiline':False]['text':'If T is not an array type, U derives from T','line_number':554,'multiline':False]['text':'it uses the default deleter and T has no virtual destructor, then you have a problem','line_number':555,'multiline':False]['text':'! <b>Requires</b>: The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,','line_number':560,'multiline':False]['text':'!   and shall not throw exceptions.','line_number':561,'multiline':False]['text':'!','line_number':562,'multiline':False]['text':'! <b>Effects</b>: If <tt>get() == nullpt1r</tt> there are no effects. Otherwise <tt>get_deleter()(get())</tt>.','line_number':563,'multiline':False]['text':'!','line_number':564,'multiline':False]['text':'! <b>Note</b>: The use of default_delete requires T to be a complete type','line_number':565,'multiline':False]['text':'! <b>Requires</b>: If D is not a reference type, D shall satisfy the requirements of MoveAssignable','line_number':569,'multiline':False]['text':'!   and assignment of the deleter from an rvalue of type D shall not throw an exception. Otherwise, D','line_number':570,'multiline':False]['text':'!   is a reference type; <tt>remove_reference<D>::type</tt> shall satisfy the CopyAssignable requirements and','line_number':571,'multiline':False]['text':'!   assignment of the deleter from an lvalue of type D shall not throw an exception.','line_number':572,'multiline':False]['text':'!','line_number':573,'multiline':False]['text':'! <b>Effects</b>: Transfers ownership from u to *this as if by calling <tt>reset(u.release())</tt> followed','line_number':574,'multiline':False]['text':'!   by <tt>get_deleter() = std::forward<D>(u.get_deleter())</tt>.','line_number':575,'multiline':False]['text':'!','line_number':576,'multiline':False]['text':'! <b>Returns</b>: *this.','line_number':577,'multiline':False]['text':'! <b>Requires</b>: If E is not a reference type, assignment of the deleter from an rvalue of type E shall be','line_number':585,'multiline':False]['text':'!   well-formed and shall not throw an exception. Otherwise, E is a reference type and assignment of the','line_number':586,'multiline':False]['text':'!   deleter from an lvalue of type E shall be well-formed and shall not throw an exception.','line_number':587,'multiline':False]['text':'!','line_number':588,'multiline':False]['text':'! <b>Remarks</b>: This operator shall not participate in overload resolution unless:','line_number':589,'multiline':False]['text':'!   - <tt>unique_ptr<U, E>::pointer</tt> is implicitly convertible to pointer and','line_number':590,'multiline':False]['text':'!   - U is not an array type.','line_number':591,'multiline':False]['text':'!','line_number':592,'multiline':False]['text':'! <b>Effects</b>: Transfers ownership from u to *this as if by calling <tt>reset(u.release())</tt> followed by','line_number':593,'multiline':False]['text':'!   <tt>get_deleter() = std::forward<E>(u.get_deleter())</tt>.','line_number':594,'multiline':False]['text':'!','line_number':595,'multiline':False]['text':'! <b>Returns</b>: *this.','line_number':596,'multiline':False]['text':'! <b>Effects</b>: <tt>reset()</tt>.','line_number':607,'multiline':False]['text':'!','line_number':608,'multiline':False]['text':'! <b>Postcondition</b>: <tt>get() == nullptr</tt>','line_number':609,'multiline':False]['text':'!','line_number':610,'multiline':False]['text':'! <b>Returns</b>: *this.','line_number':611,'multiline':False]['text':'! <b>Requires</b>: <tt>get() != nullptr</tt>.','line_number':615,'multiline':False]['text':'!','line_number':616,'multiline':False]['text':'! <b>Returns</b>: <tt>*get()</tt>.','line_number':617,'multiline':False]['text':'!','line_number':618,'multiline':False]['text':'! <b>Remarks</b: If T is an array type, the program is ill-formed.','line_number':619,'multiline':False]['text':'! <b>Requires</b>: i < the number of elements in the array to which the stored pointer points.','line_number':627,'multiline':False]['text':'!','line_number':628,'multiline':False]['text':'! <b>Returns</b>: <tt>get()[i]</tt>.','line_number':629,'multiline':False]['text':'!','line_number':630,'multiline':False]['text':'! <b>Remarks</b: If T is not an array type, the program is ill-formed.','line_number':631,'multiline':False]['text':'! <b>Requires</b>: <tt>get() != nullptr</tt>.','line_number':640,'multiline':False]['text':'!','line_number':641,'multiline':False]['text':'! <b>Returns</b>: <tt>get()</tt>.','line_number':642,'multiline':False]['text':'!','line_number':643,'multiline':False]['text':'! <b>Note</b>: use typically requires that T be a complete type.','line_number':644,'multiline':False]['text':'!','line_number':645,'multiline':False]['text':'! <b>Remarks</b: If T is an array type, the program is ill-formed.','line_number':646,'multiline':False]['text':'! <b>Returns</b>: The stored pointer.','line_number':654,'multiline':False]['text':'!','line_number':655,'multiline':False]['text':'! <b>Returns</b>: A reference to the stored deleter.','line_number':659,'multiline':False]['text':'!','line_number':660,'multiline':False]['text':'! <b>Returns</b>: A reference to the stored deleter.','line_number':665,'multiline':False]['text':'!','line_number':666,'multiline':False]['text':'! <b>Returns</b>: Returns: get() != nullptr.','line_number':672,'multiline':False]['text':'!','line_number':673,'multiline':False]['text':'! <b>Postcondition</b>: <tt>get() == nullptr</tt>.','line_number':685,'multiline':False]['text':'!','line_number':686,'multiline':False]['text':'! <b>Returns</b>: The value <tt>get()</tt> had at the start of the call to release.   ','line_number':687,'multiline':False]['text':'! <b>Requires</b>: The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,','line_number':695,'multiline':False]['text':'!   and shall not throw exceptions.','line_number':696,'multiline':False]['text':'!','line_number':697,'multiline':False]['text':'! <b>Effects</b>: assigns p to the stored pointer, and then if the old value of the stored pointer, old_p, was not','line_number':698,'multiline':False]['text':'!   equal to nullptr, calls <tt>get_deleter()(old_p)</tt>. Note: The order of these operations is significant','line_number':699,'multiline':False]['text':'!   because the call to <tt>get_deleter()</tt> may destroy *this.','line_number':700,'multiline':False]['text':'!','line_number':701,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == p</tt>. Note: The postcondition does not hold if the call to <tt>get_deleter()</tt>','line_number':702,'multiline':False]['text':'!   destroys *this since <tt>this->get()</tt> is no longer a valid expression.','line_number':703,'multiline':False]['text':'!','line_number':704,'multiline':False]['text':'! <b>Remarks</b>: This constructor shall not participate in overload resolution unless:','line_number':705,'multiline':False]['text':'!      - If T is not an array type and Pointer is implicitly convertible to pointer.','line_number':706,'multiline':False]['text':'!      - If T is an array type and Pointer is a more CV qualified pointer to element_type.','line_number':707,'multiline':False]['text':'If T is not an array type, element_type_t<Pointer> derives from T','line_number':712,'multiline':False]['text':'it uses the default deleter and T has no virtual destructor, then you have a problem','line_number':713,'multiline':False]['text':'! <b>Requires</b>: The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,','line_number':721,'multiline':False]['text':'!   and shall not throw exceptions.','line_number':722,'multiline':False]['text':'!','line_number':723,'multiline':False]['text':'! <b>Effects</b>: assigns nullptr to the stored pointer, and then if the old value of the stored pointer, old_p, was not','line_number':724,'multiline':False]['text':'!   equal to nullptr, calls <tt>get_deleter()(old_p)</tt>. Note: The order of these operations is significant','line_number':725,'multiline':False]['text':'!   because the call to <tt>get_deleter()</tt> may destroy *this.','line_number':726,'multiline':False]['text':'!','line_number':727,'multiline':False]['text':'! <b>Postconditions</b>: <tt>get() == p</tt>. Note: The postcondition does not hold if the call to <tt>get_deleter()</tt>','line_number':728,'multiline':False]['text':'!   destroys *this since <tt>this->get()</tt> is no longer a valid expression.','line_number':729,'multiline':False]['text':'! <b>Effects</b>: Same as <tt>reset()</tt>','line_number':733,'multiline':False]['text':'! ','line_number':734,'multiline':False]['text':'! <b>Requires</b>: <tt>get_deleter()</tt> shall be swappable and shall not throw an exception under swap.','line_number':738,'multiline':False]['text':'!','line_number':739,'multiline':False]['text':'! <b>Effects</b>: Invokes swap on the stored pointers and on the stored deleters of *this and u.','line_number':740,'multiline':False]['text':'! <b>Effects</b>: Calls <tt>x.swap(y)</tt>.','line_number':748,'multiline':False]['text':'!','line_number':749,'multiline':False]['text':'! <b>Returns</b>: <tt>x.get() == y.get()</tt>.','line_number':754,'multiline':False]['text':'!','line_number':755,'multiline':False]['text':'! <b>Returns</b>: <tt>x.get() != y.get()</tt>.','line_number':760,'multiline':False]['text':'!','line_number':761,'multiline':False]['text':'! <b>Returns</b>: x.get() < y.get().','line_number':766,'multiline':False]['text':'!','line_number':767,'multiline':False]['text':'! <b>Remarks</b>: This comparison shall induce a','line_number':768,'multiline':False]['text':'!   strict weak ordering betwen pointers.','line_number':769,'multiline':False]['text':'! <b>Returns</b>: !(y < x).','line_number':774,'multiline':False]['text':'!','line_number':775,'multiline':False]['text':'! <b>Returns</b>: y < x.','line_number':780,'multiline':False]['text':'!','line_number':781,'multiline':False]['text':'! <b>Returns</b>:!(x < y).','line_number':786,'multiline':False]['text':'!','line_number':787,'multiline':False]['text':'! <b>Returns</b>:!x.','line_number':792,'multiline':False]['text':'!','line_number':793,'multiline':False]['text':'! <b>Returns</b>:!x.','line_number':798,'multiline':False]['text':'!','line_number':799,'multiline':False]['text':'! <b>Returns</b>: (bool)x.','line_number':804,'multiline':False]['text':'!','line_number':805,'multiline':False]['text':'! <b>Returns</b>: (bool)x.','line_number':810,'multiline':False]['text':'!','line_number':811,'multiline':False]['text':'! <b>Requires</b>: <tt>operator </tt> shall induce a strict weak ordering on unique_ptr<T, D>::pointer values.','line_number':816,'multiline':False]['text':'!','line_number':817,'multiline':False]['text':'! <b>Returns</b>: Returns <tt>x.get() < pointer()</tt>.','line_number':818,'multiline':False]['text':'! <b>Requires</b>: <tt>operator </tt> shall induce a strict weak ordering on unique_ptr<T, D>::pointer values.','line_number':823,'multiline':False]['text':'!','line_number':824,'multiline':False]['text':'! <b>Returns</b>: Returns <tt>pointer() < x.get()</tt>.','line_number':825,'multiline':False]['text':'! <b>Returns</b>: <tt>nullptr < x</tt>.','line_number':830,'multiline':False]['text':'!','line_number':831,'multiline':False]['text':'! <b>Returns</b>: <tt>x < nullptr</tt>.','line_number':836,'multiline':False]['text':'!','line_number':837,'multiline':False]['text':'! <b>Returns</b>: <tt>!(nullptr < x)</tt>.','line_number':842,'multiline':False]['text':'!','line_number':843,'multiline':False]['text':'! <b>Returns</b>: <tt>!(x < nullptr)</tt>.','line_number':848,'multiline':False]['text':'!','line_number':849,'multiline':False]['text':'! <b>Returns</b>: <tt>!(x < nullptr)</tt>.','line_number':854,'multiline':False]['text':'!','line_number':855,'multiline':False]['text':'! <b>Returns</b>: <tt>!(nullptr < x)</tt>.','line_number':860,'multiline':False]['text':'!','line_number':861,'multiline':False]['text':'namespace movelib {','line_number':866,'multiline':False]['text':'namespace boost{','line_number':867,'multiline':False]['text':'#ifndef BOOST_MOVE_UNIQUE_PTR_HPP_INCLUDED','line_number':871,'multiline':False]