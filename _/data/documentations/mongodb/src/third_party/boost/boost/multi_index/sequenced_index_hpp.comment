['text':' Copyright 2003-2021 Joaquin M Lopez Munoz.
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See http://www.boost.org/libs/multi_index for library home page.
 ','line_number':1,'multiline':True]['text':' keep it first to prevent nasty warns in MSVC ','line_number':16,'multiline':True]['text':' sequenced_index adds a layer of sequenced indexing to a given Super ','line_number':69,'multiline':True]['text':' this used in base member initializer list ','line_number':73,'multiline':True]['text':' The "ISO C++ Template Parser" option in CW8.3 has a problem with the
 * lifetime of const references bound to temporaries --precisely what
 * scopeguards are.
 ','line_number':82,'multiline':True]['text':' cross-index access ','line_number':91,'multiline':True]['text':' types ','line_number':106,'multiline':True]['text':' needed to avoid commas in some macros ','line_number':168,'multiline':True]['text':' construct/copy/destroy
   * Default and copy ctors are in the protected section as indices are
   * not supposed to be created on their own. No range ctor either.
   ','line_number':174,'multiline':True]['text':' iterators ','line_number':220,'multiline':True]['text':' capacity ','line_number':259,'multiline':True]['text':' access: no non-const versions provided as sequenced_index
   * handles const elements.
   ','line_number':282,'multiline':True]['text':' modifiers ','line_number':289,'multiline':True]['text':' MSVC++ 6.0 optimizer on safe mode code chokes if this
     * this is not added. Left it for all compilers as it does no
     * harm.
     ','line_number':433,'multiline':True]['text':' MSVC++ 6.0 optimizer on safe mode code chokes if this
     * this is not added. Left it for all compilers as it does no
     * harm.
     ','line_number':454,'multiline':True]['text':' list operations ','line_number':479,'multiline':True]['text':' same container ','line_number':488,'multiline':True]['text':' same container ','line_number':518,'multiline':True]['text':' same container ','line_number':557,'multiline':True]['text':' rearrange operations ','line_number':632,'multiline':True]['text':' the actual copying takes place in subsequent call to copy_() ','line_number':691,'multiline':True]['text':' the container is guaranteed to be empty by now ','line_number':708,'multiline':True]['text':' serialization ','line_number':853,'multiline':True]['text':' invariant stuff ','line_number':876,'multiline':True]['text':' This forwarding function eases things for the boost::mem_fn construct
   * in BOOST_MULTI_INDEX_SEQ_INDEX_CHECK_INVARIANT. Actually,
   * final_check_invariant is already an inherited member function of index.
   ','line_number':897,'multiline':True]['text':' copy-constructible value ','line_number':1028,'multiline':True]['text':' backwards compatibility with old, non-transfer-based splice ','line_number':1034,'multiline':True]['text':' copy-constructible value ','line_number':1046,'multiline':True]['text':' copy-constructible value ','line_number':1079,'multiline':True]['text':' backwards compatibility with old, non-transfer-based splice ','line_number':1085,'multiline':True]['text':' copy-constructible value ','line_number':1099,'multiline':True]['text':' C4355 ','line_number':1132,'multiline':True]['text':' comparison ','line_number':1135,'multiline':True]['text':'  specialized algorithms ','line_number':1203,'multiline':True]['text':' namespace multi_index::detail ','line_number':1213,'multiline':True]['text':' sequenced index specifier ','line_number':1215,'multiline':True]['text':' namespace multi_index ','line_number':1235,'multiline':True]['text':' namespace boost ','line_number':1237,'multiline':True]['text':' Boost.Foreach compatibility ','line_number':1239,'multiline':True]