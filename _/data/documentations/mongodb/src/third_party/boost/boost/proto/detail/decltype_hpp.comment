['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'/ \file decltype.hpp','line_number':2,'multiline':False]['text':'/ Contains definition the BOOST_PROTO_DECLTYPE_() macro and assorted helpers','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':5,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':6,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':' function 'xxx' marked as __forceinline not inlined','line_number':41,'multiline':False]['text':' We're STILL using Boost.Typeof on MSVC even for msvc-11.0 because of this bug:','line_number':44,'multiline':False]['text':' https://connect.microsoft.com/VisualStudio/feedback/details/765392/decltype-of-a-pointer-to-member-operator-gets-ref-qualification-wrong','line_number':45,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':68,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':87,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':91,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':95,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':109,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':158,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':162,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':174,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':185,'multiline':False]['text':' Other specializations are generated by the preprocessor','line_number':196,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':199,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':212,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':231,'multiline':False]['text':'','line_number':234,'multiline':True]['text':'','line_number':242,'multiline':True]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':244,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':270,'multiline':False]['text':' result_of_ is a wrapper around boost::result_of that also handles "invocations" of','line_number':271,'multiline':False]['text':' member object pointers.','line_number':272,'multiline':False]['text':' If V is not a U, then it is a (smart) pointer and we can always return an lvalue.','line_number':284,'multiline':False]['text':' Otherwise, we can only return an lvalue if we are given one.','line_number':285,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':299,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':323,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':351,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////////////////','line_number':376,'multiline':False]['text':' normalize a function type for use with boost::result_of','line_number':377,'multiline':False]['text':'// Tests for result_of_fixup','line_number':409,'multiline':False]['text':'struct bar {};','line_number':410,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<bar,        result_of_fixup<bar>::type>));','line_number':411,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<bar const,  result_of_fixup<bar const>::type>));','line_number':412,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<bar,        result_of_fixup<bar &>::type>));','line_number':413,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<bar const,  result_of_fixup<bar const &>::type>));','line_number':414,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<void(*)(),  result_of_fixup<void(*)()>::type>));','line_number':415,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<void(*)(),  result_of_fixup<void(* const)()>::type>));','line_number':416,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<void(*)(),  result_of_fixup<void(* const &)()>::type>));','line_number':417,'multiline':False]['text':'BOOST_MPL_ASSERT((is_same<void(*)(),  result_of_fixup<void(&)()>::type>));','line_number':418,'multiline':False]['text':' Other overloads generated by the preprocessor','line_number':438,'multiline':False]['text':' namespace detail','line_number':446,'multiline':False]