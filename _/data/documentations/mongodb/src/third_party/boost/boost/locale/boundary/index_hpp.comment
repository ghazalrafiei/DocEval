['text':'','line_number':1,'multiline':False]['text':'  Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':'  Distributed under the Boost Software License, Version 1.0. (See','line_number':4,'multiline':False]['text':'  accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]['text':'  http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':'/','line_number':39,'multiline':False]['text':'/ \defgroup boundary Boundary Analysis','line_number':40,'multiline':False]['text':'/','line_number':41,'multiline':False]['text':'/ This module contains all operations required for %boundary analysis of text: character, word, like and sentence boundaries','line_number':42,'multiline':False]['text':'/','line_number':43,'multiline':False]['text':'/ @{','line_number':44,'multiline':False]['text':'/','line_number':45,'multiline':False]['text':'/ \cond INTERNAL','line_number':47,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' Optimize for most common cases','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' C++0x requires that string is continious in memory and all known','line_number':89,'multiline':False]['text':' string implementations','line_number':90,'multiline':False]['text':' do this because of c_str() support. ','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':' make sure we not acess index[size]','line_number':322,'multiline':False]['text':' last and first are always valid regardless of mark','line_number':470,'multiline':False]['text':' details','line_number':492,'multiline':False]['text':'/ \endcond','line_number':494,'multiline':False]['text':'/','line_number':503,'multiline':False]['text':'/ \brief This class holds an index of segments in the text range and allows to iterate over them ','line_number':504,'multiline':False]['text':'/','line_number':505,'multiline':False]['text':'/ This class is provides \ref begin() and \ref end() member functions that return bidirectional iterators','line_number':506,'multiline':False]['text':'/ to the \ref segment objects.','line_number':507,'multiline':False]['text':'/','line_number':508,'multiline':False]['text':'/ It provides two options on way of selecting segments:','line_number':509,'multiline':False]['text':'/','line_number':510,'multiline':False]['text':'/ -   \ref rule(rule_type mask) - a mask that allows to select only specific types of segments according to','line_number':511,'multiline':False]['text':'/     various masks %as \ref word_any.','line_number':512,'multiline':False]['text':'/     \n','line_number':513,'multiline':False]['text':'/     The default is to select any types of boundaries.','line_number':514,'multiline':False]['text':'/     \n ','line_number':515,'multiline':False]['text':'/     For example: using word %boundary analysis, when the provided mask is \ref word_kana then the iterators','line_number':516,'multiline':False]['text':'/     would iterate only over the words containing Kana letters and \ref word_any would select all types of','line_number':517,'multiline':False]['text':'/     words excluding ranges that consist of white space and punctuation marks. So iterating over the text','line_number':518,'multiline':False]['text':'/     "to be or not to be?" with \ref word_any rule would return segments "to", "be", "or", "not", "to", "be", instead','line_number':519,'multiline':False]['text':'/     of default "to", " ", "be", " ", "or", " ", "not", " ", "to", " ", "be", "?".','line_number':520,'multiline':False]['text':'/ -   \ref full_select(bool how) - a flag that defines the way a range is selected if the rule of the previous','line_number':521,'multiline':False]['text':'/     %boundary point does not fit the selected rule.','line_number':522,'multiline':False]['text':'/     \n','line_number':523,'multiline':False]['text':'/     For example: We want to fetch all sentences from the following text: "Hello! How\nare you?".','line_number':524,'multiline':False]['text':'/     \n','line_number':525,'multiline':False]['text':'/     This text contains three %boundary points separating it to sentences by different rules:','line_number':526,'multiline':False]['text':'/     - The exclamation mark "!" ends the sentence "Hello!"','line_number':527,'multiline':False]['text':'/     - The line feed that splits the sentence "How\nare you?" into two parts.','line_number':528,'multiline':False]['text':'/     - The question mark that ends the second sentence.','line_number':529,'multiline':False]['text':'/     \n','line_number':530,'multiline':False]['text':'/     If you would only change the \ref rule() to \ref sentence_term then the segment_index would','line_number':531,'multiline':False]['text':'/     provide two sentences "Hello!" and "are you?" %as only them actually terminated with required','line_number':532,'multiline':False]['text':'/     terminator "!" or "?". But changing \ref full_select() to true, the selected segment would include','line_number':533,'multiline':False]['text':'/     all the text up to previous valid %boundary point and would return two expected sentences:','line_number':534,'multiline':False]['text':'/     "Hello!" and "How\nare you?".','line_number':535,'multiline':False]['text':'/     ','line_number':536,'multiline':False]['text':'/ This class allows to find a segment according to the given iterator in range using \ref find() member','line_number':537,'multiline':False]['text':'/ function.','line_number':538,'multiline':False]['text':'/','line_number':539,'multiline':False]['text':'/ \note','line_number':540,'multiline':False]['text':'/','line_number':541,'multiline':False]['text':'/ -   Changing any of the options - \ref rule() or \ref full_select() and of course re-indexing the text','line_number':542,'multiline':False]['text':'/     invalidates existing iterators and they can't be used any more.','line_number':543,'multiline':False]['text':'/ -   segment_index can be created from boundary_point_index or other segment_index that was created with','line_number':544,'multiline':False]['text':'/     same \ref boundary_type.  This is very fast operation %as they shared same index','line_number':545,'multiline':False]['text':'/     and it does not require its regeneration.','line_number':546,'multiline':False]['text':'/','line_number':547,'multiline':False]['text':'/ \see','line_number':548,'multiline':False]['text':'/','line_number':549,'multiline':False]['text':'/ - \ref boundary_point_index','line_number':550,'multiline':False]['text':'/ - \ref segment','line_number':551,'multiline':False]['text':'/ - \ref boundary_point','line_number':552,'multiline':False]['text':'/','line_number':553,'multiline':False]['text':'/','line_number':559,'multiline':False]['text':'/ The type of the iterator used to iterate over the original text','line_number':560,'multiline':False]['text':'/','line_number':561,'multiline':False]['text':'/','line_number':564,'multiline':False]['text':'/ The bidirectional iterator that iterates over \ref value_type objects.','line_number':565,'multiline':False]['text':'/','line_number':566,'multiline':False]['text':'/ -   The iterators may be invalidated by use of any non-const member function','line_number':567,'multiline':False]['text':'/     including but not limited to \ref rule(rule_type) and \ref full_select(bool).','line_number':568,'multiline':False]['text':'/ -   The returned value_type object is valid %as long %as iterator points to it.','line_number':569,'multiline':False]['text':'/     So this following code is wrong %as t used after p was updated:','line_number':570,'multiline':False]['text':'/     \code','line_number':571,'multiline':False]['text':'/     segment_index<some_iterator>::iterator p=index.begin();','line_number':572,'multiline':False]['text':'/     segment<some_iterator> &t = *p;','line_number':573,'multiline':False]['text':'/     ++p;','line_number':574,'multiline':False]['text':'/     cout << t.str() << endl;','line_number':575,'multiline':False]['text':'/     \endcode','line_number':576,'multiline':False]['text':'/','line_number':577,'multiline':False]['text':'/','line_number':579,'multiline':False]['text':'/ \copydoc iterator','line_number':580,'multiline':False]['text':'/','line_number':581,'multiline':False]['text':'/','line_number':587,'multiline':False]['text':'/ The type dereferenced by the \ref iterator and \ref const_iterator. It is','line_number':588,'multiline':False]['text':'/ an object that represents selected segment.','line_number':589,'multiline':False]['text':'/','line_number':590,'multiline':False]['text':'/','line_number':593,'multiline':False]['text':'/ Default constructor. ','line_number':594,'multiline':False]['text':'/','line_number':595,'multiline':False]['text':'/ \note','line_number':596,'multiline':False]['text':'/','line_number':597,'multiline':False]['text':'/ When this object is constructed by default it does not include a valid index, thus','line_number':598,'multiline':False]['text':'/ calling \ref begin(), \ref end() or \ref find() member functions would lead to undefined','line_number':599,'multiline':False]['text':'/ behavior','line_number':600,'multiline':False]['text':'/','line_number':601,'multiline':False]['text':'/','line_number':605,'multiline':False]['text':'/ Create a segment_index for %boundary analysis \ref boundary_type "type" of the text','line_number':606,'multiline':False]['text':'/ in range [begin,end) using a rule \a mask for locale \a loc.','line_number':607,'multiline':False]['text':'/','line_number':608,'multiline':False]['text':'/','line_number':620,'multiline':False]['text':'/ Create a segment_index for %boundary analysis \ref boundary_type "type" of the text','line_number':621,'multiline':False]['text':'/ in range [begin,end) selecting all possible segments (full mask) for locale \a loc.','line_number':622,'multiline':False]['text':'/','line_number':623,'multiline':False]['text':'/','line_number':635,'multiline':False]['text':'/ Create a segment_index from a \ref boundary_point_index. It copies all indexing information','line_number':636,'multiline':False]['text':'/ and used default rule (all possible segments)','line_number':637,'multiline':False]['text':'/','line_number':638,'multiline':False]['text':'/ This operation is very cheap, so if you use boundary_point_index and segment_index on same text','line_number':639,'multiline':False]['text':'/ range it is much better to create one from another rather then indexing the same','line_number':640,'multiline':False]['text':'/ range twice.','line_number':641,'multiline':False]['text':'/','line_number':642,'multiline':False]['text':'/ \note \ref rule() flags are not copied','line_number':643,'multiline':False]['text':'/','line_number':644,'multiline':False]['text':'/','line_number':646,'multiline':False]['text':'/ Copy an index from a \ref boundary_point_index. It copies all indexing information','line_number':647,'multiline':False]['text':'/ and uses the default rule (all possible segments)','line_number':648,'multiline':False]['text':'/','line_number':649,'multiline':False]['text':'/ This operation is very cheap, so if you use boundary_point_index and segment_index on same text','line_number':650,'multiline':False]['text':'/ range it is much better to create one from another rather then indexing the same','line_number':651,'multiline':False]['text':'/ range twice.','line_number':652,'multiline':False]['text':'/','line_number':653,'multiline':False]['text':'/ \note \ref rule() flags are not copied','line_number':654,'multiline':False]['text':'/','line_number':655,'multiline':False]['text':'/','line_number':659,'multiline':False]['text':'/ Create a new index for %boundary analysis \ref boundary_type "type" of the text','line_number':660,'multiline':False]['text':'/ in range [begin,end) for locale \a loc.','line_number':661,'multiline':False]['text':'/','line_number':662,'multiline':False]['text':'/ \note \ref rule() and \ref full_select() remain unchanged.','line_number':663,'multiline':False]['text':'/','line_number':664,'multiline':False]['text':'/','line_number':670,'multiline':False]['text':'/ Get the \ref iterator on the beginning of the segments range.','line_number':671,'multiline':False]['text':'/','line_number':672,'multiline':False]['text':'/ Preconditions: the segment_index should have a mapping','line_number':673,'multiline':False]['text':'/','line_number':674,'multiline':False]['text':'/ \note','line_number':675,'multiline':False]['text':'/','line_number':676,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':677,'multiline':False]['text':'/','line_number':678,'multiline':False]['text':'/','line_number':684,'multiline':False]['text':'/ Get the \ref iterator on the ending of the segments range.','line_number':685,'multiline':False]['text':'/','line_number':686,'multiline':False]['text':'/ Preconditions: the segment_index should have a mapping','line_number':687,'multiline':False]['text':'/','line_number':688,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':689,'multiline':False]['text':'/','line_number':690,'multiline':False]['text':'/','line_number':696,'multiline':False]['text':'/ Find a first valid segment following a position \a p. ','line_number':697,'multiline':False]['text':'/','line_number':698,'multiline':False]['text':'/ If \a p is inside a valid segment this segment is selected:','line_number':699,'multiline':False]['text':'/','line_number':700,'multiline':False]['text':'/ For example: For \ref word %boundary analysis with \ref word_any rule():','line_number':701,'multiline':False]['text':'/','line_number':702,'multiline':False]['text':'/ - "to| be or ", would point to "be",','line_number':703,'multiline':False]['text':'/ - "t|o be or ", would point to "to",','line_number':704,'multiline':False]['text':'/ - "to be or| ", would point to end.','line_number':705,'multiline':False]['text':'/','line_number':706,'multiline':False]['text':'/                 ','line_number':707,'multiline':False]['text':'/ Preconditions: the segment_index should have a mapping and \a p should be valid iterator','line_number':708,'multiline':False]['text':'/ to the text in the mapped range.','line_number':709,'multiline':False]['text':'/','line_number':710,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':711,'multiline':False]['text':'/','line_number':712,'multiline':False]['text':'/','line_number':718,'multiline':False]['text':'/ Get the mask of rules that are used','line_number':719,'multiline':False]['text':'/ ','line_number':720,'multiline':False]['text':'/','line_number':725,'multiline':False]['text':'/ Set the mask of rules that are used','line_number':726,'multiline':False]['text':'/ ','line_number':727,'multiline':False]['text':'/','line_number':733,'multiline':False]['text':'/ Get the full_select property value -  should segment include in the range','line_number':734,'multiline':False]['text':'/ values that not belong to specific \ref rule() or not.','line_number':735,'multiline':False]['text':'/','line_number':736,'multiline':False]['text':'/ The default value is false.','line_number':737,'multiline':False]['text':'/','line_number':738,'multiline':False]['text':'/ For example for \ref sentence %boundary with rule \ref sentence_term the segments','line_number':739,'multiline':False]['text':'/ of text "Hello! How\nare you?" are "Hello!\", "are you?" when full_select() is false','line_number':740,'multiline':False]['text':'/ because "How\n" is selected %as sentence by a rule spits the text by line feed. If full_select()','line_number':741,'multiline':False]['text':'/ is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the','line_number':742,'multiline':False]['text':'/ following part "are you?"','line_number':743,'multiline':False]['text':'/','line_number':744,'multiline':False]['text':'/','line_number':751,'multiline':False]['text':'/ Set the full_select property value -  should segment include in the range','line_number':752,'multiline':False]['text':'/ values that not belong to specific \ref rule() or not.','line_number':753,'multiline':False]['text':'/','line_number':754,'multiline':False]['text':'/ The default value is false.','line_number':755,'multiline':False]['text':'/','line_number':756,'multiline':False]['text':'/ For example for \ref sentence %boundary with rule \ref sentence_term the segments','line_number':757,'multiline':False]['text':'/ of text "Hello! How\nare you?" are "Hello!\", "are you?" when full_select() is false','line_number':758,'multiline':False]['text':'/ because "How\n" is selected %as sentence by a rule spits the text by line feed. If full_select()','line_number':759,'multiline':False]['text':'/ is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the','line_number':760,'multiline':False]['text':'/ following part "are you?"','line_number':761,'multiline':False]['text':'/','line_number':762,'multiline':False]['text':'/','line_number':777,'multiline':False]['text':'/ \brief This class holds an index of \ref boundary_point "boundary points" and allows iterating','line_number':778,'multiline':False]['text':'/ over them.','line_number':779,'multiline':False]['text':'/','line_number':780,'multiline':False]['text':'/ This class is provides \ref begin() and \ref end() member functions that return bidirectional iterators','line_number':781,'multiline':False]['text':'/ to the \ref boundary_point objects.','line_number':782,'multiline':False]['text':'/','line_number':783,'multiline':False]['text':'/ It provides an option that affects selecting %boundary points according to different rules:','line_number':784,'multiline':False]['text':'/ using \ref rule(rule_type mask) member function. It allows to set a mask that select only specific','line_number':785,'multiline':False]['text':'/ types of %boundary points like \ref sentence_term.','line_number':786,'multiline':False]['text':'/','line_number':787,'multiline':False]['text':'/ For example for a sentence %boundary analysis of a text "Hello! How\nare you?" when the default','line_number':788,'multiline':False]['text':'/ rule is used the %boundary points would be:','line_number':789,'multiline':False]['text':'/','line_number':790,'multiline':False]['text':'/ - "|Hello! How\nare you?"','line_number':791,'multiline':False]['text':'/ - "Hello! |How\nare you?"','line_number':792,'multiline':False]['text':'/ - "Hello! How\n|are you?"','line_number':793,'multiline':False]['text':'/ - "Hello! How\nare you?|"','line_number':794,'multiline':False]['text':'/','line_number':795,'multiline':False]['text':'/ However if \ref rule() is set to \ref sentence_term then the selected %boundary points would be: ','line_number':796,'multiline':False]['text':'/','line_number':797,'multiline':False]['text':'/ - "|Hello! How\nare you?"','line_number':798,'multiline':False]['text':'/ - "Hello! |How\nare you?"','line_number':799,'multiline':False]['text':'/ - "Hello! How\nare you?|"','line_number':800,'multiline':False]['text':'/ ','line_number':801,'multiline':False]['text':'/ Such that a %boundary point defined by a line feed character would be ignored.','line_number':802,'multiline':False]['text':'/     ','line_number':803,'multiline':False]['text':'/ This class allows to find a boundary_point according to the given iterator in range using \ref find() member','line_number':804,'multiline':False]['text':'/ function.','line_number':805,'multiline':False]['text':'/','line_number':806,'multiline':False]['text':'/ \note','line_number':807,'multiline':False]['text':'/ -   Even an empty text range [x,x) considered to have a one %boundary point x.','line_number':808,'multiline':False]['text':'/ -   \a a and \a b points of the range [a,b) are always considered %boundary points','line_number':809,'multiline':False]['text':'/     regardless the rules used.','line_number':810,'multiline':False]['text':'/ -   Changing any of the option \ref rule() or course re-indexing the text','line_number':811,'multiline':False]['text':'/     invalidates existing iterators and they can't be used any more.','line_number':812,'multiline':False]['text':'/ -   boundary_point_index can be created from segment_index or other boundary_point_index that was created with','line_number':813,'multiline':False]['text':'/     same \ref boundary_type.  This is very fast operation %as they shared same index','line_number':814,'multiline':False]['text':'/     and it does not require its regeneration.','line_number':815,'multiline':False]['text':'/','line_number':816,'multiline':False]['text':'/ \see','line_number':817,'multiline':False]['text':'/','line_number':818,'multiline':False]['text':'/ - \ref segment_index','line_number':819,'multiline':False]['text':'/ - \ref boundary_point','line_number':820,'multiline':False]['text':'/ - \ref segment','line_number':821,'multiline':False]['text':'/','line_number':822,'multiline':False]['text':'/','line_number':828,'multiline':False]['text':'/ The type of the iterator used to iterate over the original text','line_number':829,'multiline':False]['text':'/','line_number':830,'multiline':False]['text':'/','line_number':833,'multiline':False]['text':'/ The bidirectional iterator that iterates over \ref value_type objects.','line_number':834,'multiline':False]['text':'/','line_number':835,'multiline':False]['text':'/ -   The iterators may be invalidated by use of any non-const member function','line_number':836,'multiline':False]['text':'/     including but not limited to \ref rule(rule_type) member function.','line_number':837,'multiline':False]['text':'/ -   The returned value_type object is valid %as long %as iterator points to it.','line_number':838,'multiline':False]['text':'/     So this following code is wrong %as t used after p was updated:','line_number':839,'multiline':False]['text':'/     \code','line_number':840,'multiline':False]['text':'/     boundary_point_index<some_iterator>::iterator p=index.begin();','line_number':841,'multiline':False]['text':'/     boundary_point<some_iterator> &t = *p;','line_number':842,'multiline':False]['text':'/     ++p;','line_number':843,'multiline':False]['text':'/     rule_type r = t->rule();','line_number':844,'multiline':False]['text':'/     \endcode','line_number':845,'multiline':False]['text':'/','line_number':846,'multiline':False]['text':'/','line_number':848,'multiline':False]['text':'/ \copydoc iterator','line_number':849,'multiline':False]['text':'/','line_number':850,'multiline':False]['text':'/','line_number':856,'multiline':False]['text':'/ The type dereferenced by the \ref iterator and \ref const_iterator. It is','line_number':857,'multiline':False]['text':'/ an object that represents the selected \ref boundary_point "boundary point".','line_number':858,'multiline':False]['text':'/','line_number':859,'multiline':False]['text':'/','line_number':862,'multiline':False]['text':'/ Default constructor. ','line_number':863,'multiline':False]['text':'/','line_number':864,'multiline':False]['text':'/ \note','line_number':865,'multiline':False]['text':'/','line_number':866,'multiline':False]['text':'/ When this object is constructed by default it does not include a valid index, thus','line_number':867,'multiline':False]['text':'/ calling \ref begin(), \ref end() or \ref find() member functions would lead to undefined','line_number':868,'multiline':False]['text':'/ behavior','line_number':869,'multiline':False]['text':'/','line_number':870,'multiline':False]['text':'/','line_number':875,'multiline':False]['text':'/ Create a segment_index for %boundary analysis \ref boundary_type "type" of the text','line_number':876,'multiline':False]['text':'/ in range [begin,end) using a rule \a mask for locale \a loc.','line_number':877,'multiline':False]['text':'/','line_number':878,'multiline':False]['text':'/','line_number':889,'multiline':False]['text':'/ Create a segment_index for %boundary analysis \ref boundary_type "type" of the text','line_number':890,'multiline':False]['text':'/ in range [begin,end) selecting all possible %boundary points (full mask) for locale \a loc.','line_number':891,'multiline':False]['text':'/','line_number':892,'multiline':False]['text':'/','line_number':903,'multiline':False]['text':'/ Create a boundary_point_index from a \ref segment_index. It copies all indexing information','line_number':904,'multiline':False]['text':'/ and uses the default rule (all possible %boundary points)','line_number':905,'multiline':False]['text':'/','line_number':906,'multiline':False]['text':'/ This operation is very cheap, so if you use boundary_point_index and segment_index on same text','line_number':907,'multiline':False]['text':'/ range it is much better to create one from another rather then indexing the same','line_number':908,'multiline':False]['text':'/ range twice.','line_number':909,'multiline':False]['text':'/','line_number':910,'multiline':False]['text':'/ \note \ref rule() flags are not copied','line_number':911,'multiline':False]['text':'/','line_number':912,'multiline':False]['text':'/','line_number':914,'multiline':False]['text':'/ Copy a boundary_point_index from a \ref segment_index. It copies all indexing information','line_number':915,'multiline':False]['text':'/ and keeps the current \ref rule() unchanged','line_number':916,'multiline':False]['text':'/','line_number':917,'multiline':False]['text':'/ This operation is very cheap, so if you use boundary_point_index and segment_index on same text','line_number':918,'multiline':False]['text':'/ range it is much better to create one from another rather then indexing the same','line_number':919,'multiline':False]['text':'/ range twice.','line_number':920,'multiline':False]['text':'/','line_number':921,'multiline':False]['text':'/ \note \ref rule() flags are not copied','line_number':922,'multiline':False]['text':'/','line_number':923,'multiline':False]['text':'/','line_number':926,'multiline':False]['text':'/ Create a new index for %boundary analysis \ref boundary_type "type" of the text','line_number':927,'multiline':False]['text':'/ in range [begin,end) for locale \a loc.','line_number':928,'multiline':False]['text':'/','line_number':929,'multiline':False]['text':'/ \note \ref rule() remains unchanged.','line_number':930,'multiline':False]['text':'/','line_number':931,'multiline':False]['text':'/','line_number':937,'multiline':False]['text':'/ Get the \ref iterator on the beginning of the %boundary points range.','line_number':938,'multiline':False]['text':'/','line_number':939,'multiline':False]['text':'/ Preconditions: this boundary_point_index should have a mapping','line_number':940,'multiline':False]['text':'/','line_number':941,'multiline':False]['text':'/ \note','line_number':942,'multiline':False]['text':'/','line_number':943,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':944,'multiline':False]['text':'/','line_number':945,'multiline':False]['text':'/','line_number':951,'multiline':False]['text':'/ Get the \ref iterator on the ending of the %boundary points range.','line_number':952,'multiline':False]['text':'/','line_number':953,'multiline':False]['text':'/ Preconditions: this boundary_point_index should have a mapping','line_number':954,'multiline':False]['text':'/','line_number':955,'multiline':False]['text':'/ \note','line_number':956,'multiline':False]['text':'/','line_number':957,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':958,'multiline':False]['text':'/','line_number':959,'multiline':False]['text':'/','line_number':965,'multiline':False]['text':'/ Find a first valid %boundary point on a position \a p or following it.','line_number':966,'multiline':False]['text':'/','line_number':967,'multiline':False]['text':'/ For example: For \ref word %boundary analysis of the text "to be or"','line_number':968,'multiline':False]['text':'/','line_number':969,'multiline':False]['text':'/ - "|to be", would return %boundary point at "|to be",','line_number':970,'multiline':False]['text':'/ - "t|o be", would point to "to| be"','line_number':971,'multiline':False]['text':'/                 ','line_number':972,'multiline':False]['text':'/ Preconditions: the boundary_point_index should have a mapping and \a p should be valid iterator','line_number':973,'multiline':False]['text':'/ to the text in the mapped range.','line_number':974,'multiline':False]['text':'/','line_number':975,'multiline':False]['text':'/ The returned iterator is invalidated by access to any non-const member functions of this object','line_number':976,'multiline':False]['text':'/','line_number':977,'multiline':False]['text':'/','line_number':983,'multiline':False]['text':'/ Get the mask of rules that are used','line_number':984,'multiline':False]['text':'/ ','line_number':985,'multiline':False]['text':'/','line_number':990,'multiline':False]['text':'/ Set the mask of rules that are used','line_number':991,'multiline':False]['text':'/ ','line_number':992,'multiline':False]['text':'/ \cond INTERNAL  ','line_number':1006,'multiline':False]['text':'/ \endcond','line_number':1035,'multiline':False]['text':'/< convenience typedef','line_number':1037,'multiline':False]['text':'/< convenience typedef','line_number':1038,'multiline':False]['text':'/< convenience typedef','line_number':1040,'multiline':False]['text':'/< convenience typedef','line_number':1043,'multiline':False]['text':'/< convenience typedef','line_number':1046,'multiline':False]['text':'/< convenience typedef','line_number':1047,'multiline':False]['text':'/< convenience typedef','line_number':1049,'multiline':False]['text':'/< convenience typedef','line_number':1052,'multiline':False]['text':'/< convenience typedef','line_number':1055,'multiline':False]['text':'/< convenience typedef','line_number':1056,'multiline':False]['text':'/< convenience typedef','line_number':1058,'multiline':False]['text':'/< convenience typedef','line_number':1061,'multiline':False]['text':'/< convenience typedef','line_number':1064,'multiline':False]['text':'/< convenience typedef','line_number':1065,'multiline':False]['text':'/< convenience typedef','line_number':1067,'multiline':False]['text':'/< convenience typedef','line_number':1070,'multiline':False]['text':' boundary','line_number':1075,'multiline':False]['text':' locale','line_number':1077,'multiline':False]['text':' boost','line_number':1078,'multiline':False]['text':'/','line_number':1080,'multiline':False]['text':'/ \example boundary.cpp','line_number':1081,'multiline':False]['text':'/ Example of using segment_index','line_number':1082,'multiline':False]['text':'/ \example wboundary.cpp','line_number':1083,'multiline':False]['text':'/ Example of using segment_index over wide strings','line_number':1084,'multiline':False]['text':'/','line_number':1085,'multiline':False]['text':' vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4','line_number':1092,'multiline':False]