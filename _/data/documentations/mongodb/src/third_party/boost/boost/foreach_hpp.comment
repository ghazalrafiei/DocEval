['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':' foreach.hpp header file','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Copyright 2004 Eric Niebler.','line_number':4,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':' See http://www.boost.org/libs/foreach for documentation','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' Credits:','line_number':10,'multiline':False]['text':'  Anson Tsao        - for the initial inspiration and several good suggestions.','line_number':11,'multiline':False]['text':'  Thorsten Ottosen  - for Boost.Range, and for suggesting a way to detect','line_number':12,'multiline':False]['text':'                      const-qualified rvalues at compile time on VC7.1+','line_number':13,'multiline':False]['text':'  Russell Hind      - For help porting to Borland','line_number':14,'multiline':False]['text':'  Alisdair Meredith - For help porting to Borland','line_number':15,'multiline':False]['text':'  Stefan Slapeta    - For help porting to Intel','line_number':16,'multiline':False]['text':'  David Jenkins     - For help finding a Microsoft Code Analysis bug','line_number':17,'multiline':False]['text':'  mimomorin@...     - For a patch to use rvalue refs on supporting compilers','line_number':18,'multiline':False]['text':' MS compatible compilers support #pragma once','line_number':22,'multiline':False]['text':' for std::pair','line_number':28,'multiline':False]['text':' Define a compiler generic null pointer value','line_number':33,'multiline':False]['text':' Some compilers let us detect even const-qualified rvalues at compile-time','line_number':40,'multiline':False]['text':' Some compilers allow temporaries to be bound to non-const references.','line_number':49,'multiline':False]['text':' These compilers make it impossible to for BOOST_FOREACH to detect','line_number':50,'multiline':False]['text':' temporaries and avoid reevaluation of the collection expression.','line_number':51,'multiline':False]['text':' Some compilers do not correctly implement the lvalue/rvalue conversion','line_number':58,'multiline':False]['text':' rules of the ternary conditional operator.','line_number':59,'multiline':False]['text':' forward declarations for iterator_range','line_number':105,'multiline':False]['text':' forward declarations for sub_range','line_number':109,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':115,'multiline':False]['text':' in_range','line_number':116,'multiline':False]['text':'','line_number':117,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':124,'multiline':False]['text':' boost::foreach::is_lightweight_proxy','line_number':125,'multiline':False]['text':'   Specialize this for user-defined collection types if they are inexpensive to copy.','line_number':126,'multiline':False]['text':'   This tells BOOST_FOREACH it can avoid the rvalue/lvalue detection stuff.','line_number':127,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':134,'multiline':False]['text':' boost::foreach::is_noncopyable','line_number':135,'multiline':False]['text':'   Specialize this for user-defined collection types if they cannot be copied.','line_number':136,'multiline':False]['text':'   This also tells BOOST_FOREACH to avoid the rvalue/lvalue detection stuff.','line_number':137,'multiline':False]['text':' namespace foreach','line_number':155,'multiline':False]['text':' namespace boost','line_number':157,'multiline':False]['text':' vc6/7 needs help ordering the following overloads','line_number':159,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':166,'multiline':False]['text':' boost_foreach_is_lightweight_proxy','line_number':167,'multiline':False]['text':'   Another customization point for the is_lightweight_proxy optimization,','line_number':168,'multiline':False]['text':'   this one works on legacy compilers. Overload boost_foreach_is_lightweight_proxy','line_number':169,'multiline':False]['text':'   at the global namespace for your type.','line_number':170,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':191,'multiline':False]['text':' boost_foreach_is_noncopyable','line_number':192,'multiline':False]['text':'   Another customization point for the is_noncopyable trait,','line_number':193,'multiline':False]['text':'   this one works on legacy compilers. Overload boost_foreach_is_noncopyable','line_number':194,'multiline':False]['text':'   at the global namespace for your type.','line_number':195,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':206,'multiline':False]['text':' Define some utilities for assessing the properties of expressions','line_number':207,'multiline':False]['text':'','line_number':208,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':246,'multiline':False]['text':' auto_any_t/auto_any','line_number':247,'multiline':False]['text':'  General utility for putting an object of any type into automatic storage','line_number':248,'multiline':False]['text':' auto_any_base must evaluate to false in boolean context so that','line_number':251,'multiline':False]['text':' they can be declared in if() statements.','line_number':252,'multiline':False]['text':' temporaries of type auto_any will be bound to const auto_any_base','line_number':267,'multiline':False]['text':' references, but we still want to be able to mutate the stored','line_number':268,'multiline':False]['text':' data, so declare it as mutable.','line_number':269,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':283,'multiline':False]['text':' type2type','line_number':284,'multiline':False]['text':'','line_number':285,'multiline':False]['text':' **** READ THIS IF YOUR COMPILE BREAKS HERE ****','line_number':344,'multiline':False]['text':'','line_number':345,'multiline':False]['text':' There is an ambiguity about how to iterate over arrays of char and wchar_t. ','line_number':346,'multiline':False]['text':' Should the last array element be treated as a null terminator to be skipped, or','line_number':347,'multiline':False]['text':' is it just like any other element in the array? To fix the problem, you must','line_number':348,'multiline':False]['text':' say which behavior you want.','line_number':349,'multiline':False]['text':'','line_number':350,'multiline':False]['text':' To treat the container as a null-terminated string, merely cast it to a','line_number':351,'multiline':False]['text':' char const *, as in BOOST_FOREACH( char ch, (char const *)"hello" ) ...','line_number':352,'multiline':False]['text':'','line_number':353,'multiline':False]['text':' To treat the container as an array, use boost::as_array() in <boost/range/as_array.hpp>,','line_number':354,'multiline':False]['text':' as in BOOST_FOREACH( char ch, boost::as_array("hello") ) ...','line_number':355,'multiline':False]['text':' If the type is a pointer to a null terminated string (as opposed ','line_number':358,'multiline':False]['text':' to an array type), there is no ambiguity.','line_number':359,'multiline':False]['text':' **** READ THIS IF YOUR COMPILE BREAKS HERE ****','line_number':373,'multiline':False]['text':'','line_number':374,'multiline':False]['text':' There is an ambiguity about how to iterate over arrays of char and wchar_t. ','line_number':375,'multiline':False]['text':' Should the last array element be treated as a null terminator to be skipped, or','line_number':376,'multiline':False]['text':' is it just like any other element in the array? To fix the problem, you must','line_number':377,'multiline':False]['text':' say which behavior you want.','line_number':378,'multiline':False]['text':'','line_number':379,'multiline':False]['text':' To treat the container as a null-terminated string, merely cast it to a','line_number':380,'multiline':False]['text':' char const *, as in BOOST_FOREACH( char ch, (char const *)"hello" ) ...','line_number':381,'multiline':False]['text':'','line_number':382,'multiline':False]['text':' To treat the container as an array, use boost::as_array() in <boost/range/as_array.hpp>,','line_number':383,'multiline':False]['text':' as in BOOST_FOREACH( char ch, boost::as_array("hello") ) ...','line_number':384,'multiline':False]['text':' If the type is a pointer to a null terminated string (as opposed ','line_number':387,'multiline':False]['text':' to an array type), there is no ambiguity.','line_number':388,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':404,'multiline':False]['text':' encode_type','line_number':405,'multiline':False]['text':'','line_number':406,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':419,'multiline':False]['text':' set_false','line_number':420,'multiline':False]['text':'','line_number':421,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':428,'multiline':False]['text':' to_ptr','line_number':429,'multiline':False]['text':'','line_number':430,'multiline':False]['text':' Borland needs a little extra help with arrays','line_number':438,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':447,'multiline':False]['text':' derefof','line_number':448,'multiline':False]['text':'','line_number':449,'multiline':False]['text':' This is a work-around for a compiler bug in Borland. If T* is a pointer to array type U(*)[N],','line_number':453,'multiline':False]['text':' then dereferencing it results in a U* instead of U(&)[N]. The cast forces the issue.','line_number':454,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':469,'multiline':False]['text':' Rvalue references makes it drop-dead simple to detect at compile time','line_number':470,'multiline':False]['text':' whether an expression is an rvalue.','line_number':471,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':472,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':479,'multiline':False]['text':' Detect at compile-time whether an expression yields an rvalue or','line_number':480,'multiline':False]['text':' an lvalue. This is rather non-standard, but some popular compilers','line_number':481,'multiline':False]['text':' accept it.','line_number':482,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':483,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':485,'multiline':False]['text':' rvalue_probe','line_number':486,'multiline':False]['text':'','line_number':487,'multiline':False]['text':' can't ever return an array by value','line_number':492,'multiline':False]['text':' never called','line_number':496,'multiline':False]['text':' never called','line_number':497,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':513,'multiline':False]['text':' Detect at run-time whether an expression yields an rvalue','line_number':514,'multiline':False]['text':' or an lvalue. This is 100% standard C++, but not all compilers','line_number':515,'multiline':False]['text':' accept it. Also, it causes FOREACH to break when used with non-','line_number':516,'multiline':False]['text':' copyable collection types.','line_number':517,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':518,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':520,'multiline':False]['text':' rvalue_probe','line_number':521,'multiline':False]['text':'','line_number':522,'multiline':False]['text':' can't ever return an array or an abstract type by value','line_number':533,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':566,'multiline':False]['text':' simple_variant','line_number':567,'multiline':False]['text':'  holds either a T or a T const*','line_number':568,'multiline':False]['text':' If the collection is an array or is noncopyable, it must be an lvalue.','line_number':614,'multiline':False]['text':' If the collection is a lightweight proxy, treat it as an rvalue','line_number':615,'multiline':False]['text':' BUGBUG what about a noncopyable proxy?','line_number':616,'multiline':False]['text':' Otherwise, we must determine at runtime whether it's an lvalue or rvalue','line_number':624,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':633,'multiline':False]['text':' contain','line_number':634,'multiline':False]['text':'','line_number':635,'multiline':False]['text':' rvalue','line_number':637,'multiline':False]['text':' lvalue','line_number':643,'multiline':False]['text':' Cannot seem to get sunpro to handle addressof() with array types.','line_number':645,'multiline':False]['text':'///////////////////////////////////////////////////////////////////////////','line_number':662,'multiline':False]['text':' begin','line_number':663,'multiline':False]['text':'','line_number':664,'multiline':False]['text':' rvalue','line_number':667,'multiline':False]['text':' lvalue','line_number':675,'multiline':False]['text':' null-terminated C-style strings','line_number':696,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':702,'multiline':False]['text':' end','line_number':703,'multiline':False]['text':'','line_number':704,'multiline':False]['text':' rvalue','line_number':707,'multiline':False]['text':' lvalue','line_number':715,'multiline':False]['text':' null-terminated C-style strings','line_number':736,'multiline':False]['text':' not used','line_number':738,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':742,'multiline':False]['text':' done','line_number':743,'multiline':False]['text':'','line_number':744,'multiline':False]['text':' null-terminated C-style strings','line_number':754,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':760,'multiline':False]['text':' next','line_number':761,'multiline':False]['text':'','line_number':762,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':770,'multiline':False]['text':' deref','line_number':771,'multiline':False]['text':'','line_number':772,'multiline':False]['text':'///////////////////////////////////////////////////////////////////////////','line_number':781,'multiline':False]['text':' rbegin','line_number':782,'multiline':False]['text':'','line_number':783,'multiline':False]['text':' rvalue','line_number':786,'multiline':False]['text':' lvalue','line_number':794,'multiline':False]['text':' null-terminated C-style strings','line_number':815,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':824,'multiline':False]['text':' rend','line_number':825,'multiline':False]['text':'','line_number':826,'multiline':False]['text':' rvalue','line_number':829,'multiline':False]['text':' lvalue','line_number':837,'multiline':False]['text':' null-terminated C-style strings','line_number':858,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':865,'multiline':False]['text':' rdone','line_number':866,'multiline':False]['text':'','line_number':867,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':875,'multiline':False]['text':' rnext','line_number':876,'multiline':False]['text':'','line_number':877,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':885,'multiline':False]['text':' rderef','line_number':886,'multiline':False]['text':'','line_number':887,'multiline':False]['text':' namespace foreach_detail_','line_number':896,'multiline':False]['text':' namespace boost','line_number':897,'multiline':False]['text':' Suppress a bogus code analysis warning on vc8+','line_number':899,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':906,'multiline':False]['text':' Define a macro for giving hidden variables a unique name. Not strictly','line_number':907,'multiline':False]['text':' needed, but eliminates some warnings on some compilers.','line_number':908,'multiline':False]['text':' With some versions of MSVC, use of __LINE__ to create unique identifiers','line_number':910,'multiline':False]['text':' can fail when the Edit-and-Continue debug flag is used.','line_number':911,'multiline':False]['text':' A sneaky way to get the type of the collection without evaluating the expression','line_number':917,'multiline':False]['text':' returns true_* if the type is noncopyable','line_number':921,'multiline':False]['text':' returns true_* if the type is a lightweight proxy (and is not noncopyable)','line_number':927,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':936,'multiline':False]['text':' R-values and const R-values supported here with zero runtime overhead','line_number':937,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':938,'multiline':False]['text':' No variable is needed to track the rvalue-ness of the collection expression','line_number':940,'multiline':False]['text':' Evaluate the collection expression','line_number':944,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':954,'multiline':False]['text':' R-values and const R-values supported here','line_number':955,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':956,'multiline':False]['text':' Declare a variable to track the rvalue-ness of the collection expression','line_number':958,'multiline':False]['text':' Evaluate the collection expression, and detect if it is an lvalue or and rvalue','line_number':963,'multiline':False]['text':' The rvalue/lvalue-ness of the collection expression is determined dynamically, unless','line_number':967,'multiline':False]['text':' the type is an array or is noncopyable or is non-const, in which case we know it's an lvalue.','line_number':968,'multiline':False]['text':' If the type happens to be a lightweight proxy, always make a copy.','line_number':969,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':980,'multiline':False]['text':' R-values supported here, const R-values NOT supported here','line_number':981,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':982,'multiline':False]['text':' No variable is needed to track the rvalue-ness of the collection expression','line_number':984,'multiline':False]['text':' Evaluate the collection expression','line_number':988,'multiline':False]['text':' Determine whether the collection expression is an lvalue or an rvalue.','line_number':992,'multiline':False]['text':' NOTE: this gets the answer wrong for const rvalues.','line_number':993,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1000,'multiline':False]['text':' R-values NOT supported here','line_number':1001,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1002,'multiline':False]['text':' No variable is needed to track the rvalue-ness of the collection expression','line_number':1004,'multiline':False]['text':' Evaluate the collection expression','line_number':1008,'multiline':False]['text':' Can't use rvalues with BOOST_FOREACH (unless they are lightweight proxies)','line_number':1012,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1079,'multiline':False]['text':' BOOST_FOREACH','line_number':1080,'multiline':False]['text':'','line_number':1081,'multiline':False]['text':'   For iterating over collections. Collections can be','line_number':1082,'multiline':False]['text':'   arrays, null-terminated strings, or STL containers.','line_number':1083,'multiline':False]['text':'   The loop variable can be a value or reference. For','line_number':1084,'multiline':False]['text':'   example:','line_number':1085,'multiline':False]['text':'','line_number':1086,'multiline':False]['text':'   std::list<int> int_list(/*stuff*/);','line_number':1087,'multiline':False]['text':'   BOOST_FOREACH(int &i, int_list)','line_number':1088,'multiline':False]['text':'   {','line_number':1089,'multiline':False]['text':'       /* ','line_number':1090,'multiline':False]['text':'        * loop body goes here.','line_number':1091,'multiline':False]['text':'        * i is a reference to the int in int_list.','line_number':1092,'multiline':False]['text':'        */','line_number':1093,'multiline':False]['text':'   }','line_number':1094,'multiline':False]['text':'','line_number':1095,'multiline':False]['text':'   Alternately, you can declare the loop variable first,','line_number':1096,'multiline':False]['text':'   so you can access it after the loop finishes. Obviously,','line_number':1097,'multiline':False]['text':'   if you do it this way, then the loop variable cannot be','line_number':1098,'multiline':False]['text':'   a reference.','line_number':1099,'multiline':False]['text':'','line_number':1100,'multiline':False]['text':'   int i;','line_number':1101,'multiline':False]['text':'   BOOST_FOREACH(i, int_list)','line_number':1102,'multiline':False]['text':'       { ... }','line_number':1103,'multiline':False]['text':'','line_number':1104,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1116,'multiline':False]['text':' BOOST_REVERSE_FOREACH','line_number':1117,'multiline':False]['text':'','line_number':1118,'multiline':False]['text':'   For iterating over collections in reverse order. In','line_number':1119,'multiline':False]['text':'   all other respects, BOOST_REVERSE_FOREACH is like','line_number':1120,'multiline':False]['text':'   BOOST_FOREACH.','line_number':1121,'multiline':False]['text':'','line_number':1122,'multiline':False]