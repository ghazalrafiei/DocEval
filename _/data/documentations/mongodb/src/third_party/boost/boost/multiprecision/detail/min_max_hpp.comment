['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2016 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' Expression template overloads for (min) and (max):','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' Introduced in response to https://svn.boost.org/trac/boost/ticket/11149','line_number':16,'multiline':False]['text':' note that these can not legally be injected into namespace std, and that doing so','line_number':17,'multiline':False]['text':' may break future enhancements to the standard.  None the less adding','line_number':18,'multiline':False]['text':' namespace std{ using boost::multiprecision::(min); using boost::multiprecision::(max); }','line_number':19,'multiline':False]['text':' to your code may get some generic code working that wouldn't work otherwise.','line_number':20,'multiline':False]['text':'','line_number':21,'multiline':False]['text':' The use of enable_if on the return type is to avoid poisoning std::min/max,','line_number':22,'multiline':False]['text':' otherwise attempting to make an explicit call to min<long>(a, b) when these and std','line_number':23,'multiline':False]['text':' versions are in scope, will cause the compiler to try to instantiate the signatures','line_number':24,'multiline':False]['text':' for our versions as well as the std ones, which in turn instantiates number<long>','line_number':25,'multiline':False]['text':' which fails to compile as "long" is not a valid backend type.','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':' namespace boost::multiprecision','line_number':104,'multiline':False]