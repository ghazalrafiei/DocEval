['text':'=============================================================================
    Copyright (c) 2011 Eric Niebler

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================','line_number':1,'multiline':True]['text':' fun(seq, state, context)','line_number':27,'multiline':False]['text':'  seq: a non-segmented range','line_number':28,'multiline':False]['text':'  state: the state of the fold so far','line_number':29,'multiline':False]['text':'  context: the path to the current range','line_number':30,'multiline':False]['text':'','line_number':31,'multiline':False]['text':' returns: (state', fcontinue)','line_number':32,'multiline':False]['text':'auto push_context(cur, end, context)','line_number':113,'multiline':False]['text':'{','line_number':114,'multiline':False]['text':'  return push_back(context, segment_sequence(iterator_range(cur, end)));','line_number':115,'multiline':False]['text':'}','line_number':116,'multiline':False]['text':'auto make_segmented_iterator(cur, end, context)','line_number':131,'multiline':False]['text':'{','line_number':132,'multiline':False]['text':'  return segmented_iterator(push_context(cur, end, context));','line_number':133,'multiline':False]['text':'}','line_number':134,'multiline':False]['text':'','line_number':135,'multiline':False]['text':'auto segmented_fold_until_impl(seq, state, context, fun)','line_number':136,'multiline':False]['text':'{','line_number':137,'multiline':False]['text':'  if (is_segmented(seq))','line_number':138,'multiline':False]['text':'  {','line_number':139,'multiline':False]['text':'    segmented_fold_until_on_segments(segments(seq), state, context, fun);','line_number':140,'multiline':False]['text':'  }','line_number':141,'multiline':False]['text':'  else','line_number':142,'multiline':False]['text':'  {','line_number':143,'multiline':False]['text':'    return fun(seq, state, context);','line_number':144,'multiline':False]['text':'  }','line_number':145,'multiline':False]['text':'}','line_number':146,'multiline':False]['text':'auto segmented_fold_until_on_segments(segs, state, context, fun)','line_number':202,'multiline':False]['text':'{','line_number':203,'multiline':False]['text':'  auto cur = begin(segs), end = end(segs);','line_number':204,'multiline':False]['text':'  for (; cur != end; ++cur)','line_number':205,'multiline':False]['text':'  {','line_number':206,'multiline':False]['text':'    if (empty(*cur))','line_number':207,'multiline':False]['text':'      continue;','line_number':208,'multiline':False]['text':'    auto context` = push_context(cur, end, context);','line_number':209,'multiline':False]['text':'    state = segmented_fold_until_impl(*cur, state, context`, fun);','line_number':210,'multiline':False]['text':'    if (!second(state))','line_number':211,'multiline':False]['text':'      return state;','line_number':212,'multiline':False]['text':'  }','line_number':213,'multiline':False]['text':'}','line_number':214,'multiline':False]['text':' begin != end and !empty(*begin)','line_number':225,'multiline':False]['text':' continue','line_number':286,'multiline':False]['text':' break','line_number':302,'multiline':False]