['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'/ \file when.hpp','line_number':2,'multiline':False]['text':'/ Definition of when transform.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':5,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':6,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':' function 'xxx' marked as __forceinline not inlined','line_number':29,'multiline':False]['text':' Note: do not evaluate is_callable<R> in this scope.','line_number':44,'multiline':False]['text':' R may be an incomplete type at this point.','line_number':45,'multiline':False]['text':' OK to evaluate is_callable<R> here. R should be compete by now.','line_number':50,'multiline':False]['text':' "R" is a function to call','line_number':54,'multiline':False]['text':' "R" is an object to construct','line_number':55,'multiline':False]['text':'/ Evaluate <tt>R(A0,A1,...)</tt> as a transform either with','line_number':61,'multiline':False]['text':'/ <tt>call\<\></tt> or with <tt>make\<\></tt> depending on','line_number':62,'multiline':False]['text':'/ whether <tt>is_callable\<R\>::value</tt> is \c true or','line_number':63,'multiline':False]['text':'/ \c false.','line_number':64,'multiline':False]['text':'/','line_number':65,'multiline':False]['text':'/ \param e The current expression','line_number':66,'multiline':False]['text':'/ \param s The current state','line_number':67,'multiline':False]['text':'/ \param d An arbitrary data','line_number':68,'multiline':False]['text':'/ \pre <tt>matches\<Expr, Grammar\>::value</tt> is \c true','line_number':69,'multiline':False]['text':'/ \return <tt>which()(e, s, d)</tt>','line_number':70,'multiline':False]['text':'/ \brief A grammar element and a PrimitiveTransform that associates','line_number':84,'multiline':False]['text':'/ a transform with the grammar.','line_number':85,'multiline':False]['text':'/','line_number':86,'multiline':False]['text':'/ Use <tt>when\<\></tt> to override a grammar's default transform','line_number':87,'multiline':False]['text':'/ with a custom transform. It is for used when composing larger','line_number':88,'multiline':False]['text':'/ transforms by associating smaller transforms with individual','line_number':89,'multiline':False]['text':'/ rules in your grammar, as in the following transform which','line_number':90,'multiline':False]['text':'/ counts the number of terminals in an expression.','line_number':91,'multiline':False]['text':'/','line_number':92,'multiline':False]['text':'/ \code','line_number':93,'multiline':False]['text':'/ // Count the terminals in an expression tree.','line_number':94,'multiline':False]['text':'/ // Must be invoked with initial state == mpl::int_<0>().','line_number':95,'multiline':False]['text':'/ struct CountLeaves','line_number':96,'multiline':False]['text':'/   : or_<','line_number':97,'multiline':False]['text':'/         when<terminal<_>, mpl::next<_state>()>','line_number':98,'multiline':False]['text':'/       , otherwise<fold<_, _state, CountLeaves> >','line_number':99,'multiline':False]['text':'/     >','line_number':100,'multiline':False]['text':'/ {};','line_number':101,'multiline':False]['text':'/ \endcode','line_number':102,'multiline':False]['text':'/','line_number':103,'multiline':False]['text':'/ In <tt>when\<G, T\></tt>, when \c T is a class type it is a','line_number':104,'multiline':False]['text':'/ PrimitiveTransform and the following equivalencies hold:','line_number':105,'multiline':False]['text':'/','line_number':106,'multiline':False]['text':'/ <tt>boost::result_of\<when\<G,T\>(E,S,V)\>::type</tt> is the same as','line_number':107,'multiline':False]['text':'/ <tt>boost::result_of\<T(E,S,V)\>::type</tt>.','line_number':108,'multiline':False]['text':'/','line_number':109,'multiline':False]['text':'/ <tt>when\<G,T\>()(e,s,d)</tt> is the same as','line_number':110,'multiline':False]['text':'/ <tt>T()(e,s,d)</tt>.','line_number':111,'multiline':False]['text':'= Grammar','line_number':112,'multiline':True]['text':'/ \brief A specialization that treats function pointer Transforms as','line_number':121,'multiline':False]['text':'/ if they were function type Transforms.','line_number':122,'multiline':False]['text':'/','line_number':123,'multiline':False]['text':'/ This specialization requires that \c Fun is actually a function type.','line_number':124,'multiline':False]['text':'/','line_number':125,'multiline':False]['text':'/ This specialization is required for nested transforms such as','line_number':126,'multiline':False]['text':'/ <tt>when\<G, T0(T1(_))\></tt>. In C++, functions that are used as','line_number':127,'multiline':False]['text':'/ parameters to other functions automatically decay to funtion','line_number':128,'multiline':False]['text':'/ pointer types. In other words, the type <tt>T0(T1(_))</tt> is','line_number':129,'multiline':False]['text':'/ indistinguishable from <tt>T0(T1(*)(_))</tt>. This specialization','line_number':130,'multiline':False]['text':'/ is required to handle these nested function pointer type transforms','line_number':131,'multiline':False]['text':'/ properly.','line_number':132,'multiline':False]['text':'/ \brief Syntactic sugar for <tt>when\<_, Fun\></tt>, for use','line_number':138,'multiline':False]['text':'/ in grammars to handle all the cases not yet handled.','line_number':139,'multiline':False]['text':'/','line_number':140,'multiline':False]['text':'/ Use <tt>otherwise\<T\></tt> in your grammars as a synonym for','line_number':141,'multiline':False]['text':'/ <tt>when\<_, T\></tt> as in the following transform which','line_number':142,'multiline':False]['text':'/ counts the number of terminals in an expression.','line_number':143,'multiline':False]['text':'/','line_number':144,'multiline':False]['text':'/ \code','line_number':145,'multiline':False]['text':'/ // Count the terminals in an expression tree.','line_number':146,'multiline':False]['text':'/ // Must be invoked with initial state == mpl::int_<0>().','line_number':147,'multiline':False]['text':'/ struct CountLeaves','line_number':148,'multiline':False]['text':'/   : or_<','line_number':149,'multiline':False]['text':'/         when<terminal<_>, mpl::next<_state>()>','line_number':150,'multiline':False]['text':'/       , otherwise<fold<_, _state, CountLeaves> >','line_number':151,'multiline':False]['text':'/     >','line_number':152,'multiline':False]['text':'/ {};','line_number':153,'multiline':False]['text':'/ \endcode','line_number':154,'multiline':False]['text':' Define the transforms global','line_number':162,'multiline':False]['text':'/ \brief This specialization uses the Data parameter as a collection','line_number':168,'multiline':False]['text':'/ of transforms that can be indexed by the specified rule.','line_number':169,'multiline':False]['text':'/','line_number':170,'multiline':False]['text':'/ Use <tt>when\<T, external_transform\></tt> in your code when you would like','line_number':171,'multiline':False]['text':'/ to define a grammar once and use it to evaluate expressions with','line_number':172,'multiline':False]['text':'/ many different sets of transforms. The transforms are found by','line_number':173,'multiline':False]['text':'/ using the Data parameter as a map from rules to transforms.','line_number':174,'multiline':False]['text':'/','line_number':175,'multiline':False]['text':'/ See \c action_map for an example.','line_number':176,'multiline':False]['text':'/ \brief For defining a map of Rule/Transform pairs for use with','line_number':197,'multiline':False]['text':'/ <tt>when\<T, external_transform\></tt> to make transforms external to the grammar','line_number':198,'multiline':False]['text':'/','line_number':199,'multiline':False]['text':'/ The following code defines a grammar with a couple of external transforms.','line_number':200,'multiline':False]['text':'/ It also defines an action_map that maps from rules to transforms. It then','line_number':201,'multiline':False]['text':'/ passes that transforms map at the Data parameter to the grammar. In this way,','line_number':202,'multiline':False]['text':'/ the behavior of the grammar can be modified post-hoc by passing a different','line_number':203,'multiline':False]['text':'/ action_map.','line_number':204,'multiline':False]['text':'/','line_number':205,'multiline':False]['text':'/ \code','line_number':206,'multiline':False]['text':'/ struct int_terminal','line_number':207,'multiline':False]['text':'/   : proto::terminal<int>','line_number':208,'multiline':False]['text':'/ {};','line_number':209,'multiline':False]['text':'/ ','line_number':210,'multiline':False]['text':'/ struct char_terminal','line_number':211,'multiline':False]['text':'/   : proto::terminal<char>','line_number':212,'multiline':False]['text':'/ {};','line_number':213,'multiline':False]['text':'/ ','line_number':214,'multiline':False]['text':'/ struct my_grammar','line_number':215,'multiline':False]['text':'/   : proto::or_<','line_number':216,'multiline':False]['text':'/         proto::when< int_terminal, proto::external_transform >','line_number':217,'multiline':False]['text':'/       , proto::when< char_terminal, proto::external_transform >','line_number':218,'multiline':False]['text':'/       , proto::when<','line_number':219,'multiline':False]['text':'/             proto::plus< my_grammar, my_grammar >','line_number':220,'multiline':False]['text':'/           , proto::fold< _, int(), my_grammar >','line_number':221,'multiline':False]['text':'/         >','line_number':222,'multiline':False]['text':'/     >','line_number':223,'multiline':False]['text':'/ {};','line_number':224,'multiline':False]['text':'/ ','line_number':225,'multiline':False]['text':'/ struct my_transforms','line_number':226,'multiline':False]['text':'/   : proto::external_transforms<','line_number':227,'multiline':False]['text':'/         proto::when<int_terminal, print(proto::_value)>','line_number':228,'multiline':False]['text':'/       , proto::when<char_terminal, print(proto::_value)>','line_number':229,'multiline':False]['text':'/     >','line_number':230,'multiline':False]['text':'/ {};','line_number':231,'multiline':False]['text':'/','line_number':232,'multiline':False]['text':'/ proto::literal<int> i(1);','line_number':233,'multiline':False]['text':'/ proto::literal<char> c('a');','line_number':234,'multiline':False]['text':'/ my_transforms trx;','line_number':235,'multiline':False]['text':'/','line_number':236,'multiline':False]['text':'/ // Evaluate "i+c" using my_grammar with the specified transforms:','line_number':237,'multiline':False]['text':'/ my_grammar()(i + c, 0, trx);','line_number':238,'multiline':False]['text':'/ \endcode','line_number':239,'multiline':False]['text':' Other specializations of proto::when are generated by the preprocessor...','line_number':251,'multiline':False]['text':'/ INTERNAL ONLY','line_number':254,'multiline':False]['text':'/','line_number':255,'multiline':False]['text':' namespace boost::proto','line_number':261,'multiline':False]