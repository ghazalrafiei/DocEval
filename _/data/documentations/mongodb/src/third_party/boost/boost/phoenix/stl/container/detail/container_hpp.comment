['text':'=============================================================================
    Copyright (c) 2004 Angus Leeming
    Copyright (c) 2004 Joel de Guzman

    Distributed under the Boost Software License, Version 1.0. (See accompanying 
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================','line_number':1,'multiline':True]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':19,'multiline':False]['text':'','line_number':20,'multiline':False]['text':'  Metafunctions "value_type_of", "key_type_of" etc.','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':'      These metafunctions define a typedef "type" that returns the nested','line_number':23,'multiline':False]['text':'      type if it exists. If not then the typedef returns void.','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':'      For example, "value_type_of<std::vector<int> >::type" is "int" whilst','line_number':26,'multiline':False]['text':'      "value_type_of<double>::type" is "void".','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':'      I use a macro to define structs "value_type_of" etc simply to cut','line_number':29,'multiline':False]['text':'      down on the amount of code. The macro is #undef-ed immediately after','line_number':30,'multiline':False]['text':'      its final use.','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':'///////////////////////////////////////////////////////////////c//////////////','line_number':33,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':'  Const-Qualified types.','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':'      Many of the stl member functions have const and non-const','line_number':62,'multiline':False]['text':'      overloaded versions that return distinct types. For example:','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':'          iterator begin();','line_number':65,'multiline':False]['text':'          const_iterator begin() const;','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':'      The three class templates defined below,','line_number':68,'multiline':False]['text':'      const_qualified_reference_of, const_qualified_iterator_of','line_number':69,'multiline':False]['text':'      and const_qualified_reverse_iterator_of provide a means to extract','line_number':70,'multiline':False]['text':'      this return type automatically.','line_number':71,'multiline':False]['text':'','line_number':72,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':73,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':110,'multiline':False]['text':'','line_number':111,'multiline':False]['text':'  has_mapped_type<C>','line_number':112,'multiline':False]['text':'','line_number':113,'multiline':False]['text':'      Given a container C, determine if it is a map, multimap, unordered_map,','line_number':114,'multiline':False]['text':'      or unordered_multimap by checking if it has a member type named "mapped_type".','line_number':115,'multiline':False]['text':'','line_number':116,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':117,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':'  has_key_type<C>','line_number':139,'multiline':False]['text':'','line_number':140,'multiline':False]['text':'      Given a container C, determine if it is a Associative Container','line_number':141,'multiline':False]['text':'      by checking if it has a member type named "key_type".','line_number':142,'multiline':False]['text':'','line_number':143,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':144,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':'  is_key_type_of<C, Arg>','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':'      Lazy evaluation friendly predicate.','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':167,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':'  map_insert_returns_pair<C>','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':'      Distinguish a map from a multimap by checking the return type','line_number':178,'multiline':False]['text':'      of its "insert" member function. A map returns a pair while','line_number':179,'multiline':False]['text':'      a multimap returns an iterator.','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':182,'multiline':False]['text':'  Cool implementation of map_insert_returns_pair by Daniel Wallin.','line_number':185,'multiline':False]['text':'  Thanks Daniel!!! I owe you a Pizza!','line_number':186,'multiline':False]['text':' namespace boost::phoenix::stl','line_number':209,'multiline':False]['text':' BOOST_PHOENIX_STL_CONTAINER_TRAITS_HPP','line_number':211,'multiline':False]