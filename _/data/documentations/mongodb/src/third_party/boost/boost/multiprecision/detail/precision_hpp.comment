['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2018 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' We have an arbitrary precision integer, take it's "precision" as the','line_number':25,'multiline':False]['text':' location of the most-significant-bit less the location of the','line_number':26,'multiline':False]['text':' least-significant-bit, ie the number of bits required to represent the','line_number':27,'multiline':False]['text':' the value assuming we will have an exponent to shift things by:','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' We have an arbitrary precision rational, take it's "precision" as the','line_number':36,'multiline':False]['text':' the larger of the "precision" of numerator and denominator:','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' For string literals:','line_number':83,'multiline':False]['text':'','line_number':148,'multiline':False]['text':' This function is never called: in C++17 it won't be compiled either:','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' namespace boost::multiprecision::detail','line_number':311,'multiline':False]['text':' BOOST_MP_IS_BACKEND_HPP','line_number':313,'multiline':False]