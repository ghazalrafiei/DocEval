['text':' boost random/detail/signed_unsigned_tools.hpp header file
 *
 * Copyright Jens Maurer 2006
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See http://www.boost.org for most recent version including documentation.
 ','line_number':1,'multiline':True]['text':'
 * Compute x - y, we know that x >= y, return an unsigned value.
 ','line_number':23,'multiline':True]['text':' signed ','line_number':31,'multiline':True]['text':' signed ','line_number':38,'multiline':True]['text':' because x >= y, it follows that x >= 0, too','line_number':43,'multiline':False]['text':' y < 0','line_number':45,'multiline':False]['text':' avoid the nasty two's complement case for y == min()','line_number':46,'multiline':False]['text':' both x and y are negative: no signed overflow','line_number':48,'multiline':False]['text':'
 * Compute x + y, x is unsigned, result fits in type of "y".
 ','line_number':53,'multiline':True]['text':' signed or else T2 has more digits than T1 so the cast always works - needed when T2 is a multiprecision type and T1 is a native integer ','line_number':61,'multiline':True]['text':' signed ','line_number':68,'multiline':True]['text':' y < 0','line_number':75,'multiline':False]['text':' result >= 0 after subtraction','line_number':76,'multiline':False]['text':' avoid the nasty two's complement edge case for y == min()','line_number':77,'multiline':False]['text':' abs(x) < abs(y), thus T2 able to represent x','line_number':79,'multiline':False]['text':' namespace detail','line_number':84,'multiline':False]['text':' namespace random','line_number':85,'multiline':False]['text':' namespace boost','line_number':86,'multiline':False]['text':' BOOST_RANDOM_DETAIL_SIGNED_UNSIGNED_TOOLS','line_number':88,'multiline':False]