['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'  Copyright 2012-2020 John Maddock.','line_number':2,'multiline':False]['text':'  Copyright 2020 Madhur Chauhan.','line_number':3,'multiline':False]['text':'  Copyright 2021 Matt Borland.','line_number':4,'multiline':False]['text':'  Distributed under the Boost Software License, Version 1.0.','line_number':5,'multiline':False]['text':'  (See accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':'   https://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' Comparison operators for cpp_int_backend:','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':' lsb etc','line_number':20,'multiline':False]['text':' std::gcd','line_number':23,'multiline':False]['text':' conditional expression is constant','line_number':39,'multiline':False]['text':' unary minus operator applied to unsigned type, result still unsigned','line_number':40,'multiline':False]['text':' Forward decleration of gcd and lcm functions','line_number':43,'multiline':False]['text':' namespace boost::multiprecision::detail','line_number':52,'multiline':False]['text':'val','line_number':87,'multiline':True]['text':'','line_number':140,'multiline':False]['text':' We have one more limb to extract, but may not need all the bits, so treat this as a special case:','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':' Overflow:','line_number':149,'multiline':False]['text':' Overflow:','line_number':163,'multiline':False]['text':' Extract the bits we need, and then manually round the result:','line_number':200,'multiline':False]['text':' Perform rounding:','line_number':228,'multiline':False]['text':'','line_number':277,'multiline':False]['text':' Get the location of the least-significant-bit:','line_number':278,'multiline':False]['text':'','line_number':279,'multiline':False]['text':'','line_number':284,'multiline':False]['text':' Find the index of the least significant limb that is non-zero:','line_number':285,'multiline':False]['text':'','line_number':286,'multiline':False]['text':'','line_number':290,'multiline':False]['text':' Find the index of the least significant bit within that limb:','line_number':291,'multiline':False]['text':'','line_number':292,'multiline':False]['text':'','line_number':314,'multiline':False]['text':' Get the location of the most-significant-bit:','line_number':315,'multiline':False]['text':'','line_number':316,'multiline':False]['text':'','line_number':321,'multiline':False]['text':' Find the index of the most significant bit that is non-zero:','line_number':322,'multiline':False]['text':'','line_number':323,'multiline':False]['text':'','line_number':344,'multiline':False]['text':' We really shouldn't need to be disabling this warning, but it really does appear to be','line_number':345,'multiline':False]['text':' spurious.  The warning appears only when in release mode, and asserts are on.','line_number':346,'multiline':False]['text':'','line_number':347,'multiline':False]['text':' fixed precision overflow','line_number':380,'multiline':False]['text':' fixed precision overflow','line_number':412,'multiline':False]['text':' boundary cases','line_number':493,'multiline':False]['text':'','line_number':593,'multiline':False]['text':' These 2 overloads take care of gcd against an (unsigned) short etc:','line_number':594,'multiline':False]['text':'','line_number':595,'multiline':False]['text':'','line_number':614,'multiline':False]['text':' What follows is Lehmer's GCD algorithm:','line_number':615,'multiline':False]['text':' Essentially this uses the leading digit(s) of U and V','line_number':616,'multiline':False]['text':' only to run a "simulated" Euclid algorithm.  It stops','line_number':617,'multiline':False]['text':' when the calculated quotient differs from what would have been','line_number':618,'multiline':False]['text':' the true quotient.  At that point the cosequences are used to','line_number':619,'multiline':False]['text':' calculate the new U and V.  A nice lucid description appears','line_number':620,'multiline':False]['text':' in "An Analysis of Lehmer's Euclidean GCD Algorithm",','line_number':621,'multiline':False]['text':' by Jonathan Sorenson.  https://www.researchgate.net/publication/2424634_An_Analysis_of_Lehmer%27s_Euclidean_GCD_Algorithm','line_number':622,'multiline':False]['text':' DOI: 10.1145/220346.220378.','line_number':623,'multiline':False]['text':'','line_number':624,'multiline':False]['text':' There are two versions of this algorithm here, and both are "double digit"','line_number':625,'multiline':False]['text':' variations: which is to say if there are k bits per limb, then they extract','line_number':626,'multiline':False]['text':' 2k bits into a double_limb_type and then run the algorithm on that.  The first','line_number':627,'multiline':False]['text':' version is a straightforward version of the algorithm, and is designed for','line_number':628,'multiline':False]['text':' situations where double_limb_type is a native integer (for example where','line_number':629,'multiline':False]['text':' limb_type is a 32-bit integer on a 64-bit machine).  For 32-bit limbs it','line_number':630,'multiline':False]['text':' reduces the size of U by about 30 bits per call.  The second is a more complex','line_number':631,'multiline':False]['text':' version for situations where double_limb_type is a synthetic type: for example','line_number':632,'multiline':False]['text':' __int128.  For 64 bit limbs it reduces the size of U by about 62 bits per call.','line_number':633,'multiline':False]['text':'','line_number':634,'multiline':False]['text':' The complexity of the algorithm given by Sorenson is roughly O(ln^2(N)) for','line_number':635,'multiline':False]['text':' two N bit numbers.','line_number':636,'multiline':False]['text':'','line_number':637,'multiline':False]['text':' The original double-digit version of the algorithm is described in:','line_number':638,'multiline':False]['text':' ','line_number':639,'multiline':False]['text':' "A Double Digit Lehmer-Euclid Algorithm for Finding the GCD of Long Integers",','line_number':640,'multiline':False]['text':' Tudor Jebelean, J Symbolic Computation, 1995 (19), 145.','line_number':641,'multiline':False]['text':'','line_number':642,'multiline':False]['text':'','line_number':644,'multiline':False]['text':' When double_limb_type is a native integer type then we should just use it and not worry about the consequences.','line_number':645,'multiline':False]['text':' This can eliminate approximately a full limb with each call.','line_number':646,'multiline':False]['text':'','line_number':647,'multiline':False]['text':'','line_number':651,'multiline':False]['text':' Extract the leading 2 * bits_per_limb bits from U and V:','line_number':652,'multiline':False]['text':'','line_number':653,'multiline':False]['text':'','line_number':664,'multiline':False]['text':' Co-sequences x an y: we need only the last 3 values of these,','line_number':665,'multiline':False]['text':' the first 2 values are known correct, the third gets checked','line_number':666,'multiline':False]['text':' in each loop operation, and we terminate when they go wrong.','line_number':667,'multiline':False]['text':'','line_number':668,'multiline':False]['text':' x[i+0] is positive for even i.','line_number':669,'multiline':False]['text':' y[i+0] is positive for odd i.','line_number':670,'multiline':False]['text':'','line_number':671,'multiline':False]['text':' However we track only absolute values here:','line_number':672,'multiline':False]['text':'','line_number':673,'multiline':False]['text':'','line_number':693,'multiline':False]['text':' We must make sure that y[2] occupies a single limb otherwise','line_number':694,'multiline':False]['text':' the multiprecision multiplications below would be much more expensive.','line_number':695,'multiline':False]['text':' This can sometimes lose us one iteration, but is worth it for improved','line_number':696,'multiline':False]['text':' calculation efficiency.','line_number':697,'multiline':False]['text':'','line_number':698,'multiline':False]['text':'','line_number':701,'multiline':False]['text':' These are Jebelean's exact termination conditions:','line_number':702,'multiline':False]['text':'','line_number':703,'multiline':False]['text':' No change to U and V we've stalled!','line_number':728,'multiline':False]['text':'','line_number':735,'multiline':False]['text':' Update U and V.','line_number':736,'multiline':False]['text':' We have:','line_number':737,'multiline':False]['text':'','line_number':738,'multiline':False]['text':' U = x[0]U + y[0]V and','line_number':739,'multiline':False]['text':' V = x[1]U + y[1]V.','line_number':740,'multiline':False]['text':'','line_number':741,'multiline':False]['text':' But since we track only absolute values of x and y','line_number':742,'multiline':False]['text':' we have to take account of the implied signs and perform','line_number':743,'multiline':False]['text':' the appropriate subtraction depending on the whether i is','line_number':744,'multiline':False]['text':' even or odd:','line_number':745,'multiline':False]['text':'','line_number':746,'multiline':False]['text':'','line_number':804,'multiline':False]['text':' Since we have stripped all common powers of 2 from U and V at the start','line_number':805,'multiline':False]['text':' if either are even at this point, we can remove stray powers of 2 now.','line_number':806,'multiline':False]['text':' Note that it is not possible for *both* U and V to be even at this point.','line_number':807,'multiline':False]['text':'','line_number':808,'multiline':False]['text':' This has an adverse effect on performance for high bit counts, but has','line_number':809,'multiline':False]['text':' a significant positive effect for smaller counts.','line_number':810,'multiline':False]['text':'','line_number':811,'multiline':False]['text':'','line_number':827,'multiline':False]['text':' This branch is taken when double_limb_type is a synthetic type with no native hardware support.','line_number':828,'multiline':False]['text':' For example __int128.  The assumption is that add/subtract/multiply of double_limb_type are efficient,','line_number':829,'multiline':False]['text':' but that division is very slow.','line_number':830,'multiline':False]['text':'','line_number':831,'multiline':False]['text':' We begin with a specialized routine for division.','line_number':832,'multiline':False]['text':' We know that most of the time this is called the result will be 1.','line_number':833,'multiline':False]['text':' For small limb counts, this almost doubles the performance of Lehmer's routine!','line_number':834,'multiline':False]['text':'','line_number':835,'multiline':False]['text':' precondition on entry.','line_number':838,'multiline':False]['text':'','line_number':855,'multiline':False]['text':' Extract the leading 2*bits_per_limb bits from U and V:','line_number':856,'multiline':False]['text':'','line_number':857,'multiline':False]['text':'','line_number':874,'multiline':False]['text':' Cosequences are stored as limb_types, we take care not to overflow these:','line_number':875,'multiline':False]['text':'','line_number':876,'multiline':False]['text':' x[i+0] is positive for even i.','line_number':877,'multiline':False]['text':' y[i+0] is positive for odd i.','line_number':878,'multiline':False]['text':'','line_number':879,'multiline':False]['text':' However we track only absolute values here:','line_number':880,'multiline':False]['text':'','line_number':881,'multiline':False]['text':'','line_number':891,'multiline':False]['text':' We begine by running a single digit version of Lehmer's algorithm, we still have','line_number':892,'multiline':False]['text':' to track u and v at double precision, but this adds only a tiny performance penalty.','line_number':893,'multiline':False]['text':' What we gain is fast division, and fast termination testing.','line_number':894,'multiline':False]['text':' When you see static_cast<limb_type>(u >> bits_per_limb) here, this is really just','line_number':895,'multiline':False]['text':' a direct access to the upper bits_per_limb of the double limb type.  For __int128','line_number':896,'multiline':False]['text':' this is simple a load of the upper 64 bits and the "shift" is optimised away.','line_number':897,'multiline':False]['text':'','line_number':898,'multiline':False]['text':' We've gone terribly wrong, probably numeric overflow:','line_number':920,'multiline':False]['text':'','line_number':943,'multiline':False]['text':' We get here when the single digit algorithm has gone wrong, back up i, u and v:','line_number':944,'multiline':False]['text':'','line_number':945,'multiline':False]['text':'','line_number':949,'multiline':False]['text':' Now run the full double-digit algorithm:','line_number':950,'multiline':False]['text':'','line_number':951,'multiline':False]['text':'','line_number':959,'multiline':False]['text':' If calculation of y[2] would overflow a single limb, then we *must* terminate.','line_number':960,'multiline':False]['text':' Note that x[2] < y[2] so there is no need to check that as well:','line_number':961,'multiline':False]['text':'','line_number':962,'multiline':False]['text':' No change to U and V we've stalled!','line_number':995,'multiline':False]['text':'','line_number':1002,'multiline':False]['text':' Update U and V.','line_number':1003,'multiline':False]['text':' We have:','line_number':1004,'multiline':False]['text':'','line_number':1005,'multiline':False]['text':' U = x[0]U + y[0]V and','line_number':1006,'multiline':False]['text':' V = x[1]U + y[1]V.','line_number':1007,'multiline':False]['text':'','line_number':1008,'multiline':False]['text':' But since we track only absolute values of x and y','line_number':1009,'multiline':False]['text':' we have to take account of the implied signs and perform','line_number':1010,'multiline':False]['text':' the appropriate subtraction depending on the whether i is','line_number':1011,'multiline':False]['text':' even or odd:','line_number':1012,'multiline':False]['text':'','line_number':1013,'multiline':False]['text':'','line_number':1071,'multiline':False]['text':' Since we have stripped all common powers of 2 from U and V at the start','line_number':1072,'multiline':False]['text':' if either are even at this point, we can remove stray powers of 2 now.','line_number':1073,'multiline':False]['text':' Note that it is not possible for *both* U and V to be even at this point.','line_number':1074,'multiline':False]['text':'','line_number':1075,'multiline':False]['text':' This has an adverse effect on performance for high bit counts, but has','line_number':1076,'multiline':False]['text':' a significant positive effect for smaller counts.','line_number':1077,'multiline':False]['text':'','line_number':1078,'multiline':False]['text':' GCD(0,x) := x ','line_number':1127,'multiline':True]['text':'','line_number':1147,'multiline':False]['text':' Remove common factors of 2:','line_number':1148,'multiline':False]['text':'','line_number':1149,'multiline':False]['text':'','line_number':1165,'multiline':False]['text':' Special case: if V has no more than 2 limbs','line_number':1166,'multiline':False]['text':' then we can reduce U and V to a pair of integers and perform','line_number':1167,'multiline':False]['text':' direct integer gcd:','line_number':1168,'multiline':False]['text':'','line_number':1169,'multiline':False]['text':'','line_number':1201,'multiline':False]['text':' Now again for trivial backends:','line_number':1202,'multiline':False]['text':'','line_number':1203,'multiline':False]['text':' This one is only enabled for unchecked cpp_int's, for checked int's we need the checking in the default version:','line_number':1211,'multiline':False]['text':' result may overflow the specified number of bits','line_number':1217,'multiline':False]['text':'','line_number':1228,'multiline':False]['text':' clang-11 on Mingw segfaults on conversion of __int128 -> float.','line_number':1229,'multiline':False]['text':' See: https://bugs.llvm.org/show_bug.cgi?id=48941','line_number':1230,'multiline':False]['text':' These workarounds pass everything through an intermediate uint64_t.','line_number':1231,'multiline':False]['text':'','line_number':1232,'multiline':False]['text':'','line_number':1345,'multiline':False]['text':' Find the index of the least significant bit within that limb:','line_number':1346,'multiline':False]['text':'','line_number':1347,'multiline':False]['text':'','line_number':1355,'multiline':False]['text':' Find the index of the least significant bit within that limb:','line_number':1356,'multiline':False]['text':'','line_number':1357,'multiline':False]['text':' Namespace backends','line_number':1393,'multiline':False]['text':' BOOST_MP_STANDALONE','line_number':1425,'multiline':False]['text':' Namespace boost::multiprecision','line_number':1429,'multiline':False]