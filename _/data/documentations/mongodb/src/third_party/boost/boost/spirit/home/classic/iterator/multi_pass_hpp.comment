['text':'=============================================================================
    Copyright (c) 2001, Daniel C. Nuffer
    http://spirit.sourceforge.net/

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]['text':' for std::swap','line_number':16,'multiline':False]['text':' for std::exception','line_number':17,'multiline':False]['text':' for BOOST_SPIRIT_ASSERT','line_number':21,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':38,'multiline':False]['text':' class ref_counted','line_number':39,'multiline':False]['text':' Implementation of an OwnershipPolicy used by multi_pass.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' Implementation modified from RefCounted class from the Loki library by','line_number':42,'multiline':False]['text':' Andrei Alexandrescu','line_number':43,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':44,'multiline':False]['text':' clone is called when a copy of the iterator is made, so increment','line_number':56,'multiline':False]['text':' the ref-count.','line_number':57,'multiline':False]['text':' called when a copy is deleted.  Decrement the ref-count.  Return','line_number':63,'multiline':False]['text':' value of true indicates that the last copy has been released.','line_number':64,'multiline':False]['text':' returns true if there is only one iterator in existence.','line_number':82,'multiline':False]['text':' std_deque StoragePolicy will free it's buffered data if this','line_number':83,'multiline':False]['text':' returns true.','line_number':84,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':94,'multiline':False]['text':' class first_owner','line_number':95,'multiline':False]['text':' Implementation of an OwnershipPolicy used by multi_pass','line_number':96,'multiline':False]['text':' This ownership policy dictates that the first iterator created will','line_number':97,'multiline':False]['text':' determine the lifespan of the shared components.  This works well for','line_number':98,'multiline':False]['text':' spirit, since no dynamic allocation of iterators is done, and all copies','line_number':99,'multiline':False]['text':' are make on the stack.','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':' There is a caveat about using this policy together with the std_deque','line_number':102,'multiline':False]['text':' StoragePolicy. Since first_owner always returns false from unique(),','line_number':103,'multiline':False]['text':' std_deque will only release the queued data if clear_queue() is called.','line_number':104,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':105,'multiline':False]['text':' return true to indicate deletion of resources','line_number':121,'multiline':False]['text':' if we're the first, we still remain the first, even if assigned','line_number':129,'multiline':False]['text':' to, so don't swap first_.  swap is only called from operator=','line_number':130,'multiline':False]['text':' no way to know, so always return false','line_number':136,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':143,'multiline':False]['text':' class illegal_backtracking','line_number':144,'multiline':False]['text':' thrown by buf_id_check CheckingPolicy if an instance of an iterator is','line_number':145,'multiline':False]['text':' used after another one has invalidated the queue','line_number':146,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':147,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':160,'multiline':False]['text':' class buf_id_check','line_number':161,'multiline':False]['text':' Implementation of the CheckingPolicy used by multi_pass','line_number':162,'multiline':False]['text':' This policy is most effective when used together with the std_deque','line_number':163,'multiline':False]['text':' StoragePolicy.','line_number':164,'multiline':False]['text':' If used with the fixed_size_queue StoragePolicy, it will not detect','line_number':165,'multiline':False]['text':' iterator dereferences that are out of the range of the queue.','line_number':166,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':167,'multiline':False]['text':' will be called from the destructor of the last iterator.','line_number':181,'multiline':False]['text':' called to verify that everything is okay.','line_number':194,'multiline':False]['text':' called from multi_pass::clear_queue, so we can increment the count','line_number':203,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':215,'multiline':False]['text':' class no_check','line_number':216,'multiline':False]['text':' Implementation of the CheckingPolicy used by multi_pass','line_number':217,'multiline':False]['text':' It does not do anything :-)','line_number':218,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':219,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':231,'multiline':False]['text':' class std_deque','line_number':232,'multiline':False]['text':' Implementation of the StoragePolicy used by multi_pass','line_number':233,'multiline':False]['text':' This stores all data in a std::deque, and keeps an offset to the current','line_number':234,'multiline':False]['text':' position. It stores all the data unless there is only one','line_number':235,'multiline':False]['text':' iterator using the queue.','line_number':236,'multiline':False]['text':' Note: a position is used instead of an iterator, because a push_back on','line_number':237,'multiline':False]['text':' a deque can invalidate any iterators.','line_number':238,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':239,'multiline':False]['text':' will be called from the destructor of the last iterator.','line_number':264,'multiline':False]['text':' This is called when the iterator is dereferenced.  It's a template','line_number':278,'multiline':False]['text':' method so we can recover the type of the multi_pass iterator','line_number':279,'multiline':False]['text':' and call unique and access the m_input data member.','line_number':280,'multiline':False]['text':' check if this is the only iterator','line_number':286,'multiline':False]['text':' free up the memory used by the queue.','line_number':289,'multiline':False]['text':' This is called when the iterator is incremented.  It's a template','line_number':304,'multiline':False]['text':' method so we can recover the type of the multi_pass iterator','line_number':305,'multiline':False]['text':' and call unique and access the m_input data member.','line_number':306,'multiline':False]['text':' check if this is the only iterator','line_number':312,'multiline':False]['text':' free up the memory used by the queue.','line_number':315,'multiline':False]['text':' called to forcibly clear the queue','line_number':336,'multiline':False]['text':' called to determine whether the iterator is an eof iterator','line_number':343,'multiline':False]['text':' called by operator==','line_number':351,'multiline':False]['text':' called by operator<','line_number':357,'multiline':False]['text':' class inner','line_number':362,'multiline':False]['text':' class std_deque','line_number':364,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':367,'multiline':False]['text':' class fixed_size_queue','line_number':368,'multiline':False]['text':' Implementation of the StoragePolicy used by multi_pass','line_number':369,'multiline':False]['text':' fixed_size_queue keeps a circular buffer (implemented by','line_number':370,'multiline':False]['text':' BOOST_SPIRIT_CLASSIC_NS::fixed_size_queue class) that is size N+1 and stores N elements.','line_number':371,'multiline':False]['text':' It is up to the user to ensure that there is enough look ahead for their','line_number':372,'multiline':False]['text':' grammar.  Currently there is no way to tell if an iterator is pointing','line_number':373,'multiline':False]['text':' to forgotten data.  The leading iterator will put an item in the queue','line_number':374,'multiline':False]['text':' and remove one when it is incremented.  No dynamic allocation is done,','line_number':375,'multiline':False]['text':' except on creation of the queue (fixed_size_queue constructor).','line_number':376,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':377,'multiline':False]['text':' will be called from the destructor of the last iterator.','line_number':403,'multiline':False]['text':' This is called when the iterator is dereferenced.  It's a template','line_number':417,'multiline':False]['text':' method so we can recover the type of the multi_pass iterator','line_number':418,'multiline':False]['text':' and access the m_input data member.','line_number':419,'multiline':False]['text':' This is called when the iterator is incremented.  It's a template','line_number':433,'multiline':False]['text':' method so we can recover the type of the multi_pass iterator','line_number':434,'multiline':False]['text':' and access the m_input data member.','line_number':435,'multiline':False]['text':' don't let the queue get larger than N','line_number':441,'multiline':False]['text':' no-op','line_number':451,'multiline':False]['text':' called to determine whether the iterator is an eof iterator','line_number':455,'multiline':False]['text':' called by operator==','line_number':463,'multiline':False]['text':' called by operator<','line_number':469,'multiline':False]['text':' class inner','line_number':474,'multiline':False]['text':' class fixed_size_queue','line_number':476,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':479,'multiline':False]['text':' class input_iterator','line_number':480,'multiline':False]['text':' Implementation of the InputPolicy used by multi_pass','line_number':481,'multiline':False]['text':' input_iterator encapsulates an input iterator of type InputT','line_number':482,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':483,'multiline':False]['text':' Needed by compilers not implementing the resolution to DR45. For','line_number':510,'multiline':False]['text':' reference, see','line_number':511,'multiline':False]['text':' http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45.','line_number':512,'multiline':False]['text':' get the first token','line_number':562,'multiline':False]['text':' should get the next token','line_number':578,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':593,'multiline':False]['text':' class lex_input','line_number':594,'multiline':False]['text':' Implementation of the InputPolicy used by multi_pass','line_number':595,'multiline':False]['text':' lex_input gets tokens (ints) from yylex()','line_number':596,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':597,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':664,'multiline':False]['text':' class functor_input','line_number':665,'multiline':False]['text':' Implementation of the InputPolicy used by multi_pass','line_number':666,'multiline':False]['text':' functor_input gets tokens from a functor','line_number':667,'multiline':False]['text':' Note: the functor must have a typedef for result_type','line_number':668,'multiline':False]['text':' It also must have a static variable of type result_type defined to','line_number':669,'multiline':False]['text':' represent eof that is called eof.','line_number':670,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':671,'multiline':False]['text':' namespace multi_pass_policies','line_number':753,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':755,'multiline':False]['text':' iterator_base_creator','line_number':756,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':757,'multiline':False]['text':' Meta-function to generate a std::iterator<>-like base class for multi_pass.','line_number':761,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':778,'multiline':False]['text':' class template multi_pass ','line_number':779,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':780,'multiline':False]['text':' The default multi_pass instantiation uses a ref-counted std_deque scheme.','line_number':782,'multiline':False]['text':' BOOST_WORKAROUND(__GLIBCPP__, == 20020514)','line_number':820,'multiline':False]['text':' helper functions','line_number':839,'multiline':False]['text':' The standard library shipped with gcc-3.1 has a bug in','line_number':880,'multiline':False]['text':' bits/basic_string.tcc. It tries  to use iter::iter(0) to','line_number':881,'multiline':False]['text':' construct an iterator. Ironically, this  happens in sanity','line_number':882,'multiline':False]['text':' checking code that isn't required by the standard.','line_number':883,'multiline':False]['text':' The workaround is to provide an additional constructor that','line_number':884,'multiline':False]['text':' ignores its int argument and behaves like the default constructor.','line_number':885,'multiline':False]['text':' BOOST_WORKAROUND(__GLIBCPP__, == 20020514)','line_number':903,'multiline':False]['text':'/// Comparisons','line_number':1093,'multiline':False]['text':' both are EOF','line_number':1112,'multiline':False]['text':' one is EOF, one isn't','line_number':1116,'multiline':False]['text':'/// Generator function','line_number':1216,'multiline':False]['text':' this could be a template typedef, since such a thing doesn't','line_number':1228,'multiline':False]['text':' exist in C++, we'll use inheritance to accomplish the same thing.','line_number':1229,'multiline':False]['text':' workaround for a bug in the library','line_number':1257,'multiline':False]['text':' shipped with gcc 3.1','line_number':1258,'multiline':False]['text':' BOOST_WORKAROUND(__GLIBCPP__, == 20020514)','line_number':1259,'multiline':False]['text':' default generated operators destructor and assignment operator are okay.','line_number':1261,'multiline':False]['text':' namespace BOOST_SPIRIT_CLASSIC_NS','line_number':1296,'multiline':False]['text':' BOOST_SPIRIT_ITERATOR_MULTI_PASS_HPP','line_number':1298,'multiline':False]