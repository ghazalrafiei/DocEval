['text':' boost\math\tools\promotion.hpp','line_number':1,'multiline':False]['text':' Copyright John Maddock 2006.','line_number':3,'multiline':False]['text':' Copyright Paul A. Bristow 2006.','line_number':4,'multiline':False]['text':' Use, modification and distribution are subject to the','line_number':6,'multiline':False]['text':' Boost Software License, Version 1.0.','line_number':7,'multiline':False]['text':' (See accompanying file LICENSE_1_0.txt','line_number':8,'multiline':False]['text':' or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':9,'multiline':False]['text':' Promote arguments functions to allow math functions to have arguments','line_number':11,'multiline':False]['text':' provided as integer OR real (floating-point, built-in or UDT)','line_number':12,'multiline':False]['text':' (called ArithmeticType in functions that use promotion)','line_number':13,'multiline':False]['text':' that help to reduce the risk of creating multiple instantiations.','line_number':14,'multiline':False]['text':' Allows creation of an inline wrapper that forwards to a foo(RT, RT) function,','line_number':15,'multiline':False]['text':' so you never get to instantiate any mixed foo(RT, IT) functions.','line_number':16,'multiline':False]['text':' If either T1 or T2 is an integer type,','line_number':34,'multiline':False]['text':' pretend it was a double (for the purposes of further analysis).','line_number':35,'multiline':False]['text':' Then pick the wider of the two floating-point types','line_number':36,'multiline':False]['text':' as the actual signature to forward to.','line_number':37,'multiline':False]['text':' For example:','line_number':38,'multiline':False]['text':' foo(int, short) -> double foo(double, double);','line_number':39,'multiline':False]['text':' foo(int, float) -> double foo(double, double);','line_number':40,'multiline':False]['text':' Note: NOT float foo(float, float)','line_number':41,'multiline':False]['text':' foo(int, double) -> foo(double, double);','line_number':42,'multiline':False]['text':' foo(double, float) -> double foo(double, double);','line_number':43,'multiline':False]['text':' foo(double, float) -> double foo(double, double);','line_number':44,'multiline':False]['text':' foo(any-int-or-float-type, long double) -> foo(long double, long double);','line_number':45,'multiline':False]['text':' but ONLY float foo(float, float) is unchanged.','line_number':46,'multiline':False]['text':' So the only way to get an entirely float version is to call foo(1.F, 2.F),','line_number':47,'multiline':False]['text':' But since most (all?) the math functions convert to double internally,','line_number':48,'multiline':False]['text':' probably there would not be the hoped-for gain by using float here.','line_number':49,'multiline':False]['text':' This follows the C-compatible conversion rules of pow, etc','line_number':51,'multiline':False]['text':' where pow(int, float) is converted to pow(double, double).','line_number':52,'multiline':False]['text':' If T is integral type, then promote to double.','line_number':56,'multiline':False]['text':' These full specialisations reduce std::conditional usage and speed up','line_number':59,'multiline':False]['text':' compilation:','line_number':60,'multiline':False]['text':' Promote, if necessary, & pick the wider of the two floating-point types.','line_number':68,'multiline':False]['text':' for both parameter types, if integral promote to double.','line_number':69,'multiline':False]['text':' T1 perhaps promoted.','line_number':70,'multiline':False]['text':' T2 perhaps promoted.','line_number':71,'multiline':False]['text':' both T1P and T2P are floating-point?','line_number':74,'multiline':False]['text':' either long double?','line_number':76,'multiline':False]['text':' either long double?','line_number':79,'multiline':False]['text':' then result type is long double.','line_number':80,'multiline':False]['text':' either double?','line_number':81,'multiline':False]['text':' result type is double.','line_number':82,'multiline':False]['text':' else result type is float.','line_number':83,'multiline':False]['text':' else one or the other is a user-defined type:','line_number':89,'multiline':False]['text':' promote_arg2','line_number':91,'multiline':False]['text':' These full specialisations reduce std::conditional usage and speed up','line_number':92,'multiline':False]['text':' compilation:','line_number':93,'multiline':False]['text':'','line_number':131,'multiline':False]['text':' Guard against use of long double if it's not supported:','line_number':132,'multiline':False]['text':'','line_number':133,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' This struct is the same as above, but has no static assert on long double usage,','line_number':139,'multiline':False]['text':' it should be used only on functions that can be implemented for long double','line_number':140,'multiline':False]['text':' even when std lib support is missing or broken for that type.','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':' namespace tools','line_number':163,'multiline':False]['text':' namespace math','line_number':164,'multiline':False]['text':' namespace boost','line_number':165,'multiline':False]['text':' BOOST_MATH_PROMOTION_HPP','line_number':167,'multiline':False]