['text':'=============================================================================
    Phoenix v1.2
    Copyright (c) 2001-2002 Joel de Guzman

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================','line_number':1,'multiline':True]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':11,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':15,'multiline':False]['text':'  These are forward declared here because we cannot include impl.hpp','line_number':18,'multiline':False]['text':'  or operators.hpp yet but the actor's assignment operator and index','line_number':19,'multiline':False]['text':'  operator are required to be members.','line_number':20,'multiline':False]['text':'////////////////////////////////','line_number':22,'multiline':False]['text':'////////////////////////////////','line_number':26,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':'  unpack_tuple class','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':'      This class is used to unpack a supplied tuple such, that the members of ','line_number':37,'multiline':False]['text':'      this tuple will be handled as if they would be supplied separately.','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':40,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':50,'multiline':False]['text':'','line_number':51,'multiline':False]['text':'  actor class','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':'      This class is a protocol class for all actors. This class is','line_number':54,'multiline':False]['text':'      essentially an interface contract. The actor class does not','line_number':55,'multiline':False]['text':'      really know how how to act on anything but instead relies on the','line_number':56,'multiline':False]['text':'      template parameter BaseT (from which the actor will derive from)','line_number':57,'multiline':False]['text':'      to do the actual action.','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':'      An actor is a functor that is capable of accepting arguments up','line_number':60,'multiline':False]['text':'      to a predefined maximum. It is up to the base class to do the','line_number':61,'multiline':False]['text':'      actual processing or possibly to limit the arity (no. of','line_number':62,'multiline':False]['text':'      arguments) passed in. Upon invocation of the functor through a','line_number':63,'multiline':False]['text':'      supplied operator(), the actor funnels the arguments passed in','line_number':64,'multiline':False]['text':'      by the client into a tuple and calls the base eval member','line_number':65,'multiline':False]['text':'      function.','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':'      Schematically:','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':'          arg0 ---------|','line_number':70,'multiline':False]['text':'          arg1 ---------|','line_number':71,'multiline':False]['text':'          arg2 ---------|---> tupled_args ---> base.eval','line_number':72,'multiline':False]['text':'          ...           |','line_number':73,'multiline':False]['text':'          argN ---------|','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':'          actor::operator()(arg0, arg1... argN)','line_number':76,'multiline':False]['text':'              ---> BaseT::eval(tupled_args);','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':'      Actor base classes from which this class inherits from are','line_number':79,'multiline':False]['text':'      expected to have a corresponding member function eval compatible','line_number':80,'multiline':False]['text':'      with the conceptual Interface:','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':'          template <typename TupleT>','line_number':83,'multiline':False]['text':'          actor_return_type','line_number':84,'multiline':False]['text':'          eval(TupleT const& args) const;','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':'      where args are the actual arguments passed in by the client','line_number':87,'multiline':False]['text':'      funneled into a tuple (see tuple.hpp for details).','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':'      The actor_return_type can be anything. Base classes are free to','line_number':90,'multiline':False]['text':'      return any type, even argument dependent types (types that are','line_number':91,'multiline':False]['text':'      deduced from the types of the arguments). After evaluating the','line_number':92,'multiline':False]['text':'      parameters and doing some computations or actions, the eval','line_number':93,'multiline':False]['text':'      member function concludes by returning something back to the','line_number':94,'multiline':False]['text':'      client. To do this, the forwarding function (the actor's','line_number':95,'multiline':False]['text':'      operator()) needs to know the return type of the eval member','line_number':96,'multiline':False]['text':'      function that it is calling. For this purpose, actor base','line_number':97,'multiline':False]['text':'      classes are required to provide a nested template class:','line_number':98,'multiline':False]['text':'','line_number':99,'multiline':False]['text':'          template <typename TupleT>','line_number':100,'multiline':False]['text':'          struct result;','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':'      This auxiliary class provides the result type information','line_number':103,'multiline':False]['text':'      returned by the eval member function of a base actor class. The','line_number':104,'multiline':False]['text':'      nested template class result should have a typedef 'type' that','line_number':105,'multiline':False]['text':'      reflects the return type of its member function eval. It is','line_number':106,'multiline':False]['text':'      basically a type computer that answers the question "given','line_number':107,'multiline':False]['text':'      arguments packed into a TupleT type, what will be the result','line_number':108,'multiline':False]['text':'      type of the eval member function of ActorT?". The template class','line_number':109,'multiline':False]['text':'      actor_result queries this to extract the return type of an','line_number':110,'multiline':False]['text':'      actor. Example:','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':'          typedef typename actor_result<ActorT, TupleT>::type','line_number':113,'multiline':False]['text':'              actor_return_type;','line_number':114,'multiline':False]['text':'','line_number':115,'multiline':False]['text':'      where actor_return_type is the actual type returned by ActorT's','line_number':116,'multiline':False]['text':'      eval member function given some arguments in a TupleT.','line_number':117,'multiline':False]['text':'','line_number':118,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':119,'multiline':False]['text':'////////////////////////////////','line_number':127,'multiline':False]['text':'assignment operator could not be generated','line_number':130,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':283,'multiline':False]['text':'','line_number':284,'multiline':False]['text':'  as_actor','line_number':285,'multiline':False]['text':'','line_number':286,'multiline':False]['text':'      as_actor is a meta-program that converts an arbitrary type into','line_number':287,'multiline':False]['text':'      an actor. All participants in the framework must be first-class','line_number':288,'multiline':False]['text':'      actors. This meta-program is used all throughout the framework','line_number':289,'multiline':False]['text':'      whenever an unknown type needs to be converted to an actor.','line_number':290,'multiline':False]['text':'      as_actor specializations are expected to have a typedef 'type'.','line_number':291,'multiline':False]['text':'      This is the destination actor type. A static member function','line_number':292,'multiline':False]['text':'      'convert' converts an object to this target type.','line_number':293,'multiline':False]['text':'','line_number':294,'multiline':False]['text':'      The meta-program does no conversion if the object to be','line_number':295,'multiline':False]['text':'      converted is already an actor.','line_number':296,'multiline':False]['text':'','line_number':297,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////','line_number':298,'multiline':False]['text':'////////////////////////////////','line_number':302,'multiline':False]['text':'////////////////////////////////','line_number':310,'multiline':False]['text':'x','line_number':315,'multiline':True]['text':'////////////////////////////////','line_number':319,'multiline':False]['text':'  ERROR!!!','line_number':324,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':327,'multiline':False]['text':'','line_number':328,'multiline':False]['text':'  actor class implementation','line_number':329,'multiline':False]['text':'','line_number':330,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':331,'multiline':False]['text':'////////////////////////////////','line_number':336,'multiline':False]['text':'////////////////////////////////','line_number':341,'multiline':False]['text':'////////////////////////////////','line_number':349,'multiline':False]['text':'////////////////////////////////','line_number':358,'multiline':False]['text':'////////////////////////////////','line_number':367,'multiline':False]['text':'////////////////////////////////','line_number':377,'multiline':False]['text':'////////////////////////////////','line_number':386,'multiline':False]['text':'////////////////////////////////','line_number':395,'multiline':False]['text':'////////////////////////////////','line_number':414,'multiline':False]['text':'////////////////////////////////','line_number':432,'multiline':False]['text':'////////////////////////////////','line_number':450,'multiline':False]['text':'////////////////////////////////','line_number':469,'multiline':False]['text':'////////////////////////////////','line_number':487,'multiline':False]['text':'////////////////////////////////','line_number':507,'multiline':False]['text':'////////////////////////////////','line_number':528,'multiline':False]['text':'////////////////////////////////','line_number':548,'multiline':False]['text':'////////////////////////////////','line_number':568,'multiline':False]['text':'////////////////////////////////','line_number':593,'multiline':False]['text':'/////////////////////////////////////////////////////////////////////////////','line_number':602,'multiline':False]['text':'  namespace phoenix','line_number':603,'multiline':False]