['text':'  Copyright (c) 2006 Xiaogang Zhang','line_number':1,'multiline':False]['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]['text':' Bessel functions of the first and second kind of fractional order','line_number':25,'multiline':False]['text':'','line_number':31,'multiline':False]['text':' Simultaneous calculation of A&S 9.2.9 and 9.2.10','line_number':32,'multiline':False]['text':' for use in A&S 9.2.5 and 9.2.6.','line_number':33,'multiline':False]['text':' This series is quick to evaluate, but divergent unless','line_number':34,'multiline':False]['text':' x is very large, in fact it's pretty hard to figure out','line_number':35,'multiline':False]['text':' with any degree of precision when this series actually ','line_number':36,'multiline':False]['text':' *will* converge!!  Consequently, we may just have to','line_number':37,'multiline':False]['text':' try it and see...','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' Calculate Y(v, x) and Y(v+1, x) by Temme's method, see','line_number':70,'multiline':False]['text':' Temme, Journal of Computational Physics, vol 21, 343 (1976)','line_number':71,'multiline':False]['text':' precondition for using this routine','line_number':83,'multiline':False]['text':' series summation','line_number':115,'multiline':False]['text':' Evaluate continued fraction fv = J_(v+1) / J_v, see','line_number':139,'multiline':False]['text':' Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73','line_number':140,'multiline':False]['text':' |x| <= |v|, CF1_jy converges rapidly','line_number':150,'multiline':False]['text':' |x| > |v|, CF1_jy needs O(|x|) iterations to converge','line_number':151,'multiline':False]['text':' modified Lentz's method, see','line_number':153,'multiline':False]['text':' Lentz, Applied Optics, vol 15, 668 (1976)','line_number':154,'multiline':False]['text':' b0 = 0, replace with tiny','line_number':157,'multiline':False]['text':' sign of denominator','line_number':176,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' This algorithm was originally written by Xiaogang Zhang','line_number':181,'multiline':False]['text':' using std::complex to perform the complex arithmetic.','line_number':182,'multiline':False]['text':' However, that turns out to 10x or more slower than using','line_number':183,'multiline':False]['text':' all real-valued arithmetic, so it's been rewritten using','line_number':184,'multiline':False]['text':' real values only.','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' |x| >= |v|, CF2_jy converges rapidly','line_number':196,'multiline':False]['text':' |x| -> 0, CF2_jy fails to converge','line_number':197,'multiline':False]['text':' modified Lentz's method, complex numbers involved, see','line_number':200,'multiline':False]['text':' Lentz, Applied Optics, vol 15, 668 (1976)','line_number':201,'multiline':False]['text':'Dr = Di = 0;','line_number':206,'multiline':False]['text':' Note complex this one time only!','line_number':208,'multiline':False]['text':' Compute J(v, x) and Y(v, x) simultaneously by Steed's method, see','line_number':260,'multiline':False]['text':' Barnett et al, Computer Physics Communications, vol 8, 377 (1974)','line_number':261,'multiline':False]['text':' v is non-negative from here','line_number':285,'multiline':False]['text':' -1/2 <= u < 1/2','line_number':293,'multiline':False]['text':' need both for reflection formula','line_number':301,'multiline':False]['text':' complex infinity','line_number':311,'multiline':False]['text':' any value will do, not using J.','line_number':313,'multiline':False]['text':' any value will do, not using Y.','line_number':316,'multiline':False]['text':' complex infinity','line_number':320,'multiline':False]['text':' x is positive until reflection','line_number':324,'multiline':False]['text':' Wronskian','line_number':325,'multiline':False]['text':'','line_number':329,'multiline':False]['text':' This series will actually converge rapidly for all small','line_number':330,'multiline':False]['text':' x - say up to x < 20 - but the first few terms are large','line_number':331,'multiline':False]['text':' and divergent which leads to large errors :-(','line_number':332,'multiline':False]['text':'','line_number':333,'multiline':False]['text':' Evaluate using series representations.','line_number':339,'multiline':False]['text':' This is particularly important for x << v as in this','line_number':340,'multiline':False]['text':' area temme_jy may be slow to converge, if it converges at all.','line_number':341,'multiline':False]['text':' Requires x is not an integer.','line_number':342,'multiline':False]['text':' Only calculate if we need it, and if the reflection formula will actually use it:','line_number':350,'multiline':False]['text':' Truncated series evaluation for small x and v an integer,','line_number':358,'multiline':False]['text':' much quicker in this area than temme_jy below.','line_number':359,'multiline':False]['text':' Only calculate if we need it, and if the reflection formula will actually use it:','line_number':367,'multiline':False]['text':' any value will do, we're not using it.','line_number':380,'multiline':False]['text':' any value will do, we're not using it.','line_number':386,'multiline':False]['text':'','line_number':390,'multiline':False]['text':' Hankel approximation: note that this method works best when x ','line_number':391,'multiline':False]['text':' is large, but in that case we end up calculating sines and cosines','line_number':392,'multiline':False]['text':' of large values, with horrendous resulting accuracy.  It is fast though','line_number':393,'multiline':False]['text':' when it works....','line_number':394,'multiline':False]['text':'','line_number':395,'multiline':False]['text':' Normally we calculate sin/cos(chi) where:','line_number':396,'multiline':False]['text':'','line_number':397,'multiline':False]['text':' chi = x - fmod(T(v / 2 + 0.25f), T(2)) * boost::math::constants::pi<T>();','line_number':398,'multiline':False]['text':'','line_number':399,'multiline':False]['text':' But this introduces large errors, so use sin/cos addition formulae to','line_number':400,'multiline':False]['text':' improve accuracy:','line_number':401,'multiline':False]['text':'','line_number':402,'multiline':False]['text':' == sin(chi);','line_number':409,'multiline':False]['text':' == cos(chi);','line_number':410,'multiline':False]['text':'sqrt(2 / (boost::math::constants::pi<T>() * x));','line_number':411,'multiline':False]['text':' x in (0, 2]','line_number':415,'multiline':False]['text':' Temme series','line_number':417,'multiline':False]['text':' domain error:','line_number':419,'multiline':False]['text':' forward recurrence for Y','line_number':427,'multiline':False]['text':' continued fraction CF1_jy','line_number':444,'multiline':False]['text':' Wronskian relation','line_number':445,'multiline':False]['text':' any value will do, we're not using it.','line_number':448,'multiline':False]['text':' x in (2, \infty)','line_number':451,'multiline':False]['text':' Get Y(u, x):','line_number':453,'multiline':False]['text':' tiny initial value to prevent overflow','line_number':457,'multiline':False]['text':' backward recurrence for J','line_number':465,'multiline':False]['text':' scaling ratio','line_number':471,'multiline':False]['text':' can also call CF1_jy() to get fu, not much difference in precision','line_number':472,'multiline':False]['text':'','line_number':477,'multiline':False]['text':' When v is large we may get overflow in this calculation','line_number':478,'multiline':False]['text':' leading to NaN's and other nasty surprises:','line_number':479,'multiline':False]['text':'','line_number':480,'multiline':False]['text':' backward recurrence for J','line_number':483,'multiline':False]['text':' scaling ratio','line_number':497,'multiline':False]['text':' can also call CF1_jy() to get fu, not much difference in precision','line_number':498,'multiline':False]['text':' continued fraction CF2_jy','line_number':507,'multiline':False]['text':' t = J'/J','line_number':508,'multiline':False]['text':'','line_number':510,'multiline':False]['text':' We can't allow gamma to cancel out to zero completely as it messes up','line_number':511,'multiline':False]['text':' the subsequent logic.  So pretend that one bit didn't cancel out','line_number':512,'multiline':False]['text':' and set to a suitably small value.  The only test case we've been able to','line_number':513,'multiline':False]['text':' find for this, is when v = 8.5 and x = 4*PI.','line_number':514,'multiline':False]['text':'','line_number':515,'multiline':False]['text':' normalization','line_number':529,'multiline':False]['text':' compute Y:','line_number':536,'multiline':False]['text':' forward recurrence for Y','line_number':540,'multiline':False]['text':' any value will do, we're not using it.','line_number':556,'multiline':False]['text':' reflection formula','line_number':564,'multiline':False]['text':' namespace detail','line_number':582,'multiline':False]['text':' namespaces','line_number':584,'multiline':False]['text':' BOOST_MATH_BESSEL_JY_HPP','line_number':586,'multiline':False]