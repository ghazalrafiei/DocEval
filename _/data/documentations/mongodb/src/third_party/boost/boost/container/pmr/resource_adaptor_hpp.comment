['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' (C) Copyright Ion Gaztanaga 2015-2015. Distributed under the Boost','line_number':3,'multiline':False]['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See http://www.boost.org/libs/container for documentation.','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]['text':'namespace pmr_dtl','line_number':54,'multiline':False]['text':'! An instance of resource_adaptor<Allocator> is an adaptor that wraps a memory_resource interface','line_number':58,'multiline':False]['text':'! around Allocator. In order that resource_adaptor<X<T>> and resource_adaptor<X<U>> are the same','line_number':59,'multiline':False]['text':'! type for any allocator template X and types T and U, resource_adaptor<Allocator> is rendered as','line_number':60,'multiline':False]['text':'! an alias to this class template such that Allocator is rebound to a char value type in every','line_number':61,'multiline':False]['text':'! specialization of the class template. The requirements on this class template are defined below.','line_number':62,'multiline':False]['text':'! In addition to the Allocator requirements, the parameter to resource_adaptor shall meet','line_number':63,'multiline':False]['text':'! the following additional requirements:','line_number':64,'multiline':False]['text':'!','line_number':65,'multiline':False]['text':'! - `typename allocator_traits<Allocator>:: pointer` shall be identical to','line_number':66,'multiline':False]['text':'!   `typename allocator_traits<Allocator>:: value_type*`.','line_number':67,'multiline':False]['text':'!','line_number':68,'multiline':False]['text':'! - `typename allocator_traits<Allocator>:: const_pointer` shall be identical to','line_number':69,'multiline':False]['text':'!   `typename allocator_traits<Allocator>:: value_type const*`.','line_number':70,'multiline':False]['text':'!','line_number':71,'multiline':False]['text':'! - `typename allocator_traits<Allocator>:: void_pointer` shall be identical to `void*`.','line_number':72,'multiline':False]['text':'!','line_number':73,'multiline':False]['text':'! - `typename allocator_traits<Allocator>:: const_void_pointer` shall be identical to `void const*`.','line_number':74,'multiline':False]['text':'This class can only be used with allocators type char','line_number':89,'multiline':False]['text':'! <b>Effects</b>: Default constructs','line_number':97,'multiline':False]['text':'!   m_alloc.','line_number':98,'multiline':False]['text':'! <b>Effects</b>: Copy constructs','line_number':102,'multiline':False]['text':'!   m_alloc.','line_number':103,'multiline':False]['text':'! <b>Effects</b>: Move constructs','line_number':108,'multiline':False]['text':'!   m_alloc.','line_number':109,'multiline':False]['text':'! <b>Effects</b>: Initializes m_alloc with','line_number':114,'multiline':False]['text':'!   a2.','line_number':115,'multiline':False]['text':'! <b>Effects</b>: Initializes m_alloc with','line_number':120,'multiline':False]['text':'!   a2.','line_number':121,'multiline':False]['text':'! <b>Effects</b>: Copy assigns','line_number':126,'multiline':False]['text':'!   m_alloc.','line_number':127,'multiline':False]['text':'! <b>Effects</b>: Move assigns','line_number':131,'multiline':False]['text':'!   m_alloc.','line_number':132,'multiline':False]['text':'! <b>Effects</b>: Returns m_alloc.','line_number':136,'multiline':False]['text':'! <b>Effects</b>: Returns m_alloc.','line_number':140,'multiline':False]['text':'! <b>Returns</b>: Allocated memory obtained by calling m_alloc.allocate. The size and alignment','line_number':145,'multiline':False]['text':'!   of the allocated memory shall meet the requirements for a class derived from memory_resource.','line_number':146,'multiline':False]['text':'! <b>Requires</b>: p was previously allocated using A.allocate, where A == m_alloc, and not','line_number':155,'multiline':False]['text':'!   subsequently deallocated. ','line_number':156,'multiline':False]['text':'!','line_number':157,'multiline':False]['text':'! <b>Effects</b>: Returns memory to the allocator using m_alloc.deallocate().','line_number':158,'multiline':False]['text':'! Let p be dynamic_cast<const resource_adaptor_imp*>(&other).','line_number':167,'multiline':False]['text':'!','line_number':168,'multiline':False]['text':'! <b>Returns</b>: false if p is null, otherwise the value of m_alloc == p->m_alloc.','line_number':169,'multiline':False]['text':'Allocate space for requested bytes, plus alignment, plus bookeeping data','line_number':179,'multiline':False]['text':'Obtain the aligned address after the bookeeping data','line_number':183,'multiline':False]['text':'Store bookeeping data. Use memcpy as the underlying memory might be unaligned for','line_number':186,'multiline':False]['text':'a pointer (e.g. 2 byte alignment in 32 bit, 4 byte alignment in 64 bit)','line_number':187,'multiline':False]['text':'Obtain bookeeping data','line_number':196,'multiline':False]['text':'! `resource_adaptor<Allocator>` is rendered as an alias to resource_adaptor_imp class template','line_number':221,'multiline':False]['text':'! such that Allocator is rebound to a char value type.','line_number':222,'multiline':False]['text':'get_allocator and protected functions are properly inherited','line_number':266,'multiline':False]['text':'namespace pmr {','line_number':271,'multiline':False]['text':'namespace container {','line_number':272,'multiline':False]['text':'namespace boost {','line_number':273,'multiline':False]['text':'BOOST_CONTAINER_PMR_RESOURCE_ADAPTOR_HPP','line_number':277,'multiline':False]