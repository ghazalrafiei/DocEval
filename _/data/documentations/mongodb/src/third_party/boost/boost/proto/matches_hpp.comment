['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]['text':'/ \file matches.hpp','line_number':2,'multiline':False]['text':'/ Contains definition of matches\<\> metafunction for determining if','line_number':3,'multiline':False]['text':'/ a given expression matches a given pattern.','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':6,'multiline':False]['text':'  Software License, Version 1.0. (See accompanying file','line_number':7,'multiline':False]['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':' 'specialization' : truncation from 'const int' to 'bool'','line_number':48,'multiline':False]['text':' vararg_matches_impl','line_number':125,'multiline':False]['text':' vararg_matches','line_number':129,'multiline':False]['text':' How terminal_matches<> handles references and cv-qualifiers.','line_number':156,'multiline':False]['text':' The cv and ref matter *only* if the grammar has a top-level ref.','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':' Expr       |   Grammar    |  Matches?','line_number':159,'multiline':False]['text':' -------------------------------------','line_number':160,'multiline':False]['text':' T              T             yes','line_number':161,'multiline':False]['text':' T &            T             yes','line_number':162,'multiline':False]['text':' T const &      T             yes','line_number':163,'multiline':False]['text':' T              T &           no','line_number':164,'multiline':False]['text':' T &            T &           yes','line_number':165,'multiline':False]['text':' T const &      T &           no','line_number':166,'multiline':False]['text':' T              T const &     no','line_number':167,'multiline':False]['text':' T &            T const &     no','line_number':168,'multiline':False]['text':' T const &      T const &     yes','line_number':169,'multiline':False]['text':' MSVC-7.1 has lots of problems with array types that have been','line_number':187,'multiline':False]['text':' deduced. Partially specializing terminal_matches<> on array types','line_number':188,'multiline':False]['text':' doesn't seem to work.','line_number':189,'multiline':False]['text':' terminal_matches','line_number':214,'multiline':False]['text':' terminal_matches','line_number':229,'multiline':False]['text':' Avoid ambiguity errors on MSVC','line_number':251,'multiline':False]['text':' matches_','line_number':290,'multiline':False]['text':' handle proto::if_','line_number':350,'multiline':False]['text':' handle degenerate cases of proto::or_','line_number':376,'multiline':False]['text':' handle degenerate cases of proto::and_','line_number':391,'multiline':False]['text':' handle proto::not_','line_number':402,'multiline':False]['text':' handle proto::switch_','line_number':408,'multiline':False]['text':' handle proto::switch_ with the default Transform for specially for better compile times','line_number':426,'multiline':False]['text':'/ \brief A Boolean metafunction that evaluates whether a given','line_number':439,'multiline':False]['text':'/ expression type matches a grammar.','line_number':440,'multiline':False]['text':'/','line_number':441,'multiline':False]['text':'/ <tt>matches\<Expr,Grammar\></tt> inherits (indirectly) from','line_number':442,'multiline':False]['text':'/ \c mpl::true_ if <tt>Expr::proto_grammar</tt> matches','line_number':443,'multiline':False]['text':'/ <tt>Grammar::proto_grammar</tt>, and from \c mpl::false_','line_number':444,'multiline':False]['text':'/ otherwise.','line_number':445,'multiline':False]['text':'/','line_number':446,'multiline':False]['text':'/ Non-terminal expressions are matched against a grammar','line_number':447,'multiline':False]['text':'/ according to the following rules:','line_number':448,'multiline':False]['text':'/','line_number':449,'multiline':False]['text':'/ \li The wildcard pattern, \c _, matches any expression.','line_number':450,'multiline':False]['text':'/ \li An expression <tt>expr\<AT, listN\<A0,A1,...An\> \></tt>','line_number':451,'multiline':False]['text':'/     matches a grammar <tt>expr\<BT, listN\<B0,B1,...Bn\> \></tt>','line_number':452,'multiline':False]['text':'/     if \c BT is \c _ or \c AT, and if \c Ax matches \c Bx for','line_number':453,'multiline':False]['text':'/     each \c x in <tt>[0,n)</tt>.','line_number':454,'multiline':False]['text':'/ \li An expression <tt>expr\<AT, listN\<A0,...An,U0,...Um\> \></tt>','line_number':455,'multiline':False]['text':'/     matches a grammar <tt>expr\<BT, listM\<B0,...Bn,vararg\<V\> \> \></tt>','line_number':456,'multiline':False]['text':'/     if \c BT is \c _ or \c AT, and if \c Ax matches \c Bx','line_number':457,'multiline':False]['text':'/     for each \c x in <tt>[0,n)</tt> and if \c Ux matches \c V','line_number':458,'multiline':False]['text':'/     for each \c x in <tt>[0,m)</tt>.','line_number':459,'multiline':False]['text':'/ \li An expression \c E matches <tt>or_\<B0,B1,...Bn\></tt> if \c E','line_number':460,'multiline':False]['text':'/     matches some \c Bx for \c x in <tt>[0,n)</tt>.','line_number':461,'multiline':False]['text':'/ \li An expression \c E matches <tt>and_\<B0,B1,...Bn\></tt> if \c E','line_number':462,'multiline':False]['text':'/     matches all \c Bx for \c x in <tt>[0,n)</tt>.','line_number':463,'multiline':False]['text':'/ \li An expression \c E matches <tt>if_\<T,U,V\></tt> if','line_number':464,'multiline':False]['text':'/     <tt>boost::result_of\<when\<_,T\>(E,int,int)\>::type::value</tt>','line_number':465,'multiline':False]['text':'/     is \c true and \c E matches \c U; or, if','line_number':466,'multiline':False]['text':'/     <tt>boost::result_of\<when\<_,T\>(E,int,int)\>::type::value</tt>','line_number':467,'multiline':False]['text':'/     is \c false and \c E matches \c V. (Note: \c U defaults to \c _','line_number':468,'multiline':False]['text':'/     and \c V defaults to \c not_\<_\>.)','line_number':469,'multiline':False]['text':'/ \li An expression \c E matches <tt>not_\<T\></tt> if \c E does','line_number':470,'multiline':False]['text':'/     not match \c T.','line_number':471,'multiline':False]['text':'/ \li An expression \c E matches <tt>switch_\<C,T\></tt> if','line_number':472,'multiline':False]['text':'/     \c E matches <tt>C::case_\<boost::result_of\<T(E)\>::type\></tt>.','line_number':473,'multiline':False]['text':'/     (Note: T defaults to <tt>tag_of\<_\>()</tt>.)','line_number':474,'multiline':False]['text':'/','line_number':475,'multiline':False]['text':'/ A terminal expression <tt>expr\<AT,term\<A\> \></tt> matches','line_number':476,'multiline':False]['text':'/ a grammar <tt>expr\<BT,term\<B\> \></tt> if \c BT is \c AT or','line_number':477,'multiline':False]['text':'/ \c proto::_ and if one of the following is true:','line_number':478,'multiline':False]['text':'/','line_number':479,'multiline':False]['text':'/ \li \c B is the wildcard pattern, \c _','line_number':480,'multiline':False]['text':'/ \li \c A is \c B','line_number':481,'multiline':False]['text':'/ \li \c A is <tt>B &</tt>','line_number':482,'multiline':False]['text':'/ \li \c A is <tt>B const &</tt>','line_number':483,'multiline':False]['text':'/ \li \c B is <tt>exact\<A\></tt>','line_number':484,'multiline':False]['text':'/ \li \c B is <tt>convertible_to\<X\></tt> and','line_number':485,'multiline':False]['text':'/     <tt>is_convertible\<A,X\>::value</tt> is \c true.','line_number':486,'multiline':False]['text':'/ \li \c A is <tt>X[M]</tt> or <tt>X(&)[M]</tt> and','line_number':487,'multiline':False]['text':'/     \c B is <tt>X[proto::N]</tt>.','line_number':488,'multiline':False]['text':'/ \li \c A is <tt>X(&)[M]</tt> and \c B is <tt>X(&)[proto::N]</tt>.','line_number':489,'multiline':False]['text':'/ \li \c A is <tt>X[M]</tt> or <tt>X(&)[M]</tt> and','line_number':490,'multiline':False]['text':'/     \c B is <tt>X*</tt>.','line_number':491,'multiline':False]['text':'/ \li \c B lambda-matches \c A (see below).','line_number':492,'multiline':False]['text':'/','line_number':493,'multiline':False]['text':'/ A type \c B lambda-matches \c A if one of the following is true:','line_number':494,'multiline':False]['text':'/','line_number':495,'multiline':False]['text':'/ \li \c B is \c A','line_number':496,'multiline':False]['text':'/ \li \c B is the wildcard pattern, \c _','line_number':497,'multiline':False]['text':'/ \li \c B is <tt>T\<B0,B1,...Bn\></tt> and \c A is','line_number':498,'multiline':False]['text':'/     <tt>T\<A0,A1,...An\></tt> and for each \c x in','line_number':499,'multiline':False]['text':'/     <tt>[0,n)</tt>, \c Ax and \c Bx are types','line_number':500,'multiline':False]['text':'/     such that \c Ax lambda-matches \c Bx','line_number':501,'multiline':False]['text':'/ INTERNAL ONLY','line_number':511,'multiline':False]['text':'/','line_number':512,'multiline':False]['text':'/ \brief A wildcard grammar element that matches any expression,','line_number':522,'multiline':False]['text':'/ and a transform that returns the current expression unchanged.','line_number':523,'multiline':False]['text':'/','line_number':524,'multiline':False]['text':'/ The wildcard type, \c _, is a grammar element such that','line_number':525,'multiline':False]['text':'/ <tt>matches\<E,_\>::value</tt> is \c true for any expression','line_number':526,'multiline':False]['text':'/ type \c E.','line_number':527,'multiline':False]['text':'/','line_number':528,'multiline':False]['text':'/ The wildcard can also be used as a stand-in for a template','line_number':529,'multiline':False]['text':'/ argument when matching terminals. For instance, the following','line_number':530,'multiline':False]['text':'/ is a grammar that will match any <tt>std::complex\<\></tt>','line_number':531,'multiline':False]['text':'/ terminal:','line_number':532,'multiline':False]['text':'/','line_number':533,'multiline':False]['text':'/ \code','line_number':534,'multiline':False]['text':'/ BOOST_MPL_ASSERT((','line_number':535,'multiline':False]['text':'/     matches<','line_number':536,'multiline':False]['text':'/         terminal<std::complex<double> >::type','line_number':537,'multiline':False]['text':'/       , terminal<std::complex< _ > >','line_number':538,'multiline':False]['text':'/     >','line_number':539,'multiline':False]['text':'/ ));','line_number':540,'multiline':False]['text':'/ \endcode','line_number':541,'multiline':False]['text':'/','line_number':542,'multiline':False]['text':'/ When used as a transform, \c _ returns the current expression','line_number':543,'multiline':False]['text':'/ unchanged. For instance, in the following, \c _ is used with','line_number':544,'multiline':False]['text':'/ the \c fold\<\> transform to fold the children of a node:','line_number':545,'multiline':False]['text':'/','line_number':546,'multiline':False]['text':'/ \code','line_number':547,'multiline':False]['text':'/ struct CountChildren','line_number':548,'multiline':False]['text':'/   : or_<','line_number':549,'multiline':False]['text':'/         // Terminals have no children','line_number':550,'multiline':False]['text':'/         when<terminal<_>, mpl::int_<0>()>','line_number':551,'multiline':False]['text':'/         // Use fold<> to count the children of non-terminals','line_number':552,'multiline':False]['text':'/       , otherwise<','line_number':553,'multiline':False]['text':'/             fold<','line_number':554,'multiline':False]['text':'/                 _ // <-- fold the current expression','line_number':555,'multiline':False]['text':'/               , mpl::int_<0>()','line_number':556,'multiline':False]['text':'/               , mpl::plus<_state, mpl::int_<1> >()','line_number':557,'multiline':False]['text':'/             >','line_number':558,'multiline':False]['text':'/         >','line_number':559,'multiline':False]['text':'/     >','line_number':560,'multiline':False]['text':'/ {};','line_number':561,'multiline':False]['text':'/ \endcode','line_number':562,'multiline':False]['text':'/ \param expr An expression','line_number':572,'multiline':False]['text':'/ \return \c e','line_number':573,'multiline':False]['text':'/ \brief Inverts the set of expressions matched by a grammar. When','line_number':599,'multiline':False]['text':'/ used as a transform, \c not_\<\> returns the current expression','line_number':600,'multiline':False]['text':'/ unchanged.','line_number':601,'multiline':False]['text':'/','line_number':602,'multiline':False]['text':'/ If an expression type \c E does not match a grammar \c G, then','line_number':603,'multiline':False]['text':'/ \c E \e does match <tt>not_\<G\></tt>. For example,','line_number':604,'multiline':False]['text':'/ <tt>not_\<terminal\<_\> \></tt> will match any non-terminal.','line_number':605,'multiline':False]['text':'/ \param e An expression','line_number':616,'multiline':False]['text':'/ \pre <tt>matches\<Expr,not_\>::value</tt> is \c true.','line_number':617,'multiline':False]['text':'/ \return \c e','line_number':618,'multiline':False]['text':'/ \brief Used to select one grammar or another based on the result','line_number':631,'multiline':False]['text':'/ of a compile-time Boolean. When used as a transform, \c if_\<\>','line_number':632,'multiline':False]['text':'/ selects between two transforms based on a compile-time Boolean.','line_number':633,'multiline':False]['text':'/','line_number':634,'multiline':False]['text':'/ When <tt>if_\<If,Then,Else\></tt> is used as a grammar, \c If','line_number':635,'multiline':False]['text':'/ must be a Proto transform and \c Then and \c Else must be grammars.','line_number':636,'multiline':False]['text':'/ An expression type \c E matches <tt>if_\<If,Then,Else\></tt> if','line_number':637,'multiline':False]['text':'/ <tt>boost::result_of\<when\<_,If\>(E,int,int)\>::type::value</tt>','line_number':638,'multiline':False]['text':'/ is \c true and \c E matches \c U; or, if','line_number':639,'multiline':False]['text':'/ <tt>boost::result_of\<when\<_,If\>(E,int,int)\>::type::value</tt>','line_number':640,'multiline':False]['text':'/ is \c false and \c E matches \c V.','line_number':641,'multiline':False]['text':'/','line_number':642,'multiline':False]['text':'/ The template parameter \c Then defaults to \c _','line_number':643,'multiline':False]['text':'/ and \c Else defaults to \c not\<_\>, so an expression type \c E','line_number':644,'multiline':False]['text':'/ will match <tt>if_\<If\></tt> if and only if','line_number':645,'multiline':False]['text':'/ <tt>boost::result_of\<when\<_,If\>(E,int,int)\>::type::value</tt>','line_number':646,'multiline':False]['text':'/ is \c true.','line_number':647,'multiline':False]['text':'/','line_number':648,'multiline':False]['text':'/ \code','line_number':649,'multiline':False]['text':'/ // A grammar that only matches integral terminals,','line_number':650,'multiline':False]['text':'/ // using is_integral<> from Boost.Type_traits.','line_number':651,'multiline':False]['text':'/ struct IsIntegral','line_number':652,'multiline':False]['text':'/   : and_<','line_number':653,'multiline':False]['text':'/         terminal<_>','line_number':654,'multiline':False]['text':'/       , if_< is_integral<_value>() >','line_number':655,'multiline':False]['text':'/     >','line_number':656,'multiline':False]['text':'/ {};','line_number':657,'multiline':False]['text':'/ \endcode','line_number':658,'multiline':False]['text':'/','line_number':659,'multiline':False]['text':'/ When <tt>if_\<If,Then,Else\></tt> is used as a transform, \c If,','line_number':660,'multiline':False]['text':'/ \c Then and \c Else must be Proto transforms. When applying','line_number':661,'multiline':False]['text':'/ the transform to an expression \c E, state \c S and data \c V,','line_number':662,'multiline':False]['text':'/ if <tt>boost::result_of\<when\<_,If\>(E,S,V)\>::type::value</tt>','line_number':663,'multiline':False]['text':'/ is \c true then the \c Then transform is applied; otherwise','line_number':664,'multiline':False]['text':'/ the \c Else transform is applied.','line_number':665,'multiline':False]['text':'/','line_number':666,'multiline':False]['text':'/ \code','line_number':667,'multiline':False]['text':'/ // Match a terminal. If the terminal is integral, return','line_number':668,'multiline':False]['text':'/ // mpl::true_; otherwise, return mpl::false_.','line_number':669,'multiline':False]['text':'/ struct IsIntegral2','line_number':670,'multiline':False]['text':'/   : when<','line_number':671,'multiline':False]['text':'/         terminal<_>','line_number':672,'multiline':False]['text':'/       , if_<','line_number':673,'multiline':False]['text':'/             is_integral<_value>()','line_number':674,'multiline':False]['text':'/           , mpl::true_()','line_number':675,'multiline':False]['text':'/           , mpl::false_()','line_number':676,'multiline':False]['text':'/         >','line_number':677,'multiline':False]['text':'/     >','line_number':678,'multiline':False]['text':'/ {};','line_number':679,'multiline':False]['text':'/ \endcode','line_number':680,'multiline':False]['text':' = _','line_number':683,'multiline':False]['text':' = not_<_>','line_number':684,'multiline':False]['text':'/ \param e An expression','line_number':707,'multiline':False]['text':'/ \param s The current state','line_number':708,'multiline':False]['text':'/ \param d A data of arbitrary type','line_number':709,'multiline':False]['text':'/ \return <tt>which::impl<Expr, State, Data>()(e, s, d)</tt>','line_number':710,'multiline':False]['text':'/ \brief For matching one of a set of alternate grammars. Alternates','line_number':722,'multiline':False]['text':'/ tried in order to avoid ambiguity. When used as a transform, \c or_\<\>','line_number':723,'multiline':False]['text':'/ applies the transform associated with the first grammar that matches','line_number':724,'multiline':False]['text':'/ the expression.','line_number':725,'multiline':False]['text':'/','line_number':726,'multiline':False]['text':'/ An expression type \c E matches <tt>or_\<B0,B1,...Bn\></tt> if \c E','line_number':727,'multiline':False]['text':'/ matches any \c Bx for \c x in <tt>[0,n)</tt>.','line_number':728,'multiline':False]['text':'/','line_number':729,'multiline':False]['text':'/ When applying <tt>or_\<B0,B1,...Bn\></tt> as a transform with an','line_number':730,'multiline':False]['text':'/ expression \c e of type \c E, state \c s and data \c d, it is','line_number':731,'multiline':False]['text':'/ equivalent to <tt>Bx()(e, s, d)</tt>, where \c x is the lowest','line_number':732,'multiline':False]['text':'/ number such that <tt>matches\<E,Bx\>::value</tt> is \c true.','line_number':733,'multiline':False]['text':'/ \param e An expression','line_number':739,'multiline':False]['text':'/ \param s The current state','line_number':740,'multiline':False]['text':'/ \param d A data of arbitrary type','line_number':741,'multiline':False]['text':'/ \pre <tt>matches\<Expr,or_\>::value</tt> is \c true.','line_number':742,'multiline':False]['text':'/ \return <tt>which()(e, s, d)</tt>, where <tt>which</tt> is the','line_number':743,'multiline':False]['text':'/ sub-grammar that matched <tt>Expr</tt>.','line_number':744,'multiline':False]['text':'/ \brief For matching all of a set of grammars. When used as a','line_number':765,'multiline':False]['text':'/ transform, \c and_\<\> applies the transforms associated with','line_number':766,'multiline':False]['text':'/ the each grammar in the set, and returns the result of the last.','line_number':767,'multiline':False]['text':'/','line_number':768,'multiline':False]['text':'/ An expression type \c E matches <tt>and_\<B0,B1,...Bn\></tt> if \c E','line_number':769,'multiline':False]['text':'/ matches all \c Bx for \c x in <tt>[0,n)</tt>.','line_number':770,'multiline':False]['text':'/','line_number':771,'multiline':False]['text':'/ When applying <tt>and_\<B0,B1,...Bn\></tt> as a transform with an','line_number':772,'multiline':False]['text':'/ expression \c e, state \c s and data \c d, it is','line_number':773,'multiline':False]['text':'/ equivalent to <tt>(B0()(e, s, d),B1()(e, s, d),...Bn()(e, s, d))</tt>.','line_number':774,'multiline':False]['text':'/ \brief For matching one of a set of alternate grammars, which','line_number':786,'multiline':False]['text':'/ are looked up based on some property of an expression. The','line_number':787,'multiline':False]['text':'/ property on which to dispatch is specified by the \c Transform','line_number':788,'multiline':False]['text':'/ template parameter, which defaults to <tt>tag_of\<_\>()</tt>.','line_number':789,'multiline':False]['text':'/ That is, when the \c Trannsform is not specified, the alternate','line_number':790,'multiline':False]['text':'/ grammar is looked up using the tag type of the current expression.','line_number':791,'multiline':False]['text':'/','line_number':792,'multiline':False]['text':'/ When used as a transform, \c switch_\<\> applies the transform','line_number':793,'multiline':False]['text':'/ associated with the grammar that matches the expression.','line_number':794,'multiline':False]['text':'/','line_number':795,'multiline':False]['text':'/ \note \c switch_\<\> is functionally identical to \c or_\<\> but','line_number':796,'multiline':False]['text':'/ is often more efficient. It does a fast, O(1) lookup using the','line_number':797,'multiline':False]['text':'/ result of the specified transform to find a sub-grammar that may','line_number':798,'multiline':False]['text':'/ potentially match the expression.','line_number':799,'multiline':False]['text':'/','line_number':800,'multiline':False]['text':'/ An expression type \c E matches <tt>switch_\<C,T\></tt> if \c E','line_number':801,'multiline':False]['text':'/ matches <tt>C::case_\<boost::result_of\<T(E)\>::type\></tt>.','line_number':802,'multiline':False]['text':'/','line_number':803,'multiline':False]['text':'/ When applying <tt>switch_\<C,T\></tt> as a transform with an','line_number':804,'multiline':False]['text':'/ expression \c e of type \c E, state \c s of type \S and data','line_number':805,'multiline':False]['text':'/ \c d of type \c D, it is equivalent to','line_number':806,'multiline':False]['text':'/ <tt>C::case_\<boost::result_of\<T(E,S,D)\>::type\>()(e, s, d)</tt>.','line_number':807,'multiline':False]['text':'/ INTERNAL ONLY (This is merely a compile-time optimization for the common case)','line_number':821,'multiline':False]['text':'/','line_number':822,'multiline':False]['text':'/ \brief For forcing exact matches of terminal types.','line_number':839,'multiline':False]['text':'/','line_number':840,'multiline':False]['text':'/ By default, matching terminals ignores references and','line_number':841,'multiline':False]['text':'/ cv-qualifiers. For instance, a terminal expression of','line_number':842,'multiline':False]['text':'/ type <tt>terminal\<int const &\>::type</tt> will match','line_number':843,'multiline':False]['text':'/ the grammar <tt>terminal\<int\></tt>. If that is not','line_number':844,'multiline':False]['text':'/ desired, you can force an exact match with','line_number':845,'multiline':False]['text':'/ <tt>terminal\<exact\<int\> \></tt>. This will only','line_number':846,'multiline':False]['text':'/ match integer terminals where the terminal is held by','line_number':847,'multiline':False]['text':'/ value.','line_number':848,'multiline':False]['text':'/ \brief For matching terminals that are convertible to','line_number':853,'multiline':False]['text':'/ a type.','line_number':854,'multiline':False]['text':'/','line_number':855,'multiline':False]['text':'/ Use \c convertible_to\<\> to match a terminal that is','line_number':856,'multiline':False]['text':'/ convertible to some type. For example, the grammar','line_number':857,'multiline':False]['text':'/ <tt>terminal\<convertible_to\<int\> \></tt> will match','line_number':858,'multiline':False]['text':'/ any terminal whose argument is convertible to an integer.','line_number':859,'multiline':False]['text':'/','line_number':860,'multiline':False]['text':'/ \note The trait \c is_convertible\<\> from Boost.Type_traits','line_number':861,'multiline':False]['text':'/ is used to determinal convertibility.','line_number':862,'multiline':False]['text':'/ \brief For matching a Grammar to a variable number of','line_number':867,'multiline':False]['text':'/ sub-expressions.','line_number':868,'multiline':False]['text':'/','line_number':869,'multiline':False]['text':'/ An expression type <tt>expr\<AT, listN\<A0,...An,U0,...Um\> \></tt>','line_number':870,'multiline':False]['text':'/ matches a grammar <tt>expr\<BT, listM\<B0,...Bn,vararg\<V\> \> \></tt>','line_number':871,'multiline':False]['text':'/ if \c BT is \c _ or \c AT, and if \c Ax matches \c Bx','line_number':872,'multiline':False]['text':'/ for each \c x in <tt>[0,n)</tt> and if \c Ux matches \c V','line_number':873,'multiline':False]['text':'/ for each \c x in <tt>[0,m)</tt>.','line_number':874,'multiline':False]['text':'/','line_number':875,'multiline':False]['text':'/ For example:','line_number':876,'multiline':False]['text':'/','line_number':877,'multiline':False]['text':'/ \code','line_number':878,'multiline':False]['text':'/ // Match any function call expression, irregardless','line_number':879,'multiline':False]['text':'/ // of the number of function arguments:','line_number':880,'multiline':False]['text':'/ struct Function','line_number':881,'multiline':False]['text':'/   : function< vararg<_> >','line_number':882,'multiline':False]['text':'/ {};','line_number':883,'multiline':False]['text':'/ \endcode','line_number':884,'multiline':False]['text':'/','line_number':885,'multiline':False]['text':'/ When used as a transform, <tt>vararg\<G\></tt> applies','line_number':886,'multiline':False]['text':'/ <tt>G</tt>'s transform.','line_number':887,'multiline':False]['text':'/ INTERNAL ONLY','line_number':892,'multiline':False]['text':'/ INTERNAL ONLY','line_number':896,'multiline':False]['text':'/','line_number':897,'multiline':False]['text':'/ INTERNAL ONLY','line_number':903,'multiline':False]['text':'/','line_number':904,'multiline':False]['text':'/ INTERNAL ONLY','line_number':910,'multiline':False]['text':'/','line_number':911,'multiline':False]['text':'/ INTERNAL ONLY','line_number':917,'multiline':False]['text':'/','line_number':918,'multiline':False]['text':'/ INTERNAL ONLY','line_number':924,'multiline':False]['text':'/','line_number':925,'multiline':False]['text':'/ INTERNAL ONLY','line_number':931,'multiline':False]['text':'/','line_number':932,'multiline':False]