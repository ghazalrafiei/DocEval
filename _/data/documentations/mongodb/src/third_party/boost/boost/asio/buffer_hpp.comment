['text':'','line_number':1,'multiline':False]['text':' buffer.hpp','line_number':2,'multiline':False]['text':' ~~~~~~~~~~','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Copyright (c) 2003-2022 Christopher M. Kohlhoff (chris at kohlhoff dot com)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See accompanying','line_number':7,'multiline':False]['text':' file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' defined(_MSC_VER) && (_MSC_VER >= 1200)','line_number':16,'multiline':False]['text':' !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)','line_number':35,'multiline':False]['text':' defined(_HAS_ITERATOR_DEBUGGING)','line_number':36,'multiline':False]['text':' defined(BOOST_ASIO_MSVC) && (BOOST_ASIO_MSVC >= 1700)','line_number':37,'multiline':False]['text':' !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)','line_number':43,'multiline':False]['text':' defined(_GLIBCXX_DEBUG)','line_number':44,'multiline':False]['text':' defined(__GNUC__)','line_number':45,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':49,'multiline':False]['text':' BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582))','line_number':56,'multiline':False]['text':' BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))','line_number':59,'multiline':False]['text':' defined(BOOST_ASIO_HAS_BOOST_WORKAROUND)','line_number':60,'multiline':False]['text':' defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':64,'multiline':False]['text':'/ Holds a buffer that can be modified.','line_number':74,'multiline':False]['text':'*
 * The mutable_buffer class provides a safe representation of a buffer that can
 * be modified. It does not own the underlying data, and so is cheap to copy or
 * assign.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code boost::asio::mutable_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
 * @endcode
 *
 * The @c data() member function permits violations of type safety, so uses of
 * it in application code should be carefully considered.
 ','line_number':75,'multiline':True]['text':'/ Construct an empty buffer.','line_number':96,'multiline':False]['text':'/ Construct a buffer to represent a given memory range.','line_number':103,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':123,'multiline':False]['text':'/ Get a pointer to the beginning of the memory range.','line_number':125,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':131,'multiline':False]['text':'/ Get the size of the memory range.','line_number':135,'multiline':False]['text':'/ Move the start of the buffer by the specified number of bytes.','line_number':141,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':156,'multiline':False]['text':'/ (Deprecated: Use mutable_buffer.) Adapts a single modifiable buffer so that','line_number':161,'multiline':False]['text':'/ it meets the requirements of the MutableBufferSequence concept.','line_number':162,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':167,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':170,'multiline':False]['text':'/ Construct to represent a given memory range.','line_number':173,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':185,'multiline':False]['text':'/ Construct to represent a single modifiable buffer.','line_number':187,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':193,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':199,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DEPRECATED)','line_number':206,'multiline':False]['text':'/ Holds a buffer that cannot be modified.','line_number':208,'multiline':False]['text':'*
 * The const_buffer class provides a safe representation of a buffer that cannot
 * be modified. It does not own the underlying data, and so is cheap to copy or
 * assign.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code boost::asio::const_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());
 * @endcode
 *
 * The @c data() member function permits violations of type safety, so uses of
 * it in application code should be carefully considered.
 ','line_number':209,'multiline':True]['text':'/ Construct an empty buffer.','line_number':230,'multiline':False]['text':'/ Construct a buffer to represent a given memory range.','line_number':237,'multiline':False]['text':'/ Construct a non-modifiable buffer from a modifiable one.','line_number':244,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':250,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':267,'multiline':False]['text':'/ Get a pointer to the beginning of the memory range.','line_number':269,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':275,'multiline':False]['text':'/ Get the size of the memory range.','line_number':279,'multiline':False]['text':'/ Move the start of the buffer by the specified number of bytes.','line_number':285,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':300,'multiline':False]['text':'/ (Deprecated: Use const_buffer.) Adapts a single non-modifiable buffer so','line_number':305,'multiline':False]['text':'/ that it meets the requirements of the ConstBufferSequence concept.','line_number':306,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':311,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':314,'multiline':False]['text':'/ Construct to represent a given memory range.','line_number':317,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':329,'multiline':False]['text':'/ Construct to represent a single non-modifiable buffer.','line_number':331,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':337,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':343,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DEPRECATED)','line_number':350,'multiline':False]['text':'/ (Deprecated: Use the socket/descriptor wait() and async_wait() member','line_number':352,'multiline':False]['text':'/ functions.) An implementation of both the ConstBufferSequence and','line_number':353,'multiline':False]['text':'/ MutableBufferSequence concepts to represent a null buffer sequence.','line_number':354,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':358,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':361,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':364,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':370,'multiline':False]['text':'* @defgroup buffer_sequence_begin boost::asio::buffer_sequence_begin
 *
 * @brief The boost::asio::buffer_sequence_begin function returns an iterator
 * pointing to the first element in a buffer sequence.
 ','line_number':380,'multiline':True]['text':'@{','line_number':385,'multiline':True]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':387,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':397,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':409,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':420,'multiline':False]['text':' defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':431,'multiline':False]['text':' defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':453,'multiline':False]['text':'@}','line_number':455,'multiline':True]['text':'* @defgroup buffer_sequence_end boost::asio::buffer_sequence_end
 *
 * @brief The boost::asio::buffer_sequence_end function returns an iterator
 * pointing to one past the end element in a buffer sequence.
 ','line_number':457,'multiline':True]['text':'@{','line_number':462,'multiline':True]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':464,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':474,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':486,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':497,'multiline':False]['text':' defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':508,'multiline':False]['text':' defined(BOOST_ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':530,'multiline':False]['text':'@}','line_number':532,'multiline':True]['text':' Tag types used to select appropriately optimised overloads.','line_number':536,'multiline':False]['text':' Helper trait to detect single buffers.','line_number':540,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DEPRECATED)','line_number':548,'multiline':False]['text':' namespace detail','line_number':575,'multiline':False]['text':'/ Get the total number of bytes in a buffer sequence.','line_number':577,'multiline':False]['text':'*
 * The @c buffer_size function determines the total size of all buffers in the
 * buffer sequence, as if computed as follows:
 *
 * @code size_t total_size = 0;
 * auto i = boost::asio::buffer_sequence_begin(buffers);
 * auto end = boost::asio::buffer_sequence_end(buffers);
 * for (; i != end; ++i)
 * {
 *   const_buffer b(*i);
 *   total_size += b.size();
 * }
 * return total_size; @endcode
 *
 * The @c BufferSequence template parameter may meet either of the @c
 * ConstBufferSequence or @c MutableBufferSequence type requirements.
 ','line_number':578,'multiline':True]['text':'* @defgroup buffer_cast boost::asio::buffer_cast
 *
 * @brief (Deprecated: Use the @c data() member function.) The
 * boost::asio::buffer_cast function is used to obtain a pointer to the
 * underlying memory region associated with a buffer.
 *
 * @par Examples:
 *
 * To access the memory of a non-modifiable buffer, use:
 * @code boost::asio::const_buffer b1 = ...;
 * const unsigned char* p1 = boost::asio::buffer_cast<const unsigned char*>(b1);
 * @endcode
 *
 * To access the memory of a modifiable buffer, use:
 * @code boost::asio::mutable_buffer b2 = ...;
 * unsigned char* p2 = boost::asio::buffer_cast<unsigned char*>(b2);
 * @endcode
 *
 * The boost::asio::buffer_cast function permits violations of type safety, so
 * uses of it in application code should be carefully considered.
 ','line_number':606,'multiline':True]['text':'@{','line_number':627,'multiline':True]['text':'/ Cast a non-modifiable buffer to a specified pointer to POD type.','line_number':629,'multiline':False]['text':'/ Cast a non-modifiable buffer to a specified pointer to POD type.','line_number':636,'multiline':False]['text':'@}','line_number':643,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DEPRECATED)','line_number':645,'multiline':False]['text':'/ Create a new modifiable buffer that is offset from the start of another.','line_number':647,'multiline':False]['text':'*
 * @relates mutable_buffer
 ','line_number':648,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':660,'multiline':False]['text':'/ Create a new modifiable buffer that is offset from the start of another.','line_number':664,'multiline':False]['text':'*
 * @relates mutable_buffer
 ','line_number':665,'multiline':True]['text':'/ Create a new non-modifiable buffer that is offset from the start of another.','line_number':674,'multiline':False]['text':'*
 * @relates const_buffer
 ','line_number':675,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':687,'multiline':False]['text':'/ Create a new non-modifiable buffer that is offset from the start of another.','line_number':691,'multiline':False]['text':'*
 * @relates const_buffer
 ','line_number':692,'multiline':True]['text':' MSVC 8's string iterator checking may crash in a std::string::iterator','line_number':716,'multiline':False]['text':' object's destructor when the iterator points to an already-destroyed','line_number':717,'multiline':False]['text':' std::string object, unless the iterator is cleared first.','line_number':718,'multiline':False]['text':' defined(BOOST_ASIO_MSVC) && (BOOST_ASIO_MSVC == 1400)','line_number':720,'multiline':False]['text':' namespace detail','line_number':732,'multiline':False]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':733,'multiline':False]['text':'* @defgroup buffer boost::asio::buffer
 *
 * @brief The boost::asio::buffer function is used to create a buffer object to
 * represent raw memory, an array of POD elements, a vector of POD elements,
 * or a std::string.
 *
 * A buffer object represents a contiguous region of memory as a 2-tuple
 * consisting of a pointer and size in bytes. A tuple of the form <tt>{void*,
 * size_t}</tt> specifies a mutable (modifiable) region of memory. Similarly, a
 * tuple of the form <tt>{const void*, size_t}</tt> specifies a const
 * (non-modifiable) region of memory. These two forms correspond to the classes
 * mutable_buffer and const_buffer, respectively. To mirror C++'s conversion
 * rules, a mutable_buffer is implicitly convertible to a const_buffer, and the
 * opposite conversion is not permitted.
 *
 * The simplest use case involves reading or writing a single buffer of a
 * specified size:
 *
 * @code sock.send(boost::asio::buffer(data, size)); @endcode
 *
 * In the above example, the return value of boost::asio::buffer meets the
 * requirements of the ConstBufferSequence concept so that it may be directly
 * passed to the socket's write function. A buffer created for modifiable
 * memory also meets the requirements of the MutableBufferSequence concept.
 *
 * An individual buffer may be created from a builtin array, std::vector,
 * std::array or boost::array of POD elements. This helps prevent buffer
 * overruns by automatically determining the size of the buffer:
 *
 * @code char d1[128];
 * size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));
 *
 * std::vector<char> d2(128);
 * bytes_transferred = sock.receive(boost::asio::buffer(d2));
 *
 * std::array<char, 128> d3;
 * bytes_transferred = sock.receive(boost::asio::buffer(d3));
 *
 * boost::array<char, 128> d4;
 * bytes_transferred = sock.receive(boost::asio::buffer(d4)); @endcode
 *
 * In all three cases above, the buffers created are exactly 128 bytes long.
 * Note that a vector is @e never automatically resized when creating or using
 * a buffer. The buffer size is determined using the vector's <tt>size()</tt>
 * member function, and not its capacity.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code boost::asio::mutable_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
 *
 * boost::asio::const_buffer b2 = ...;
 * std::size_t s2 = b2.size();
 * const void* p2 = b2.data(); @endcode
 *
 * The @c data() member function permits violations of type safety, so
 * uses of it in application code should be carefully considered.
 *
 * For convenience, a @ref buffer_size function is provided that works with
 * both buffers and buffer sequences (that is, types meeting the
 * ConstBufferSequence or MutableBufferSequence type requirements). In this
 * case, the function returns the total size of all buffers in the sequence.
 *
 * @par Buffer Copying
 *
 * The @ref buffer_copy function may be used to copy raw bytes between
 * individual buffers and buffer sequences.
*
 * In particular, when used with the @ref buffer_size function, the @ref
 * buffer_copy function can be used to linearise a sequence of buffers. For
 * example:
 *
 * @code vector<const_buffer> buffers = ...;
 *
 * vector<unsigned char> data(boost::asio::buffer_size(buffers));
 * boost::asio::buffer_copy(boost::asio::buffer(data), buffers); @endcode
 *
 * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
 * consequently it cannot be used to copy between overlapping memory regions.
 *
 * @par Buffer Invalidation
 *
 * A buffer object does not have any ownership of the memory it refers to. It
 * is the responsibility of the application to ensure the memory region remains
 * valid until it is no longer required for an I/O operation. When the memory
 * is no longer available, the buffer is said to have been invalidated.
 *
 * For the boost::asio::buffer overloads that accept an argument of type
 * std::vector, the buffer objects returned are invalidated by any vector
 * operation that also invalidates all references, pointers and iterators
 * referring to the elements in the sequence (C++ Std, 23.2.4)
 *
 * For the boost::asio::buffer overloads that accept an argument of type
 * std::basic_string, the buffer objects returned are invalidated according to
 * the rules defined for invalidation of references, pointers and iterators
 * referring to elements of the sequence (C++ Std, 21.3).
 *
 * @par Buffer Arithmetic
 *
 * Buffer objects may be manipulated using simple arithmetic in a safe way
 * which helps prevent buffer overruns. Consider an array initialised as
 * follows:
 *
 * @code boost::array<char, 6> a = { 'a', 'b', 'c', 'd', 'e' }; @endcode
 *
 * A buffer object @c b1 created using:
 *
 * @code b1 = boost::asio::buffer(a); @endcode
 *
 * represents the entire array, <tt>{ 'a', 'b', 'c', 'd', 'e' }</tt>. An
 * optional second argument to the boost::asio::buffer function may be used to
 * limit the size, in bytes, of the buffer:
 *
 * @code b2 = boost::asio::buffer(a, 3); @endcode
 *
 * such that @c b2 represents the data <tt>{ 'a', 'b', 'c' }</tt>. Even if the
 * size argument exceeds the actual size of the array, the size of the buffer
 * object created will be limited to the array size.
 *
 * An offset may be applied to an existing buffer to create a new one:
 *
 * @code b3 = b1 + 2; @endcode
 *
 * where @c b3 will set to represent <tt>{ 'c', 'd', 'e' }</tt>. If the offset
 * exceeds the size of the existing buffer, the newly created buffer will be
 * empty.
 *
 * Both an offset and size may be specified to create a buffer that corresponds
 * to a specific range of bytes within an existing buffer:
 *
 * @code b4 = boost::asio::buffer(b1 + 1, 3); @endcode
 *
 * so that @c b4 will refer to the bytes <tt>{ 'b', 'c', 'd' }</tt>.
 *
 * @par Buffers and Scatter-Gather I/O
 *
 * To read or write using multiple buffers (i.e. scatter-gather I/O), multiple
 * buffer objects may be assigned into a container that supports the
 * MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:
 *
 * @code
 * char d1[128];
 * std::vector<char> d2(128);
 * boost::array<char, 128> d3;
 *
 * boost::array<mutable_buffer, 3> bufs1 = {
 *   boost::asio::buffer(d1),
 *   boost::asio::buffer(d2),
 *   boost::asio::buffer(d3) };
 * bytes_transferred = sock.receive(bufs1);
 *
 * std::vector<const_buffer> bufs2;
 * bufs2.push_back(boost::asio::buffer(d1));
 * bufs2.push_back(boost::asio::buffer(d2));
 * bufs2.push_back(boost::asio::buffer(d3));
 * bytes_transferred = sock.send(bufs2); @endcode
 ','line_number':735,'multiline':True]['text':'@{','line_number':896,'multiline':True]['text':' defined(BOOST_ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)','line_number':901,'multiline':False]['text':' defined(BOOST_ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)','line_number':904,'multiline':False]['text':'/ Create a new modifiable buffer from an existing buffer.','line_number':906,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(b)</tt>.
 ','line_number':907,'multiline':True]['text':'/ Create a new modifiable buffer from an existing buffer.','line_number':916,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     b.data(),
 *     min(b.size(), max_size_in_bytes)); @endcode
 ','line_number':917,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':933,'multiline':False]['text':'/ Create a new non-modifiable buffer from an existing buffer.','line_number':937,'multiline':False]['text':'*
 * @returns <tt>const_buffer(b)</tt>.
 ','line_number':938,'multiline':True]['text':'/ Create a new non-modifiable buffer from an existing buffer.','line_number':947,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     b.data(),
 *     min(b.size(), max_size_in_bytes)); @endcode
 ','line_number':948,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':963,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given memory range.','line_number':967,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data, size_in_bytes)</tt>.
 ','line_number':968,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given memory range.','line_number':977,'multiline':False]['text':'*
 * @returns <tt>const_buffer(data, size_in_bytes)</tt>.
 ','line_number':978,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':987,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     static_cast<void*>(data),
 *     N * sizeof(PodType)); @endcode
 ','line_number':988,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1001,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     static_cast<void*>(data),
 *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1002,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1018,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     static_cast<const void*>(data),
 *     N * sizeof(PodType)); @endcode
 ','line_number':1019,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1032,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     static_cast<const void*>(data),
 *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1033,'multiline':True]['text':' Borland C++ and Sun Studio think the overloads:','line_number':1051,'multiline':False]['text':'','line_number':1052,'multiline':False]['text':'   unspecified buffer(boost::array<PodType, N>& array ...);','line_number':1053,'multiline':False]['text':'','line_number':1054,'multiline':False]['text':' and','line_number':1055,'multiline':False]['text':'','line_number':1056,'multiline':False]['text':'   unspecified buffer(boost::array<const PodType, N>& array ...);','line_number':1057,'multiline':False]['text':'','line_number':1058,'multiline':False]['text':' are ambiguous. This will be worked around by using a buffer_types traits','line_number':1059,'multiline':False]['text':' class that contains typedefs for the appropriate buffer and container','line_number':1060,'multiline':False]['text':' classes, based on whether PodType is const or non-const.','line_number':1061,'multiline':False]['text':' namespace detail','line_number':1088,'multiline':False]['text':' defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':1119,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1121,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1122,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1136,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1137,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1153,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1154,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1167,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1168,'multiline':True]['text':' defined(BOOST_ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':1184,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1186,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1187,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1200,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1201,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1219,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1220,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1233,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1234,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1250,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1251,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1264,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1265,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1281,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1282,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1295,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1296,'multiline':True]['text':' defined(BOOST_ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)','line_number':1312,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD vector.','line_number':1314,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     data.size() * sizeof(PodType)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1315,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1334,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD vector.','line_number':1338,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1339,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1360,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD vector.','line_number':1364,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.size() ? &data[0] : 0,
 *     data.size() * sizeof(PodType)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1365,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1384,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD vector.','line_number':1388,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1389,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1410,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string.','line_number':1414,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
 * data.size() * sizeof(Elem))</tt>.
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1415,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1432,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string.','line_number':1436,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1437,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1458,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1462,'multiline':False]['text':'*
 * @returns <tt>const_buffer(data.data(), data.size() * sizeof(Elem))</tt>.
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1463,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1478,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1482,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1483,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1504,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string_view.','line_number':1511,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
 * data.size() * sizeof(Elem))</tt>.
 ','line_number':1512,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1526,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1530,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 ','line_number':1531,'multiline':True]['text':' BOOST_ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1549,'multiline':False]['text':' defined(BOOST_ASIO_HAS_STRING_VIEW)','line_number':1553,'multiline':False]['text':'  || defined(GENERATING_DOCUMENTATION)','line_number':1554,'multiline':False]['text':'@}','line_number':1556,'multiline':True]['text':'/ Adapt a basic_string to the DynamicBuffer requirements.','line_number':1558,'multiline':False]['text':'*
 * Requires that <tt>sizeof(Elem) == 1</tt>.
 ','line_number':1559,'multiline':True]['text':'/ The type used to represent a sequence of constant buffers that refers to','line_number':1566,'multiline':False]['text':'/ the underlying memory.','line_number':1567,'multiline':False]['text':'/ The type used to represent a sequence of mutable buffers that refers to','line_number':1570,'multiline':False]['text':'/ the underlying memory.','line_number':1571,'multiline':False]['text':'/ Construct a dynamic buffer from a string.','line_number':1574,'multiline':False]['text':'*
   * @param s The string to be used as backing storage for the dynamic buffer.
   * The object stores a reference to the string and the user is responsible
   * for ensuring that the string object remains valid while the
   * dynamic_string_buffer object, and copies of the object, are in use.
   *
   * @b DynamicBuffer_v1: Any existing data in the string is treated as the
   * dynamic buffer's input sequence.
   *
   * @param maximum_size Specifies a maximum size for the buffer, in bytes.
   ','line_number':1575,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1592,'multiline':False]['text':'/ @b DynamicBuffer_v2: Copy construct a dynamic buffer.','line_number':1597,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1602,'multiline':False]['text':'/ Move construct a dynamic buffer.','line_number':1608,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1613,'multiline':False]['text':' defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)','line_number':1617,'multiline':False]['text':'/ @b DynamicBuffer_v1: Get the size of the input sequence.','line_number':1619,'multiline':False]['text':'/ @b DynamicBuffer_v2: Get the current size of the underlying memory.','line_number':1620,'multiline':False]['text':'*
   * @returns @b DynamicBuffer_v1 The current size of the input sequence.
   * @b DynamicBuffer_v2: The current size of the underlying string if less than
   * max_size(). Otherwise returns max_size().
   ','line_number':1621,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1631,'multiline':False]['text':'/ Get the maximum size of the dynamic buffer.','line_number':1635,'multiline':False]['text':'*
   * @returns The allowed maximum size of the underlying memory.
   ','line_number':1636,'multiline':True]['text':'/ Get the maximum size that the buffer may grow to without triggering','line_number':1644,'multiline':False]['text':'/ reallocation.','line_number':1645,'multiline':False]['text':'*
   * @returns The current capacity of the underlying string if less than
   * max_size(). Otherwise returns max_size().
   ','line_number':1646,'multiline':True]['text':'/ @b DynamicBuffer_v1: Get a list of buffers that represents the input','line_number':1656,'multiline':False]['text':'/ sequence.','line_number':1657,'multiline':False]['text':'*
   * @returns An object of type @c const_buffers_type that satisfies
   * ConstBufferSequence requirements, representing the basic_string memory in
   * the input sequence.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that resizes or erases the string.
   ','line_number':1658,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1670,'multiline':False]['text':'/ @b DynamicBuffer_v2: Get a sequence of buffers that represents the','line_number':1672,'multiline':False]['text':'/ underlying memory.','line_number':1673,'multiline':False]['text':'*
   * @param pos Position of the first byte to represent in the buffer sequence
   *
   * @param n The number of bytes to return in the buffer sequence. If the
   * underlying memory is shorter, the buffer sequence represents as many bytes
   * as are available.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing the basic_string memory.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that resizes or erases the string.
   ','line_number':1674,'multiline':True]['text':'/ @b DynamicBuffer_v2: Get a sequence of buffers that represents the','line_number':1693,'multiline':False]['text':'/ underlying memory.','line_number':1694,'multiline':False]['text':'*
   * @param pos Position of the first byte to represent in the buffer sequence
   *
   * @param n The number of bytes to return in the buffer sequence. If the
   * underlying memory is shorter, the buffer sequence represents as many bytes
   * as are available.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that resizes or erases the string.
   ','line_number':1695,'multiline':True]['text':'/ @b DynamicBuffer_v1: Get a list of buffers that represents the output','line_number':1713,'multiline':False]['text':'/ sequence, with the given size.','line_number':1714,'multiline':False]['text':'*
   * Ensures that the output sequence can accommodate @c n bytes, resizing the
   * basic_string object as necessary.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing basic_string memory
   * at the start of the output sequence of size @c n.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that modifies the input sequence or
   * output sequence.
   ','line_number':1715,'multiline':True]['text':' Enable v1 behaviour.','line_number':1738,'multiline':False]['text':'/ @b DynamicBuffer_v1: Move bytes from the output sequence to the input','line_number':1745,'multiline':False]['text':'/ sequence.','line_number':1746,'multiline':False]['text':'*
   * @param n The number of bytes to append from the start of the output
   * sequence to the end of the input sequence. The remainder of the output
   * sequence is discarded.
   *
   * Requires a preceding call <tt>prepare(x)</tt> where <tt>x >= n</tt>, and
   * no intervening operations that modify the input or output sequence.
   *
   * @note If @c n is greater than the size of the output sequence, the entire
   * output sequence is moved to the input sequence and no error is issued.
   ','line_number':1747,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1763,'multiline':False]['text':'/ @b DynamicBuffer_v2: Grow the underlying memory by the specified number of','line_number':1765,'multiline':False]['text':'/ bytes.','line_number':1766,'multiline':False]['text':'*
   * Resizes the string to accommodate an additional @c n bytes at the end.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   ','line_number':1767,'multiline':True]['text':'/ @b DynamicBuffer_v2: Shrink the underlying memory by the specified number','line_number':1783,'multiline':False]['text':'/ of bytes.','line_number':1784,'multiline':False]['text':'*
   * Erases @c n bytes from the end of the string by resizing the basic_string
   * object. If @c n is greater than the current size of the string, the string
   * is emptied.
   ','line_number':1785,'multiline':True]['text':'/ @b DynamicBuffer_v1: Remove characters from the input sequence.','line_number':1795,'multiline':False]['text':'/ @b DynamicBuffer_v2: Consume the specified number of bytes from the','line_number':1796,'multiline':False]['text':'/ beginning of the underlying memory.','line_number':1797,'multiline':False]['text':'*
   * @b DynamicBuffer_v1: Removes @c n characters from the beginning of the
   * input sequence. @note If @c n is greater than the size of the input
   * sequence, the entire input sequence is consumed and no error is issued.
   *
   * @b DynamicBuffer_v2: Erases @c n bytes from the beginning of the string.
   * If @c n is greater than the current size of the string, the string is
   * emptied.
   ','line_number':1798,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1817,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1825,'multiline':False]['text':'/ Adapt a vector to the DynamicBuffer requirements.','line_number':1829,'multiline':False]['text':'*
 * Requires that <tt>sizeof(Elem) == 1</tt>.
 ','line_number':1830,'multiline':True]['text':'/ The type used to represent a sequence of constant buffers that refers to','line_number':1837,'multiline':False]['text':'/ the underlying memory.','line_number':1838,'multiline':False]['text':'/ The type used to represent a sequence of mutable buffers that refers to','line_number':1841,'multiline':False]['text':'/ the underlying memory.','line_number':1842,'multiline':False]['text':'/ Construct a dynamic buffer from a vector.','line_number':1845,'multiline':False]['text':'*
   * @param v The vector to be used as backing storage for the dynamic buffer.
   * The object stores a reference to the vector and the user is responsible
   * for ensuring that the vector object remains valid while the
   * dynamic_vector_buffer object, and copies of the object, are in use.
   *
   * @param maximum_size Specifies a maximum size for the buffer, in bytes.
   ','line_number':1846,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1860,'multiline':False]['text':'/ @b DynamicBuffer_v2: Copy construct a dynamic buffer.','line_number':1865,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1870,'multiline':False]['text':'/ Move construct a dynamic buffer.','line_number':1876,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1881,'multiline':False]['text':' defined(BOOST_ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)','line_number':1885,'multiline':False]['text':'/ @b DynamicBuffer_v1: Get the size of the input sequence.','line_number':1887,'multiline':False]['text':'/ @b DynamicBuffer_v2: Get the current size of the underlying memory.','line_number':1888,'multiline':False]['text':'*
   * @returns @b DynamicBuffer_v1 The current size of the input sequence.
   * @b DynamicBuffer_v2: The current size of the underlying vector if less than
   * max_size(). Otherwise returns max_size().
   ','line_number':1889,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1899,'multiline':False]['text':'/ Get the maximum size of the dynamic buffer.','line_number':1903,'multiline':False]['text':'*
   * @returns @b DynamicBuffer_v1: The allowed maximum of the sum of the sizes
   * of the input sequence and output sequence. @b DynamicBuffer_v2: The allowed
   * maximum size of the underlying memory.
   ','line_number':1904,'multiline':True]['text':'/ Get the maximum size that the buffer may grow to without triggering','line_number':1914,'multiline':False]['text':'/ reallocation.','line_number':1915,'multiline':False]['text':'*
   * @returns @b DynamicBuffer_v1: The current total capacity of the buffer,
   * i.e. for both the input sequence and output sequence. @b DynamicBuffer_v2:
   * The current capacity of the underlying vector if less than max_size().
   * Otherwise returns max_size().
   ','line_number':1916,'multiline':True]['text':'/ @b DynamicBuffer_v1: Get a list of buffers that represents the input','line_number':1928,'multiline':False]['text':'/ sequence.','line_number':1929,'multiline':False]['text':'*
   * @returns An object of type @c const_buffers_type that satisfies
   * ConstBufferSequence requirements, representing the vector memory in the
   * input sequence.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c vector member function that modifies the input sequence or output
   * sequence.
   ','line_number':1930,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':1943,'multiline':False]['text':'/ @b DynamicBuffer_v2: Get a sequence of buffers that represents the','line_number':1945,'multiline':False]['text':'/ underlying memory.','line_number':1946,'multiline':False]['text':'*
   * @param pos Position of the first byte to represent in the buffer sequence
   *
   * @param n The number of bytes to return in the buffer sequence. If the
   * underlying memory is shorter, the buffer sequence represents as many bytes
   * as are available.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing the vector memory.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c vector member function that resizes or erases the vector.
   ','line_number':1947,'multiline':True]['text':'/ @b DynamicBuffer_v2: Get a sequence of buffers that represents the','line_number':1966,'multiline':False]['text':'/ underlying memory.','line_number':1967,'multiline':False]['text':'*
   * @param pos Position of the first byte to represent in the buffer sequence
   *
   * @param n The number of bytes to return in the buffer sequence. If the
   * underlying memory is shorter, the buffer sequence represents as many bytes
   * as are available.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c vector member function that resizes or erases the vector.
   ','line_number':1968,'multiline':True]['text':'/ @b DynamicBuffer_v1: Get a list of buffers that represents the output','line_number':1986,'multiline':False]['text':'/ sequence, with the given size.','line_number':1987,'multiline':False]['text':'*
   * Ensures that the output sequence can accommodate @c n bytes, resizing the
   * vector object as necessary.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing vector memory at the
   * start of the output sequence of size @c n.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c vector member function that modifies the input sequence or output
   * sequence.
   ','line_number':1988,'multiline':True]['text':' Enable v1 behaviour.','line_number':2011,'multiline':False]['text':'/ @b DynamicBuffer_v1: Move bytes from the output sequence to the input','line_number':2018,'multiline':False]['text':'/ sequence.','line_number':2019,'multiline':False]['text':'*
   * @param n The number of bytes to append from the start of the output
   * sequence to the end of the input sequence. The remainder of the output
   * sequence is discarded.
   *
   * Requires a preceding call <tt>prepare(x)</tt> where <tt>x >= n</tt>, and
   * no intervening operations that modify the input or output sequence.
   *
   * @note If @c n is greater than the size of the output sequence, the entire
   * output sequence is moved to the input sequence and no error is issued.
   ','line_number':2020,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2036,'multiline':False]['text':'/ @b DynamicBuffer_v2: Grow the underlying memory by the specified number of','line_number':2038,'multiline':False]['text':'/ bytes.','line_number':2039,'multiline':False]['text':'*
   * Resizes the vector to accommodate an additional @c n bytes at the end.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   ','line_number':2040,'multiline':True]['text':'/ @b DynamicBuffer_v2: Shrink the underlying memory by the specified number','line_number':2056,'multiline':False]['text':'/ of bytes.','line_number':2057,'multiline':False]['text':'*
   * Erases @c n bytes from the end of the vector by resizing the vector
   * object. If @c n is greater than the current size of the vector, the vector
   * is emptied.
   ','line_number':2058,'multiline':True]['text':'/ @b DynamicBuffer_v1: Remove characters from the input sequence.','line_number':2068,'multiline':False]['text':'/ @b DynamicBuffer_v2: Consume the specified number of bytes from the','line_number':2069,'multiline':False]['text':'/ beginning of the underlying memory.','line_number':2070,'multiline':False]['text':'*
   * @b DynamicBuffer_v1: Removes @c n characters from the beginning of the
   * input sequence. @note If @c n is greater than the size of the input
   * sequence, the entire input sequence is consumed and no error is issued.
   *
   * @b DynamicBuffer_v2: Erases @c n bytes from the beginning of the vector.
   * If @c n is greater than the current size of the vector, the vector is
   * emptied.
   ','line_number':2071,'multiline':True]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2090,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2098,'multiline':False]['text':'* @defgroup dynamic_buffer boost::asio::dynamic_buffer
 *
 * @brief The boost::asio::dynamic_buffer function is used to create a
 * dynamically resized buffer from a @c std::basic_string or @c std::vector.
 ','line_number':2102,'multiline':True]['text':'@{','line_number':2107,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given string.','line_number':2109,'multiline':False]['text':'*
 * @returns <tt>dynamic_string_buffer<Elem, Traits, Allocator>(data)</tt>.
 ','line_number':2110,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given string.','line_number':2121,'multiline':False]['text':'*
 * @returns <tt>dynamic_string_buffer<Elem, Traits, Allocator>(data,
 * max_size)</tt>.
 ','line_number':2122,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given vector.','line_number':2135,'multiline':False]['text':'*
 * @returns <tt>dynamic_vector_buffer<Elem, Allocator>(data)</tt>.
 ','line_number':2136,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given vector.','line_number':2147,'multiline':False]['text':'*
 * @returns <tt>dynamic_vector_buffer<Elem, Allocator>(data, max_size)</tt>.
 ','line_number':2148,'multiline':True]['text':'@}','line_number':2160,'multiline':True]['text':'* @defgroup buffer_copy boost::asio::buffer_copy
 *
 * @brief The boost::asio::buffer_copy function is used to copy bytes from a
 * source buffer (or buffer sequence) to a target buffer (or buffer sequence).
 *
 * The @c buffer_copy function is available in two forms:
 *
 * @li A 2-argument form: @c buffer_copy(target, source)
 *
 * @li A 3-argument form: @c buffer_copy(target, source, max_bytes_to_copy)
 *
 * Both forms return the number of bytes actually copied. The number of bytes
 * copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * @li @c If specified, @c max_bytes_to_copy.
 *
 * This prevents buffer overflow, regardless of the buffer sizes used in the
 * copy operation.
 *
 * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
 * consequently it cannot be used to copy between overlapping memory regions.
 ','line_number':2162,'multiline':True]['text':'@{','line_number':2188,'multiline':True]['text':' For memcpy.','line_number':2195,'multiline':False]['text':' namespace detail','line_number':2360,'multiline':False]['text':'/ Copies bytes from a source buffer sequence to a target buffer sequence.','line_number':2362,'multiline':False]['text':'*
 * @param target A modifiable buffer sequence representing the memory regions to
 * which the bytes will be copied.
 *
 * @param source A non-modifiable buffer sequence representing the memory
 * regions from which the bytes will be copied.
 *
 * @returns The number of bytes copied.
 *
 * @note The number of bytes copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * This function is implemented in terms of @c memcpy, and consequently it
 * cannot be used to copy between overlapping memory regions.
 ','line_number':2363,'multiline':True]['text':'/ Copies a limited number of bytes from a source buffer sequence to a target','line_number':2394,'multiline':False]['text':'/ buffer sequence.','line_number':2395,'multiline':False]['text':'*
 * @param target A modifiable buffer sequence representing the memory regions to
 * which the bytes will be copied.
 *
 * @param source A non-modifiable buffer sequence representing the memory
 * regions from which the bytes will be copied.
 *
 * @param max_bytes_to_copy The maximum number of bytes to be copied.
 *
 * @returns The number of bytes copied.
 *
 * @note The number of bytes copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * @li @c max_bytes_to_copy
 *
 * This function is implemented in terms of @c memcpy, and consequently it
 * cannot be used to copy between overlapping memory regions.
 ','line_number':2396,'multiline':True]['text':'@}','line_number':2432,'multiline':True]['text':' namespace asio','line_number':2434,'multiline':False]['text':' namespace boost','line_number':2435,'multiline':False]['text':'/ Trait to determine whether a type satisfies the MutableBufferSequence','line_number':2444,'multiline':False]['text':'/ requirements.','line_number':2445,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2450,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2452,'multiline':False]['text':'/ Trait to determine whether a type satisfies the ConstBufferSequence','line_number':2456,'multiline':False]['text':'/ requirements.','line_number':2457,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2462,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2464,'multiline':False]['text':'/ Trait to determine whether a type satisfies the DynamicBuffer_v1','line_number':2469,'multiline':False]['text':'/ requirements.','line_number':2470,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2475,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2477,'multiline':False]['text':' !defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2480,'multiline':False]['text':'/ Trait to determine whether a type satisfies the DynamicBuffer_v2','line_number':2482,'multiline':False]['text':'/ requirements.','line_number':2483,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2488,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2490,'multiline':False]['text':'/ Trait to determine whether a type satisfies the DynamicBuffer requirements.','line_number':2494,'multiline':False]['text':'*
 * If @c BOOST_ASIO_NO_DYNAMIC_BUFFER_V1 is not defined, determines whether the
 * type satisfies the DynamicBuffer_v1 requirements. Otherwise, if @c
 * BOOST_ASIO_NO_DYNAMIC_BUFFER_V1 is defined, determines whether the type
 * satisfies the DynamicBuffer_v2 requirements.
 ','line_number':2495,'multiline':True]['text':' defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2507,'multiline':False]['text':' defined(BOOST_ASIO_NO_DYNAMIC_BUFFER_V1)','line_number':2509,'multiline':False]['text':' namespace asio','line_number':2513,'multiline':False]['text':' namespace boost','line_number':2514,'multiline':False]['text':' BOOST_ASIO_BUFFER_HPP','line_number':2518,'multiline':False]