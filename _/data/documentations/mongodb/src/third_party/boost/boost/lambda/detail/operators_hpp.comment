['text':' Boost Lambda Library - operators.hpp --------------------------------------','line_number':1,'multiline':False]['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' For more information, see www.boost.org','line_number':9,'multiline':False]['text':' ---------------------------------------------------------------','line_number':11,'multiline':False]['text':' For all BOOSTA_LAMBDA_BE* macros:','line_number':25,'multiline':False]['text':' CONSTA must be either 'A' or 'const A'','line_number':27,'multiline':False]['text':' CONSTB must be either 'B' or 'const B'','line_number':28,'multiline':False]['text':' It is stupid to have the names A and B as macro arguments, but it avoids','line_number':30,'multiline':False]['text':' the need to pass in emtpy macro arguments, which gives warnings on some','line_number':31,'multiline':False]['text':' compilers','line_number':32,'multiline':False]['text':' A special trick for comma operator for correct preprocessing','line_number':140,'multiline':False]['text':' special cases for ostream& << Any and istream& >> Any ---------------','line_number':155,'multiline':False]['text':' the actual stream classes may vary and thus a specialisation for, ','line_number':156,'multiline':False]['text':' say ostream& does not match (the general case above is chosen). ','line_number':157,'multiline':False]['text':' Therefore we specialise for non-const reference:','line_number':158,'multiline':False]['text':' if the left argument is a stream, we store the stream as reference','line_number':159,'multiline':False]['text':' if it is something else, we store a const plain by default','line_number':160,'multiline':False]['text':' Note that the overloading is const vs. non-const first argument','line_number':162,'multiline':False]['text':' detail','line_number':185,'multiline':False]['text':' special case for io_manipulators.','line_number':191,'multiline':False]['text':' function references cannot be given as arguments to lambda operator','line_number':192,'multiline':False]['text':' expressions in general. With << and >> the use of manipulators is','line_number':193,'multiline':False]['text':' so common, that specializations are provided to make them work.','line_number':194,'multiline':False]['text':' (+ and -) take their arguments as const references. ','line_number':233,'multiline':False]['text':' This has consquences with pointer artihmetic','line_number':234,'multiline':False]['text':' E.g int a[]; ... *a = 1 works but not *(a+1) = 1. ','line_number':235,'multiline':False]['text':' the result of a+1 would be const','line_number':236,'multiline':False]['text':' To make the latter work too, ','line_number':237,'multiline':False]['text':' non-const arrays are taken as non-const and stored as non-const as well.','line_number':238,'multiline':False]['text':'BOOST_LAMBDA_PTR_ARITHMETIC_E1(operator-, arithmetic_action<minus_action>)','line_number':281,'multiline':False]['text':' This is not needed, since the result of ptr-ptr is an rvalue anyway','line_number':282,'multiline':False]['text':' ---------------------------------------------------------------------','line_number':298,'multiline':False]['text':' unary operators -----------------------------------------------------','line_number':299,'multiline':False]['text':' ---------------------------------------------------------------------','line_number':300,'multiline':False]['text':' namespace lambda','line_number':349,'multiline':False]['text':' namespace boost','line_number':350,'multiline':False]