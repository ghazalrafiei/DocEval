['text':'
 *
 * Copyright (c) 2002
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]['text':'','line_number':45,'multiline':False]['text':' error checking API:','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' can't mix match_extra with POSIX matching rules:','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':'','line_number':59,'multiline':False]['text':' function can_start:','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' WCHAR_MIN not usable in pp-directives.','line_number':83,'multiline':False]['text':'','line_number':99,'multiline':False]['text':' Unfortunately Rogue Waves standard library appears to have a bug','line_number':100,'multiline':False]['text':' in std::basic_string::compare that results in erroneous answers','line_number':101,'multiline':False]['text':' in some cases (tested with Borland C++ 5.1, Rogue Wave lib version','line_number':102,'multiline':False]['text':' 0x020101) the test case was:','line_number':103,'multiline':False]['text':' {39135,0} < {0xff,0}','line_number':104,'multiline':False]['text':' which succeeds when it should not.','line_number':105,'multiline':False]['text':'','line_number':106,'multiline':False]['text':'bool icase = e.m_flags & regex_constants::icase;','line_number':164,'multiline':False]['text':' dwa 9/13/00 suppress incorrect MSVC warning - it claims this is never','line_number':171,'multiline':False]['text':' referenced','line_number':172,'multiline':False]['text':' try and match a single character, could be a multi-character','line_number':175,'multiline':False]['text':' collating element...','line_number':176,'multiline':False]['text':' treat null string as special case:','line_number':182,'multiline':False]['text':' if null we've matched','line_number':200,'multiline':False]['text':' skip null','line_number':203,'multiline':False]['text':'','line_number':213,'multiline':False]['text':' try and match a range, NB only a single character can match','line_number':214,'multiline':False]['text':' skip first string','line_number':235,'multiline':False]['text':' skip second string','line_number':239,'multiline':False]['text':'','line_number':244,'multiline':False]['text':' try and match an equivalence class, NB only a single character can match','line_number':245,'multiline':False]['text':' skip string','line_number':254,'multiline':False]['text':' the number of iterations so far','line_number':273,'multiline':False]['text':' where the last repeat started','line_number':274,'multiline':False]['text':' this is called when we are about to start a new repeat,','line_number':328,'multiline':False]['text':' if the last one was NULL move our count to max,','line_number':329,'multiline':False]['text':' otherwise save the current position.','line_number':330,'multiline':False]['text':' match procs, stored in s_match_vtable:','line_number':431,'multiline':False]['text':' find procs stored in s_find_vtable:','line_number':476,'multiline':False]['text':' final result structure to be filled in:','line_number':484,'multiline':False]['text':' temporary result for POSIX matches:','line_number':486,'multiline':False]['text':' pointer to actual result structure to fill in:','line_number':488,'multiline':False]['text':' start of sequence being searched:','line_number':490,'multiline':False]['text':' end of sequence being searched:','line_number':492,'multiline':False]['text':' current character being examined:','line_number':494,'multiline':False]['text':' where to restart next search after failed match attempt:','line_number':496,'multiline':False]['text':' where the current search started from, acts as base for $` during grep:','line_number':498,'multiline':False]['text':' how far we can go back when matching lookbehind:','line_number':500,'multiline':False]['text':' the expression being examined:','line_number':502,'multiline':False]['text':' the expression's traits class:','line_number':504,'multiline':False]['text':' the next state in the machine being matched:','line_number':506,'multiline':False]['text':' matching flags in use:','line_number':508,'multiline':False]['text':' how many states we have examined so far:','line_number':510,'multiline':False]['text':' max number of states to examine before giving up:','line_number':512,'multiline':False]['text':' whether we should ignore case or not:','line_number':514,'multiline':False]['text':' set to true when (position == last), indicates that we may have a partial match:','line_number':516,'multiline':False]['text':' set to true whenever we get a match:','line_number':518,'multiline':False]['text':' set to true whenever we're inside an independent sub-expression:','line_number':520,'multiline':False]['text':' the current repeat being examined:','line_number':522,'multiline':False]['text':' the first repeat being examined (top of linked list):','line_number':524,'multiline':False]['text':' the mask to pass when matching word boundaries:','line_number':526,'multiline':False]['text':' the bitmask to use when determining whether a match_any matches a newline or not:','line_number':528,'multiline':False]['text':' recursion information:','line_number':530,'multiline':False]['text':' Set to false by a (*COMMIT):','line_number':533,'multiline':False]['text':'','line_number':539,'multiline':False]['text':' additional members for non-recursive version:','line_number':540,'multiline':False]['text':'','line_number':541,'multiline':False]['text':' pointer to base of stack:','line_number':577,'multiline':False]['text':' pointer to current stack position:','line_number':579,'multiline':False]['text':' how many memory blocks have we used up?:','line_number':581,'multiline':False]['text':' determines what value to return when unwinding from recursion,','line_number':583,'multiline':False]['text':' allows for mixed recursive/non-recursive algorithm:','line_number':584,'multiline':False]['text':' We have unwound to a lookahead/lookbehind, used by COMMIT/PRUNE/SKIP:','line_number':586,'multiline':False]['text':' We have unwound to an alternative, used by THEN:','line_number':588,'multiline':False]['text':' We are unwinding a commit - used by independent subs to determine whether to stop there or carry on unwinding:','line_number':590,'multiline':False]['text':'bool m_unwind_commit;','line_number':591,'multiline':False]['text':' Recursion limit:','line_number':592,'multiline':False]['text':' these operations aren't allowed, so are declared private,','line_number':602,'multiline':False]['text':' bodies are provided to keep explicit-instantiation requests happy:','line_number':603,'multiline':False]['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':615,'multiline':False]['text':' namespace boost','line_number':632,'multiline':False]['text':'','line_number':634,'multiline':False]['text':' include the implementation of perl_matcher:','line_number':635,'multiline':False]['text':'','line_number':636,'multiline':False]['text':' this one has to be last:','line_number':642,'multiline':False]