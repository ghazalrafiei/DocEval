['text':'
*******************************************************************************
*
*   Copyright (C) 2005-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  utext.cpp
*   encoding:   US-ASCII
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2005apr12
*   created by: Markus W. Scherer
','line_number':1,'multiline':True]['text':' The desired position is outside of the current chunk.','line_number':109,'multiline':False]['text':' Access the new position.  Assume a forward iteration from here,','line_number':110,'multiline':False]['text':' which will also be optimimum for a single random access.','line_number':111,'multiline':False]['text':' Reverse iterations may suffer slightly.','line_number':112,'multiline':False]['text':' utf-16 indexing.','line_number':115,'multiline':False]['text':' The convention is that the index must always be on a code point boundary.','line_number':120,'multiline':False]['text':' Adjust the index position if it is in the middle of a surrogate pair.','line_number':121,'multiline':False]['text':'','line_number':142,'multiline':False]['text':'  Fast-path the common case.','line_number':143,'multiline':False]['text':'     Common means current position is not at the beginning of a chunk','line_number':144,'multiline':False]['text':'     and the preceding character is not supplementary.','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' If at the start of text, simply return 0.','line_number':163,'multiline':False]['text':' Harder, less common cases.  We are at a chunk boundary, or on a surrogate.','line_number':168,'multiline':False]['text':'    Keep it simple, use other functions to handle the edges.','line_number':169,'multiline':False]['text':'','line_number':170,'multiline':False]['text':'','line_number':178,'multiline':False]['text':'  utext_current32.  Get the UChar32 at the current position.','line_number':179,'multiline':False]['text':'                    UText iteration position is always on a code point boundary,','line_number':180,'multiline':False]['text':'                    never on the trail half of a surrogate pair.','line_number':181,'multiline':False]['text':'','line_number':182,'multiline':False]['text':' Current position is just off the end of the chunk.','line_number':187,'multiline':False]['text':' Off the end of the text.','line_number':189,'multiline':False]['text':' Normal, non-supplementary case.','line_number':196,'multiline':False]['text':'','line_number':200,'multiline':False]['text':'  Possible supplementary char.','line_number':201,'multiline':False]['text':'','line_number':202,'multiline':False]['text':' The trail surrogate is in the same chunk.','line_number':206,'multiline':False]['text':'  The trail surrogate is in a different chunk.','line_number':209,'multiline':False]['text':'     Because we must maintain the iteration position, we need to switch forward','line_number':210,'multiline':False]['text':'     into the new chunk, get the trail surrogate, then revert the chunk back to the','line_number':211,'multiline':False]['text':'     original one.','line_number':212,'multiline':False]['text':'     An edge case to be careful of:  the entire text may end with an unpaired','line_number':213,'multiline':False]['text':'        leading surrogate.  The attempt to access the trail will fail, but','line_number':214,'multiline':False]['text':'        the original position before the unpaired lead still needs to be restored.','line_number':215,'multiline':False]['text':' reverse iteration flag loads preceding chunk','line_number':221,'multiline':False]['text':' Fast path the common case.','line_number':241,'multiline':False]['text':' For surrogates, let current32() deal with the complications','line_number':255,'multiline':False]['text':'    of supplementaries that may span chunk boundaries.','line_number':256,'multiline':False]['text':' Normal case, not supplementary.','line_number':276,'multiline':False]['text':'   (A trail surrogate seen here is just returned as is, as a surrogate value.','line_number':277,'multiline':False]['text':'    It cannot be part of a pair.)','line_number':278,'multiline':False]['text':' c is an unpaired lead surrogate at the end of the text.','line_number':284,'multiline':False]['text':' return it as it is.','line_number':285,'multiline':False]['text':' c was an unpaired lead surrogate, not at the end of the text.','line_number':291,'multiline':False]['text':' return it as it is (unpaired).  Iteration position is on the','line_number':292,'multiline':False]['text':' following character, possibly in the next chunk, where the','line_number':293,'multiline':False]['text':'  trail surrogate would have been if it had existed.','line_number':294,'multiline':False]['text':' move iteration position over the trail surrogate.','line_number':299,'multiline':False]['text':' Normal case, not supplementary.','line_number':316,'multiline':False]['text':'   (A lead surrogate seen here is just returned as is, as a surrogate value.','line_number':317,'multiline':False]['text':'    It cannot be part of a pair.)','line_number':318,'multiline':False]['text':' c is an unpaired trail surrogate at the start of the text.','line_number':324,'multiline':False]['text':' return it as it is.','line_number':325,'multiline':False]['text':' c was an unpaired trail surrogate, not at the end of the text.','line_number':332,'multiline':False]['text':' return it as it is (unpaired).  Iteration position is at c','line_number':333,'multiline':False]['text':' move iteration position over the lead surrogate.','line_number':338,'multiline':False]['text':' Desired position is outside of the current chunk.','line_number':349,'multiline':False]['text':' no chunk available here','line_number':351,'multiline':False]['text':' Desired position is in chunk, with direct 1:1 native to UTF16 indexing','line_number':355,'multiline':False]['text':' Desired position is in chunk, with non-UTF16 indexing.','line_number':358,'multiline':False]['text':' Surrogates.  Many edge cases.  Use other functions that already','line_number':364,'multiline':False]['text':'              deal with the problems.','line_number':365,'multiline':False]['text':'','line_number':375,'multiline':False]['text':'  Return the character preceding the specified index.','line_number':376,'multiline':False]['text':'  Leave the iteration position at the start of the character that was returned.','line_number':377,'multiline':False]['text':'','line_number':378,'multiline':False]['text':' The character preceding cCurr, which is what we will return.','line_number':379,'multiline':False]['text':' Address the chunk containg the position preceding the incoming index','line_number':381,'multiline':False]['text':' A tricky edge case:','line_number':382,'multiline':False]['text':'   We try to test the requested native index against the chunkNativeStart to determine','line_number':383,'multiline':False]['text':'    whether the character preceding the one at the index is in the current chunk.','line_number':384,'multiline':False]['text':'    BUT, this test can fail with UTF-8 (or any other multibyte encoding), when the','line_number':385,'multiline':False]['text':'    requested index is on something other than the first position of the first char.','line_number':386,'multiline':False]['text':'','line_number':387,'multiline':False]['text':' Requested native index is outside of the current chunk.','line_number':389,'multiline':False]['text':' no chunk available here','line_number':391,'multiline':False]['text':' Direct UTF-16 indexing.','line_number':395,'multiline':False]['text':' no chunk available here','line_number':400,'multiline':False]['text':'','line_number':405,'multiline':False]['text':' Simple case with no surrogates.','line_number':406,'multiline':False]['text':'','line_number':407,'multiline':False]['text':' Possible supplementary.  Many edge cases.','line_number':412,'multiline':False]['text':' Let other functions do the heavy lifting.','line_number':413,'multiline':False]['text':' Null or invalid arguments don't compare equal to anything.','line_number':436,'multiline':False]['text':' Different types of text providers.','line_number':441,'multiline':False]['text':' Different sources (different strings)','line_number':446,'multiline':False]['text':' Different current position in the string.','line_number':450,'multiline':False]['text':' Zero out the WRITABLE flag.','line_number':467,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':538,'multiline':False]['text':'','line_number':539,'multiline':False]['text':'   UText common functions implementation','line_number':540,'multiline':False]['text':'','line_number':541,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':542,'multiline':False]['text':'','line_number':544,'multiline':False]['text':'  UText.flags bit definitions','line_number':545,'multiline':False]['text':'','line_number':546,'multiline':False]['text':'  1 if ICU has allocated this UText struct on the heap.','line_number':548,'multiline':False]['text':'  0 if caller provided storage for the UText.','line_number':549,'multiline':False]['text':'  1 if ICU has allocated extra storage as a separate','line_number':551,'multiline':False]['text':'     heap block.','line_number':552,'multiline':False]['text':'  0 if there is no separate allocation.  Either no extra','line_number':553,'multiline':False]['text':'     storage was requested, or it is appended to the end','line_number':554,'multiline':False]['text':'     of the main UText storage.','line_number':555,'multiline':False]['text':'  1 if this UText is currently open','line_number':557,'multiline':False]['text':'  0 if this UText is not open.','line_number':558,'multiline':False]['text':'','line_number':562,'multiline':False]['text':'  Extended form of a UText.  The purpose is to aid in computing the total size required','line_number':563,'multiline':False]['text':'    when a provider asks for a UText to be allocated with extra storage.','line_number':564,'multiline':False]['text':' We need to heap-allocate storage for the new UText','line_number':580,'multiline':False]['text':' We have been supplied with an already existing UText.','line_number':598,'multiline':False]['text':' Verify that it really appears to be a UText.','line_number':599,'multiline':False]['text':' If the ut is already open and there's a provider supplied close','line_number':604,'multiline':False]['text':'   function, call it.','line_number':605,'multiline':False]['text':' If extra space was requested by our caller, check whether','line_number':611,'multiline':False]['text':'   sufficient already exists, and allocate new if needed.','line_number':612,'multiline':False]['text':' Need more space.  If there is existing separately allocated space,','line_number':614,'multiline':False]['text':'   delete it first, then allocate new space.','line_number':615,'multiline':False]['text':' Initialize all remaining fields of the UText.','line_number':632,'multiline':False]['text':'','line_number':633,'multiline':False]['text':' The supplied ut is not an open UText.','line_number':666,'multiline':False]['text':' Do nothing.','line_number':667,'multiline':False]['text':' If the provider gave us a close function, call it now.','line_number':671,'multiline':False]['text':' This will clean up anything allocated specifically by the provider.','line_number':672,'multiline':False]['text':' If we (the framework) allocated the UText or subsidiary storage,','line_number':678,'multiline':False]['text':'   delete it.','line_number':679,'multiline':False]['text':' Zero out function table of the closed UText.  This is a defensive move,','line_number':687,'multiline':False]['text':'   inteded to cause applications that inadvertantly use a closed','line_number':688,'multiline':False]['text':'   utext to crash with null pointer errors.','line_number':689,'multiline':False]['text':' This UText was allocated by UText setup.  We need to free it.','line_number':693,'multiline':False]['text':' Clear magic, so we can detect if the user messes up and immediately','line_number':694,'multiline':False]['text':'  tries to reopen another UText using the deleted storage.','line_number':695,'multiline':False]['text':'','line_number':706,'multiline':False]['text':' invalidateChunk   Reset a chunk to have no contents, so that the next call','line_number':707,'multiline':False]['text':'                   to access will cause new data to load.','line_number':708,'multiline':False]['text':'                   This is needed when copy/move/replace operate directly on the','line_number':709,'multiline':False]['text':'                   backing text, potentially putting it out of sync with the','line_number':710,'multiline':False]['text':'                   contents in the chunk.','line_number':711,'multiline':False]['text':'','line_number':712,'multiline':False]['text':'','line_number':722,'multiline':False]['text':' pinIndex        Do range pinning on a native index parameter.','line_number':723,'multiline':False]['text':'                 64 bit pinning is done in place.','line_number':724,'multiline':False]['text':'                 32 bit truncated result is returned as a convenience for','line_number':725,'multiline':False]['text':'                        use in providers that don't need 64 bits.','line_number':726,'multiline':False]['text':'','line_number':740,'multiline':False]['text':' Pointer relocation function,','line_number':741,'multiline':False]['text':'   a utility used by shallow clone.','line_number':742,'multiline':False]['text':'   Adjust a pointer that refers to something within one UText (the source)','line_number':743,'multiline':False]['text':'   to refer to the same relative offset within a another UText (the target)','line_number':744,'multiline':False]['text':'','line_number':745,'multiline':False]['text':' convert all pointers to (char *) so that byte address arithmetic will work.','line_number':747,'multiline':False]['text':' target ptr was to something within the src UText's pExtra storage.','line_number':753,'multiline':False]['text':'   relocate it into the target UText's pExtra region.','line_number':754,'multiline':False]['text':' target ptr was pointing to somewhere within the source UText itself.','line_number':757,'multiline':False]['text':'   Move it to the same offset within the target UText.','line_number':758,'multiline':False]['text':'','line_number':764,'multiline':False]['text':'  Clone.  This is a generic copy-the-utext-by-value clone function that can be','line_number':765,'multiline':False]['text':'          used as-is with some utext types, and as a helper by other clones.','line_number':766,'multiline':False]['text':'','line_number':767,'multiline':False]['text':'','line_number':775,'multiline':False]['text':' Use the generic text_setup to allocate storage if required.','line_number':776,'multiline':False]['text':'','line_number':777,'multiline':False]['text':'','line_number':783,'multiline':False]['text':'  flags (how the UText was allocated) and the pointer to the','line_number':784,'multiline':False]['text':'   extra storage must retain the values in the cloned utext that','line_number':785,'multiline':False]['text':'   were set up by utext_setup.  Save them separately before','line_number':786,'multiline':False]['text':'   copying the whole struct.','line_number':787,'multiline':False]['text':'','line_number':788,'multiline':False]['text':'','line_number':793,'multiline':False]['text':'  Copy the whole UText struct by value.','line_number':794,'multiline':False]['text':'  Any "Extra" storage is copied also.','line_number':795,'multiline':False]['text':'','line_number':796,'multiline':False]['text':'','line_number':808,'multiline':False]['text':' Relocate any pointers in the target that refer to the UText itself','line_number':809,'multiline':False]['text':'   to point to the cloned copy rather than the original source.','line_number':810,'multiline':False]['text':'','line_number':811,'multiline':False]['text':' The newly shallow-cloned UText does _not_ own the underlying storage for the text.','line_number':818,'multiline':False]['text':' (The source for the clone may or may not have owned the text.)','line_number':819,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':831,'multiline':False]['text':'','line_number':832,'multiline':False]['text':'     UText implementation for UTF-8 char * strings (read-only)','line_number':833,'multiline':False]['text':'     Limitation:  string length must be <= 0x7fffffff in length.','line_number':834,'multiline':False]['text':'                  (length must for in an int32_t variable)','line_number':835,'multiline':False]['text':'','line_number':836,'multiline':False]['text':'         Use of UText data members:','line_number':837,'multiline':False]['text':'              context    pointer to UTF-8 string','line_number':838,'multiline':False]['text':'              utext.b    is the input string length (bytes).','line_number':839,'multiline':False]['text':'              utext.c    Length scanned so far in string','line_number':840,'multiline':False]['text':'                           (for optimizing finding length of zero terminated strings.)','line_number':841,'multiline':False]['text':'              utext.p    pointer to the current buffer','line_number':842,'multiline':False]['text':'              utext.q    pointer to the other buffer.','line_number':843,'multiline':False]['text':'','line_number':844,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':845,'multiline':False]['text':' Chunk size.','line_number':847,'multiline':False]['text':'     Must be less than 85, because of byte mapping from UChar indexes to native indexes.','line_number':848,'multiline':False]['text':'     Worst case is three native bytes to one UChar.  (Supplemenaries are 4 native bytes','line_number':849,'multiline':False]['text':'     to two UChars.)','line_number':850,'multiline':False]['text':'','line_number':851,'multiline':False]['text':'','line_number':854,'multiline':False]['text':' UTF8Buf  Two of these structs will be set up in the UText's extra allocated space.','line_number':855,'multiline':False]['text':'          Each contains the UChar chunk buffer, the to and from native maps, and','line_number':856,'multiline':False]['text':'          header info.','line_number':857,'multiline':False]['text':'','line_number':858,'multiline':False]['text':'     because backwards iteration fills the buffers starting at the end and','line_number':859,'multiline':False]['text':'     working towards the front, the filled part of the buffers may not begin','line_number':860,'multiline':False]['text':'     at the start of the available storage for the buffers.','line_number':861,'multiline':False]['text':'','line_number':862,'multiline':False]['text':'     Buffer size is one bigger than the specified UTF8_TEXT_CHUNK_SIZE to allow for','line_number':863,'multiline':False]['text':'     the last character added being a supplementary, and thus requiring a surrogate','line_number':864,'multiline':False]['text':'     pair.  Doing this is simpler than checking for the edge case.','line_number':865,'multiline':False]['text':'','line_number':866,'multiline':False]['text':' Native index of first char in UChar buf','line_number':869,'multiline':False]['text':' Native index following last char in buf.','line_number':870,'multiline':False]['text':' First filled position in buf.','line_number':871,'multiline':False]['text':' Limit of filled range in buf.','line_number':872,'multiline':False]['text':' Limit of native indexing part of buf','line_number':873,'multiline':False]['text':' Native index corresponding to','line_number':874,'multiline':False]['text':'   mapToUChars[0].','line_number':875,'multiline':False]['text':'   Set to bufNativeStart when filling forwards.','line_number':876,'multiline':False]['text':'   Set to computed value when filling backwards.','line_number':877,'multiline':False]['text':' The UChar buffer.  Requires one extra position beyond the','line_number':879,'multiline':False]['text':'   the chunk size, to allow for surrogate at the end.','line_number':880,'multiline':False]['text':'   Length must be identical to mapToNative array, below,','line_number':881,'multiline':False]['text':'   because of the way indexing works when the array is','line_number':882,'multiline':False]['text':'   filled backwards during a reverse iteration.  Thus,','line_number':883,'multiline':False]['text':'   the additional extra size.','line_number':884,'multiline':False]['text':' map UChar index in buf to','line_number':885,'multiline':False]['text':'  native offset from bufNativeStart.','line_number':886,'multiline':False]['text':'  Requires two extra slots,','line_number':887,'multiline':False]['text':'    one for a supplementary starting in the last normal position,','line_number':888,'multiline':False]['text':'    and one for an entry for the buffer limit position.','line_number':889,'multiline':False]['text':' Map native offset from bufNativeStart to','line_number':890,'multiline':False]['text':'   correspoding offset in filled part of buf.','line_number':891,'multiline':False]['text':'','line_number':897,'multiline':False]['text':'   utf8TextLength','line_number':898,'multiline':False]['text':'','line_number':899,'multiline':False]['text':'        Get the length of the string.  If we don't already know it,','line_number':900,'multiline':False]['text':'              we'll need to scan for the trailing  nul.','line_number':901,'multiline':False]['text':'','line_number':902,'multiline':False]['text':' Zero terminated string, and we haven't scanned to the end yet.','line_number':906,'multiline':False]['text':' Scan it now.','line_number':907,'multiline':False]['text':' Actual string was bigger (more than 2 gig) than we','line_number':915,'multiline':False]['text':'   can handle.  Clip it to 2 GB.','line_number':916,'multiline':False]['text':'','line_number':931,'multiline':False]['text':'  Apologies to those who are allergic to goto statements.','line_number':932,'multiline':False]['text':'    Consider each goto to a labelled block to be the equivalent of','line_number':933,'multiline':False]['text':'         call the named block as if it were a function();','line_number':934,'multiline':False]['text':'         return;','line_number':935,'multiline':False]['text':'','line_number':936,'multiline':False]['text':' Length of original utf-8','line_number':939,'multiline':False]['text':' Requested index, trimmed to 32 bits.','line_number':940,'multiline':False]['text':' Strings with 64 bit lengths not supported by this UTF-8 provider.','line_number':945,'multiline':False]['text':' Pin requested index to the string length.','line_number':949,'multiline':False]['text':' Zero terminated string, and requested index is beyond','line_number':954,'multiline':False]['text':'   the region that has already been scanned.','line_number':955,'multiline':False]['text':'   Scan up to either the end of the string or to the','line_number':956,'multiline':False]['text':'   requested position, whichever comes first.','line_number':957,'multiline':False]['text':'  TODO:  support for null terminated string length > 32 bits.','line_number':961,'multiline':False]['text':' We just found the actual length of the string.','line_number':963,'multiline':False]['text':'  Trim the requested index back to that.','line_number':964,'multiline':False]['text':'','line_number':973,'multiline':False]['text':' Dispatch to the appropriate action for a forward iteration request.','line_number':974,'multiline':False]['text':'','line_number':975,'multiline':False]['text':' Check for normal sequential iteration cases first.','line_number':978,'multiline':False]['text':' Just reached end of string','line_number':980,'multiline':False]['text':' Don't swap buffers, but do set the','line_number':981,'multiline':False]['text':'   current buffer position.','line_number':982,'multiline':False]['text':' End of current buffer.','line_number':986,'multiline':False]['text':'   check whether other buffer already has what we need.','line_number':987,'multiline':False]['text':' A random access.  Desired index could be in either or niether buf.','line_number':995,'multiline':False]['text':' For optimizing the order of testing, first check for the index','line_number':996,'multiline':False]['text':'    being in the other buffer.  This will be the case for uses that','line_number':997,'multiline':False]['text':'    move back and forth over a fairly limited range','line_number':998,'multiline':False]['text':' the alternate buffer','line_number':1000,'multiline':False]['text':' Requested index is in the other buffer.','line_number':1002,'multiline':False]['text':' Requested index is end-of-string.','line_number':1006,'multiline':False]['text':'   (this is the case of randomly seeking to the end.','line_number':1007,'multiline':False]['text':'    The case of iterating off the end is handled earlier.)','line_number':1008,'multiline':False]['text':' Current buffer extends up to the end of the string.','line_number':1010,'multiline':False]['text':'   Leave it as the current buffer.','line_number':1011,'multiline':False]['text':' Alternate buffer extends to the end of string.','line_number':1016,'multiline':False]['text':'   Swap it in as the current buffer.','line_number':1017,'multiline':False]['text':' Neither existing buffer extends to the end of the string.','line_number':1021,'multiline':False]['text':' Requested index is in neither buffer.','line_number':1026,'multiline':False]['text':' Requested index is in this buffer.','line_number':1030,'multiline':False]['text':' the current buffer','line_number':1031,'multiline':False]['text':'','line_number':1040,'multiline':False]['text':' Dispatch to the appropriate action for a','line_number':1041,'multiline':False]['text':'   Backwards Diretion iteration request.','line_number':1042,'multiline':False]['text':'','line_number':1043,'multiline':False]['text':' Check for normal sequential iteration cases first.','line_number':1045,'multiline':False]['text':' Just reached the start of string','line_number':1047,'multiline':False]['text':' Don't swap buffers, but do set the','line_number':1048,'multiline':False]['text':'   current buffer position.','line_number':1049,'multiline':False]['text':' Start of current buffer.','line_number':1053,'multiline':False]['text':'   check whether other buffer already has what we need.','line_number':1054,'multiline':False]['text':' A random access.  Desired index could be in either or niether buf.','line_number':1062,'multiline':False]['text':' For optimizing the order of testing,','line_number':1063,'multiline':False]['text':'    Most likely case:  in the other buffer.','line_number':1064,'multiline':False]['text':'    Second most likely: in neither buffer.','line_number':1065,'multiline':False]['text':'    Unlikely, but must work:  in the current buffer.','line_number':1066,'multiline':False]['text':' the alternate buffer','line_number':1067,'multiline':False]['text':' Requested index is in the other buffer.','line_number':1069,'multiline':False]['text':' Requested index is start-of-string.','line_number':1072,'multiline':False]['text':'   (this is the case of randomly seeking to the start.','line_number':1073,'multiline':False]['text':'    The case of iterating off the start is handled earlier.)','line_number':1074,'multiline':False]['text':' Alternate buffer contains the data for the start string.','line_number':1077,'multiline':False]['text':' Make it be the current buffer.','line_number':1078,'multiline':False]['text':' Request for data before the start of string,','line_number':1081,'multiline':False]['text':'   neither buffer is usable.','line_number':1082,'multiline':False]['text':'   set up a zero-length buffer.','line_number':1083,'multiline':False]['text':' Requested index is in neither buffer.','line_number':1089,'multiline':False]['text':' Requested index is in this buffer.','line_number':1093,'multiline':False]['text':'   Set the utf16 buffer index.','line_number':1094,'multiline':False]['text':' This occurs when the first character in the text is','line_number':1099,'multiline':False]['text':'   a multi-byte UTF-8 char, and the requested index is to','line_number':1100,'multiline':False]['text':'   one of the trailing bytes.  Because there is no preceding ,','line_number':1101,'multiline':False]['text':'   character, this access fails.  We can't pick up on the','line_number':1102,'multiline':False]['text':'   situation sooner because the requested index is not zero.','line_number':1103,'multiline':False]['text':'  The alternate buffer (ut->q) has the string data that was requested.','line_number':1112,'multiline':False]['text':'  Swap the primary and alternate buffers, and set the','line_number':1113,'multiline':False]['text':'   chunk index into the new primary buffer.','line_number':1114,'multiline':False]['text':' Index into the (now current) chunk','line_number':1125,'multiline':False]['text':' Use the map to set the chunk index.  It's more trouble than it's worth','line_number':1126,'multiline':False]['text':'    to check whether native indexing can be used.','line_number':1127,'multiline':False]['text':' We got a request for either the start or end of the string,','line_number':1140,'multiline':False]['text':'  with iteration continuing in the out-of-bounds direction.','line_number':1141,'multiline':False]['text':' The alternate buffer already contains the data up to the','line_number':1142,'multiline':False]['text':'  start/end.','line_number':1143,'multiline':False]['text':' Swap the buffers, then return failure, indicating that we couldn't','line_number':1144,'multiline':False]['text':'  make things correct for continuing the iteration in the requested','line_number':1145,'multiline':False]['text':'  direction.  The position & buffer are correct should the','line_number':1146,'multiline':False]['text':'  user decide to iterate in the opposite direction.','line_number':1147,'multiline':False]['text':' Index into the (now current) chunk','line_number':1157,'multiline':False]['text':'  For this function  (swapBuffersAndFail), the requested index','line_number':1158,'multiline':False]['text':'    will always be at either the start or end of the chunk.','line_number':1159,'multiline':False]['text':'   The user has done a seek/access past the start or end','line_number':1169,'multiline':False]['text':'   of the string.  Rather than loading data that is likely','line_number':1170,'multiline':False]['text':'   to never be used, just set up a zero-length buffer at','line_number':1171,'multiline':False]['text':'   the position.','line_number':1172,'multiline':False]['text':' Move the incoming index to a code point boundary.','line_number':1188,'multiline':False]['text':' Swap the UText buffers.','line_number':1191,'multiline':False]['text':'  We want to fill what was previously the alternate buffer,','line_number':1192,'multiline':False]['text':'  and make what was the current buffer be the new alternate.','line_number':1193,'multiline':False]['text':' Fill the chunk buffer and mapping arrays.','line_number':1213,'multiline':False]['text':' Special case ASCII range for speed.','line_number':1217,'multiline':False]['text':'   zero is excluded to simplify bounds checking.','line_number':1218,'multiline':False]['text':' General case, handle everything.','line_number':1225,'multiline':False]['text':'  store Native <--> Chunk Map entries for the end of the buffer.','line_number':1255,'multiline':False]['text':'    There is no actual character here, but the index position is valid.','line_number':1256,'multiline':False]['text':'  fill in Buffer descriptor','line_number':1260,'multiline':False]['text':' Set UText chunk to refer to this buffer.','line_number':1270,'multiline':False]['text':' For zero terminated strings, keep track of the maximum point','line_number':1278,'multiline':False]['text':'   scanned so far.','line_number':1279,'multiline':False]['text':' We scanned to the end.','line_number':1283,'multiline':False]['text':'   Remember the actual length.','line_number':1284,'multiline':False]['text':' Move the incoming index to a code point boundary.','line_number':1295,'multiline':False]['text':' Can only do this if the incoming index is somewhere in the interior of the string.','line_number':1296,'multiline':False]['text':'   If index is at the end, there is no character there to look at.','line_number':1297,'multiline':False]['text':' Swap the UText buffers.','line_number':1302,'multiline':False]['text':'  We want to fill what was previously the alternate buffer,','line_number':1303,'multiline':False]['text':'  and make what was the current buffer be the new alternate.','line_number':1304,'multiline':False]['text':' Start in the overflow region','line_number':1313,'multiline':False]['text':'   at end of buffer to leave room','line_number':1314,'multiline':False]['text':'   for a surrogate pair at the','line_number':1315,'multiline':False]['text':'   buffer start.','line_number':1316,'multiline':False]['text':' Map to/from Native Indexes, fill in for the position at the end of','line_number':1321,'multiline':False]['text':'   the buffer.','line_number':1322,'multiline':False]['text':'','line_number':1323,'multiline':False]['text':' Fill the chunk buffer','line_number':1327,'multiline':False]['text':' Work backwards, filling from the end of the buffer towards the front.','line_number':1328,'multiline':False]['text':'','line_number':1329,'multiline':False]['text':' Get last byte of the UTF-8 character','line_number':1334,'multiline':False]['text':' Special case ASCII range for speed.','line_number':1337,'multiline':False]['text':' General case, handle everything non-ASCII.','line_number':1342,'multiline':False]['text':' ix of last byte of multi-byte u8 char','line_number':1344,'multiline':False]['text':' Get the full character from the UTF8 string.','line_number':1346,'multiline':False]['text':'   use code derived from tbe macros in utf8.h','line_number':1347,'multiline':False]['text':'   Leaves srcIx pointing at the first byte of the UTF-8 char.','line_number':1348,'multiline':False]['text':'','line_number':1349,'multiline':False]['text':' leaves srcIx at first byte of the multi-byte char.','line_number':1351,'multiline':False]['text':' Store the character in UTF-16 buffer.','line_number':1353,'multiline':False]['text':' Fill in the map from native indexes to UChars buf index.','line_number':1364,'multiline':False]['text':' Set native indexing limit to be the current position.','line_number':1369,'multiline':False]['text':'   We are processing a non-ascii, non-native-indexing char now;','line_number':1370,'multiline':False]['text':'     the limit will be here if the rest of the chars to be','line_number':1371,'multiline':False]['text':'     added to this buffer are ascii.','line_number':1372,'multiline':False]['text':'','line_number':1396,'multiline':False]['text':'  This is a slightly modified copy of u_strFromUTF8,','line_number':1397,'multiline':False]['text':'     Inserts a Replacement Char rather than failing on invalid UTF-8','line_number':1398,'multiline':False]['text':'     Removes unnecessary features.','line_number':1399,'multiline':False]['text':'','line_number':1400,'multiline':False]['text':' required.  NUL terminated not supported.','line_number':1406,'multiline':False]['text':' donot fill the dest buffer just count the UChars needed ','line_number':1438,'multiline':True]['text':' Terminate the buffer ','line_number':1455,'multiline':True]['text':' adjust the incoming indexes to land on code point boundaries if needed.','line_number':1485,'multiline':False]['text':'    adjust by no more than three, because that is the largest number of trail bytes','line_number':1486,'multiline':False]['text':'    in a well formed UTF8 character.','line_number':1487,'multiline':False]['text':' Do the actual extract.','line_number':1508,'multiline':False]['text':'','line_number':1517,'multiline':False]['text':' utf8TextMapOffsetToNative','line_number':1518,'multiline':False]['text':'','line_number':1519,'multiline':False]['text':' Map a chunk (UTF-16) offset to a native index.','line_number':1520,'multiline':False]['text':'','line_number':1523,'multiline':False]['text':'','line_number':1531,'multiline':False]['text':' Map a native index to the corrsponding chunk offset','line_number':1532,'multiline':False]['text':'','line_number':1533,'multiline':False]['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':1550,'multiline':False]['text':' For deep clones, make a copy of the string.','line_number':1553,'multiline':False]['text':'  The copied storage is owned by the newly created clone.','line_number':1554,'multiline':False]['text':'','line_number':1555,'multiline':False]['text':' TODO:  There is an isssue with using utext_nativeLength().','line_number':1556,'multiline':False]['text':'        That function is non-const in cases where the input was NUL terminated','line_number':1557,'multiline':False]['text':'          and the length has not yet been determined.','line_number':1558,'multiline':False]['text':'        This function (clone()) is const.','line_number':1559,'multiline':False]['text':'        There potentially a thread safety issue lurking here.','line_number':1560,'multiline':False]['text':'','line_number':1561,'multiline':False]['text':' Most of the work of close is done by the generic UText framework close.','line_number':1579,'multiline':False]['text':' All that needs to be done here is to delete the UTF8 string if the UText','line_number':1580,'multiline':False]['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':1581,'multiline':False]['text':' Reserved alignment padding','line_number':1595,'multiline':False]['text':' replace','line_number':1600,'multiline':True]['text':' copy   ','line_number':1601,'multiline':True]['text':' spare 1','line_number':1605,'multiline':False]['text':' spare 2','line_number':1606,'multiline':False]['text':' spare 3','line_number':1607,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':1653,'multiline':False]['text':'','line_number':1654,'multiline':False]['text':'     UText implementation wrapper for Replaceable (read/write)','line_number':1655,'multiline':False]['text':'','line_number':1656,'multiline':False]['text':'         Use of UText data members:','line_number':1657,'multiline':False]['text':'            context    pointer to Replaceable.','line_number':1658,'multiline':False]['text':'            p          pointer to Replaceable if it is owned by the UText.','line_number':1659,'multiline':False]['text':'','line_number':1660,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':1661,'multiline':False]['text':' minimum chunk size for this implementation: 3','line_number':1665,'multiline':False]['text':' to allow for possible trimming for code point boundaries','line_number':1666,'multiline':False]['text':'
     * Chunk UChars.
     * +1 to simplify filling with surrogate pair at the end.
     ','line_number':1670,'multiline':True]['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':1682,'multiline':False]['text':' For deep clones, make a copy of the Replaceable.','line_number':1685,'multiline':False]['text':'  The copied Replaceable storage is owned by the newly created UText clone.','line_number':1686,'multiline':False]['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':1687,'multiline':False]['text':'    it.','line_number':1688,'multiline':False]['text':'','line_number':1689,'multiline':False]['text':' with deep clone, the copy is writable, even when the source is not.','line_number':1695,'multiline':False]['text':' Most of the work of close is done by the generic UText framework close.','line_number':1704,'multiline':False]['text':' All that needs to be done here is delete the Replaceable if the UText','line_number':1705,'multiline':False]['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':1706,'multiline':False]['text':' Full length of the input text (bigger than a chunk)','line_number':1726,'multiline':False]['text':' clip the requested index to the limits of the text.','line_number':1728,'multiline':False]['text':'
     * Compute start/limit boundaries around index, for a segment of text
     * to be extracted.
     * To allow for the possibility that our user gave an index to the trailing
     * half of a surrogate pair, we must request one extra preceding UChar when
     * going in the forward direction.  This will ensure that the buffer has the
     * entire code point at the specified index.
     ','line_number':1733,'multiline':True]['text':' Buffer already contains the requested position.','line_number':1744,'multiline':False]['text':' Request for end of string, and buffer already extends up to it.','line_number':1749,'multiline':False]['text':' Can't get the data, but don't change the buffer.','line_number':1750,'multiline':False]['text':' Going forward, so we want to have the buffer with stuff at and beyond','line_number':1756,'multiline':False]['text':'   the requested index.  The -1 gets us one code point before the','line_number':1757,'multiline':False]['text':'   requested index also, to handle the case of the index being on','line_number':1758,'multiline':False]['text':'   a trail surrogate of a surrogate pair.','line_number':1759,'multiline':False]['text':' unless buffer ran off end, start is index-1.','line_number':1763,'multiline':False]['text':' Reverse iteration.  Fill buffer with data preceding the requested index.','line_number':1769,'multiline':False]['text':' Requested position already in buffer.','line_number':1771,'multiline':False]['text':' Request for start, buffer already begins at start.','line_number':1776,'multiline':False]['text':'  No data, but keep the buffer as is.','line_number':1777,'multiline':False]['text':' Figure out the bounds of the chunk to extract for reverse iteration.','line_number':1782,'multiline':False]['text':' Need to worry about chunk not splitting surrogate pairs, and while still','line_number':1783,'multiline':False]['text':' containing the data we need.','line_number':1784,'multiline':False]['text':' Fix by requesting a chunk that includes an extra UChar at the end.','line_number':1785,'multiline':False]['text':' If this turns out to be a lead surrogate, we can lop it off and still have','line_number':1786,'multiline':False]['text':'   the data we wanted.','line_number':1787,'multiline':False]['text':' Extract the new chunk of text from the Replaceable source.','line_number':1799,'multiline':False]['text':' UnicodeString with its buffer a writable alias to the chunk buffer','line_number':1801,'multiline':False]['text':'buffer length','line_number':1802,'multiline':True]['text':'buffer capacity','line_number':1802,'multiline':True]['text':' Surrogate pairs from the input text must not span chunk boundaries.','line_number':1809,'multiline':False]['text':' If end of chunk could be the start of a surrogate, trim it off.','line_number':1810,'multiline':False]['text':' if the first UChar in the chunk could be the trailing half of a surrogate pair,','line_number':1820,'multiline':False]['text':' trim it off.','line_number':1821,'multiline':False]['text':' adjust the index/chunkOffset to a code point boundary','line_number':1829,'multiline':False]['text':' Use fast indexing for get/setNativeIndex()','line_number':1832,'multiline':False]['text':' adjust start, limit if they point to trail half of surrogates','line_number':1862,'multiline':False]['text':' writable alias','line_number':1876,'multiline':False]['text':' will subtract from new length','line_number':1898,'multiline':False]['text':' Snap start & limit to code point boundaries.','line_number':1907,'multiline':False]['text':' Do the actual replace operation using methods of the Replaceable class','line_number':1919,'multiline':False]['text':' read-only alias','line_number':1920,'multiline':False]['text':' Is the UText chunk buffer OK?','line_number':1925,'multiline':False]['text':' this replace operation may have impacted the current chunk.','line_number':1927,'multiline':False]['text':' invalidate it, which will force a reload on the next access.','line_number':1928,'multiline':False]['text':' set the iteration position to the end of the newly inserted replacement text.','line_number':1932,'multiline':False]['text':' TODO:  snap input parameters to code point boundaries.','line_number':1963,'multiline':False]['text':' move: copy to destIndex, then replace original with nothing','line_number':1966,'multiline':False]['text':' copy','line_number':1975,'multiline':False]['text':' If the change to the text touched the region in the chunk buffer,','line_number':1979,'multiline':False]['text':'  invalidate the buffer.','line_number':1980,'multiline':False]['text':' changes may have affected range covered by the chunk','line_number':1986,'multiline':False]['text':' Put iteration position at the newly inserted (moved) block,','line_number':1990,'multiline':False]['text':' moved a block of text towards the end of the string.','line_number':1993,'multiline':False]['text':' Set position, reload chunk if needed.','line_number':1997,'multiline':False]['text':' Reserved alignment padding','line_number':2004,'multiline':False]['text':' MapOffsetToNative,','line_number':2011,'multiline':False]['text':' MapIndexToUTF16,','line_number':2012,'multiline':False]['text':' spare 1','line_number':2014,'multiline':False]['text':' spare 2','line_number':2015,'multiline':False]['text':' spare 3','line_number':2016,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2054,'multiline':False]['text':'','line_number':2055,'multiline':False]['text':'     UText implementation for UnicodeString (read/write)  and','line_number':2056,'multiline':False]['text':'                    for const UnicodeString (read only)','line_number':2057,'multiline':False]['text':'             (same implementation, only the flags are different)','line_number':2058,'multiline':False]['text':'','line_number':2059,'multiline':False]['text':'         Use of UText data members:','line_number':2060,'multiline':False]['text':'            context    pointer to UnicodeString','line_number':2061,'multiline':False]['text':'            p          pointer to UnicodeString IF this UText owns the string','line_number':2062,'multiline':False]['text':'                       and it must be deleted on close().  NULL otherwise.','line_number':2063,'multiline':False]['text':'','line_number':2064,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2065,'multiline':False]['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':2072,'multiline':False]['text':' For deep clones, make a copy of the UnicodeSring.','line_number':2075,'multiline':False]['text':'  The copied UnicodeString storage is owned by the newly created UText clone.','line_number':2076,'multiline':False]['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':2077,'multiline':False]['text':'    the UText.','line_number':2078,'multiline':False]['text':'','line_number':2079,'multiline':False]['text':' with deep clone, the copy is writable, even when the source is not.','line_number':2085,'multiline':False]['text':' Most of the work of close is done by the generic UText framework close.','line_number':2093,'multiline':False]['text':' All that needs to be done here is delete the UnicodeString if the UText','line_number':2094,'multiline':False]['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2095,'multiline':False]['text':' Check whether request is at the start or end','line_number':2115,'multiline':False]['text':' replace','line_number':2187,'multiline':False]['text':' Update the chunk description.','line_number':2191,'multiline':False]['text':' Set iteration position to the point just following the newly inserted text.','line_number':2197,'multiline':False]['text':' move: copy to destIndex, then replace original with nothing','line_number':2226,'multiline':False]['text':' copy','line_number':2234,'multiline':False]['text':' update chunk description, set iteration position.','line_number':2238,'multiline':False]['text':' copy operation, string length grows','line_number':2241,'multiline':False]['text':' Iteration position to end of the newly inserted text.','line_number':2247,'multiline':False]['text':' Reserved alignment padding','line_number':2258,'multiline':False]['text':' MapOffsetToNative,','line_number':2265,'multiline':False]['text':' MapIndexToUTF16,','line_number':2266,'multiline':False]['text':' spare 1','line_number':2268,'multiline':False]['text':' spare 2','line_number':2269,'multiline':False]['text':' spare 3','line_number':2270,'multiline':False]['text':' The UnicodeString is bogus, but we still need to detach the UText','line_number':2292,'multiline':False]['text':'   from whatever it was hooked to before, if anything.','line_number':2293,'multiline':False]['text':'    note:  use the standard (writable) function table for UnicodeString.','line_number':2299,'multiline':False]['text':'           The flag settings disable writing, so having the functions in','line_number':2300,'multiline':False]['text':'           the table is harmless.','line_number':2301,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2315,'multiline':False]['text':'','line_number':2316,'multiline':False]['text':'     UText implementation for const UChar * strings','line_number':2317,'multiline':False]['text':'','line_number':2318,'multiline':False]['text':'         Use of UText data members:','line_number':2319,'multiline':False]['text':'            context    pointer to UnicodeString','line_number':2320,'multiline':False]['text':'            a          length.  -1 if not yet known.','line_number':2321,'multiline':False]['text':'','line_number':2322,'multiline':False]['text':'         TODO:  support 64 bit lengths.','line_number':2323,'multiline':False]['text':'','line_number':2324,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2325,'multiline':False]['text':' First do a generic shallow clone.','line_number':2332,'multiline':False]['text':' For deep clones, make a copy of the string.','line_number':2335,'multiline':False]['text':'  The copied storage is owned by the newly created clone.','line_number':2336,'multiline':False]['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':2337,'multiline':False]['text':'    it.','line_number':2338,'multiline':False]['text':'','line_number':2339,'multiline':False]['text':' The cloned string IS going to be NUL terminated, whether or not the original was.','line_number':2344,'multiline':False]['text':' Most of the work of close is done by the generic UText framework close.','line_number':2365,'multiline':False]['text':' All that needs to be done here is delete the string if the UText','line_number':2366,'multiline':False]['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2367,'multiline':False]['text':' null terminated, we don't yet know the length.  Scan for it.','line_number':2380,'multiline':False]['text':'    Access is not convenient for doing this','line_number':2381,'multiline':False]['text':'    because the current interation postion can't be changed.','line_number':2382,'multiline':False]['text':' pin the requested index to the bounds of the string,','line_number':2403,'multiline':False]['text':'  and set current iteration position.','line_number':2404,'multiline':False]['text':' The request data is within the chunk as it is known so far.','line_number':2408,'multiline':False]['text':' Put index on a code point boundary.','line_number':2409,'multiline':False]['text':' We know the length of this string, and the user is requesting something','line_number':2412,'multiline':False]['text':' at or beyond the length.  Pin the requested index to the length.','line_number':2413,'multiline':False]['text':' Null terminated string, length not yet known, and the requested index','line_number':2416,'multiline':False]['text':'  is beyond where we have scanned so far.','line_number':2417,'multiline':False]['text':'  Scan to 32 UChars beyond the requested index.  The strategy here is','line_number':2418,'multiline':False]['text':'  to avoid fully scanning a long string when the caller only wants to','line_number':2419,'multiline':False]['text':'  see a few characters at its beginning.','line_number':2420,'multiline':False]['text':' note: int64 expression','line_number':2422,'multiline':False]['text':' We found the end of the string.  Remember it, pin the requested index to it,','line_number':2429,'multiline':False]['text':'  and bail out of here.','line_number':2430,'multiline':False]['text':' We scanned through the next batch of UChars without finding the end.','line_number':2445,'multiline':False]['text':' Scanned to the limit of a 32 bit length.','line_number':2448,'multiline':False]['text':' Forceably trim the overlength string back so length fits in int32','line_number':2449,'multiline':False]['text':'  TODO:  add support for 64 bit strings.','line_number':2450,'multiline':False]['text':' The endpoint of a chunk must not be left in the middle of a surrogate pair.','line_number':2460,'multiline':False]['text':' If the current end is on a lead surrogate, back the end up by one.','line_number':2461,'multiline':False]['text':' It doesn't matter if the end char happens to be an unpaired surrogate,','line_number':2462,'multiline':False]['text':'    and it's simpler not to worry about it.','line_number':2463,'multiline':False]['text':' Null-terminated chunk with end still unknown.','line_number':2467,'multiline':False]['text':' Update the chunk length to reflect what has been scanned thus far.','line_number':2468,'multiline':False]['text':' That the full length is still unknown is (still) flagged by','line_number':2469,'multiline':False]['text':'    ut->a being < 0.','line_number':2470,'multiline':False]['text':' Check whether request is at the start or end','line_number':2481,'multiline':False]['text':'const UChar *s=(const UChar *)ut->context;','line_number':2502,'multiline':False]['text':' Access the start.  Does two things we need:','line_number':2508,'multiline':False]['text':'   Pins 'start' to the length of the string, if it came in out-of-bounds.','line_number':2509,'multiline':False]['text':'   Snaps 'start' to the beginning of a code point.','line_number':2510,'multiline':False]['text':' Just hit the end of a null-terminated string.','line_number':2524,'multiline':False]['text':' set string length for this UText','line_number':2525,'multiline':False]['text':' to ensure di never exceeds INT32_MAX, which must not happen logically ','line_number':2533,'multiline':True]['text':' only store if there is space.','line_number':2535,'multiline':False]['text':' We have filled the destination buffer, and the string length is known.','line_number':2539,'multiline':False]['text':'  Cut the loop short.  There is no need to scan string termination.','line_number':2540,'multiline':False]['text':' If the limit index points to a lead surrogate of a pair,','line_number':2549,'multiline':False]['text':'   add the corresponding trail surrogate to the destination.','line_number':2550,'multiline':False]['text':' store only if there is space in the output buffer.','line_number':2555,'multiline':False]['text':' Put iteration position at the point just following the extracted text','line_number':2561,'multiline':False]['text':' Add a terminating NUL if space in the buffer permits,','line_number':2568,'multiline':False]['text':' and set the error status as required.','line_number':2569,'multiline':False]['text':' Reserved alignment padding','line_number':2577,'multiline':False]['text':' Replace','line_number':2582,'multiline':False]['text':' Copy','line_number':2583,'multiline':False]['text':' MapOffsetToNative,','line_number':2584,'multiline':False]['text':' MapIndexToUTF16,','line_number':2585,'multiline':False]['text':' spare 1','line_number':2587,'multiline':False]['text':' spare 2','line_number':2588,'multiline':False]['text':' spare 3','line_number':2589,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2628,'multiline':False]['text':'','line_number':2629,'multiline':False]['text':'     UText implementation for text from ICU CharacterIterators','line_number':2630,'multiline':False]['text':'','line_number':2631,'multiline':False]['text':'         Use of UText data members:','line_number':2632,'multiline':False]['text':'            context    pointer to the CharacterIterator','line_number':2633,'multiline':False]['text':'            a          length of the full text.','line_number':2634,'multiline':False]['text':'            p          pointer to  buffer 1','line_number':2635,'multiline':False]['text':'            b          start index of local buffer 1 contents','line_number':2636,'multiline':False]['text':'            q          pointer to buffer 2','line_number':2637,'multiline':False]['text':'            c          start index of local buffer 2 contents','line_number':2638,'multiline':False]['text':'            r          pointer to the character iterator if the UText owns it.','line_number':2639,'multiline':False]['text':'                       Null otherwise.','line_number':2640,'multiline':False]['text':'','line_number':2641,'multiline':False]['text':'------------------------------------------------------------------------------','line_number':2642,'multiline':False]['text':' Most of the work of close is done by the generic UText framework close.','line_number':2648,'multiline':False]['text':' All that needs to be done here is delete the CharacterIterator if the UText','line_number':2649,'multiline':False]['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2650,'multiline':False]['text':' reverse iteration, want the position just before what was asked for.','line_number':2673,'multiline':False]['text':' Forward iteration, don't ask for something past the end of the text.','line_number':2676,'multiline':False]['text':' Find the native index of the start of the buffer containing what we want.','line_number':2680,'multiline':False]['text':' The buffer we want is already the current chunk.','line_number':2687,'multiline':False]['text':' The first buffer (buffer p) has what we need.','line_number':2690,'multiline':False]['text':' The second buffer (buffer q) has what we need.','line_number':2693,'multiline':False]['text':' Neither buffer already has what we need.','line_number':2696,'multiline':False]['text':' Load new data from the character iterator.','line_number':2697,'multiline':False]['text':' Use the buf that is not the current buffer.','line_number':2698,'multiline':False]['text':' We have a buffer with the data we need.','line_number':2712,'multiline':False]['text':' Set it up as the current chunk, if it wasn't already.','line_number':2713,'multiline':False]['text':' There is no CharacterIterator API for cloning the underlying text storage.','line_number':2738,'multiline':False]['text':' cast off const on getNativeIndex.','line_number':2748,'multiline':False]['text':'   For CharacterIterator based UTexts, this is safe, the operation is const.','line_number':2749,'multiline':False]['text':' flags that this UText owns the CharacterIterator','line_number':2752,'multiline':False]['text':' Moves ix to lead of surrogate pair, if needed.','line_number':2778,'multiline':False]['text':' to ensure desti+len never exceeds MAX_INT32, which must not happen logically ','line_number':2784,'multiline':True]['text':' Reserved alignment padding','line_number':2804,'multiline':False]['text':' Replace','line_number':2809,'multiline':False]['text':' Copy','line_number':2810,'multiline':False]['text':' MapOffsetToNative,','line_number':2811,'multiline':False]['text':' MapIndexToUTF16,','line_number':2812,'multiline':False]['text':' spare 1','line_number':2814,'multiline':False]['text':' spare 2','line_number':2815,'multiline':False]['text':' spare 3','line_number':2816,'multiline':False]['text':' No support for CharacterIterators that do not start indexing from zero.','line_number':2828,'multiline':False]['text':' Extra space in UText for 2 buffers of CIBufSize UChars each.','line_number':2833,'multiline':False]['text':' Length of text','line_number':2840,'multiline':False]['text':' First buffer','line_number':2841,'multiline':False]['text':' Native index of first buffer contents','line_number':2842,'multiline':False]['text':' Second buffer','line_number':2843,'multiline':False]['text':' Native index of second buffer contents','line_number':2844,'multiline':False]['text':' Initialize current chunk contents to be empty.','line_number':2846,'multiline':False]['text':'   First access will fault something in.','line_number':2847,'multiline':False]['text':'   Note:  The initial nativeStart and chunkOffset must sum to zero','line_number':2848,'multiline':False]['text':'          so that getNativeIndex() will correctly compute to zero','line_number':2849,'multiline':False]['text':'          if no call to Access() has ever been made.  They can't be both','line_number':2850,'multiline':False]['text':'          zero without Access() thinking that the chunk is valid.','line_number':2851,'multiline':False]['text':' enables native indexing','line_number':2857,'multiline':False]