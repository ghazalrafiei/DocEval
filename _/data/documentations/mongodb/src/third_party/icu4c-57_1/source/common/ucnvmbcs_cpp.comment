['text':'
******************************************************************************
*
*   Copyright (C) 2000-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  ucnvmbcs.cpp
*   encoding:   US-ASCII
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2000jul03
*   created by: Markus W. Scherer
*
*   The current code in this file replaces the previous implementation
*   of conversion code from multi-byte codepages to Unicode and back.
*   This implementation supports the following:
*   - legacy variable-length codepages with up to 4 bytes per character
*   - all Unicode code points (up to 0x10ffff)
*   - efficient distinction of unassigned vs. illegal byte sequences
*   - it is possible in fromUnicode() to directly deal with simple
*     stateful encodings (used for EBCDIC_STATEFUL)
*   - it is possible to convert Unicode code points
*     to a single zero byte (but not as a fallback except for SBCS)
*
*   Remaining limitations in fromUnicode:
*   - byte sequences must not have leading zero bytes
*   - except for SBCS codepages: no fallback mapping from Unicode to a zero byte
*   - limitation to up to 4 bytes per character
*
*   ICU 2.8 (late 2003) adds a secondary data structure which lifts some of these
*   limitations and adds m:n character mappings and other features.
*   See ucnv_ext.h for details.
*
*   Change history: 
*
*    5/6/2001       Ram       Moved  MBCS_SINGLE_RESULT_FROM_U,MBCS_STAGE_2_FROM_U,
*                             MBCS_VALUE_2_FROM_STAGE_2, MBCS_VALUE_4_FROM_STAGE_2
*                             macros to ucnvmbcs.h file
','line_number':1,'multiline':True]['text':' control optimizations according to the platform ','line_number':61,'multiline':True]['text':'
 * _MBCSHeader versions 5.3 & 4.3
 * (Note that the _MBCSHeader version is in addition to the converter formatVersion.)
 *
 * This version is optional. Version 5 is used for incompatible data format changes.
 * makeconv will continue to generate version 4 files if possible.
 *
 * Changes from version 4:
 *
 * The main difference is an additional _MBCSHeader field with
 * - the length (number of uint32_t) of the _MBCSHeader
 * - flags for further incompatible data format changes
 * - flags for further, backward compatible data format changes
 *
 * The MBCS_OPT_FROM_U flag indicates that most of the fromUnicode data is omitted from
 * the file and needs to be reconstituted at load time.
 * This requires a utf8Friendly format with an additional mbcsIndex table for fast
 * (and UTF-8-friendly) fromUnicode conversion for Unicode code points up to maxFastUChar.
 * (For details about these structures see below, and see ucnvmbcs.h.)
 *
 *   utf8Friendly also implies that the fromUnicode mappings are stored in ascending order
 *   of the Unicode code points. (This requires that the .ucm file has the |0 etc.
 *   precision markers for all mappings.)
 *
 *   All fallbacks have been moved to the extension table, leaving only roundtrips in the
 *   omitted data that can be reconstituted from the toUnicode data.
 *
 *   Of the stage 2 table, the part corresponding to maxFastUChar and below is omitted.
 *   With only roundtrip mappings in the base fromUnicode data, this part is fully
 *   redundant with the mbcsIndex and will be reconstituted from that (also using the
 *   stage 1 table which contains the information about how stage 2 was compacted).
 *
 *   The rest of the stage 2 table, the part for code points above maxFastUChar,
 *   is stored in the file and will be appended to the reconstituted part.
 *
 *   The entire fromUBytes array is omitted from the file and will be reconstitued.
 *   This is done by enumerating all toUnicode roundtrip mappings, performing
 *   each mapping (using the stage 1 and reconstituted stage 2 tables) and
 *   writing instead of reading the byte values.
 *
 * _MBCSHeader version 4.3
 *
 * Change from version 4.2:
 * - Optional utf8Friendly data structures, with 64-entry stage 3 block
 *   allocation for parts of the BMP, and an additional mbcsIndex in non-SBCS
 *   files which can be used instead of stages 1 & 2.
 *   Faster lookups for roundtrips from most commonly used characters,
 *   and lookups from UTF-8 byte sequences with a natural bit distribution.
 *   See ucnvmbcs.h for more details.
 *
 * Change from version 4.1:
 * - Added an optional extension table structure at the end of the .cnv file.
 *   It is present if the upper bits of the header flags field contains a non-zero
 *   byte offset to it.
 *   Files that contain only a conversion table and no base table
 *   use the special outputType MBCS_OUTPUT_EXT_ONLY.
 *   These contain the base table name between the MBCS header and the extension
 *   data.
 *
 * Change from version 4.0:
 * - Replace header.reserved with header.fromUBytesLength so that all
 *   fields in the data have length.
 *
 * Changes from version 3 (for performance improvements):
 * - new bit distribution for state table entries
 * - reordered action codes
 * - new data structure for single-byte fromUnicode
 *   + stage 2 only contains indexes
 *   + stage 3 stores 16 bits per character with classification bits 15..8
 * - no multiplier for stage 1 entries
 * - stage 2 for non-single-byte codepages contains the index and the flags in
 *   one 32-bit value
 * - 2-byte and 4-byte fromUnicode results are stored directly as 16/32-bit integers
 *
 * For more details about old versions of the MBCS data structure, see
 * the corresponding versions of this file.
 *
 * Converting stateless codepage data ---------------------------------------***
 * (or codepage data with simple states) to Unicode.
 *
 * Data structure and algorithm for converting from complex legacy codepages
 * to Unicode. (Designed before 2000-may-22.)
 *
 * The basic idea is that the structure of legacy codepages can be described
 * with state tables.
 * When reading a byte stream, each input byte causes a state transition.
 * Some transitions result in the output of a code point, some result in
 * "unassigned" or "illegal" output.
 * This is used here for character conversion.
 *
 * The data structure begins with a state table consisting of a row
 * per state, with 256 entries (columns) per row for each possible input
 * byte value.
 * Each entry is 32 bits wide, with two formats distinguished by
 * the sign bit (bit 31):
 *
 * One format for transitional entries (bit 31 not set) for non-final bytes, and
 * one format for final entries (bit 31 set).
 * Both formats contain the number of the next state in the same bit
 * positions.
 * State 0 is the initial state.
 *
 * Most of the time, the offset values of subsequent states are added
 * up to a scalar value. This value will eventually be the index of
 * the Unicode code point in a table that follows the state table.
 * The effect is that the code points for final state table rows
 * are contiguous. The code points of final state rows follow each other
 * in the order of the references to those final states by previous
 * states, etc.
 *
 * For some terminal states, the offset is itself the output Unicode
 * code point (16 bits for a BMP code point or 20 bits for a supplementary
 * code point (stored as code point minus 0x10000 so that 20 bits are enough).
 * For others, the code point in the Unicode table is stored with either
 * one or two code units: one for BMP code points, two for a pair of
 * surrogates.
 * All code points for a final state entry take up the same number of code
 * units, regardless of whether they all actually _use_ the same number
 * of code units. This is necessary for simple array access.
 *
 * An additional feature comes in with what in ICU is called "fallback"
 * mappings:
 *
 * In addition to round-trippable, precise, 1:1 mappings, there are often
 * mappings defined between similar, though not the same, characters.
 * Typically, such mappings occur only in fromUnicode mapping tables because
 * Unicode has a superset repertoire of most other codepages. However, it
 * is possible to provide such mappings in the toUnicode tables, too.
 * In this case, the fallback mappings are partly integrated into the
 * general state tables because the structure of the encoding includes their
 * byte sequences.
 * For final entries in an initial state, fallback mappings are stored in
 * the entry itself like with roundtrip mappings.
 * For other final entries, they are stored in the code units table if
 * the entry is for a pair of code units.
 * For single-unit results in the code units table, there is no space to
 * alternatively hold a fallback mapping; in this case, the code unit
 * is stored as U+fffe (unassigned), and the fallback mapping needs to
 * be looked up by the scalar offset value in a separate table.
 *
 * "Unassigned" state entries really mean "structurally unassigned",
 * i.e., such a byte sequence will never have a mapping result.
 *
 * The interpretation of the bits in each entry is as follows:
 *
 * Bit 31 not set, not a terminal entry ("transitional"):
 * 30..24 next state
 * 23..0  offset delta, to be added up
 *
 * Bit 31 set, terminal ("final") entry:
 * 30..24 next state (regardless of action code)
 * 23..20 action code:
 *        action codes 0 and 1 result in precise-mapping Unicode code points
 *        0  valid byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point
 *                  never U+fffe or U+ffff
 *        1  valid byte sequence
 *           19..0  20-bit Unicode supplementary code point
 *                  never U+fffe or U+ffff
 *
 *        action codes 2 and 3 result in fallback (unidirectional-mapping) Unicode code points
 *        2  valid byte sequence (fallback)
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point as fallback result
 *        3  valid byte sequence (fallback)
 *           19..0  20-bit Unicode supplementary code point as fallback result
 *
 *        action codes 4 and 5 may result in roundtrip/fallback/unassigned/illegal results
 *        depending on the code units they result in
 *        4  valid byte sequence
 *           19..9  not used, 0
 *            8..0  final offset delta
 *                  pointing to one 16-bit code unit which may be
 *                  fffe  unassigned -- look for a fallback for this offset
 *                  ffff  illegal
 *        5  valid byte sequence
 *           19..9  not used, 0
 *            8..0  final offset delta
 *                  pointing to two 16-bit code units
 *                  (typically UTF-16 surrogates)
 *                  the result depends on the first code unit as follows:
 *                  0000..d7ff  roundtrip BMP code point (1st alone)
 *                  d800..dbff  roundtrip surrogate pair (1st, 2nd)
 *                  dc00..dfff  fallback surrogate pair (1st-400, 2nd)
 *                  e000        roundtrip BMP code point (2nd alone)
 *                  e001        fallback BMP code point (2nd alone)
 *                  fffe        unassigned
 *                  ffff        illegal
 *           (the final offset deltas are at most 255 * 2,
 *            times 2 because of storing code unit pairs)
 *
 *        6  unassigned byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point U+fffe (new with version 2)
 *                  this does not contain a final offset delta because the main
 *                  purpose of this action code is to save scalar offset values;
 *                  therefore, fallback values cannot be assigned to byte
 *                  sequences that result in this action code
 *        7  illegal byte sequence
 *           19..16 not used, 0
 *           15..0  16-bit Unicode BMP code point U+ffff (new with version 2)
 *        8  state change only
 *           19..0  not used, 0
 *           useful for state changes in simple stateful encodings,
 *           at Shift-In/Shift-Out codes
 *
 *
 *        9..15 reserved for future use
 *           current implementations will only perform a state change
 *           and ignore bits 19..0
 *
 * An encoding with contiguous ranges of unassigned byte sequences, like
 * Shift-JIS and especially EUC-TW, can be stored efficiently by having
 * at least two states for the trail bytes:
 * One trail byte state that results in code points, and one that only
 * has "unassigned" and "illegal" terminal states.
 *
 * Note: partly by accident, this data structure supports simple stateful
 * encodings without any additional logic.
 * Currently, only simple Shift-In/Shift-Out schemes are handled with
 * appropriate state tables (especially EBCDIC_STATEFUL!).
 *
 * MBCS version 2 added:
 * unassigned and illegal action codes have U+fffe and U+ffff
 * instead of unused bits; this is useful for _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP()
 *
 * Converting from Unicode to codepage bytes --------------------------------***
 *
 * The conversion data structure for fromUnicode is designed for the known
 * structure of Unicode. It maps from 21-bit code points (0..0x10ffff) to
 * a sequence of 1..4 bytes, in addition to a flag that indicates if there is
 * a roundtrip mapping.
 *
 * The lookup is done with a 3-stage trie, using 11/6/4 bits for stage 1/2/3
 * like in the character properties table.
 * The beginning of the trie is at offsetFromUTable, the beginning of stage 3
 * with the resulting bytes is at offsetFromUBytes.
 *
 * Beginning with version 4, single-byte codepages have a significantly different
 * trie compared to other codepages.
 * In all cases, the entry in stage 1 is directly the index of the block of
 * 64 entries in stage 2.
 *
 * Single-byte lookup:
 *
 * Stage 2 only contains 16-bit indexes directly to the 16-blocks in stage 3.
 * Stage 3 contains one 16-bit word per result:
 * Bits 15..8 indicate the kind of result:
 *    f  roundtrip result
 *    c  fallback result from private-use code point
 *    8  fallback result from other code points
 *    0  unassigned
 * Bits 7..0 contain the codepage byte. A zero byte is always possible.
 *
 * In version 4.3, the runtime code can build an sbcsIndex for a utf8Friendly
 * file. For 2-byte UTF-8 byte sequences and some 3-byte sequences the lookup
 * becomes a 2-stage (single-index) trie lookup with 6 bits for stage 3.
 * ASCII code points can be looked up with a linear array access into stage 3.
 * See maxFastUChar and other details in ucnvmbcs.h.
 *
 * Multi-byte lookup:
 *
 * Stage 2 contains a 32-bit word for each 16-block in stage 3:
 * Bits 31..16 contain flags for which stage 3 entries contain roundtrip results
 *             test: MBCS_FROM_U_IS_ROUNDTRIP(stage2Entry, c)
 *             If this test is false, then a non-zero result will be interpreted as
 *             a fallback mapping.
 * Bits 15..0  contain the index to stage 3, which must be multiplied by 16*(bytes per char)
 *
 * Stage 3 contains 2, 3, or 4 bytes per result.
 * 2 or 4 bytes are stored as uint16_t/uint32_t in platform endianness,
 * while 3 bytes are stored as bytes in big-endian order.
 * Leading zero bytes are ignored, and the number of bytes is counted.
 * A zero byte mapping result is possible as a roundtrip result.
 * For some output types, the actual result is processed from this;
 * see ucnv_MBCSFromUnicodeWithOffsets().
 *
 * Note that stage 1 always contains 0x440=1088 entries (0x440==0x110000>>10),
 * or (version 3 and up) for BMP-only codepages, it contains 64 entries.
 *
 * In version 4.3, a utf8Friendly file contains an mbcsIndex table.
 * For 2-byte UTF-8 byte sequences and most 3-byte sequences the lookup
 * becomes a 2-stage (single-index) trie lookup with 6 bits for stage 3.
 * ASCII code points can be looked up with a linear array access into stage 3.
 * See maxFastUChar, mbcsIndex and other details in ucnvmbcs.h.
 *
 * In version 3, stage 2 blocks may overlap by multiples of the multiplier
 * for compaction.
 * In version 4, stage 2 blocks (and for single-byte codepages, stage 3 blocks)
 * may overlap by any number of entries.
 *
 * MBCS version 2 added:
 * the converter checks for known output types, which allows
 * adding new ones without crashing an unaware converter
 ','line_number':65,'multiline':True]['text':'*
 * Callback from ucnv_MBCSEnumToUnicode(), takes 32 mappings from
 * consecutive sequences of bytes, starting from the one encoded in value,
 * to Unicode code points. (Multiple mappings to reduce per-function call overhead.)
 * Does not currently support m:n mappings or reverse fallbacks.
 * This function will not be called for sequences of bytes with leading zeros.
 *
 * @param context an opaque pointer, as passed into ucnv_MBCSEnumToUnicode()
 * @param value contains 1..4 bytes of the first byte sequence, right-aligned
 * @param codePoints resulting Unicode code points, or negative if a byte sequence does
 *        not map to anything
 * @return TRUE to continue enumeration, FALSE to stop
 ','line_number':362,'multiline':True]['text':' Static data is in tools/makeconv/ucnvstat.c for data-based
 * converters. Be sure to update it as well.
 ','line_number':507,'multiline':True]['text':' GB 18030 data ------------------------------------------------------------ ','line_number':518,'multiline':True]['text':' helper macros for linear values for GB 18030 four-byte sequences ','line_number':520,'multiline':True]['text':'
 * Some ranges of GB 18030 where both the Unicode code points and the
 * GB four-byte sequences are contiguous and are handled algorithmically by
 * the special callback functions below.
 * The values are start & end of Unicode & GB codes.
 *
 * Note that single surrogates are not mapped by GB 18030
 * as of the re-released mapping tables from 2000-nov-30.
 ','line_number':527,'multiline':True]['text':' bit flag for UConverter.options indicating GB 18030 special handling ','line_number':554,'multiline':True]['text':' bit flag for UConverter.options indicating KEIS,JEF,JIF special handling ','line_number':557,'multiline':True]['text':' Should never happen. ','line_number':620,'multiline':True]['text':' Miscellaneous ------------------------------------------------------------ ','line_number':627,'multiline':True]['text':' similar to ucnv_MBCSGetNextUChar() but recursive ','line_number':629,'multiline':True]['text':' becomes non-negative if there is a mapping ','line_number':646,'multiline':True]['text':' skip byte sequences with leading zeros because they are not stored in the fromUnicode table ','line_number':650,'multiline':True]['text':' recurse to a state with non-ignorable actions ','line_number':660,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':675,'multiline':True]['text':' output BMP code point ','line_number':681,'multiline':True]['text':' output BMP code point ','line_number':687,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':695,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':697,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':700,'multiline':True]['text':' output supplementary code point ','line_number':706,'multiline':True]['text':'
 * Only called if stateProps[state]==-1.
 * A recursive call may do stateProps[state]|=0x40 if this state is the target of an
 * MBCS_STATE_CHANGE_ONLY.
 ','line_number':727,'multiline':True]['text':' find first non-ignorable state ','line_number':740,'multiline':True]['text':' (int8_t)0xc0 ','line_number':755,'multiline':True]['text':' find last non-ignorable state ','line_number':761,'multiline':True]['text':' recurse further and collect direct-state information ','line_number':778,'multiline':True]['text':'
 * Internal function enumerating the toUnicode data of an MBCS converter.
 * Currently only used for reconstituting data for a MBCS_OPT_NO_FROM_U
 * table, but could also be used for a future ucnv_getUnicodeSet() option
 * that includes reverse fallbacks (after updating this function's implementation).
 * Currently only handles roundtrip mappings.
 * Does not currently handle extensions.
 ','line_number':796,'multiline':True]['text':'
     * Properties for each state, to speed up the enumeration.
     * Ignorable actions are unassigned/illegal/state-change-only:
     * They do not lead to mappings.
     *
     * Bits 7..6:
     * 1 direct/initial state (stateful converters have multiple)
     * 0 non-initial state with transitions or with non-ignorable result actions
     * -1 final state with only ignorable actions
     *
     * Bits 5..3:
     * The lowest byte value with non-ignorable actions is
     * value<<5 (rounded down).
     *
     * Bits 2..0:
     * The highest byte value with non-ignorable actions is
     * (value<<5)&0x1f (rounded up).
     ','line_number':808,'multiline':True]['text':' recurse from state 0 and set all stateProps ','line_number':831,'multiline':True]['text':'if(stateProps[state]==-1) {
            printf("unused/unreachable <icu:state> %d\n", state);
        }','line_number':835,'multiline':True]['text':' start from each direct state ','line_number':839,'multiline':True]['text':' enumerate the from-Unicode trie table ','line_number':862,'multiline':True]['text':' keep track of the current code point while enumerating ','line_number':871,'multiline':True]['text':'
         * Set a threshold variable for selecting which mappings to use.
         * See ucnv_MBCSSingleFromBMPWithOffsets() and
         * MBCS_SINGLE_RESULT_FROM_U() for details.
         ','line_number':879,'multiline':True]['text':' use only roundtrips ','line_number':885,'multiline':True]['text':' UCNV_ROUNDTRIP_AND_FALLBACK_SET ','line_number':887,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':888,'multiline':True]['text':' read the stage 3 block ','line_number':898,'multiline':True]['text':' empty stage 3 block ','line_number':907,'multiline':True]['text':' empty stage 2 block ','line_number':911,'multiline':True]['text':' read the stage 3 block ','line_number':944,'multiline':True]['text':' get the roundtrip flags for the stage 3 block ','line_number':947,'multiline':True]['text':'
                         * Add code points for which the roundtrip flag is set,
                         * or which map to non-zero bytes if we use fallbacks.
                         * See ucnv_MBCSFromUnicodeWithOffsets() for details.
                         ','line_number':950,'multiline':True]['text':' Ignore single-byte results (<0x100). ','line_number':985,'multiline':True]['text':' +=st3Multiplier ','line_number':991,'multiline':True]['text':' Only add code points that map to CNS 11643 planes 1 & 2 for non-EXT ISO-2022-CN. ','line_number':995,'multiline':True]['text':' +=st3Multiplier ','line_number':1001,'multiline':True]['text':' Only add code points that map to Shift-JIS codes corresponding to JIS X 0208. ','line_number':1005,'multiline':True]['text':' +=st3Multiplier ','line_number':1011,'multiline':True]['text':' Only add code points that map to ISO 2022 GR 94 DBCS codes (each byte A1..FE). ','line_number':1015,'multiline':True]['text':' +=st3Multiplier ','line_number':1024,'multiline':True]['text':' Only add code points that are suitable for HZ DBCS (lead byte A1..FD). ','line_number':1028,'multiline':True]['text':' +=st3Multiplier ','line_number':1037,'multiline':True]['text':' empty stage 3 block ','line_number':1045,'multiline':True]['text':' empty stage 2 block ','line_number':1049,'multiline':True]['text':' conversion extensions for input not in the main table -------------------- ','line_number':1083,'multiline':True]['text':'
 * Hardcoded extension handling for GB 18030.
 * Definition of LINEAR macros and gb18030Ranges see near the beginning of the file.
 *
 * In the future, conversion extensions may handle m:n mappings and delta tables,
 * see http://source.icu-project.org/repos/icu/icuhtml/trunk/design/conversion/conversion_extensions.html
 *
 * If an input character cannot be mapped, then these functions set an error
 * code. The framework will then call the callback function.
 ','line_number':1085,'multiline':True]['text':'
 * @return if(U_FAILURE) return the code point for cnv->fromUChar32
 *         else return 0 after output has been written to the target
 ','line_number':1096,'multiline':True]['text':' an extension mapping handled the input ','line_number':1121,'multiline':True]['text':' GB 18030 ','line_number':1124,'multiline':True]['text':' found the Unicode code point, output the four-byte sequence for it ','line_number':1132,'multiline':True]['text':' get the linear value of the first GB 18030 code in this range ','line_number':1136,'multiline':True]['text':' add the offset from the beginning of the range ','line_number':1139,'multiline':True]['text':' turn this into a four-byte sequence ','line_number':1142,'multiline':True]['text':' output this sequence ','line_number':1148,'multiline':True]['text':' no mapping ','line_number':1157,'multiline':True]['text':'
 * Input sequence: cnv->toUBytes[0..length[
 * @return if(U_FAILURE) return the length (toULength, byteIndex) for the input
 *         else return 0 after output has been written to the target
 ','line_number':1162,'multiline':True]['text':' an extension mapping handled the input ','line_number':1186,'multiline':True]['text':' GB 18030 ','line_number':1189,'multiline':True]['text':' found the sequence, output the Unicode code point for it ','line_number':1199,'multiline':True]['text':' add the linear difference between the input and start sequences to the start code point ','line_number':1202,'multiline':True]['text':' output this code point ','line_number':1205,'multiline':True]['text':' no mapping ','line_number':1213,'multiline':True]['text':' EBCDIC swap LF<->NL ------------------------------------------------------ ','line_number':1218,'multiline':True]['text':'
 * This code modifies a standard EBCDIC<->Unicode mapping table for
 * OS/390 (z/OS) Unix System Services (Open Edition).
 * The difference is in the mapping of Line Feed and New Line control codes:
 * Standard EBCDIC maps
 *
 *   <U000A> \x25 |0
 *   <U0085> \x15 |0
 *
 * but OS/390 USS EBCDIC swaps the control codes for LF and NL,
 * mapping
 *
 *   <U000A> \x15 |0
 *   <U0085> \x25 |0
 *
 * This code modifies a loaded standard EBCDIC<->Unicode mapping table
 * by copying it into allocated memory and swapping the LF and NL values.
 * It allows to support the same EBCDIC charset in both versions without
 * duplicating the entire installed table.
 ','line_number':1220,'multiline':True]['text':' standard EBCDIC codes ','line_number':1241,'multiline':True]['text':' standard EBCDIC codes with roundtrip flag as stored in Unicode-to-single-byte tables ','line_number':1245,'multiline':True]['text':' Unicode code points ','line_number':1249,'multiline':True]['text':'
     * Check that this is an EBCDIC table with SBCS portion -
     * SBCS or EBCDIC_STATEFUL with standard EBCDIC LF and NL mappings.
     *
     * If not, ignore the option. Options are always ignored if they do not apply.
     ','line_number':1274,'multiline':True]['text':' MBCS_OUTPUT_2_SISO ','line_number':1295,'multiline':True]['text':'
         * We _know_ the number of bytes in the fromUnicodeBytes array
         * starting with header.version 4.1.
         ','line_number':1314,'multiline':True]['text':'
         * Otherwise:
         * There used to be code to enumerate the fromUnicode
         * trie and find the highest entry, but it was removed in ICU 3.2
         * because it was not tested and caused a low code coverage number.
         * See Jitterbug 3674.
         * This affects only some .cnv file formats with a header.version
         * below 4.1, and only when swaplfnl is requested.
         *
         * ucnvmbcs.c revision 1.99 is the last one with the
         * ucnv_MBCSSizeofFromUBytes() function.
         ','line_number':1320,'multiline':True]['text':'
     * The table has an appropriate format.
     * Allocate and build
     * - a modified to-Unicode state table
     * - a modified from-Unicode output array
     * - a converter name string with the swap option appended
     ','line_number':1336,'multiline':True]['text':' copy and modify the to-Unicode state table ','line_number':1353,'multiline':True]['text':' copy and modify the from-Unicode result table ','line_number':1360,'multiline':True]['text':' conveniently, the table access macros work on the left side of expressions ','line_number':1364,'multiline':True]['text':' MBCS_OUTPUT_2_SISO ','line_number':1368,'multiline':True]['text':' set the canonical converter name ','line_number':1376,'multiline':True]['text':' set the pointers ','line_number':1381,'multiline':True]['text':' release the allocated memory if another thread beat us to it ','line_number':1392,'multiline':True]['text':' reconstitute omitted fromUnicode data ------------------------------------ ','line_number':1399,'multiline':True]['text':' for details, compare with genmbcs.c MBCSAddFromUnicode() and transformEUC() ','line_number':1401,'multiline':True]['text':' for EUC outputTypes, modify the value like genmbcs.c's transformEUC() ','line_number':1414,'multiline':True]['text':' short sequences are stored directly ','line_number':1418,'multiline':True]['text':' code set 0 or 1 ','line_number':1419,'multiline':True]['text':' code set 2 ','line_number':1421,'multiline':True]['text':' first byte is 0x8f ','line_number':1423,'multiline':True]['text':' code set 3 ','line_number':1424,'multiline':True]['text':' short sequences are stored directly ','line_number':1430,'multiline':True]['text':' code set 0 or 1 ','line_number':1431,'multiline':True]['text':' code set 2 ','line_number':1433,'multiline':True]['text':' first byte is 0x8f ','line_number':1435,'multiline':True]['text':' code set 3 ','line_number':1436,'multiline':True]['text':' locate the stage 2 & 3 data ','line_number':1450,'multiline':True]['text':' write the codepage bytes into stage 3 ','line_number':1455,'multiline':True]['text':' 2 bytes per character ','line_number':1468,'multiline':True]['text':' set the roundtrip flag ','line_number':1473,'multiline':True]['text':' lengths are numbers of units, not bytes ','line_number':1482,'multiline':True]['text':' copy existing data and reroute the pointers ','line_number':1494,'multiline':True]['text':' indexes into stage 2 count from the bottom of the fromUnicodeTable ','line_number':1506,'multiline':True]['text':' reconstitute the initial part of stage 2 from the mbcsIndex ','line_number':1509,'multiline':True]['text':' each stage 2 block has 64 entries corresponding to 16 entries in the mbcsIndex ','line_number':1518,'multiline':True]['text':' an stage 2 entry's index is per stage 3 16-block, not per stage 3 entry ','line_number':1522,'multiline':True]['text':'
                         * 4 stage 2 entries point to 4 consecutive stage 3 16-blocks which are
                         * allocated together as a single 64-block for access from the mbcsIndex
                         ','line_number':1524,'multiline':True]['text':' no stage 3 block, skip ','line_number':1533,'multiline':True]['text':' no stage 2 block, skip ','line_number':1538,'multiline':True]['text':' reconstitute fromUnicodeBytes with roundtrips from toUnicode data ','line_number':1544,'multiline':True]['text':' MBCS setup functions ----------------------------------------------------- ','line_number':1548,'multiline':True]['text':' extension data, header version 4.2 and higher ','line_number':1579,'multiline':True]['text':' extension-only file, load the base table and set values appropriately ','line_number':1591,'multiline':True]['text':' extension-only file without extension ','line_number':1593,'multiline':True]['text':' an extension table must not be loaded as a base table ','line_number':1599,'multiline':True]['text':' load the base table ','line_number':1604,'multiline':True]['text':' forbid loading this same extension-only file ','line_number':1607,'multiline':True]['text':' TODO parse package name out of the prefix of the base name in the extension .cnv file? ','line_number':1612,'multiline':True]['text':'
             * Exit as soon as we know that we can load the converter
             * and the format is valid and supported.
             * The worst that can happen in the following code is a memory
             * allocation error.
             ','line_number':1632,'multiline':True]['text':' copy the base table data ','line_number':1642,'multiline':True]['text':' overwrite values with relevant ones for the extension converter ','line_number':1645,'multiline':True]['text':'
         * It would be possible to share the swapLFNL data with a base converter,
         * but the generated name would have to be different, and the memory
         * would have to be free'd only once.
         * It is easier to just create the data for the extension converter
         * separately when it is requested.
         ','line_number':1649,'multiline':True]['text':'
         * The reconstitutedData must be deleted only when the base converter
         * is unloaded.
         ','line_number':1660,'multiline':True]['text':'
         * Set a special, runtime-only outputType if the extension converter
         * is a DBCS version of a base converter that also maps single bytes.
         ','line_number':1666,'multiline':True]['text':' the base converter is SI/SO-stateful ','line_number':1675,'multiline':True]['text':' get the dbcs state from the state table entry for SO=0x0e ','line_number':1678,'multiline':True]['text':' non-stateful base converter, need to modify the state table ','line_number':1694,'multiline':True]['text':' allocate a new state table and copy the base state table contents ','line_number':1699,'multiline':True]['text':' change all final single-byte entries to go to a new all-illegal state ','line_number':1710,'multiline':True]['text':' build the new all-illegal state ','line_number':1718,'multiline':True]['text':'
         * unlike below for files with base tables, do not get the unicodeMask
         * from the sharedData; instead, use the base table's unicodeMask,
         * which we copied in the memcpy above;
         * this is necessary because the static data unicodeMask, especially
         * the UCNV_HAS_SUPPLEMENTARY flag, is part of the base table data
         ','line_number':1731,'multiline':True]['text':' conversion file with a base table; an additional extension table is optional ','line_number':1739,'multiline':True]['text':' make sure that the output type is known ','line_number':1740,'multiline':True]['text':' OK ','line_number':1749,'multiline':True]['text':'
             * Exit as soon as we know that we can load the converter
             * and the format is valid and supported.
             * The worst that can happen in the following code is a memory
             * allocation error.
             ','line_number':1756,'multiline':True]['text':'
         * converter versions 6.1 and up contain a unicodeMask that is
         * used here to select the most efficient function implementations
         ','line_number':1775,'multiline':True]['text':' mask off possible future extensions to be safe ','line_number':1782,'multiline':True]['text':' for older versions, assume worst case: contains anything possible (prevent over-optimizations) ','line_number':1785,'multiline':True]['text':'
         * _MBCSHeader.version 4.3 adds utf8Friendly data structures.
         * Check for the header version, SBCS vs. MBCS, and for whether the
         * data structures are optimized for code points as high as what the
         * runtime code is designed for.
         * The implementation does not handle mapping tables with entries for
         * unpaired surrogates.
         ','line_number':1789,'multiline':True]['text':'
                 * SBCS: Stage 3 is allocated in 64-entry blocks for U+0000..SBCS_FAST_MAX or higher.
                 * Build a table with indexes to each block, to be used instead of
                 * the regular stage 1/2 table.
                 ','line_number':1807,'multiline':True]['text':' set SBCS_FAST_MAX to reflect the reach of sbcsIndex[] even if header->version[2]>(SBCS_FAST_MAX>>8) ','line_number':1816,'multiline':True]['text':'
                 * MBCS: Stage 3 is allocated in 64-entry blocks for U+0000..MBCS_FAST_MAX or higher.
                 * The .cnv file is prebuilt with an additional stage table with indexes
                 * to each block.
                 ','line_number':1819,'multiline':True]['text':' calculate a bit set of 4 ASCII characters per bit that round-trip to ASCII bytes ','line_number':1831,'multiline':True]['text':' Set the impl pointer here so that it is set for both extension-only and base tables. ','line_number':1855,'multiline':True]['text':'
         * MBCS_OUTPUT_DBCS_ONLY: No SBCS mappings, therefore ASCII does not roundtrip.
         * MBCS_OUTPUT_2_SISO: Bypass the ASCII fastpath to handle prevLength correctly.
         ','line_number':1867,'multiline':True]['text':' the swaplfnl option does not apply, remove it ','line_number':1910,'multiline':True]['text':' do this because double-checked locking is broken ','line_number':1915,'multiline':True]['text':' something went wrong ','line_number':1925,'multiline':True]['text':' the option does not apply, remove it ','line_number':1928,'multiline':True]['text':' set a flag for GB 18030 mode, which changes the callback behavior ','line_number':1936,'multiline':True]['text':' set a flag for KEIS converter, which changes the SI/SO character sequence ','line_number':1940,'multiline':True]['text':' set a flag for JEF converter, which changes the SI/SO character sequence ','line_number':1943,'multiline':True]['text':' set a flag for JIPS converter, which changes the SI/SO character sequence ','line_number':1946,'multiline':True]['text':' fix maxBytesPerUChar depending on outputType and options etc. ','line_number':1950,'multiline':True]['text':' SO+DBCS ','line_number':1952,'multiline':True]['text':' SO + multiple DBCS ','line_number':1959,'multiline':True]['text':'
     * documentation of UConverter fields used for status
     * all of these fields are (re)set to 0 by ucnv_bld.c and ucnv_reset()
     ','line_number':1968,'multiline':True]['text':' toUnicode ','line_number':1973,'multiline':True]['text':' offset ','line_number':1974,'multiline':True]['text':' state ','line_number':1975,'multiline':True]['text':' byteIndex ','line_number':1976,'multiline':True]['text':' fromUnicode ','line_number':1978,'multiline':True]['text':' prevLength ','line_number':1980,'multiline':True]['text':' MBCS-to-Unicode conversion functions ------------------------------------- ','line_number':1993,'multiline':True]['text':' do a binary search for the fallback mapping ','line_number':2002,'multiline':True]['text':' did we really find it? ','line_number':2014,'multiline':True]['text':' This version of ucnv_MBCSToUnicodeWithOffsets() is optimized for single-byte, single-state codepages. ','line_number':2023,'multiline':True]['text':' set up the local pointers ','line_number':2041,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2055,'multiline':True]['text':' conversion loop ','line_number':2058,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one code unit that
         * overflows as a result of a surrogate pair or callback output
         * from the last source byte.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':2060,'multiline':True]['text':' target is full ','line_number':2069,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2075,'multiline':True]['text':' test the most common case first ','line_number':2077,'multiline':True]['text':' output BMP code point ','line_number':2079,'multiline':True]['text':' normal end of action codes: prepare for a new character ','line_number':2085,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2090,'multiline':True]['text':' output surrogate pair ','line_number':2099,'multiline':True]['text':' target overflow ','line_number':2111,'multiline':True]['text':' output BMP code point ','line_number':2122,'multiline':True]['text':' just fall through ','line_number':2132,'multiline':True]['text':' callback(illegal) ','line_number':2134,'multiline':True]['text':' reserved, must never occur ','line_number':2137,'multiline':True]['text':' callback(illegal) ','line_number':2143,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2145,'multiline':True]['text':' try an extension mapping ','line_number':2146,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2158,'multiline':True]['text':' write back the updated pointers ','line_number':2164,'multiline':True]['text':'
 * This version of ucnv_MBCSSingleToUnicodeWithOffsets() is optimized for single-byte, single-state codepages
 * that only map to and from the BMP.
 * In addition to single-byte optimizations, the offset calculations
 * become much easier.
 ','line_number':2170,'multiline':True]['text':' set up the local pointers ','line_number':2192,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2206,'multiline':True]['text':'
     * since the conversion here is 1:1 UChar:uint8_t, we need only one counter
     * for the minimum of the sourceLength and targetCapacity
     ','line_number':2210,'multiline':True]['text':' unrolling makes it faster on Pentium III/Windows 2000 ','line_number':2220,'multiline':True]['text':' unroll the loop with the most common case ','line_number':2221,'multiline':True]['text':' were all 16 entries really valid? ','line_number':2261,'multiline':True]['text':' no, return to the first of these 16 ','line_number':2263,'multiline':True]['text':' conversion loop ','line_number':2297,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2300,'multiline':True]['text':' test the most common case first ','line_number':2302,'multiline':True]['text':' output BMP code point ','line_number':2304,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2310,'multiline':True]['text':' output BMP code point ','line_number':2317,'multiline':True]['text':' just fall through ','line_number':2323,'multiline':True]['text':' callback(illegal) ','line_number':2325,'multiline':True]['text':' reserved, must never occur ','line_number':2328,'multiline':True]['text':' set offsets since the start or the last extension ','line_number':2332,'multiline':True]['text':' predecrement: do not set the offset for the callback-causing character ','line_number':2336,'multiline':True]['text':' offset and sourceIndex are now set for the current character ','line_number':2340,'multiline':True]['text':' callback(illegal) ','line_number':2344,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2346,'multiline':True]['text':' try an extension mapping ','line_number':2347,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2359,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':2363,'multiline':True]['text':' unrolling makes it faster on Pentium III/Windows 2000 ','line_number':2372,'multiline':True]['text':' target is full ','line_number':2378,'multiline':True]['text':' set offsets since the start or the last callback ','line_number':2382,'multiline':True]['text':' write back the updated pointers ','line_number':2391,'multiline':True]['text':' First test for final entries in this state for some commonly valid byte values. ','line_number':2401,'multiline':True]['text':' Then test for final entries in this state. ','line_number':2414,'multiline':True]['text':' Then recurse for transition entries. ','line_number':2423,'multiline':True]['text':'
 * Is byte b a single/lead byte in this state?
 * Recurse for transition states, because here we don't want to say that
 * b is a lead byte if all byte sequences that start with b are illegal.
 ','line_number':2435,'multiline':True]['text':' lead byte ','line_number':2444,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':2449,'multiline':True]['text':' use optimized function if possible ','line_number':2479,'multiline':True]['text':'
         * pass sourceIndex=-1 because we continue from an earlier buffer
         * in the future, this may change with continuous offsets
         ','line_number':2483,'multiline':True]['text':' set up the local pointers ','line_number':2503,'multiline':True]['text':' get the converter state from UConverter ','line_number':2517,'multiline':True]['text':'
     * if we are in the SBCS state for a DBCS-only converter,
     * then load the DBCS state from the MBCS data
     * (dbcsOnlyState==0 if it is not a DBCS-only converter)
     ','line_number':2522,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':2531,'multiline':True]['text':' conversion loop ','line_number':2535,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one code unit that
         * overflows as a result of a surrogate pair or callback output
         * from the last source byte.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':2537,'multiline':True]['text':' target is full ','line_number':2546,'multiline':True]['text':' optimized loop for 1/2-byte input and BMP output ','line_number':2552,'multiline':True]['text':' typically 0 ','line_number':2568,'multiline':True]['text':' set the state and leave the optimized loop ','line_number':2571,'multiline':True]['text':' output BMP code point ','line_number':2578,'multiline':True]['text':' typically 0 ','line_number':2581,'multiline':True]['text':' leave the optimized loop ','line_number':2583,'multiline':True]['text':' offsets!=NULL ','line_number':2588,'multiline':True]['text':' typically 0 ','line_number':2607,'multiline':True]['text':' set the state and leave the optimized loop ','line_number':2610,'multiline':True]['text':' output BMP code point ','line_number':2618,'multiline':True]['text':' typically 0 ','line_number':2625,'multiline':True]['text':' leave the optimized loop ','line_number':2627,'multiline':True]['text':'
             * these tests and break statements could be put inside the loop
             * if C had "break outerLoop" like Java
             ','line_number':2634,'multiline':True]['text':' target is full ','line_number':2642,'multiline':True]['text':' byteIndex>0 ','line_number':2649,'multiline':True]['text':' save the previous state for proper extension mapping with SI/SO-stateful converters ','line_number':2660,'multiline':True]['text':' set the next state early so that we can reuse the entry variable ','line_number':2663,'multiline':True]['text':' typically 0 ','line_number':2664,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2666,'multiline':True]['text':' output BMP code point ','line_number':2675,'multiline':True]['text':' output fallback BMP code point ','line_number':2683,'multiline':True]['text':' callback(illegal) ','line_number':2691,'multiline':True]['text':' output BMP code point ','line_number':2695,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':2705,'multiline':True]['text':' output roundtrip or fallback surrogate pair ','line_number':2712,'multiline':True]['text':' target overflow ','line_number':2724,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':2733,'multiline':True]['text':' callback(illegal) ','line_number':2740,'multiline':True]['text':' output surrogate pair ','line_number':2747,'multiline':True]['text':' target overflow ','line_number':2760,'multiline':True]['text':'
             * This serves as a state change without any output.
             * It is useful for reading simple stateful encodings,
             * for example using just Shift-In/Shift-Out codes.
             * The 21 unused bits may later be used for more sophisticated
             * state transitions.
             ','line_number':2769,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':2779,'multiline':True]['text':' restore the previous state ','line_number':2780,'multiline':True]['text':' callback(illegal) ','line_number':2782,'multiline':True]['text':' output BMP code point ','line_number':2787,'multiline':True]['text':' just fall through ','line_number':2795,'multiline':True]['text':' callback(illegal) ','line_number':2797,'multiline':True]['text':' reserved, must never occur ','line_number':2800,'multiline':True]['text':' end of action codes: prepare for a new character ','line_number':2804,'multiline':True]['text':' callback(illegal) ','line_number':2810,'multiline':True]['text':'
                 * Ticket 5691: consistent illegal sequences:
                 * - We include at least the first byte in the illegal sequence.
                 * - If any of the non-initial bytes could be the start of a character,
                 *   we stop the illegal sequence before the first one of those.
                 ','line_number':2812,'multiline':True]['text':' Back out some bytes. ','line_number':2824,'multiline':True]['text':' length of reported illegal byte sequence ','line_number':2827,'multiline':True]['text':' Back out bytes from the previous buffer: Need to replay them. ','line_number':2831,'multiline':True]['text':' preToULength is negative! ','line_number':2833,'multiline':True]['text':' unassigned sequences indicated with byteIndex>0 ','line_number':2840,'multiline':True]['text':' try an extension mapping ','line_number':2841,'multiline':True]['text':' not mappable or buffer overflow ','line_number':2852,'multiline':True]['text':' set the converter state back into UConverter ','line_number':2858,'multiline':True]['text':' write back the updated pointers ','line_number':2863,'multiline':True]['text':'
 * This version of ucnv_MBCSGetNextUChar() is optimized for single-byte, single-state codepages.
 * We still need a conversion loop in case we find reserved action codes, which are to be ignored.
 ','line_number':2869,'multiline':True]['text':' set up the local pointers ','line_number':2883,'multiline':True]['text':' conversion loop ','line_number':2893,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':2896,'multiline':True]['text':' write back the updated pointer early so that we can return directly ','line_number':2898,'multiline':True]['text':' output BMP code point ','line_number':2902,'multiline':True]['text':'
         * An if-else-if chain provides more reliable performance for
         * the most common cases compared to a switch.
         ','line_number':2906,'multiline':True]['text':' output supplementary code point ','line_number':2914,'multiline':True]['text':' output BMP code point ','line_number':2918,'multiline':True]['text':' just fall through ','line_number':2922,'multiline':True]['text':' callback(illegal) ','line_number':2924,'multiline':True]['text':' reserved, must never occur ','line_number':2927,'multiline':True]['text':' callback(illegal) ','line_number':2932,'multiline':True]['text':' unassigned sequence ','line_number':2934,'multiline':True]['text':' defer to the generic implementation ','line_number':2935,'multiline':True]['text':' no output because of empty input or only state changes ','line_number':2941,'multiline':True]['text':'
 * Version of _MBCSToUnicodeWithOffsets() optimized for single-character
 * conversion without offset handling.
 *
 * When a character does not have a mapping to Unicode, then we return to the
 * generic ucnv_getNextUChar() code for extension/GB 18030 and error/callback
 * handling.
 * We also defer to the generic code in other complicated cases and have them
 * ultimately handled by _MBCSToUnicodeWithOffsets() itself.
 *
 * All normal mappings and errors are handled here.
 ','line_number':2946,'multiline':True]['text':' use optimized function if possible ','line_number':2974,'multiline':True]['text':' use the generic code in ucnv_getNextUChar() to continue with a partial match ','line_number':2978,'multiline':True]['text':'
         * Using the generic ucnv_getNextUChar() code lets us deal correctly
         * with the rare case of a codepage that maps single surrogates
         * without adding the complexity to this already complicated function here.
         ','line_number':2983,'multiline':True]['text':' set up the local pointers ','line_number':2993,'multiline':True]['text':' get the converter state from UConverter ','line_number':3004,'multiline':True]['text':'
     * if we are in the SBCS state for a DBCS-only converter,
     * then load the DBCS state from the MBCS data
     * (dbcsOnlyState==0 if it is not a DBCS-only converter)
     ','line_number':3007,'multiline':True]['text':' conversion loop ','line_number':3016,'multiline':True]['text':' optimization for 1/2-byte input and BMP output ','line_number':3024,'multiline':True]['text':' typically 0 ','line_number':3031,'multiline':True]['text':' output BMP code point ','line_number':3032,'multiline':True]['text':' save the previous state for proper extension mapping with SI/SO-stateful converters ','line_number':3036,'multiline':True]['text':' set the next state early so that we can reuse the entry variable ','line_number':3039,'multiline':True]['text':' typically 0 ','line_number':3040,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':3042,'multiline':True]['text':' output BMP code point ','line_number':3048,'multiline':True]['text':' output BMP code point ','line_number':3055,'multiline':True]['text':' callback(illegal) ','line_number':3062,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':3069,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':3072,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':3076,'multiline':True]['text':' callback(illegal) ','line_number':3080,'multiline':True]['text':' output supplementary code point ','line_number':3086,'multiline':True]['text':'
                 * This serves as a state change without any output.
                 * It is useful for reading simple stateful encodings,
                 * for example using just Shift-In/Shift-Out codes.
                 * The 21 unused bits may later be used for more sophisticated
                 * state transitions.
                 ','line_number':3090,'multiline':True]['text':' SI/SO are illegal for DBCS-only conversion ','line_number':3098,'multiline':True]['text':' restore the previous state ','line_number':3099,'multiline':True]['text':' callback(illegal) ','line_number':3101,'multiline':True]['text':' output BMP code point ','line_number':3106,'multiline':True]['text':' just fall through ','line_number':3111,'multiline':True]['text':' callback(illegal) ','line_number':3113,'multiline':True]['text':' reserved (must never occur), or only state change ','line_number':3116,'multiline':True]['text':' end of action codes: prepare for a new character ','line_number':3122,'multiline':True]['text':' callback(illegal) ','line_number':3126,'multiline':True]['text':' unassigned sequence ','line_number':3128,'multiline':True]['text':' defer to the generic implementation ','line_number':3129,'multiline':True]['text':' incomplete character byte sequence ','line_number':3140,'multiline':True]['text':' callback(illegal) ','line_number':3148,'multiline':True]['text':'
             * Ticket 5691: consistent illegal sequences:
             * - We include at least the first byte in the illegal sequence.
             * - If any of the non-initial bytes could be the start of a character,
             *   we stop the illegal sequence before the first one of those.
             ','line_number':3149,'multiline':True]['text':' first byte ','line_number':3157,'multiline':True]['text':' lastSource<source: multi-byte character ','line_number':3160,'multiline':True]['text':' no output because of empty input or only state changes ','line_number':3172,'multiline':True]['text':' set the converter state back into UConverter, ready for a new character ','line_number':3178,'multiline':True]['text':' write back the updated pointer ','line_number':3182,'multiline':True]['text':'
 * Code disabled 2002dec09 (ICU 2.4) because it is not currently used in ICU. markus
 * Removal improves code coverage.
 ','line_number':3188,'multiline':True]['text':'*
 * This version of ucnv_MBCSSimpleGetNextUChar() is optimized for single-byte, single-state codepages.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It does not handle conversion extensions (_extToU()).
 ','line_number':3192,'multiline':True]['text':' MBCS_ENTRY_IS_FINAL(entry) ','line_number':3204,'multiline':True]['text':' output BMP code point ','line_number':3207,'multiline':True]['text':'
     * An if-else-if chain provides more reliable performance for
     * the most common cases compared to a switch.
     ','line_number':3211,'multiline':True]['text':' output supplementary code point ','line_number':3217,'multiline':True]['text':' output BMP code point ','line_number':3223,'multiline':True]['text':' output supplementary code point ','line_number':3229,'multiline':True]['text':' reserved, must never occur ','line_number':3236,'multiline':True]['text':'
 * This is a simple version of _MBCSGetNextUChar() that is used
 * by other converter implementations.
 * It only returns an "assigned" result if it consumes the entire input.
 * It does not use state from the converter, nor error codes.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It handles conversion extensions but not GB 18030.
 *
 * Return value:
 * U+fffe   unassigned
 * U+ffff   illegal
 * otherwise the Unicode code point
 ','line_number':3242,'multiline':True]['text':' no input at all: "illegal" ','line_number':3269,'multiline':True]['text':'
 * Code disabled 2002dec09 (ICU 2.4) because it is not currently used in ICU. markus
 * TODO In future releases, verify that this function is never called for SBCS
 * conversions, i.e., that sharedData->mbcs.countStates==1 is still true.
 * Removal improves code coverage.
 ','line_number':3274,'multiline':True]['text':' use optimized function if possible ','line_number':3280,'multiline':True]['text':' illegal: more than a single byte for an SBCS converter ','line_number':3285,'multiline':True]['text':' set up the local pointers ','line_number':3290,'multiline':True]['text':' converter state ','line_number':3294,'multiline':True]['text':' conversion loop ','line_number':3298,'multiline':True]['text':' truncated character ','line_number':3306,'multiline':True]['text':'
             * An if-else-if chain provides more reliable performance for
             * the most common cases compared to a switch.
             ','line_number':3309,'multiline':True]['text':' done ','line_number':3318,'multiline':True]['text':' else done with 0xfffe ','line_number':3321,'multiline':True]['text':' output BMP code point ','line_number':3325,'multiline':True]['text':' output BMP code point below 0xd800 ','line_number':3332,'multiline':True]['text':' output roundtrip or fallback supplementary code point ','line_number':3334,'multiline':True]['text':' output roundtrip BMP code point above 0xd800 or fallback BMP code point ','line_number':3337,'multiline':True]['text':' output supplementary code point ','line_number':3346,'multiline':True]['text':' output BMP code point ','line_number':3354,'multiline':True]['text':' output supplementary code point ','line_number':3362,'multiline':True]['text':'
             * forbid MBCS_STATE_CHANGE_ONLY for this function,
             * and MBCS_STATE_ILLEGAL and reserved action codes
             ','line_number':3370,'multiline':True]['text':' illegal for this function: not all input consumed ','line_number':3379,'multiline':True]['text':' try an extension mapping ','line_number':3384,'multiline':True]['text':' MBCS-from-Unicode conversion functions ----------------------------------- ','line_number':3394,'multiline':True]['text':' This version of ucnv_MBCSFromUnicodeWithOffsets() is optimized for double-byte codepages. ','line_number':3396,'multiline':True]['text':' use optimized function if possible ','line_number':3419,'multiline':True]['text':' set up the local pointers ','line_number':3423,'multiline':True]['text':' get the converter state from UConverter ','line_number':3439,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3442,'multiline':True]['text':' conversion loop ','line_number':3446,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':3452,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':3461,'multiline':True]['text':'
             * utf8Friendly table: Test for <=0xd7ff rather than <=MBCS_FAST_MAX
             * to avoid dealing with surrogates.
             * MBCS_FAST_MAX must be >=0xd7ff.
             ','line_number':3478,'multiline':True]['text':' There are only roundtrips (!=0) and no-mapping (==0) entries. ','line_number':3485,'multiline':True]['text':' output the value ','line_number':3489,'multiline':True]['text':'
                 * This also tests if the codepage maps single surrogates.
                 * If it does, then surrogates are not paired but mapped separately.
                 * Note that in this case unmatched surrogates are not detected.
                 ','line_number':3491,'multiline':True]['text':' test the following code unit ','line_number':3500,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':3507,'multiline':True]['text':' callback(unassigned) ','line_number':3508,'multiline':True]['text':' convert this supplementary code point ','line_number':3511,'multiline':True]['text':' exit this condition tree ','line_number':3512,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3514,'multiline':True]['text':' callback(illegal) ','line_number':3515,'multiline':True]['text':' no more input ','line_number':3520,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3524,'multiline':True]['text':' callback(illegal) ','line_number':3525,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3531,'multiline':True]['text':' get the bytes and the length for the output ','line_number':3534,'multiline':True]['text':' MBCS_OUTPUT_2 ','line_number':3535,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3538,'multiline':True]['text':'
                     * We allow a 0 byte output if the "assigned" bit is set for this entry.
                     * There is no way with this data structure for fallback output
                     * to be a zero byte.
                     ','line_number':3542,'multiline':True]['text':' try an extension mapping ','line_number':3549,'multiline':True]['text':' not mappable or buffer overflow ','line_number':3560,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':3563,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':3565,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3568,'multiline':True]['text':' write the output character bytes from value and length ','line_number':3575,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':3576,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3578,'multiline':True]['text':' length==2 ','line_number':3584,'multiline':True]['text':' target overflow ','line_number':3600,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3608,'multiline':True]['text':' target is full ','line_number':3613,'multiline':True]['text':' set the converter state back into UConverter ','line_number':3619,'multiline':True]['text':' write back the updated pointers ','line_number':3622,'multiline':True]['text':' This version of ucnv_MBCSFromUnicodeWithOffsets() is optimized for single-byte codepages. ','line_number':3628,'multiline':True]['text':' set up the local pointers ','line_number':3648,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':3664,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':3667,'multiline':True]['text':' get the converter state from UConverter ','line_number':3672,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3675,'multiline':True]['text':' conversion loop ','line_number':3679,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':3685,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':3694,'multiline':True]['text':' test the following code unit ','line_number':3705,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':3712,'multiline':True]['text':' callback(unassigned) ','line_number':3713,'multiline':True]['text':' convert this supplementary code point ','line_number':3716,'multiline':True]['text':' exit this condition tree ','line_number':3717,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3719,'multiline':True]['text':' callback(illegal) ','line_number':3720,'multiline':True]['text':' no more input ','line_number':3725,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3729,'multiline':True]['text':' callback(illegal) ','line_number':3730,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3736,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3739,'multiline':True]['text':' assigned, write the output character bytes from value and length ','line_number':3741,'multiline':True]['text':' length==1 ','line_number':3742,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3743,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3750,'multiline':True]['text':' unassigned ','line_number':3753,'multiline':True]['text':' try an extension mapping ','line_number':3755,'multiline':True]['text':' not mappable or buffer overflow ','line_number':3766,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':3769,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':3771,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3774,'multiline':True]['text':' target is full ','line_number':3779,'multiline':True]['text':' set the converter state back into UConverter ','line_number':3785,'multiline':True]['text':' write back the updated pointers ','line_number':3788,'multiline':True]['text':'
 * This version of ucnv_MBCSFromUnicode() is optimized for single-byte codepages
 * that map only to and from the BMP.
 * In addition to single-byte/state optimizations, the offset calculations
 * become much easier.
 * It would be possible to use the sbcsIndex for UTF-8-friendly tables,
 * but measurements have shown that this diminishes performance
 * in more cases than it improves it.
 * See SVN revision 21013 (2007-feb-06) for the last version with #if switches
 * for various MBCS and SBCS optimizations.
 ','line_number':3794,'multiline':True]['text':' set up the local pointers ','line_number':3824,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':3841,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':3844,'multiline':True]['text':' get the converter state from UConverter ','line_number':3848,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':3851,'multiline':True]['text':'
     * since the conversion here is 1:1 UChar:uint8_t, we need only one counter
     * for the minimum of the sourceLength and targetCapacity
     ','line_number':3855,'multiline':True]['text':' conversion loop ','line_number':3864,'multiline':True]['text':' unrolling makes it slower on Pentium III/Windows 2000?! ','line_number':3870,'multiline':True]['text':' unroll the loop with the most common case ','line_number':3871,'multiline':True]['text':' were all 4 entries really valid? ','line_number':3892,'multiline':True]['text':' no, return to the first of these 4 ','line_number':3894,'multiline':True]['text':'
         * Get a correct Unicode code point:
         * a single UChar for a BMP code point or
         * a matched surrogate pair for a "supplementary code point".
         ','line_number':3919,'multiline':True]['text':'
         * Do not immediately check for single surrogates:
         * Assume that they are unassigned and check for them in that case.
         * This speeds up the conversion of assigned characters.
         ','line_number':3925,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':3930,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':3938,'multiline':True]['text':' assigned, write the output character bytes from value and length ','line_number':3940,'multiline':True]['text':' length==1 ','line_number':3941,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':3942,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':3946,'multiline':True]['text':' normal, unassigned BMP character ','line_number':3950,'multiline':True]['text':' test the following code unit ','line_number':3954,'multiline':True]['text':' this codepage does not map supplementary code points ','line_number':3959,'multiline':True]['text':' callback(unassigned) ','line_number':3960,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':3962,'multiline':True]['text':' callback(illegal) ','line_number':3963,'multiline':True]['text':' no more input ','line_number':3968,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':3975,'multiline':True]['text':' callback(illegal) ','line_number':3976,'multiline':True]['text':' c does not have a mapping ','line_number':3981,'multiline':True]['text':' get the number of code units for c to correctly advance sourceIndex ','line_number':3983,'multiline':True]['text':' set offsets since the start or the last extension ','line_number':3986,'multiline':True]['text':' do not set the offset for this character ','line_number':3990,'multiline':True]['text':' offsets and sourceIndex are now set for the current character ','line_number':3997,'multiline':True]['text':' try an extension mapping ','line_number':4000,'multiline':True]['text':' not mappable or buffer overflow ','line_number':4012,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':4015,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':4017,'multiline':True]['text':' unrolling makes it slower on Pentium III/Windows 2000?! ','line_number':4026,'multiline':True]['text':' target is full ','line_number':4032,'multiline':True]['text':' set offsets since the start or the last callback ','line_number':4036,'multiline':True]['text':'
            Caller gave us a partial supplementary character,
            which this function couldn't convert in any case.
            The callback will handle the offset.
            ','line_number':4040,'multiline':True]['text':' set the converter state back into UConverter ','line_number':4053,'multiline':True]['text':' write back the updated pointers ','line_number':4056,'multiline':True]['text':' Shift-In and Shift-Out byte sequences differ by encoding scheme. ','line_number':4083,'multiline':True]['text':'
         * pass sourceIndex=-1 because we continue from an earlier buffer
         * in the future, this may change with continuous offsets
         ','line_number':4093,'multiline':True]['text':' use optimized function if possible ','line_number':4104,'multiline':True]['text':' set up the local pointers ','line_number':4119,'multiline':True]['text':' get the converter state from UConverter ','line_number':4139,'multiline':True]['text':' set the real value ','line_number':4145,'multiline':True]['text':' prevent fromUnicodeStatus from being set to something non-0 ','line_number':4149,'multiline':True]['text':' sourceIndex=-1 if the current character began in the previous buffer ','line_number':4153,'multiline':True]['text':' Get the SI/SO character for the converter ','line_number':4158,'multiline':True]['text':' conversion loop ','line_number':4162,'multiline':True]['text':'
     * This is another piece of ugly code:
     * A goto into the loop if the converter state contains a first surrogate
     * from the previous function call.
     * It saves me to check in each loop iteration a check of if(c==0)
     * and duplicating the trail-surrogate-handling code in the else
     * branch of that check.
     * I could not find any other way to get around this other than
     * using a function call for the conversion and callback, which would
     * be even more inefficient.
     *
     * Markus Scherer 2000-jul-19
     ','line_number':4163,'multiline':True]['text':'
         * This following test is to see if available input would overflow the output.
         * It does not catch output of more than one byte that
         * overflows as a result of a multi-byte character or callback output
         * from the last source character.
         * Therefore, those situations also test for overflows and will
         * then break the loop, too.
         ','line_number':4181,'multiline':True]['text':'
             * Get a correct Unicode code point:
             * a single UChar for a BMP code point or
             * a matched surrogate pair for a "supplementary code point".
             ','line_number':4190,'multiline':True]['text':'
             * utf8Friendly table: Test for <=0xd7ff rather than <=MBCS_FAST_MAX
             * to avoid dealing with surrogates.
             * MBCS_FAST_MAX must be >=0xd7ff.
             ','line_number':4208,'multiline':True]['text':' get the bytes and the length for the output (copied from below and adapted for utf8Friendly data) ','line_number':4216,'multiline':True]['text':' There are only roundtrips (!=0) and no-mapping (==0) entries. ','line_number':4217,'multiline':True]['text':' 1/2-byte stateful with Shift-In/Shift-Out ','line_number':4232,'multiline':True]['text':'
                     * Save the old state in the converter object
                     * right here, then change the local prevLength state variable if necessary.
                     * Then, if this character turns out to be unassigned or a fallback that
                     * is not taken, the callback code must not save the new state in the converter
                     * because the new state is for a character that is not output.
                     * However, the callback must still restore the state from the converter
                     * in case the callback function changed it for its output.
                     ','line_number':4233,'multiline':True]['text':' save the old state ','line_number':4242,'multiline':True]['text':' change from double-byte mode to single-byte ','line_number':4250,'multiline':True]['text':' change from single-byte mode to double-byte ','line_number':4265,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4279,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4282,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4321,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4341,'multiline':True]['text':' must not occur ','line_number':4361,'multiline':True]['text':'
                     * To avoid compiler warnings that value & length may be
                     * used without having been initialized, we set them here.
                     * In reality, this is unreachable code.
                     * Not having a default branch also causes warnings with
                     * some compilers.
                     ','line_number':4362,'multiline':True]['text':' output the value ','line_number':4373,'multiline':True]['text':'
                 * This also tests if the codepage maps single surrogates.
                 * If it does, then surrogates are not paired but mapped separately.
                 * Note that in this case unmatched surrogates are not detected.
                 ','line_number':4375,'multiline':True]['text':' test the following code unit ','line_number':4384,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4391,'multiline':True]['text':' save the old state ','line_number':4392,'multiline':True]['text':' callback(unassigned) ','line_number':4393,'multiline':True]['text':' convert this supplementary code point ','line_number':4396,'multiline':True]['text':' exit this condition tree ','line_number':4397,'multiline':True]['text':' this is an unmatched lead code unit (1st surrogate) ','line_number':4399,'multiline':True]['text':' callback(illegal) ','line_number':4400,'multiline':True]['text':' no more input ','line_number':4405,'multiline':True]['text':' this is an unmatched trail code unit (2nd surrogate) ','line_number':4409,'multiline':True]['text':' callback(illegal) ','line_number':4410,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes ','line_number':4416,'multiline':True]['text':'
                 * The basic lookup is a triple-stage compact array (trie) lookup.
                 * For details see the beginning of this file.
                 *
                 * Single-byte codepages are handled with a different data structure
                 * by _MBCSSingle... functions.
                 *
                 * The result consists of a 32-bit value from stage 2 and
                 * a pointer to as many bytes as are stored per character.
                 * The pointer points to the character's bytes in stage 3.
                 * Bits 15..0 of the stage 2 entry contain the stage 3 index
                 * for that pointer, while bits 31..16 are flags for which of
                 * the 16 characters in the block are roundtrip-assigned.
                 *
                 * For 2-byte and 4-byte codepages, the bytes are stored as uint16_t
                 * respectively as uint32_t, in the platform encoding.
                 * For 3-byte codepages, the bytes are always stored in big-endian order.
                 *
                 * For EUC encodings that use only either 0x8e or 0x8f as the first
                 * byte of their longest byte sequences, the first two bytes in
                 * this third stage indicate with their 7th bits whether these bytes
                 * are to be written directly or actually need to be preceeded by
                 * one of the two Single-Shift codes. With this, the third stage
                 * stores one byte fewer per character than the actual maximum length of
                 * EUC byte sequences.
                 *
                 * Other than that, leading zero bytes are removed and the other
                 * bytes output. A single zero byte may be output if the "assigned"
                 * bit in stage 2 was on.
                 * The data structure does not support zero byte output as a fallback,
                 * and also does not allow output of leading zeros.
                 ','line_number':4418,'multiline':True]['text':' get the bytes and the length for the output ','line_number':4452,'multiline':True]['text':' 1/2-byte stateful with Shift-In/Shift-Out ','line_number':4463,'multiline':True]['text':'
                     * Save the old state in the converter object
                     * right here, then change the local prevLength state variable if necessary.
                     * Then, if this character turns out to be unassigned or a fallback that
                     * is not taken, the callback code must not save the new state in the converter
                     * because the new state is for a character that is not output.
                     * However, the callback must still restore the state from the converter
                     * in case the callback function changed it for its output.
                     ','line_number':4464,'multiline':True]['text':' save the old state ','line_number':4473,'multiline':True]['text':' no mapping, leave value==0 ','line_number':4477,'multiline':True]['text':' change from double-byte mode to single-byte ','line_number':4482,'multiline':True]['text':' change from single-byte mode to double-byte ','line_number':4497,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4511,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4514,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4515,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4546,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4562,'multiline':True]['text':' must not occur ','line_number':4578,'multiline':True]['text':'
                     * To avoid compiler warnings that value & length may be
                     * used without having been initialized, we set them here.
                     * In reality, this is unreachable code.
                     * Not having a default branch also causes warnings with
                     * some compilers.
                     ','line_number':4579,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4586,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4591,'multiline':True]['text':'
                     * We allow a 0 byte output if the "assigned" bit is set for this entry.
                     * There is no way with this data structure for fallback output
                     * to be a zero byte.
                     ','line_number':4595,'multiline':True]['text':' try an extension mapping ','line_number':4602,'multiline':True]['text':' restore SISO state ','line_number':4611,'multiline':True]['text':' not mappable or buffer overflow ','line_number':4614,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':4617,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':4619,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':4622,'multiline':True]['text':' write the output character bytes from value and length ','line_number':4632,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':4633,'multiline':True]['text':' each branch falls through to the next one ','line_number':4637,'multiline':True]['text':' will never occur ','line_number':4651,'multiline':True]['text':' each branch falls through to the next one ','line_number':4656,'multiline':True]['text':' will never occur ','line_number':4674,'multiline':True]['text':'
                 * We actually do this backwards here:
                 * In order to save an intermediate variable, we output
                 * first to the overflow buffer what does not fit into the
                 * regular target.
                 ','line_number':4682,'multiline':True]['text':' we know that 1<=targetCapacity<length<=4 ','line_number':4688,'multiline':True]['text':' each branch falls through to the next one ','line_number':4692,'multiline':True]['text':' will never occur ','line_number':4703,'multiline':True]['text':' now output what fits into the regular target ','line_number':4708,'multiline':True]['text':' length was reduced by targetCapacity ','line_number':4709,'multiline':True]['text':' each branch falls through to the next one ','line_number':4711,'multiline':True]['text':' will never occur ','line_number':4731,'multiline':True]['text':' target overflow ','line_number':4735,'multiline':True]['text':' normal end of conversion: prepare for a new character ','line_number':4742,'multiline':True]['text':' target is full ','line_number':4750,'multiline':True]['text':'
     * the end of the input stream and detection of truncated input
     * are handled by the framework, but for EBCDIC_STATEFUL conversion
     * we need to emit an SI at the very end
     *
     * conditions:
     *   successful
     *   EBCDIC_STATEFUL in DBCS mode
     *   end of input and no truncated input
     ','line_number':4756,'multiline':True]['text':' EBCDIC_STATEFUL ending with DBCS: emit an SI to return the output stream to SBCS ','line_number':4770,'multiline':True]['text':' set the last source character's index (sourceIndex points at sourceLimit now) ','line_number':4783,'multiline':True]['text':' target is full ','line_number':4787,'multiline':True]['text':' we switched into SBCS ','line_number':4795,'multiline':True]['text':' set the converter state back into UConverter ','line_number':4798,'multiline':True]['text':' write back the updated pointers ','line_number':4802,'multiline':True]['text':'
 * This is another simple conversion function for internal use by other
 * conversion implementations.
 * It does not use the converter state nor call callbacks.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It handles conversion extensions but not GB 18030.
 *
 * It converts one single Unicode code point into codepage bytes, encoded
 * as one 32-bit value. The function returns the number of bytes in *pValue:
 * 1..4 the number of bytes in *pValue
 * 0    unassigned (*pValue undefined)
 * -1   illegal (currently not used, *pValue undefined)
 *
 * *pValue will contain the resulting bytes with the last byte in bits 7..0,
 * the second to last byte in bits 15..8, etc.
 * Currently, the function assumes but does not check that 0<=c<=0x10ffff.
 ','line_number':4808,'multiline':True]['text':' #if 0 because this is not currently used in ICU - reduce code, increase code coverage ','line_number':4832,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4839,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes (same as in _MBCSFromUnicodeWithOffsets) ','line_number':4843,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4846,'multiline':True]['text':' outputType!=MBCS_OUTPUT_1 ','line_number':4851,'multiline':True]['text':' get the bytes and the length for the output ','line_number':4854,'multiline':True]['text':' #if 0 because this is not currently used in ICU - reduce code, increase code coverage ','line_number':4865,'multiline':True]['text':' table with single-byte results, but only DBCS mappings used ','line_number':4867,'multiline':True]['text':' no mapping or SBCS result, not taken for DBCS-only ','line_number':4870,'multiline':True]['text':' stage2Entry=0 to reset roundtrip flags ','line_number':4871,'multiline':True]['text':' EUC 16-bit fixed-length representation ','line_number':4902,'multiline':True]['text':' EUC 16-bit fixed-length representation applied to the first two bytes ','line_number':4918,'multiline':True]['text':' must not occur ','line_number':4935,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4939,'multiline':True]['text':'
                 * We allow a 0 byte output if the "assigned" bit is set for this entry.
                 * There is no way with this data structure for fallback output
                 * to be a zero byte.
                 ','line_number':4943,'multiline':True]['text':' assigned ','line_number':4948,'multiline':True]['text':' return abs(length); ','line_number':4958,'multiline':True]['text':' unassigned ','line_number':4961,'multiline':True]['text':'
 * This function has been moved to ucnv2022.c for inlining.
 * This implementation is here only for documentation purposes
 ','line_number':4967,'multiline':True]['text':'*
 * This version of ucnv_MBCSFromUChar32() is optimized for single-byte codepages.
 * It does not handle the EBCDIC swaplfnl option (set in UConverter).
 * It does not handle conversion extensions (_extFromU()).
 *
 * It returns the codepage byte for the code point, or -1 if it is unassigned.
 ','line_number':4972,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':4986,'multiline':True]['text':' convert the Unicode code point in c into codepage bytes (same as in _MBCSFromUnicodeWithOffsets) ','line_number':4991,'multiline':True]['text':' get the byte for the output ','line_number':4994,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':4996,'multiline':True]['text':' MBCS-from-UTF-8 conversion functions ------------------------------------- ','line_number':5005,'multiline':True]['text':' minimum code point values for n-byte UTF-8 sequences, n=0..4 ','line_number':5007,'multiline':True]['text':' offsets for n-byte UTF-8 sequences that were calculated with ((lead<<6)+trail)<<6+trail... ','line_number':5011,'multiline':True]['text':' set up the local pointers ','line_number':5036,'multiline':True]['text':' use all roundtrip and fallback results ','line_number':5054,'multiline':True]['text':' use only roundtrips and fallbacks from private-use characters ','line_number':5057,'multiline':True]['text':' get the converter state from the UTF-8 UConverter ','line_number':5062,'multiline':True]['text':'
     * Make sure that the last byte sequence before sourceLimit is complete
     * or runs into a lead byte.
     * Do not go back into the bytes that will be read for finishing a partial
     * sequence from the previous buffer.
     * In the conversion loop compare source with sourceLimit only once
     * per multi-byte character.
     ','line_number':5071,'multiline':True]['text':' exit the conversion loop before the lead byte if there are not enough trail bytes for it ','line_number':5089,'multiline':True]['text':'
         * Note: We could avoid the goto by duplicating some of the moreBytes
         * code, but only up to the point of collecting a complete UTF-8
         * sequence; then recurse for the toUBytes[toULength]
         * and then continue with normal conversion.
         *
         * If so, move this code to just after initializing the minimum
         * set of local variables for reading the UTF-8 input
         * (utf8, source, target, limits but not cnv, table, minValue, etc.).
         *
         * Potential advantages:
         * - avoid the goto
         * - oldToULength could become a local variable in just those code blocks
         *   that deal with buffer boundaries
         * - possibly faster if the goto prevents some compiler optimizations
         *   (this would need measuring to confirm)
         * Disadvantage:
         * - code duplication
         ','line_number':5101,'multiline':True]['text':' conversion loop ','line_number':5122,'multiline':True]['text':' convert ASCII ','line_number':5127,'multiline':True]['text':' handle U+0080..U+07FF inline ','line_number':5138,'multiline':True]['text':' handle U+0800..U+0FFF inline ','line_number':5156,'multiline':True]['text':' handle "complicated" and error cases, and continuing partial characters ','line_number':5178,'multiline':True]['text':'
                         * The sourceLimit may have been adjusted before the conversion loop
                         * to stop before a truncated sequence.
                         * Here we need to use the real limit in case we have two truncated
                         * sequences at the end.
                         * See ticket #7492.
                         ','line_number':5185,'multiline':True]['text':' sequence too short, stop with toULength<toULimit ','line_number':5199,'multiline':True]['text':' store the partial UTF-8 character, compatible with the regular UTF-8 converter ','line_number':5202,'multiline':True]['text':' consumed all trail bytes ','line_number':5216,'multiline':True]['text':' BMP ','line_number':5217,'multiline':True]['text':' not a surrogate ','line_number':5219,'multiline':True]['text':' supplementary code point ','line_number':5226,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':5228,'multiline':True]['text':' error handling: illegal UTF-8 byte sequence ','line_number':5234,'multiline':True]['text':' output the mapping for c ','line_number':5249,'multiline':True]['text':' value<minValue means c is unassigned (unmappable) ','line_number':5253,'multiline':True]['text':'
                 * Try an extension mapping.
                 * Pass in no source because we don't have UTF-16 input.
                 * If we have a partial match on c, we will return and revert
                 * to UTF-8->UTF-16->charset conversion.
                 ','line_number':5254,'multiline':True]['text':' not mappable or buffer overflow ','line_number':5270,'multiline':True]['text':'
                     * Partial match, return and revert to pivoting.
                     * In normal from-UTF-16 conversion, we would just continue
                     * but then exit the loop because the extension match would
                     * have consumed the source.
                     ','line_number':5274,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':5283,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':5285,'multiline':True]['text':' target is full ','line_number':5290,'multiline':True]['text':'
     * The sourceLimit may have been adjusted before the conversion loop
     * to stop before a truncated sequence.
     * If so, then collect the truncated sequence now.
     ','line_number':5296,'multiline':True]['text':' write back the updated pointers ','line_number':5316,'multiline':True]['text':' set up the local pointers ','line_number':5343,'multiline':True]['text':' get the converter state from the UTF-8 UConverter ','line_number':5362,'multiline':True]['text':'
     * Make sure that the last byte sequence before sourceLimit is complete
     * or runs into a lead byte.
     * Do not go back into the bytes that will be read for finishing a partial
     * sequence from the previous buffer.
     * In the conversion loop compare source with sourceLimit only once
     * per multi-byte character.
     ','line_number':5371,'multiline':True]['text':' exit the conversion loop before the lead byte if there are not enough trail bytes for it ','line_number':5389,'multiline':True]['text':' See note in ucnv_SBCSFromUTF8() about this goto. ','line_number':5401,'multiline':True]['text':' conversion loop ','line_number':5404,'multiline':True]['text':' convert ASCII ','line_number':5409,'multiline':True]['text':' handle U+1000..U+D7FF inline ','line_number':5423,'multiline':True]['text':' handle U+0080..U+07FF inline ','line_number':5439,'multiline':True]['text':' handle "complicated" and error cases, and continuing partial characters ','line_number':5458,'multiline':True]['text':'
                         * The sourceLimit may have been adjusted before the conversion loop
                         * to stop before a truncated sequence.
                         * Here we need to use the real limit in case we have two truncated
                         * sequences at the end.
                         * See ticket #7492.
                         ','line_number':5465,'multiline':True]['text':' sequence too short, stop with toULength<toULimit ','line_number':5479,'multiline':True]['text':' store the partial UTF-8 character, compatible with the regular UTF-8 converter ','line_number':5482,'multiline':True]['text':' consumed all trail bytes ','line_number':5496,'multiline':True]['text':' BMP ','line_number':5497,'multiline':True]['text':' not a surrogate ','line_number':5499,'multiline':True]['text':' supplementary code point ','line_number':5506,'multiline':True]['text':' BMP-only codepages are stored without stage 1 entries for supplementary code points ','line_number':5508,'multiline':True]['text':' error handling: illegal UTF-8 byte sequence ','line_number':5514,'multiline':True]['text':' get the bytes and the length for the output ','line_number':5526,'multiline':True]['text':' MBCS_OUTPUT_2 ','line_number':5527,'multiline':True]['text':' is this code point assigned, or do we use fallbacks? ','line_number':5530,'multiline':True]['text':' write the output character bytes from value and length ','line_number':5539,'multiline':True]['text':' from the first if in the loop we know that targetCapacity>0 ','line_number':5540,'multiline':True]['text':' this is easy because we know that there is enough space ','line_number':5542,'multiline':True]['text':' length==2 ','line_number':5545,'multiline':True]['text':' target overflow ','line_number':5554,'multiline':True]['text':'
                 * Try an extension mapping.
                 * Pass in no source because we don't have UTF-16 input.
                 * If we have a partial match on c, we will return and revert
                 * to UTF-8->UTF-16->charset conversion.
                 ','line_number':5563,'multiline':True]['text':' not mappable or buffer overflow ','line_number':5579,'multiline':True]['text':'
                     * Partial match, return and revert to pivoting.
                     * In normal from-UTF-16 conversion, we would just continue
                     * but then exit the loop because the extension match would
                     * have consumed the source.
                     ','line_number':5583,'multiline':True]['text':' a mapping was written to the target, continue ','line_number':5592,'multiline':True]['text':' recalculate the targetCapacity after an extension mapping ','line_number':5594,'multiline':True]['text':' target is full ','line_number':5600,'multiline':True]['text':'
     * The sourceLimit may have been adjusted before the conversion loop
     * to stop before a truncated sequence.
     * If so, then collect the truncated sequence now.
     ','line_number':5606,'multiline':True]['text':' write back the updated pointers ','line_number':5626,'multiline':True]['text':' miscellaneous ------------------------------------------------------------ ','line_number':5631,'multiline':True]['text':' all bytes that cause a state transition from state 0 are lead bytes ','line_number':5642,'multiline':True]['text':'
 * This is an internal function that allows other converter implementations
 * to check whether a byte is a lead byte.
 ','line_number':5647,'multiline':True]['text':' first, select between subChar and subChar1 ','line_number':5665,'multiline':True]['text':' select subChar1 if it is set (not 0) and the unmappable Unicode code point is up to U+00ff (IBM MBCS behavior) ','line_number':5671,'multiline':True]['text':' select subChar in all other cases ','line_number':5675,'multiline':True]['text':' reset the selector for the next code point ','line_number':5680,'multiline':True]['text':' fromUnicodeStatus contains prevLength ','line_number':5686,'multiline':True]['text':' DBCS mode and SBCS sub char: change to SBCS ','line_number':5690,'multiline':True]['text':' SBCS mode and DBCS sub char: change to DBCS ','line_number':5698,'multiline':True]['text':' SBCS, DBCS, and EBCDIC_STATEFUL are replaced by MBCS, but here we cheat a little ','line_number':5718,'multiline':True]['text':' #if !UCONFIG_NO_LEGACY_CONVERSION ','line_number':5729,'multiline':True]