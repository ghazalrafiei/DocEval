['text':'
*******************************************************************************
* Copyright (C) 1997-2015, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
*
* File COMPACTDECIMALFORMAT.CPP
*
********************************************************************************
','line_number':1,'multiline':True]['text':' Maps locale name to CDFLocaleData struct.','line_number':29,'multiline':False]['text':' Used to unescape single quotes.','line_number':49,'multiline':False]['text':' Next one will be 4 then 6 etc.','line_number':60,'multiline':False]['text':' CDFUnit represents a prefix-suffix pair for a particular variant','line_number':64,'multiline':False]['text':' and log10 value.','line_number':65,'multiline':False]['text':' CDFLocaleStyleData contains formatting data for a particular locale','line_number':81,'multiline':False]['text':' and style.','line_number':82,'multiline':False]['text':' What to divide by for each log10 value when formatting. These values','line_number':85,'multiline':False]['text':' will be powers of 10. For English, would be:','line_number':86,'multiline':False]['text':' 1, 1, 1, 1000, 1000, 1000, 1000000, 1000000, 1000000, 1000000000 ...','line_number':87,'multiline':False]['text':' Maps plural variants to CDFUnit[MAX_DIGITS] arrays.','line_number':89,'multiline':False]['text':' To format a number x,','line_number':90,'multiline':False]['text':' first compute log10(x). Compute displayNum = (x / divisors[log10(x)]).','line_number':91,'multiline':False]['text':' Compute the plural variant for displayNum','line_number':92,'multiline':False]['text':' (e.g zero, one, two, few, many, other).','line_number':93,'multiline':False]['text':' Compute cdfUnits = unitsByVariant[pluralVariant].','line_number':94,'multiline':False]['text':' Prefix and suffix to use at cdfUnits[log10(x)]','line_number':95,'multiline':False]['text':' Init initializes this object.','line_number':99,'multiline':False]['text':' CDFLocaleData contains formatting data for a particular locale.','line_number':110,'multiline':False]['text':' Init initializes this object.','line_number':116,'multiline':False]['text':' number ','line_number':284,'multiline':True]['text':' posIter ','line_number':286,'multiline':True]['text':' number ','line_number':311,'multiline':True]['text':' posIter ','line_number':313,'multiline':True]['text':' number ','line_number':338,'multiline':True]['text':' posIter ','line_number':340,'multiline':True]['text':' number ','line_number':348,'multiline':True]['text':' posIter ','line_number':350,'multiline':True]['text':' number ','line_number':358,'multiline':True]['text':' posIter ','line_number':360,'multiline':True]['text':' number ','line_number':367,'multiline':True]['text':' pos ','line_number':369,'multiline':True]['text':' text ','line_number':377,'multiline':True]['text':' result ','line_number':378,'multiline':True]['text':' parsePosition ','line_number':379,'multiline':True]['text':' text ','line_number':384,'multiline':True]['text':' result ','line_number':385,'multiline':True]['text':' text ','line_number':392,'multiline':True]['text':' pos ','line_number':393,'multiline':True]['text':' Helper method for operator=','line_number':428,'multiline':False]['text':' getCDFLocaleStyleData returns pointer to formatting data for given locale and ','line_number':438,'multiline':False]['text':' style within the global cache. On cache miss, getCDFLocaleStyleData loads','line_number':439,'multiline':False]['text':' the data from CLDR into the global cache before returning the pointer. If a','line_number':440,'multiline':False]['text':' UNUM_LONG data is requested for a locale, and that locale does not have','line_number':441,'multiline':False]['text':' UNUM_LONG data, getCDFLocaleStyleData will fall back to UNUM_SHORT data for','line_number':442,'multiline':False]['text':' that locale.','line_number':443,'multiline':False]['text':' loadCDFLocaleData loads formatting data from CLDR for a given locale. The','line_number':504,'multiline':False]['text':' caller owns the returned pointer.','line_number':505,'multiline':False]['text':' initCDFLocaleData initializes result with data from CLDR.','line_number':529,'multiline':False]['text':' inLocale is the locale, the CLDR data is stored in result.','line_number':530,'multiline':False]['text':' We load the UNUM_SHORT  and UNUM_LONG data looking first in local numbering','line_number':531,'multiline':False]['text':' system and not including root locale in fallback. Next we try in the latn','line_number':532,'multiline':False]['text':' numbering system where we fallback all the way to root. If we don't find','line_number':533,'multiline':False]['text':' UNUM_SHORT data in these three places, we report an error. If we find','line_number':534,'multiline':False]['text':' UNUM_SHORT data before finding UNUM_LONG data we make UNUM_LONG data fall','line_number':535,'multiline':False]['text':' back to UNUM_SHORT data.','line_number':536,'multiline':False]['text':' If we haven't found UNUM_SHORT look in latn numbering system. We must','line_number':569,'multiline':False]['text':' succeed at finding UNUM_SHORT here.','line_number':570,'multiline':False]['text':'*
 * tryGetDecimalFallback attempts to fetch the "decimalFormat" resource bundle
 * with a particular style. style is either "patternsShort" or "patternsLong."
 * FillIn, flags, and status work in the same way as in tryGetByKeyWithFallback.
 ','line_number':597,'multiline':True]['text':' tryGetByKeyWithFallback returns a sub-resource bundle that matches given','line_number':611,'multiline':False]['text':' criteria or NULL if none found. rb is the resource bundle that we are','line_number':612,'multiline':False]['text':' searching. If rb == NULL then this function behaves as if no sub-resource','line_number':613,'multiline':False]['text':' is found; path is the key of the sub-resource,','line_number':614,'multiline':False]['text':' (i.e "foo" but not "foo/bar"); If fillIn is NULL, caller must always call','line_number':615,'multiline':False]['text':' ures_close() on returned resource. See below for example when fillIn is','line_number':616,'multiline':False]['text':' not NULL. flags is ANY or NOT_ROOT. Optionally, these values','line_number':617,'multiline':False]['text':' can be ored with MUST. MUST by itself is the same as ANY | MUST.','line_number':618,'multiline':False]['text':' The locale of the returned sub-resource will either match the','line_number':619,'multiline':False]['text':' flags or the returned sub-resouce will be NULL. If MUST is included in','line_number':620,'multiline':False]['text':' flags, and not suitable sub-resource is found then in addition to returning','line_number':621,'multiline':False]['text':' NULL, this function also sets status to U_MISSING_RESOURCE_ERROR. If MUST','line_number':622,'multiline':False]['text':' is not included in flags, then this function just returns NULL if no','line_number':623,'multiline':False]['text':' such sub-resource is found and will never set status to','line_number':624,'multiline':False]['text':' U_MISSING_RESOURCE_ERROR.','line_number':625,'multiline':False]['text':'','line_number':626,'multiline':False]['text':' Example: This code first searches for "foo/bar" sub-resource without falling','line_number':627,'multiline':False]['text':' back to ROOT. Then searches for "baz" sub-resource as last resort.','line_number':628,'multiline':False]['text':'','line_number':629,'multiline':False]['text':' UResourcebundle* fillIn = NULL;','line_number':630,'multiline':False]['text':' UResourceBundle* data = tryGetByKeyWithFallback(rb, "foo", &fillIn, NON_ROOT, status);','line_number':631,'multiline':False]['text':' data = tryGetByKeyWithFallback(data, "bar", &fillIn, NON_ROOT, status);','line_number':632,'multiline':False]['text':' if (!data) {','line_number':633,'multiline':False]['text':'   data = tryGetbyKeyWithFallback(rb, "baz", &fillIn, MUST,  status);','line_number':634,'multiline':False]['text':' }','line_number':635,'multiline':False]['text':' if (U_FAILURE(status)) {','line_number':636,'multiline':False]['text':'   ures_close(fillIn);','line_number':637,'multiline':False]['text':'   return;','line_number':638,'multiline':False]['text':' }','line_number':639,'multiline':False]['text':' doStuffWithNonNullSubresource(data);','line_number':640,'multiline':False]['text':'','line_number':641,'multiline':False]['text':' /* Wrong! don't do the following as it can leak memory if fillIn gets set','line_number':642,'multiline':False]['text':' to NULL. */','line_number':643,'multiline':False]['text':' fillIn = tryGetByKeyWithFallback(rb, "wrong", &fillIn, ANY, status);','line_number':644,'multiline':False]['text':'','line_number':645,'multiline':False]['text':' ures_close(fillIn);','line_number':646,'multiline':False]['text':' ','line_number':647,'multiline':False]['text':' initCDFLocaleStyleData loads formatting data for a particular style.','line_number':708,'multiline':False]['text':' decimalFormatBundle is the "decimalFormat" resource bundle in CLDR.','line_number':709,'multiline':False]['text':' Loaded data stored in result.','line_number':710,'multiline':False]['text':' Iterate through all the powers of 10.','line_number':715,'multiline':False]['text':' populatePower10 grabs data for a particular power of 10 from CLDR.','line_number':734,'multiline':False]['text':' The loaded data is stored in result.','line_number':735,'multiline':False]['text':' Silently ignore divisors that are too big.','line_number':747,'multiline':False]['text':' Iterate over all the plural variants for the power of 10','line_number':755,'multiline':False]['text':' We expect all format strings to have the same number of 0's','line_number':780,'multiline':False]['text':' left of the decimal point.','line_number':781,'multiline':False]['text':' We expect to find an OTHER variant for each power of 10.','line_number':791,'multiline':False]['text':' populatePrefixSuffix Adds a specific prefix-suffix pair to result for a','line_number':803,'multiline':False]['text':' given variant and log10 value.','line_number':804,'multiline':False]['text':' variant is 'zero', 'one', 'two', 'few', 'many', or 'other'.','line_number':805,'multiline':False]['text':' formatStr is the format string from which the prefix and suffix are','line_number':806,'multiline':False]['text':' extracted. It is usually of form 'Pefix 000 suffix'.','line_number':807,'multiline':False]['text':' populatePrefixSuffix returns the number of 0's found in formatStr','line_number':808,'multiline':False]['text':' before the decimal point.','line_number':809,'multiline':False]['text':' In the special case that formatStr contains only spaces for prefix','line_number':810,'multiline':False]['text':' and suffix, populatePrefixSuffix returns log10Value + 1.','line_number':811,'multiline':False]['text':' We must have 0's in format string.','line_number':818,'multiline':False]['text':' Everything up to first 0 is the prefix','line_number':828,'multiline':False]['text':' Everything beyond the last 0 is the suffix','line_number':831,'multiline':False]['text':' If there is effectively no prefix or suffix, ignore the actual number of','line_number':835,'multiline':False]['text':' 0's and act as if the number of 0's matches the size of the number.','line_number':836,'multiline':False]['text':' Calculate number of zeros before decimal point','line_number':841,'multiline':False]['text':' fixQuotes unescapes single quotes. Don''t -> Don't. Letter 'j' -> Letter j.','line_number':853,'multiline':False]['text':' Modifies s in place.','line_number':854,'multiline':False]['text':' Update state','line_number':871,'multiline':False]['text':' fillInMissing ensures that the data in result is complete.','line_number':887,'multiline':False]['text':' result data is complete if for each variant in result, there exists','line_number':888,'multiline':False]['text':' a prefix-suffix pair for each log10 value and there also exists','line_number':889,'multiline':False]['text':' a divisor for each log10 value.','line_number':890,'multiline':False]['text':'','line_number':891,'multiline':False]['text':' First this function figures out for which log10 values, the other','line_number':892,'multiline':False]['text':' variant already had data. These are the same log10 values defined','line_number':893,'multiline':False]['text':' in CLDR. ','line_number':894,'multiline':False]['text':'','line_number':895,'multiline':False]['text':' For each log10 value not defined in CLDR, it uses the divisor for','line_number':896,'multiline':False]['text':' the last defined log10 value or 1.','line_number':897,'multiline':False]['text':'','line_number':898,'multiline':False]['text':' Then for each variant, it does the following. For each log10','line_number':899,'multiline':False]['text':' value not defined in CLDR, copy the prefix-suffix pair from the','line_number':900,'multiline':False]['text':' previous log10 value. If log10 value is defined in CLDR but is','line_number':901,'multiline':False]['text':' missing from given variant, copy the prefix-suffix pair for that','line_number':902,'multiline':False]['text':' log10 value from the 'other' variant.','line_number':903,'multiline':False]['text':' Iterate over each variant.','line_number':918,'multiline':False]['text':' computeLog10 computes floor(log10(x)). If inRange is TRUE, the biggest','line_number':939,'multiline':False]['text':' value computeLog10 will return MAX_DIGITS -1 even for','line_number':940,'multiline':False]['text':' numbers > 10^MAX_DIGITS. If inRange is FALSE, computeLog10 will return','line_number':941,'multiline':False]['text':' up to MAX_DIGITS.','line_number':942,'multiline':False]['text':' createCDFUnit returns a pointer to the prefix-suffix pair for a given','line_number':956,'multiline':False]['text':' variant and log10 value within table. If no such prefix-suffix pair is','line_number':957,'multiline':False]['text':' stored in table, one is created within table before returning pointer.','line_number':958,'multiline':False]['text':' getCDFUnitFallback returns a pointer to the prefix-suffix pair for a given','line_number':980,'multiline':False]['text':' variant and log10 value within table. If the given variant doesn't exist, it','line_number':981,'multiline':False]['text':' falls back to the OTHER variant. Therefore, this method will always return','line_number':982,'multiline':False]['text':' some non-NULL value.','line_number':983,'multiline':False]