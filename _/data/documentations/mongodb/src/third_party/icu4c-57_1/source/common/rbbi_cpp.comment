['text':'
***************************************************************************
*   Copyright (C) 1999-2016 International Business Machines Corporation
*   and others. All rights reserved.
***************************************************************************
','line_number':1,'multiline':True]['text':'','line_number':7,'multiline':False]['text':'  file:  rbbi.c    Contains the implementation of the rule based break iterator','line_number':8,'multiline':False]['text':'                   runtime engine and the API implementation for','line_number':9,'multiline':False]['text':'                   class RuleBasedBreakIterator','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':' for 'typeid' to work','line_number':13,'multiline':False]['text':' if U_LOCAL_SERVICE_HOOK is defined, then localsvc.cpp is expected to be included.','line_number':35,'multiline':False]['text':' The state number of the starting state','line_number':46,'multiline':False]['text':' The state-transition value indicating "stop"','line_number':49,'multiline':False]['text':'=======================================================================','line_number':56,'multiline':False]['text':' constructors','line_number':57,'multiline':False]['text':'=======================================================================','line_number':58,'multiline':False]['text':'*
 * Constructs a RuleBasedBreakIterator that uses the already-created
 * tables object that is passed in as a parameter.
 ','line_number':60,'multiline':True]['text':' status checked in constructor','line_number':67,'multiline':False]['text':'*
 * Same as above but does not adopt memory
 ','line_number':75,'multiline':True]['text':' status checked in constructor','line_number':81,'multiline':False]['text':'','line_number':90,'multiline':False]['text':'  Construct from precompiled binary rules (tables).  This constructor is public API,','line_number':91,'multiline':False]['text':'  taking the rules as a (const uint8_t *) to match the type produced by getBinaryRules().','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':'   Constructor   from a UDataMemory handle to precompiled break rules','line_number':121,'multiline':False]['text':'                 stored in an ICU data file.','line_number':122,'multiline':False]['text':'','line_number':123,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':124,'multiline':False]['text':' status checked in constructor','line_number':128,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':'   Constructor       from a set of rules supplied as a string.','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':142,'multiline':False]['text':' Note:  This is a bit awkward.  The RBBI ruleBuilder has a factory method that','line_number':151,'multiline':False]['text':'        creates and returns a complete RBBI.  From here, in a constructor, we','line_number':152,'multiline':False]['text':'        can't just return the object created by the builder factory, hence','line_number':153,'multiline':False]['text':'        the assignment of the factory created object to "this".','line_number':154,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':' Default Constructor.      Create an empty shell that can be set up later.','line_number':164,'multiline':False]['text':'                           Used when creating a RuleBasedBreakIterator from a set','line_number':165,'multiline':False]['text':'                           of rules.','line_number':166,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':167,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':173,'multiline':False]['text':'','line_number':174,'multiline':False]['text':'   Copy constructor.  Will produce a break iterator with the same behavior,','line_number':175,'multiline':False]['text':'                      and which iterates over the same text, as the one passed in.','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':178,'multiline':False]['text':'*
 * Destructor
 ','line_number':187,'multiline':True]['text':' fCharIter was adopted from the outside.','line_number':192,'multiline':False]['text':'*
 * Assignment operator.  Sets this iterator to have the same behavior,
 * and iterate over the same text, as the one passed in.
 ','line_number':221,'multiline':True]['text':' Delete break cache information','line_number':230,'multiline':False]['text':' Just rebuild for now','line_number':234,'multiline':False]['text':' TODO: clone fLanguageBreakEngines from "that"','line_number':236,'multiline':False]['text':' This is a little bit tricky - it will intially appear that','line_number':246,'multiline':False]['text':'  this->fCharIter is adopted, even if that->fCharIter was','line_number':247,'multiline':False]['text':'  not adopted.  That's ok.','line_number':248,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':265,'multiline':False]['text':'','line_number':266,'multiline':False]['text':'    init()      Shared initialization routine.   Used by all the constructors.','line_number':267,'multiline':False]['text':'                Initializes all fields, leaving the object in a consistent state.','line_number':268,'multiline':False]['text':'','line_number':269,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':270,'multiline':False]['text':' Defaulting BreakType to word gives reasonable','line_number':281,'multiline':False]['text':'   dictionary behavior for Break Iterators that are','line_number':282,'multiline':False]['text':'   built from rules.  Even better would be the ability to','line_number':283,'multiline':False]['text':'   declare the type in the rules.','line_number':284,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':306,'multiline':False]['text':'','line_number':307,'multiline':False]['text':'    clone - Returns a newly-constructed RuleBasedBreakIterator with the same','line_number':308,'multiline':False]['text':'            behavior, and iterating over the same text, as this one.','line_number':309,'multiline':False]['text':'            Virtual function: does the right thing with subclasses.','line_number':310,'multiline':False]['text':'','line_number':311,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':312,'multiline':False]['text':'*
 * Equality operator.  Returns TRUE if both BreakIterators are of the
 * same class, have the same behavior, and iterate over the same text.
 ','line_number':318,'multiline':True]['text':' The two break iterators are operating on different text,','line_number':331,'multiline':False]['text':'   or have a different interation position.','line_number':332,'multiline':False]['text':' TODO:  need a check for when in a dictionary region at different offsets.','line_number':336,'multiline':False]['text':' The two break iterators are using the same rules.','line_number':340,'multiline':False]['text':'*
 * Compute a hash code for this BreakIterator
 * @return A hash code
 ','line_number':346,'multiline':True]['text':' Set up a dummy CharacterIterator to be returned if anyone','line_number':367,'multiline':False]['text':'   calls getText().  With input from UText, there is no reasonable','line_number':368,'multiline':False]['text':'   way to return a characterIterator over the actual input text.','line_number':369,'multiline':False]['text':'   Return one over an empty string instead - this is the closest','line_number':370,'multiline':False]['text':'   we can come to signaling a failure.','line_number':371,'multiline':False]['text':'   (GetText() is obsolete, this failure is sort of OK)','line_number':372,'multiline':False]['text':' existing fCharIter was adopted from the outside.  Delete it now.','line_number':383,'multiline':False]['text':'*
 * Returns the description used to create this iterator
 ','line_number':399,'multiline':True]['text':' TODO:  something more elegant here.','line_number':409,'multiline':False]['text':'        perhaps API should return the string by value.','line_number':410,'multiline':False]['text':'        Note:  thread unsafe init & leak are semi-ok, better than','line_number':411,'multiline':False]['text':'               what was before.  Sould be cleaned up, though.','line_number':412,'multiline':False]['text':'=======================================================================','line_number':419,'multiline':False]['text':' BreakIterator overrides','line_number':420,'multiline':False]['text':'=======================================================================','line_number':421,'multiline':False]['text':'*
 * Return a CharacterIterator over the text being analyzed.  
 ','line_number':423,'multiline':True]['text':'*
 * Set the iterator to analyze a new piece of text.  This function resets
 * the current iteration position to the beginning of the text.
 * @param newText An iterator over the text to analyze.
 ','line_number':431,'multiline':True]['text':' If we are holding a CharacterIterator adopted from a ','line_number':438,'multiline':False]['text':'   previous call to this function, delete it now.','line_number':439,'multiline':False]['text':' startIndex !=0 wants to be an error, but there's no way to report it.','line_number':448,'multiline':False]['text':' Make the iterator text be an empty string.','line_number':449,'multiline':False]['text':'*
 * Set the iterator to analyze a new piece of text.  This function resets
 * the current iteration position to the beginning of the text.
 * @param newText An iterator over the text to analyze.
 ','line_number':457,'multiline':True]['text':' Set up a character iterator on the string.  ','line_number':468,'multiline':False]['text':'   Needed in case someone calls getText().','line_number':469,'multiline':False]['text':'  Can not, unfortunately, do this lazily on the (probably never)','line_number':470,'multiline':False]['text':'  call to getText(), because getText is const.','line_number':471,'multiline':False]['text':' old fCharIter was adopted from the outside.  Delete it.','line_number':479,'multiline':False]['text':'*
 *  Provide a new UText for the input text.  Must reference text with contents identical
 *  to the original.
 *  Intended for use with text data originating in Java (garbage collected) environments
 *  where the data may be moved in memory at arbitrary times.
 ','line_number':488,'multiline':True]['text':'  Shallow read-only clone of the new UText into the existing input UText','line_number':503,'multiline':False]['text':' Sanity check.  The new input utext is supposed to have the exact same','line_number':510,'multiline':False]['text':' contents as the old.  If we can't set to the same position, it doesn't.','line_number':511,'multiline':False]['text':' The contents underlying the old utext might be invalid at this point,','line_number':512,'multiline':False]['text':' so it's not safe to check directly.','line_number':513,'multiline':False]['text':'*
 * Sets the current iteration position to the beginning of the text, position zero.
 * @return The new iterator position, which is zero.
 ','line_number':520,'multiline':True]['text':'if (fText == NULL)','line_number':528,'multiline':False]['text':'    return BreakIterator::DONE;','line_number':529,'multiline':False]['text':'*
 * Sets the current iteration position to the end of the text.
 * @return The text's past-the-end offset.
 ','line_number':535,'multiline':True]['text':'*
 * Advances the iterator either forward or backward the specified number of steps.
 * Negative values move backward, and positive values move forward.  This is
 * equivalent to repeatedly calling next() or previous().
 * @param n The number of steps to move.  The sign indicates the direction
 * (negative is backwards, and positive is forwards).
 * @return The character offset of the boundary position n boundaries away from
 * the current one.
 ','line_number':553,'multiline':True]['text':'*
 * Advances the iterator to the next boundary position.
 * @return The position of the first boundary after this one.
 ','line_number':575,'multiline':True]['text':' if we have cached break positions and we're still in the range','line_number':580,'multiline':False]['text':' covered by them, just move one step forward in the cache','line_number':581,'multiline':False]['text':'*
 * Advances the iterator backwards, to the last boundary preceding this one.
 * @return The position of the last boundary position preceding this one.
 ','line_number':603,'multiline':True]['text':' if we have cached break positions and we're still in the range','line_number':611,'multiline':False]['text':' covered by them, just move one step backward in the cache','line_number':612,'multiline':False]['text':' If we're at the beginning of the cache, need to reevaluate the','line_number':616,'multiline':False]['text':' rule status','line_number':617,'multiline':False]['text':' if we're already sitting at the beginning of the text, return DONE','line_number':630,'multiline':False]['text':' old rule syntax','line_number':645,'multiline':False]['text':' set things up.  handlePrevious() will back us up to some valid','line_number':646,'multiline':False]['text':' break position before the current position (we back our internal','line_number':647,'multiline':False]['text':' iterator up one step to prevent handlePrevious() from returning','line_number':648,'multiline':False]['text':' the current position), but not necessarily the last one before','line_number':649,'multiline':False]['text':' where we started','line_number':650,'multiline':False]['text':' iterate forward from the known break position until we pass our','line_number':664,'multiline':False]['text':' starting point.  The last break position before the starting','line_number':665,'multiline':False]['text':' point is our return value','line_number':666,'multiline':False]['text':' fLastBreakTag wants to have the value for section of text preceding','line_number':678,'multiline':False]['text':' the result position that we are to return (in lastResult.)  If','line_number':679,'multiline':False]['text':' the backwards rules overshot and the above loop had to do two or more','line_number':680,'multiline':False]['text':' next()s to move up to the desired return position, we will have a valid','line_number':681,'multiline':False]['text':' tag value. But, if handlePrevious() took us to exactly the correct result position,','line_number':682,'multiline':False]['text':' we wont have a tag value for that position, which is only set by handleNext().','line_number':683,'multiline':False]['text':' Set the current iteration position to be the last break position','line_number':685,'multiline':False]['text':' before where we started, and then return that value.','line_number':686,'multiline':False]['text':' for use by getRuleStatus()','line_number':688,'multiline':False]['text':' No need to check the dictionary; it will have been handled by','line_number':691,'multiline':False]['text':' next()','line_number':692,'multiline':False]['text':'*
 * Sets the iterator to refer to the first boundary position following
 * the specified position.
 * @offset The position from which to begin searching for a break position.
 * @return The position of the first break after the current position.
 ','line_number':697,'multiline':True]['text':' if the offset passed in is already past the end of the text,','line_number':704,'multiline':False]['text':' just return DONE; if it's before the beginning, return the','line_number':705,'multiline':False]['text':' text's starting offset','line_number':706,'multiline':False]['text':' Move requested offset to a code point start. It might be on a trail surrogate,','line_number':715,'multiline':False]['text':' or on a trail byte if the input is UTF-8.','line_number':716,'multiline':False]['text':' if we have cached break positions and offset is in the range','line_number':720,'multiline':False]['text':' covered by them, use them','line_number':721,'multiline':False]['text':' TODO: could use binary search','line_number':722,'multiline':False]['text':' TODO: what if offset is outside range, but break is not?','line_number':723,'multiline':False]['text':' We are guaranteed not to leave the array due to range test above','line_number':728,'multiline':False]['text':' Set our internal iteration position (temporarily)','line_number':741,'multiline':False]['text':' to the position passed in.  If this is the _beginning_ position,','line_number':742,'multiline':False]['text':' then we can just use next() to get our return value','line_number':743,'multiline':False]['text':' new rule syntax','line_number':748,'multiline':False]['text':' move forward one codepoint to prepare for moving back to a','line_number':750,'multiline':False]['text':' safe point.','line_number':751,'multiline':False]['text':' this handles offset being between a supplementary character','line_number':752,'multiline':False]['text':' TODO: is this still needed, with move to code point boundary handled above?','line_number':753,'multiline':False]['text':' handlePrevious will move most of the time to < 1 boundary away','line_number':755,'multiline':False]['text':' backup plan if forward safe table is not available','line_number':764,'multiline':False]['text':' handle next will give result >= offset','line_number':767,'multiline':False]['text':' previous will give result 0 or 1 boundary away from offset,','line_number':769,'multiline':False]['text':' most of the time','line_number':770,'multiline':False]['text':' we have to','line_number':771,'multiline':False]['text':' otherwise, we have to sync up first.  Use handlePrevious() to back','line_number':786,'multiline':False]['text':' up to a known break position before the specified position (if','line_number':787,'multiline':False]['text':' we can determine that the specified position is a break position,','line_number':788,'multiline':False]['text':' we don't back up at all).  This may or may not be the last break','line_number':789,'multiline':False]['text':' position at or before our starting position.  Advance forward','line_number':790,'multiline':False]['text':' from here until we've passed the starting position.  The position','line_number':791,'multiline':False]['text':' we stop on will be the first break position after the specified one.','line_number':792,'multiline':False]['text':' old rule syntax','line_number':793,'multiline':False]['text':'*
 * Sets the iterator to refer to the last boundary position before the
 * specified position.
 * @offset The position to begin searching for a break from.
 * @return The position of the last boundary before the starting position.
 ','line_number':809,'multiline':True]['text':' if the offset passed in is already past the end of the text,','line_number':816,'multiline':False]['text':' just return DONE; if it's before the beginning, return the','line_number':817,'multiline':False]['text':' text's starting offset','line_number':818,'multiline':False]['text':' Move requested offset to a code point start. It might be on a trail surrogate,','line_number':826,'multiline':False]['text':' or on a trail byte if the input is UTF-8.','line_number':827,'multiline':False]['text':' if we have cached break positions and offset is in the range','line_number':831,'multiline':False]['text':' covered by them, use them','line_number':832,'multiline':False]['text':' TODO: binary search?','line_number':834,'multiline':False]['text':' TODO: What if offset is outside range, but break is not?','line_number':835,'multiline':False]['text':' If we're at the beginning of the cache, need to reevaluate the','line_number':843,'multiline':False]['text':' rule status','line_number':844,'multiline':False]['text':' if we start by updating the current iteration position to the','line_number':856,'multiline':False]['text':' position specified by the caller, we can just use previous()','line_number':857,'multiline':False]['text':' to carry out this operation','line_number':858,'multiline':False]['text':' new rule syntax','line_number':861,'multiline':False]['text':' Will come here if specified offset was not a code point boundary AND','line_number':865,'multiline':False]['text':'   the underlying implmentation is using UText, which snaps any non-code-point-boundary','line_number':866,'multiline':False]['text':'   indices to the containing code point.','line_number':867,'multiline':False]['text':' For breakitereator::preceding only, these non-code-point indices need to be moved','line_number':868,'multiline':False]['text':'   up to refer to the following codepoint.','line_number':869,'multiline':False]['text':' TODO:  (synwee) would it be better to just check for being in the middle of a surrogate pair,','line_number':874,'multiline':False]['text':'        rather than adjusting the position unconditionally?','line_number':875,'multiline':False]['text':'        (Change would interact with safe rules.)','line_number':876,'multiline':False]['text':' TODO:  change RBBI behavior for off-boundary indices to match that of UText?','line_number':877,'multiline':False]['text':'        affects only preceding(), seems cleaner, but is slightly different.','line_number':878,'multiline':False]['text':' backup plan if forward safe table is not available','line_number':888,'multiline':False]['text':'  TODO:  check whether this path can be discarded','line_number':889,'multiline':False]['text':'         It's probably OK to say that rules must supply both safe tables','line_number':890,'multiline':False]['text':'            if they use safe tables at all.  We have certainly never described','line_number':891,'multiline':False]['text':'            to anyone how to work with just one safe table.','line_number':892,'multiline':False]['text':' handle previous will give result <= offset','line_number':896,'multiline':False]['text':' next will give result 0 or 1 boundary away from offset,','line_number':899,'multiline':False]['text':' most of the time','line_number':900,'multiline':False]['text':' we have to','line_number':901,'multiline':False]['text':' old rule syntax','line_number':917,'multiline':False]['text':'*
 * Returns true if the specfied position is a boundary position.  As a side
 * effect, leaves the iterator pointing to the first boundary position at
 * or after "offset".
 * @param offset the offset to check.
 * @return True if "offset" is a boundary position.
 ','line_number':922,'multiline':True]['text':' the beginning index of the iterator is always a boundary position by definition','line_number':930,'multiline':False]['text':' For side effects on current position, tag values.','line_number':932,'multiline':False]['text':' For side effects on current position, tag values.','line_number':937,'multiline':False]['text':' out-of-range indexes are never boundary positions','line_number':941,'multiline':False]['text':' For side effects on current position, tag values.','line_number':943,'multiline':False]['text':' For side effects on current position, tag values.','line_number':948,'multiline':False]['text':' otherwise, we can use following() on the position before the specified','line_number':952,'multiline':False]['text':' one and return true if the position we get back is the one the user','line_number':953,'multiline':False]['text':' specified','line_number':954,'multiline':False]['text':'*
 * Returns the current iteration position.
 * @return The current iteration position.
 ','line_number':961,'multiline':True]['text':'=======================================================================','line_number':970,'multiline':False]['text':' implementation','line_number':971,'multiline':False]['text':'=======================================================================','line_number':972,'multiline':False]['text':'','line_number':974,'multiline':False]['text':' RBBIRunMode  -  the state machine runs an extra iteration at the beginning and end','line_number':975,'multiline':False]['text':'                 of user text.  A variable with this enum type keeps track of where we','line_number':976,'multiline':False]['text':'                 are.  The state machine only fetches user input while in the RUN mode.','line_number':977,'multiline':False]['text':'','line_number':978,'multiline':False]['text':' state machine processing is before first char of input','line_number':980,'multiline':False]['text':' state machine processing is in the user text','line_number':981,'multiline':False]['text':' state machine processing is after end of user text.','line_number':982,'multiline':False]['text':' Map from look-ahead break states (corresponds to rules) to boundary positions.','line_number':986,'multiline':False]['text':' Allows multiple lookahead break rules to be in flight at the same time.','line_number':987,'multiline':False]['text':'','line_number':988,'multiline':False]['text':' This is a temporary approach for ICU 57. A better fix is to make the look-ahead numbers','line_number':989,'multiline':False]['text':' in the state table be sequential, then we can just index an array. And the','line_number':990,'multiline':False]['text':' table could also tell us in advance how big that array needs to be.','line_number':991,'multiline':False]['text':'','line_number':992,'multiline':False]['text':' Before ICU 57 there was just a single simple variable for a look-ahead match that','line_number':993,'multiline':False]['text':' was in progress. Two rules at once did not work.','line_number':994,'multiline':False]['text':'-----------------------------------------------------------------------------------','line_number':1034,'multiline':False]['text':'','line_number':1035,'multiline':False]['text':'  handleNext(stateTable)','line_number':1036,'multiline':False]['text':'     This method is the actual implementation of the rbbi next() method. ','line_number':1037,'multiline':False]['text':'     This method initializes the state machine to state 1','line_number':1038,'multiline':False]['text':'     and advances through the text character by character until we reach the end','line_number':1039,'multiline':False]['text':'     of the text or the state machine transitions to state 0.  We update our return','line_number':1040,'multiline':False]['text':'     value every time the state machine passes through an accepting state.','line_number':1041,'multiline':False]['text':'','line_number':1042,'multiline':False]['text':'-----------------------------------------------------------------------------------','line_number':1043,'multiline':False]['text':' No matter what, handleNext alway correctly sets the break tag value.','line_number':1063,'multiline':False]['text':' if we're already at the end of the text, return DONE.','line_number':1067,'multiline':False]['text':'  Set the initial state for the state machine','line_number':1075,'multiline':False]['text':'(statetable->fTableData + (statetable->fRowLen * state));','line_number':1078,'multiline':False]['text':' loop until we reach the end of the text or transition to state 0','line_number':1089,'multiline':False]['text':'','line_number':1090,'multiline':False]['text':' Reached end of input string.','line_number':1093,'multiline':False]['text':' We have already run the loop one last time with the ','line_number':1095,'multiline':False]['text':'   character set to the psueudo {eof} value.  Now it is time','line_number':1096,'multiline':False]['text':'   to unconditionally bail out.','line_number':1097,'multiline':False]['text':' Run the loop one last time with the fake end-of-input character category.','line_number':1100,'multiline':False]['text':'','line_number':1105,'multiline':False]['text':' Get the char category.  An incoming category of 1 or 2 means that','line_number':1106,'multiline':False]['text':'      we are preset for doing the beginning or end of input, and','line_number':1107,'multiline':False]['text':'      that we shouldn't get a category from an actual text input character.','line_number':1108,'multiline':False]['text':'','line_number':1109,'multiline':False]['text':' look up the current character's character category, which tells us','line_number':1111,'multiline':False]['text':' which column in the state table to look at.','line_number':1112,'multiline':False]['text':' Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,','line_number':1113,'multiline':False]['text':'        not the size of the character going in, which is a UChar32.','line_number':1114,'multiline':False]['text':'','line_number':1115,'multiline':False]['text':' Check the dictionary bit in the character's category.','line_number':1118,'multiline':False]['text':'    Counter is only used by dictionary based iterators (subclasses).','line_number':1119,'multiline':False]['text':'    Chars that need to be handled by a dictionary have a flag bit set','line_number':1120,'multiline':False]['text':'    in their category values.','line_number':1121,'multiline':False]['text':'','line_number':1122,'multiline':False]['text':'  And off the dictionary flag bit.','line_number':1125,'multiline':False]['text':' State Transition - move machine to its next state','line_number':1142,'multiline':False]['text':'','line_number':1143,'multiline':False]['text':' Note: fNextState is defined as uint16_t[2], but we are casting','line_number':1145,'multiline':False]['text':' a generated RBBI table to RBBIStateTableRow and some tables','line_number':1146,'multiline':False]['text':' actually have more than 2 categories.','line_number':1147,'multiline':False]['text':'Not accessing beyond memory','line_number':1149,'multiline':True]['text':' (statetable->fTableData + (statetable->fRowLen * state));','line_number':1151,'multiline':False]['text':' Match found, common case.','line_number':1156,'multiline':False]['text':' Remember the break status (tag) values.','line_number':1160,'multiline':False]['text':' Lookahead match is completed.  ','line_number':1165,'multiline':False]['text':' At the position of a '/' in a look-ahead match. Record it.','line_number':1175,'multiline':False]['text':' This is the normal exit from the lookup state machine.','line_number':1181,'multiline':False]['text':' We have advanced through the string until it is certain that no','line_number':1182,'multiline':False]['text':'   longer match is possible, no matter what characters follow.','line_number':1183,'multiline':False]['text':' Advance to the next character.  ','line_number':1187,'multiline':False]['text':' If this is a beginning-of-input loop iteration, don't advance','line_number':1188,'multiline':False]['text':'    the input position.  The next iteration will be processing the','line_number':1189,'multiline':False]['text':'    first real input character.','line_number':1190,'multiline':False]['text':' The state machine is done.  Check whether it found a match...','line_number':1202,'multiline':False]['text':' If the iterator failed to advance in the match engine, force it ahead by one.','line_number':1204,'multiline':False]['text':'   (This really indicates a defect in the break rules.  They should always match','line_number':1205,'multiline':False]['text':'    at least one character.)','line_number':1206,'multiline':False]['text':' Leave the iterator at our result position.','line_number':1213,'multiline':False]['text':'-----------------------------------------------------------------------------------','line_number':1225,'multiline':False]['text':'','line_number':1226,'multiline':False]['text':'  handlePrevious()','line_number':1227,'multiline':False]['text':'','line_number':1228,'multiline':False]['text':'      Iterate backwards, according to the logic of the reverse rules.','line_number':1229,'multiline':False]['text':'      This version handles the exact style backwards rules.','line_number':1230,'multiline':False]['text':'','line_number':1231,'multiline':False]['text':'      The logic of this function is very similar to handleNext(), above.','line_number':1232,'multiline':False]['text':'','line_number':1233,'multiline':False]['text':'-----------------------------------------------------------------------------------','line_number':1234,'multiline':False]['text':' handlePrevious() never gets the rule status.','line_number':1251,'multiline':False]['text':' Flag the status as invalid; if the user ever asks for status, we will need','line_number':1252,'multiline':False]['text':' to back up, then re-find the break position using handleNext(), which does','line_number':1253,'multiline':False]['text':' get the status value.','line_number':1254,'multiline':False]['text':' if we're already at the start of the text, return DONE.','line_number':1258,'multiline':False]['text':'  Set up the starting char.','line_number':1263,'multiline':False]['text':'  Set the initial state for the state machine','line_number':1268,'multiline':False]['text':' loop until we reach the start of the text or transition to state 0','line_number':1280,'multiline':False]['text':'','line_number':1281,'multiline':False]['text':' Reached end of input string.','line_number':1284,'multiline':False]['text':' We have already run the loop one last time with the ','line_number':1286,'multiline':False]['text':'   character set to the psueudo {eof} value.  Now it is time','line_number':1287,'multiline':False]['text':'   to unconditionally bail out.','line_number':1288,'multiline':False]['text':' Ran off start, no match found.','line_number':1290,'multiline':False]['text':' move one index one (towards the start, since we are doing a previous())','line_number':1291,'multiline':False]['text':' TODO:  shouldn't be necessary.  We're already at beginning.  Check.','line_number':1293,'multiline':False]['text':' Run the loop one last time with the fake end-of-input character category.','line_number':1297,'multiline':False]['text':'','line_number':1302,'multiline':False]['text':' Get the char category.  An incoming category of 1 or 2 means that','line_number':1303,'multiline':False]['text':'      we are preset for doing the beginning or end of input, and','line_number':1304,'multiline':False]['text':'      that we shouldn't get a category from an actual text input character.','line_number':1305,'multiline':False]['text':'','line_number':1306,'multiline':False]['text':' look up the current character's character category, which tells us','line_number':1308,'multiline':False]['text':' which column in the state table to look at.','line_number':1309,'multiline':False]['text':' Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,','line_number':1310,'multiline':False]['text':'        not the size of the character going in, which is a UChar32.','line_number':1311,'multiline':False]['text':'','line_number':1312,'multiline':False]['text':' Check the dictionary bit in the character's category.','line_number':1315,'multiline':False]['text':'    Counter is only used by dictionary based iterators (subclasses).','line_number':1316,'multiline':False]['text':'    Chars that need to be handled by a dictionary have a flag bit set','line_number':1317,'multiline':False]['text':'    in their category values.','line_number':1318,'multiline':False]['text':'','line_number':1319,'multiline':False]['text':'  And off the dictionary flag bit.','line_number':1322,'multiline':False]['text':' State Transition - move machine to its next state','line_number':1339,'multiline':False]['text':'','line_number':1340,'multiline':False]['text':' Note: fNextState is defined as uint16_t[2], but we are casting','line_number':1342,'multiline':False]['text':' a generated RBBI table to RBBIStateTableRow and some tables','line_number':1343,'multiline':False]['text':' actually have more than 2 categories.','line_number':1344,'multiline':False]['text':'Not accessing beyond memory','line_number':1346,'multiline':True]['text':' Match found, common case.','line_number':1351,'multiline':False]['text':' Lookahead match is completed.  ','line_number':1357,'multiline':False]['text':' At the position of a '/' in a look-ahead match. Record it.','line_number':1366,'multiline':False]['text':' This is the normal exit from the lookup state machine.','line_number':1372,'multiline':False]['text':' We have advanced through the string until it is certain that no','line_number':1373,'multiline':False]['text':'   longer match is possible, no matter what characters follow.','line_number':1374,'multiline':False]['text':' Move (backwards) to the next character to process.  ','line_number':1378,'multiline':False]['text':' If this is a beginning-of-input loop iteration, don't advance','line_number':1379,'multiline':False]['text':'    the input position.  The next iteration will be processing the','line_number':1380,'multiline':False]['text':'    first real input character.','line_number':1381,'multiline':False]['text':' The state machine is done.  Check whether it found a match...','line_number':1391,'multiline':False]['text':' If the iterator failed to advance in the match engine, force it ahead by one.','line_number':1393,'multiline':False]['text':'   (This really indicates a defect in the break rules.  They should always match','line_number':1394,'multiline':False]['text':'    at least one character.)','line_number':1395,'multiline':False]['text':' Leave the iterator at our result position.','line_number':1402,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1427,'multiline':False]['text':'','line_number':1428,'multiline':False]['text':'   getRuleStatus()   Return the break rule tag associated with the current','line_number':1429,'multiline':False]['text':'                     iterator position.  If the iterator arrived at its current','line_number':1430,'multiline':False]['text':'                     position by iterating forwards, the value will have been','line_number':1431,'multiline':False]['text':'                     cached by the handleNext() function.','line_number':1432,'multiline':False]['text':'','line_number':1433,'multiline':False]['text':'                     If no cached status value is available, the status is','line_number':1434,'multiline':False]['text':'                     found by doing a previous() followed by a next(), which','line_number':1435,'multiline':False]['text':'                     leaves the iterator where it started, and computes the','line_number':1436,'multiline':False]['text':'                     status while doing the next().','line_number':1437,'multiline':False]['text':'','line_number':1438,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1439,'multiline':False]['text':'  No cached status is available.','line_number':1442,'multiline':False]['text':'  At start of text, or there is no text.  Status is always zero.','line_number':1444,'multiline':False]['text':'  Not at start of text.  Find status the tedious way.','line_number':1448,'multiline':False]['text':' Blow off the dictionary cache','line_number':1452,'multiline':False]['text':' note: the if (pa != pb) test is here only to eliminate warnings for','line_number':1456,'multiline':False]['text':'       unused local variables on gcc.  Logically, it isn't needed.','line_number':1457,'multiline':False]['text':' fLastRuleStatusIndex indexes to the start of the appropriate status record','line_number':1470,'multiline':False]['text':'                                                 (the number of status values.)','line_number':1471,'multiline':False]['text':'   This function returns the last (largest) of the array of status values.','line_number':1472,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1506,'multiline':False]['text':'','line_number':1507,'multiline':False]['text':'   getBinaryRules        Access to the compiled form of the rules,','line_number':1508,'multiline':False]['text':'                         for use by build system tools that save the data','line_number':1509,'multiline':False]['text':'                         for standard iterator types.','line_number':1510,'multiline':False]['text':'','line_number':1511,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1512,'multiline':False]['text':'stackBuffer','line_number':1525,'multiline':True]['text':' preflighting for deprecated functionality','line_number':1534,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1548,'multiline':False]['text':'','line_number':1549,'multiline':False]['text':'  isDictionaryChar      Return true if the category lookup for this char','line_number':1550,'multiline':False]['text':'                        indicates that it is in the set of dictionary lookup','line_number':1551,'multiline':False]['text':'                        chars.','line_number':1552,'multiline':False]['text':'','line_number':1553,'multiline':False]['text':'                        This function is intended for use by dictionary based','line_number':1554,'multiline':False]['text':'                        break iterators.','line_number':1555,'multiline':False]['text':'','line_number':1556,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1557,'multiline':False]['text':'UBool RuleBasedBreakIterator::isDictionaryChar(UChar32   c) {
    if (fData == NULL) {
        return FALSE;
    }
    uint16_t category;
    UTRIE_GET16(&fData->fTrie, c, category);
    return (category & 0x4000) != 0;
}','line_number':1558,'multiline':True]['text':'-------------------------------------------------------------------------------','line_number':1568,'multiline':False]['text':'','line_number':1569,'multiline':False]['text':'  checkDictionary       This function handles all processing of characters in','line_number':1570,'multiline':False]['text':'                        the "dictionary" set. It will determine the appropriate','line_number':1571,'multiline':False]['text':'                        course of action, and possibly set up a cache in the','line_number':1572,'multiline':False]['text':'                        process.','line_number':1573,'multiline':False]['text':'','line_number':1574,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1575,'multiline':False]['text':' Reset the old break cache first.','line_number':1579,'multiline':False]['text':' note: code segment below assumes that dictionary chars are in the ','line_number':1582,'multiline':False]['text':' startPos-endPos range','line_number':1583,'multiline':False]['text':' value returned should be next character in sequence','line_number':1584,'multiline':False]['text':' Starting from the starting point, scan towards the proposed result,','line_number':1589,'multiline':False]['text':' looking for the first dictionary character (which may be the one','line_number':1590,'multiline':False]['text':' we're on, if we're starting in the middle of a range).','line_number':1591,'multiline':False]['text':' Is the character we're starting on a dictionary character? If so, we','line_number':1609,'multiline':False]['text':' need to back up to include the entire run; otherwise the results of','line_number':1610,'multiline':False]['text':' the break algorithm will differ depending on where we start. Since','line_number':1611,'multiline':False]['text':' the result is cached and there is typically a non-dictionary break','line_number':1612,'multiline':False]['text':' within a small number of words, there should be little performance impact.','line_number':1613,'multiline':False]['text':' TODO:  recast to work directly with postincrement.','line_number':1617,'multiline':False]['text':' Back up to the last dictionary character','line_number':1621,'multiline':False]['text':' c = fText->last32();','line_number':1624,'multiline':False]['text':'   TODO:  why was this if needed?','line_number':1625,'multiline':False]['text':' Back up to the last dictionary character','line_number':1638,'multiline':False]['text':' c = fText->first32();','line_number':1640,'multiline':False]['text':' Loop through the text, looking for ranges of dictionary characters.','line_number':1652,'multiline':False]['text':' For each span, find the appropriate break engine, and ask it to find','line_number':1653,'multiline':False]['text':' any breaks within the span.','line_number':1654,'multiline':False]['text':' Note: we always do this in the forward direction, so that the break','line_number':1655,'multiline':False]['text':' cache is built in the right order.','line_number':1656,'multiline':False]['text':' TODO:  tweak for post-increment operation','line_number':1664,'multiline':False]['text':' We now have a dictionary character. Get the appropriate language object','line_number':1672,'multiline':False]['text':' to deal with it.','line_number':1673,'multiline':False]['text':' Ask the language object if there are any breaks. It will leave the text','line_number':1676,'multiline':False]['text':' pointer on the other side of its range, ready to search for the next one.','line_number':1677,'multiline':False]['text':' Reload the loop variables for the next go-round','line_number':1682,'multiline':False]['text':' If we found breaks, build a new break cache. The first and last entries must','line_number':1687,'multiline':False]['text':' be the original starting and ending position.','line_number':1688,'multiline':False]['text':' If there are breaks, then by definition, we are replacing the original','line_number':1711,'multiline':False]['text':' proposed break by one of the breaks we found. Use following() and','line_number':1712,'multiline':False]['text':' preceding() to do the work. They should never recurse in this case.','line_number':1713,'multiline':False]['text':' If the allocation failed, just fall through to the "no breaks found" case.','line_number':1721,'multiline':False]['text':' If we get here, there were no language-based breaks. Set the text pointer','line_number':1724,'multiline':False]['text':' to the original proposed break.','line_number':1725,'multiline':False]['text':'*
 * Release all static memory held by breakiterator.  
 ','line_number':1736,'multiline':True]['text':'-------------------------------------------------------------------------------','line_number':1796,'multiline':False]['text':'','line_number':1797,'multiline':False]['text':'  getLanguageBreakEngine  Find an appropriate LanguageBreakEngine for the','line_number':1798,'multiline':False]['text':'                          the character c.','line_number':1799,'multiline':False]['text':'','line_number':1800,'multiline':False]['text':'-------------------------------------------------------------------------------','line_number':1801,'multiline':False]['text':' No existing dictionary took the character. See if a factory wants to','line_number':1824,'multiline':False]['text':' give us a new LanguageBreakEngine for this character.','line_number':1825,'multiline':False]['text':' If we got one, use it and push it on our stack.','line_number':1828,'multiline':False]['text':' Even if we can't remember it, we can keep looking it up, so','line_number':1831,'multiline':False]['text':' return it even if the push fails.','line_number':1832,'multiline':False]['text':' No engine is forthcoming for this character. Add it to the','line_number':1836,'multiline':False]['text':' reject set. Create the reject break engine if needed.','line_number':1837,'multiline':False]['text':' Put it last so that scripts for which we have an engine get tried','line_number':1843,'multiline':False]['text':' first.','line_number':1844,'multiline':False]['text':' If we can't insert it, or creation failed, get rid of it','line_number':1846,'multiline':False]['text':' Tell the reject engine about the character; at its discretion, it may','line_number':1854,'multiline':False]['text':' add more than just the one character.','line_number':1855,'multiline':False]['text':'int32_t RuleBasedBreakIterator::getBreakType() const {
    return fBreakType;
}','line_number':1863,'multiline':True]['text':' #if !UCONFIG_NO_BREAK_ITERATION ','line_number':1874,'multiline':True]