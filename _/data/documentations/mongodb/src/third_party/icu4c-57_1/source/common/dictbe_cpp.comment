['text':'*
 *******************************************************************************
 * Copyright (C) 2006-2016, International Business Machines Corporation
 * and others. All Rights Reserved.
 *******************************************************************************
 ','line_number':1,'multiline':True]['text':'
 ******************************************************************
 ','line_number':26,'multiline':True]['text':' Find the span of characters included in the set.','line_number':52,'multiline':False]['text':'   The span to break begins at the current position in the text, and','line_number':53,'multiline':False]['text':'   extends towards the start or end of the text, depending on 'reverse'.','line_number':54,'multiline':False]['text':' rangeEnd = start + 1;','line_number':76,'multiline':False]['text':' TODO:  recast loop for postincrement','line_number':83,'multiline':False]['text':' Compact for caching','line_number':100,'multiline':False]['text':'
 ******************************************************************
 * PossibleWord
 ','line_number':104,'multiline':True]['text':' Helper class for improving readability of the Thai/Lao/Khmer word break','line_number':109,'multiline':False]['text':' algorithm. The implementation is completely inline.','line_number':110,'multiline':False]['text':' List size, limited by the maximum number of words in the dictionary','line_number':112,'multiline':False]['text':' that form a nested sequence.','line_number':113,'multiline':False]['text':' list of word candidate lengths, in increasing length order','line_number':118,'multiline':False]['text':' TODO: bytes would be sufficient for word lengths.','line_number':119,'multiline':False]['text':' Count of candidates','line_number':120,'multiline':False]['text':' The longest match with a dictionary word','line_number':121,'multiline':False]['text':' Offset in the text of these candidates','line_number':122,'multiline':False]['text':' The preferred candidate's offset','line_number':123,'multiline':False]['text':' The candidate we're currently looking at','line_number':124,'multiline':False]['text':' Word Lengths, in code units.','line_number':125,'multiline':False]['text':' Word Lengths, in code points.','line_number':126,'multiline':False]['text':' Fill the list of candidates if needed, select the longest, and return the number found','line_number':132,'multiline':False]['text':' Select the currently marked candidate, point after it in the text, and invalidate self','line_number':135,'multiline':False]['text':' Back up from the current candidate to the next shorter one; return TRUE if that exists','line_number':138,'multiline':False]['text':' and point the text after it','line_number':139,'multiline':False]['text':' Return the longest prefix this candidate location shares with a dictionary word','line_number':142,'multiline':False]['text':' Return value is in code points.','line_number':143,'multiline':False]['text':' Mark the current candidate as the one we like','line_number':146,'multiline':False]['text':' Get length in code points of the marked word.','line_number':149,'multiline':False]['text':' TODO: If getIndex is too slow, use offset < 0 and add discardAll()','line_number':155,'multiline':False]['text':' Dictionary leaves text after longest prefix, not longest word. Back up.','line_number':160,'multiline':False]['text':'
 ******************************************************************
 * ThaiBreakEngine
 ','line_number':189,'multiline':True]['text':' How many words in a row are "good enough"?','line_number':194,'multiline':False]['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':197,'multiline':False]['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':200,'multiline':False]['text':' dictionary word, with a preceding word','line_number':201,'multiline':False]['text':' Ellision character','line_number':204,'multiline':False]['text':' Repeat character','line_number':207,'multiline':False]['text':' Minimum word size','line_number':210,'multiline':False]['text':' Minimum number of characters for two words','line_number':213,'multiline':False]['text':' MAI HAN-AKAT','line_number':227,'multiline':False]['text':' SARA E through SARA AI MAIMALAI','line_number':228,'multiline':False]['text':' KO KAI through HO NOKHUK','line_number':229,'multiline':False]['text':' SARA E through SARA AI MAIMALAI','line_number':230,'multiline':False]['text':' Compact for caching.','line_number':234,'multiline':False]['text':' Not enough characters for two words','line_number':253,'multiline':False]['text':' Word Length in Code Points.','line_number':259,'multiline':False]['text':' Word length in code units (UText native indexing)','line_number':260,'multiline':False]['text':' Look for candidate words at the current position','line_number':271,'multiline':False]['text':' If we found exactly one, use that','line_number':274,'multiline':False]['text':' If there was more than one, see which one can take us forward the most words','line_number':280,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':282,'multiline':False]['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':290,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':295,'multiline':False]['text':' See if any of the possible second words is followed by a third word','line_number':300,'multiline':False]['text':' If we find a third word, stop right away','line_number':302,'multiline':False]['text':' Set UText position to after the accepted word.','line_number':313,'multiline':False]['text':' We come here after having either found a word or not. We look ahead to the','line_number':319,'multiline':False]['text':' next word. If it's not a dictionary word, we will combine it with the word we','line_number':320,'multiline':False]['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':321,'multiline':False]['text':' the threshold.','line_number':322,'multiline':False]['text':' The text iterator should now be positioned at the end of the word we found.','line_number':323,'multiline':False]['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':327,'multiline':False]['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':328,'multiline':False]['text':' of characters with a dictionary word, then scan to resynchronize','line_number':329,'multiline':False]['text':' Look for a plausible word boundary','line_number':333,'multiline':False]['text':' Maybe. See if it's in the dictionary.','line_number':348,'multiline':False]['text':' NOTE: In the original Apple code, checked that the next','line_number':349,'multiline':False]['text':' two characters after uc were not 0x0E4C THANTHAKHAT before','line_number':350,'multiline':False]['text':' checking the dictionary. That is just a performance filter,','line_number':351,'multiline':False]['text':' but it's not clear it's faster than checking the trie.','line_number':352,'multiline':False]['text':' Bump the word count if there wasn't already one','line_number':361,'multiline':False]['text':' Update the length with the passed-over characters','line_number':366,'multiline':False]['text':' Back up to where we were for next iteration','line_number':370,'multiline':False]['text':' Never stop before a combining mark.','line_number':375,'multiline':False]['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':382,'multiline':False]['text':' We do this in code rather than using a rule so that the heuristic','line_number':383,'multiline':False]['text':' resynch continues to function. For example, one of the suffix characters','line_number':384,'multiline':False]['text':' could be a typo in the middle of a word.','line_number':385,'multiline':False]['text':' Skip over previous end and PAIYANNOI','line_number':391,'multiline':False]['text':' Add PAIYANNOI to word','line_number':395,'multiline':False]['text':' Fetch next character','line_number':396,'multiline':False]['text':' Restore prior position','line_number':399,'multiline':False]['text':' Skip over previous end and MAIYAMOK','line_number':405,'multiline':False]['text':' Add MAIYAMOK to word','line_number':409,'multiline':False]['text':' Restore prior position','line_number':412,'multiline':False]['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':422,'multiline':False]['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':428,'multiline':False]['text':'
 ******************************************************************
 * LaoBreakEngine
 ','line_number':437,'multiline':True]['text':' How many words in a row are "good enough"?','line_number':442,'multiline':False]['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':445,'multiline':False]['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':448,'multiline':False]['text':' dictionary word, with a preceding word','line_number':449,'multiline':False]['text':' Minimum word size','line_number':452,'multiline':False]['text':' Minimum number of characters for two words','line_number':455,'multiline':False]['text':' prefix vowels','line_number':469,'multiline':False]['text':' basic consonants (including holes for corresponding Thai characters)','line_number':470,'multiline':False]['text':' digraph consonants (no Thai equivalent)','line_number':471,'multiline':False]['text':' prefix vowels','line_number':472,'multiline':False]['text':' Compact for caching.','line_number':474,'multiline':False]['text':' Not enough characters for two words','line_number':490,'multiline':False]['text':' Look for candidate words at the current position','line_number':506,'multiline':False]['text':' If we found exactly one, use that','line_number':509,'multiline':False]['text':' If there was more than one, see which one can take us forward the most words','line_number':515,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':517,'multiline':False]['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':525,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':530,'multiline':False]['text':' See if any of the possible second words is followed by a third word','line_number':535,'multiline':False]['text':' If we find a third word, stop right away','line_number':537,'multiline':False]['text':' We come here after having either found a word or not. We look ahead to the','line_number':553,'multiline':False]['text':' next word. If it's not a dictionary word, we will combine it withe the word we','line_number':554,'multiline':False]['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':555,'multiline':False]['text':' the threshold.','line_number':556,'multiline':False]['text':' The text iterator should now be positioned at the end of the word we found.','line_number':557,'multiline':False]['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':559,'multiline':False]['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':560,'multiline':False]['text':' of characters with a dictionary word, then scan to resynchronize','line_number':561,'multiline':False]['text':' Look for a plausible word boundary','line_number':565,'multiline':False]['text':' Maybe. See if it's in the dictionary.','line_number':581,'multiline':False]['text':' TODO: this looks iffy; compare with old code.','line_number':582,'multiline':False]['text':' Bump the word count if there wasn't already one','line_number':591,'multiline':False]['text':' Update the length with the passed-over characters','line_number':596,'multiline':False]['text':' Back up to where we were for next iteration','line_number':600,'multiline':False]['text':' Never stop before a combining mark.','line_number':605,'multiline':False]['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':612,'multiline':False]['text':' We do this in code rather than using a rule so that the heuristic','line_number':613,'multiline':False]['text':' resynch continues to function. For example, one of the suffix characters','line_number':614,'multiline':False]['text':' could be a typo in the middle of a word.','line_number':615,'multiline':False]['text':' NOT CURRENTLY APPLICABLE TO LAO','line_number':616,'multiline':False]['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':618,'multiline':False]['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':624,'multiline':False]['text':'
 ******************************************************************
 * BurmeseBreakEngine
 ','line_number':633,'multiline':True]['text':' How many words in a row are "good enough"?','line_number':638,'multiline':False]['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':641,'multiline':False]['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':644,'multiline':False]['text':' dictionary word, with a preceding word','line_number':645,'multiline':False]['text':' Minimum word size','line_number':648,'multiline':False]['text':' Minimum number of characters for two words','line_number':651,'multiline':False]['text':' basic consonants and independent vowels','line_number':665,'multiline':False]['text':' Compact for caching.','line_number':667,'multiline':False]['text':' Not enough characters for two words','line_number':683,'multiline':False]['text':' Look for candidate words at the current position','line_number':699,'multiline':False]['text':' If we found exactly one, use that','line_number':702,'multiline':False]['text':' If there was more than one, see which one can take us forward the most words','line_number':708,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':710,'multiline':False]['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':718,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':723,'multiline':False]['text':' See if any of the possible second words is followed by a third word','line_number':728,'multiline':False]['text':' If we find a third word, stop right away','line_number':730,'multiline':False]['text':' We come here after having either found a word or not. We look ahead to the','line_number':746,'multiline':False]['text':' next word. If it's not a dictionary word, we will combine it withe the word we','line_number':747,'multiline':False]['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':748,'multiline':False]['text':' the threshold.','line_number':749,'multiline':False]['text':' The text iterator should now be positioned at the end of the word we found.','line_number':750,'multiline':False]['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':752,'multiline':False]['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':753,'multiline':False]['text':' of characters with a dictionary word, then scan to resynchronize','line_number':754,'multiline':False]['text':' Look for a plausible word boundary','line_number':758,'multiline':False]['text':' Maybe. See if it's in the dictionary.','line_number':774,'multiline':False]['text':' TODO: this looks iffy; compare with old code.','line_number':775,'multiline':False]['text':' Bump the word count if there wasn't already one','line_number':784,'multiline':False]['text':' Update the length with the passed-over characters','line_number':789,'multiline':False]['text':' Back up to where we were for next iteration','line_number':793,'multiline':False]['text':' Never stop before a combining mark.','line_number':798,'multiline':False]['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':805,'multiline':False]['text':' We do this in code rather than using a rule so that the heuristic','line_number':806,'multiline':False]['text':' resynch continues to function. For example, one of the suffix characters','line_number':807,'multiline':False]['text':' could be a typo in the middle of a word.','line_number':808,'multiline':False]['text':' NOT CURRENTLY APPLICABLE TO BURMESE','line_number':809,'multiline':False]['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':811,'multiline':False]['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':817,'multiline':False]['text':'
 ******************************************************************
 * KhmerBreakEngine
 ','line_number':826,'multiline':True]['text':' How many words in a row are "good enough"?','line_number':831,'multiline':False]['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':834,'multiline':False]['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':837,'multiline':False]['text':' dictionary word, with a preceding word','line_number':838,'multiline':False]['text':' Minimum word size','line_number':841,'multiline':False]['text':' Minimum number of characters for two words','line_number':844,'multiline':False]['text':'fBeginWordSet.add(0x17A3, 0x17A4);      // deprecated vowels','line_number':859,'multiline':False]['text':'fEndWordSet.remove(0x17A5, 0x17A9);     // Khmer independent vowels that can't end a word','line_number':860,'multiline':False]['text':'fEndWordSet.remove(0x17B2);             // Khmer independent vowel that can't end a word','line_number':861,'multiline':False]['text':' KHMER SIGN COENG that combines some following characters','line_number':862,'multiline':False]['text':'fEndWordSet.remove(0x17B6, 0x17C5);     // Remove dependent vowels','line_number':863,'multiline':False]['text':'    fEndWordSet.remove(0x0E31);             // MAI HAN-AKAT','line_number':864,'multiline':False]['text':'    fEndWordSet.remove(0x0E40, 0x0E44);     // SARA E through SARA AI MAIMALAI','line_number':865,'multiline':False]['text':'    fBeginWordSet.add(0x0E01, 0x0E2E);      // KO KAI through HO NOKHUK','line_number':866,'multiline':False]['text':'    fBeginWordSet.add(0x0E40, 0x0E44);      // SARA E through SARA AI MAIMALAI','line_number':867,'multiline':False]['text':'    fSuffixSet.add(THAI_PAIYANNOI);','line_number':868,'multiline':False]['text':'    fSuffixSet.add(THAI_MAIYAMOK);','line_number':869,'multiline':False]['text':' Compact for caching.','line_number':871,'multiline':False]['text':'    fSuffixSet.compact();','line_number':875,'multiline':False]['text':' Not enough characters for two words','line_number':888,'multiline':False]['text':' Look for candidate words at the current position','line_number':904,'multiline':False]['text':' If we found exactly one, use that','line_number':907,'multiline':False]['text':' If there was more than one, see which one can take us forward the most words','line_number':914,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':916,'multiline':False]['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':924,'multiline':False]['text':' If we're already at the end of the range, we're done','line_number':929,'multiline':False]['text':' See if any of the possible second words is followed by a third word','line_number':934,'multiline':False]['text':' If we find a third word, stop right away','line_number':936,'multiline':False]['text':' We come here after having either found a word or not. We look ahead to the','line_number':952,'multiline':False]['text':' next word. If it's not a dictionary word, we will combine it with the word we','line_number':953,'multiline':False]['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':954,'multiline':False]['text':' the threshold.','line_number':955,'multiline':False]['text':' The text iterator should now be positioned at the end of the word we found.','line_number':956,'multiline':False]['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':958,'multiline':False]['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':959,'multiline':False]['text':' of characters with a dictionary word, then scan to resynchronize','line_number':960,'multiline':False]['text':' Look for a plausible word boundary','line_number':964,'multiline':False]['text':' Maybe. See if it's in the dictionary.','line_number':980,'multiline':False]['text':' Bump the word count if there wasn't already one','line_number':989,'multiline':False]['text':' Update the length with the passed-over characters','line_number':994,'multiline':False]['text':' Back up to where we were for next iteration','line_number':998,'multiline':False]['text':' Never stop before a combining mark.','line_number':1003,'multiline':False]['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':1010,'multiline':False]['text':' We do this in code rather than using a rule so that the heuristic','line_number':1011,'multiline':False]['text':' resynch continues to function. For example, one of the suffix characters','line_number':1012,'multiline':False]['text':' could be a typo in the middle of a word.','line_number':1013,'multiline':False]['text':'        if ((int32_t)utext_getNativeIndex(text) < rangeEnd && wordLength > 0) {','line_number':1014,'multiline':False]['text':'            if (words[wordsFound%KHMER_LOOKAHEAD].candidates(text, fDictionary, rangeEnd) <= 0','line_number':1015,'multiline':False]['text':'                && fSuffixSet.contains(uc = utext_current32(text))) {','line_number':1016,'multiline':False]['text':'                if (uc == KHMER_PAIYANNOI) {','line_number':1017,'multiline':False]['text':'                    if (!fSuffixSet.contains(utext_previous32(text))) {','line_number':1018,'multiline':False]['text':'                        // Skip over previous end and PAIYANNOI','line_number':1019,'multiline':False]['text':'                        utext_next32(text);','line_number':1020,'multiline':False]['text':'                        utext_next32(text);','line_number':1021,'multiline':False]['text':'                        wordLength += 1;            // Add PAIYANNOI to word','line_number':1022,'multiline':False]['text':'                        uc = utext_current32(text);     // Fetch next character','line_number':1023,'multiline':False]['text':'                    }','line_number':1024,'multiline':False]['text':'                    else {','line_number':1025,'multiline':False]['text':'                        // Restore prior position','line_number':1026,'multiline':False]['text':'                        utext_next32(text);','line_number':1027,'multiline':False]['text':'                    }','line_number':1028,'multiline':False]['text':'                }','line_number':1029,'multiline':False]['text':'                if (uc == KHMER_MAIYAMOK) {','line_number':1030,'multiline':False]['text':'                    if (utext_previous32(text) != KHMER_MAIYAMOK) {','line_number':1031,'multiline':False]['text':'                        // Skip over previous end and MAIYAMOK','line_number':1032,'multiline':False]['text':'                        utext_next32(text);','line_number':1033,'multiline':False]['text':'                        utext_next32(text);','line_number':1034,'multiline':False]['text':'                        wordLength += 1;            // Add MAIYAMOK to word','line_number':1035,'multiline':False]['text':'                    }','line_number':1036,'multiline':False]['text':'                    else {','line_number':1037,'multiline':False]['text':'                        // Restore prior position','line_number':1038,'multiline':False]['text':'                        utext_next32(text);','line_number':1039,'multiline':False]['text':'                    }','line_number':1040,'multiline':False]['text':'                }','line_number':1041,'multiline':False]['text':'            }','line_number':1042,'multiline':False]['text':'            else {','line_number':1043,'multiline':False]['text':'                utext_setNativeIndex(text, current+wordLength);','line_number':1044,'multiline':False]['text':'            }','line_number':1045,'multiline':False]['text':'        }','line_number':1046,'multiline':False]['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':1048,'multiline':False]['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':1054,'multiline':False]['text':'
 ******************************************************************
 * CjkBreakEngine
 ','line_number':1064,'multiline':True]['text':' Korean dictionary only includes Hangul syllables','line_number':1071,'multiline':False]['text':' handle Korean and Japanese/Chinese using different dictionaries','line_number':1079,'multiline':False]['text':'Chinese and Japanese','line_number':1082,'multiline':False]['text':' HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK','line_number':1087,'multiline':False]['text':' KATAKANA-HIRAGANA PROLONGED SOUND MARK','line_number':1088,'multiline':False]['text':' The katakanaCost values below are based on the length frequencies of all','line_number':1098,'multiline':False]['text':' katakana phrases in the dictionary','line_number':1099,'multiline':False]['text':'TODO: fill array with actual values from dictionary!','line_number':1105,'multiline':False]['text':' Function for accessing internal utext flags.','line_number':1117,'multiline':False]['text':'   Replicates an internal UText function.','line_number':1118,'multiline':False]['text':'
 * @param text A UText representing the text
 * @param rangeStart The start of the range of dictionary characters
 * @param rangeEnd The end of the range of dictionary characters
 * @param foundBreaks Output of C array of int32_t break positions, or 0
 * @return The number of breaks found
 ','line_number':1125,'multiline':True]['text':' UnicodeString version of input UText, NFKC normalized if necessary.','line_number':1141,'multiline':False]['text':' inputMap[inStringIndex] = corresponding native index from UText inText.','line_number':1144,'multiline':False]['text':' If NULL then mapping is 1:1','line_number':1145,'multiline':False]['text':' if UText has the input string as one contiguous UTF-16 chunk','line_number':1151,'multiline':False]['text':' Input UText is in one contiguous UTF-16 chunk.','line_number':1157,'multiline':False]['text':' Use Read-only aliasing UnicodeString.','line_number':1158,'multiline':False]['text':' Copy the text from the original inText (UText) to inString (UnicodeString).','line_number':1163,'multiline':False]['text':' Create a map from UnicodeString indices -> UText offsets.','line_number':1164,'multiline':False]['text':'  normalizedMap[normalizedInput position] ==  original UText position.','line_number':1190,'multiline':False]['text':' Once per normalization chunk','line_number':1198,'multiline':False]['text':' Map every position in the normalized chunk to the start of the chunk','line_number':1216,'multiline':False]['text':'   in the original input.','line_number':1217,'multiline':False]['text':' There are supplementary characters in the input.','line_number':1238,'multiline':False]['text':' The dictionary will produce boundary positions in terms of code point indexes,','line_number':1239,'multiline':False]['text':'   not in terms of code unit string indexes.','line_number':1240,'multiline':False]['text':' Use the inputMap mechanism to take care of this in addition to indexing differences','line_number':1241,'multiline':False]['text':'    from normalization and/or UTF-8 input.','line_number':1242,'multiline':False]['text':' bestSnlp[i] is the snlp of the best segmentation of the first i','line_number':1265,'multiline':False]['text':' code points in the range to be matched.','line_number':1266,'multiline':False]['text':' prev[i] is the index of the last CJK code point in the previous word in ','line_number':1274,'multiline':False]['text':' the best segmentation of the first i characters.','line_number':1275,'multiline':False]['text':' Dynamic programming to find the best segmentation.','line_number':1290,'multiline':False]['text':' In outer loop, i  is the code point index,','line_number':1292,'multiline':False]['text':'                ix is the corresponding string (code unit) index.','line_number':1293,'multiline':False]['text':'    They differ when the string contains supplementary characters.','line_number':1294,'multiline':False]['text':' Note: lengths is filled with code point lengths','line_number':1305,'multiline':False]['text':'       The NULL parameter is the ignored code unit lengths.','line_number':1306,'multiline':False]['text':' if there are no single character matches found in the dictionary ','line_number':1308,'multiline':False]['text':' starting with this charcter, treat character as a 1-character word ','line_number':1309,'multiline':False]['text':' with the highest value possible, i.e. the least likely to occur.','line_number':1310,'multiline':False]['text':' Exclude Korean characters from this treatment, as they should be left','line_number':1311,'multiline':False]['text':' together by default.','line_number':1312,'multiline':False]['text':' 255','line_number':1315,'multiline':False]['text':' In Japanese,','line_number':1328,'multiline':False]['text':' Katakana word in single character is pretty rare. So we apply','line_number':1329,'multiline':False]['text':' the following heuristic to Katakana: any continuous run of Katakana','line_number':1330,'multiline':False]['text':' characters is considered a candidate word with a default cost','line_number':1331,'multiline':False]['text':' specified in the katakanaCost table according to its length.','line_number':1332,'multiline':False]['text':' Find the end of the continuous run of Katakana characters','line_number':1339,'multiline':False]['text':' prev[j] = i;','line_number':1349,'multiline':False]['text':' Start pushing the optimal offset index into t_boundary (t for tentative).','line_number':1357,'multiline':False]['text':' prev[numCodePts] is guaranteed to be meaningful.','line_number':1358,'multiline':False]['text':' We'll first push in the reverse order, i.e.,','line_number':1359,'multiline':False]['text':' t_boundary[0] = numCodePts, and afterwards do a swap.','line_number':1360,'multiline':False]['text':' No segmentation found, set boundary to end of range','line_number':1364,'multiline':False]['text':' Add a break for the start of the dictionary range if there is not one','line_number':1376,'multiline':False]['text':' there already.','line_number':1377,'multiline':False]['text':' Now that we're done, convert positions in t_boundary[] (indices in ','line_number':1383,'multiline':False]['text':' the normalized input string) back to indices in the original input UText','line_number':1384,'multiline':False]['text':' while reversing t_boundary and pushing values to foundBreaks.','line_number':1385,'multiline':False]['text':' Boundaries are added to foundBreaks output in ascending order.','line_number':1389,'multiline':False]['text':' inString goes out of scope','line_number':1394,'multiline':False]['text':' inputMap goes out of scope','line_number':1395,'multiline':False]['text':' #if !UCONFIG_NO_BREAK_ITERATION ','line_number':1402,'multiline':True]