['text':'
 * Copyright (C) 2015, International Business Machines
 * Corporation and others.  All Rights Reserved.
 *
 * file name: decimfmtimpl.cpp
 ','line_number':1,'multiline':True]['text':' Needed to preserve equality. fMultiplier == 0 means','line_number':242,'multiline':False]['text':' multiplier is 1.','line_number':243,'multiline':False]['text':' ticket 9936','line_number':628,'multiline':False]['text':' ticket 9936','line_number':635,'multiline':False]['text':' ticket 9936','line_number':643,'multiline':False]['text':' Work around. Pattern parsing code and DecimalFormat code don't agree','line_number':864,'multiline':False]['text':' on the definition of field width, so we have to translate from','line_number':865,'multiline':False]['text':' pattern field width to decimal format field width here.','line_number':866,'multiline':False]['text':' Not in spec: maxIntDigitCount > 8 assume','line_number':914,'multiline':False]['text':' maxIntDigitCount = minIntDigitCount. Current DecimalFormat API has','line_number':915,'multiline':False]['text':' no provision for unsetting maxIntDigitCount which would be useful for','line_number':916,'multiline':False]['text':' scientific notation. The best we can do is assume that if','line_number':917,'multiline':False]['text':' maxIntDigitCount is the default of 2000000000 or is "big enough" then','line_number':918,'multiline':False]['text':' user did not intend to explicitly set it. The 8 was derived emperically','line_number':919,'multiline':False]['text':' by extensive testing of legacy code.','line_number':920,'multiline':False]['text':' Per the spec, exponent grouping happens if maxIntDigitCount is more','line_number':925,'multiline':False]['text':' than 1 and more than minIntDigitCount.','line_number':926,'multiline':False]['text':' For exponent grouping minIntDigits is always treated as 1 even','line_number':931,'multiline':False]['text':' if it wasn't set to 1!','line_number':932,'multiline':False]['text':' Fixed digit count left of decimal. minIntDigitCount doesn't have','line_number':935,'multiline':False]['text':' to equal maxIntDigitCount i.e minIntDigitCount == 0 while','line_number':936,'multiline':False]['text':' maxIntDigitCount == 1.','line_number':937,'multiline':False]['text':' If fixedIntDigitCount is 0 but','line_number':940,'multiline':False]['text':' min or max fraction count is 0 too then use 1. This way we can get','line_number':941,'multiline':False]['text':' unlimited precision for X.XXXEX','line_number':942,'multiline':False]['text':' Spec says this is how we compute significant digits. 0 means','line_number':949,'multiline':False]['text':' unlimited significant digits.','line_number':950,'multiline':False]['text':' Each function updates one field. Order matters. For instance,','line_number':1038,'multiline':False]['text':' updatePluralRules comes before updateCurrencyAffixInfo because the','line_number':1039,'multiline':False]['text':' fRules field is needed to update the fCurrencyAffixInfo field.','line_number':1040,'multiline':False]['text':' If no affixes changed, don't need to do any work','line_number':1063,'multiline':False]['text':' No work to do if both fSymbols and fMonetary','line_number':1081,'multiline':False]['text':' fields are unchanged','line_number':1082,'multiline':False]['text':' Its ok to say a field has changed when it really hasn't but not','line_number':1095,'multiline':False]['text':' the other way around. Here we assume the field changed unless it','line_number':1096,'multiline':False]['text':' was NULL before and is still NULL now','line_number':1097,'multiline':False]['text':' If all these fields are unchanged, no work to do.','line_number':1113,'multiline':False]['text':' In this case don't have to do any work','line_number':1121,'multiline':False]['text':' If DecimalFormatSymbols has custom currency symbol, prefer','line_number':1148,'multiline':False]['text':' that over what we just read from the resource bundles','line_number':1149,'multiline':False]['text':' No work to do if fSymbols is unchanged','line_number':1184,'multiline':False]['text':' No work to do if fSymbols is unchanged','line_number':1198,'multiline':False]['text':' No work to do','line_number':1213,'multiline':False]['text':' No work to do','line_number':1232,'multiline':False]['text':' No work to do','line_number':1251,'multiline':False]['text':' No work to do','line_number':1270,'multiline':False]['text':'*
 * Given a grouping policy, calculates how many digits are needed left of
 * the decimal point to achieve a desired length left of the
 * decimal point.
 * @param grouping the grouping policy
 * @param desiredLength number of characters needed left of decimal point
 * @param minLeftDigits at least this many digits is returned
 * @param leftDigits the number of digits needed stored here
 *  which is >= minLeftDigits.
 * @return true if a perfect fit or false if having leftDigits would exceed
 *   desiredLength
 ','line_number':1324,'multiline':True]['text':' Get a grouping policy like the one in this object that does not','line_number':1371,'multiline':False]['text':' have minimum grouping since toPattern doesn't support it.','line_number':1372,'multiline':False]['text':' Only for fixed digits, these are the digits that get 0's.','line_number':1376,'multiline':False]['text':' Only for fixed digits, these are the digits that get #'s.','line_number':1379,'multiline':False]['text':' Only for significant digits','line_number':1382,'multiline':False]['text':' These are all the digits to be displayed. For significant digits,','line_number':1386,'multiline':False]['text':' this interval always starts at the 1's place an extends left.','line_number':1387,'multiline':False]['text':' Digit range of rounding increment. If rounding increment is .025.','line_number':1390,'multiline':False]['text':' then roundingIncrementLowerExp = -3 and roundingIncrementUpperExp = -1','line_number':1391,'multiline':False]['text':' Make max int digits match min int digits for now, we','line_number':1410,'multiline':False]['text':' compute necessary padding later.','line_number':1411,'multiline':False]['text':' For some reason toPattern adds at least one leading '#'','line_number':1414,'multiline':False]['text':' We have to include the rounding increment in what we display','line_number':1422,'multiline':False]['text':' We have to include enough digits to show grouping strategy','line_number':1428,'multiline':False]['text':' If we have a minimum length, we have to add digits to the left to','line_number':1436,'multiline':False]['text':' depict padding.','line_number':1437,'multiline':False]['text':' For non scientific notation,','line_number':1439,'multiline':False]['text':'  minimumLengthForMantissa = minimumLength','line_number':1440,'multiline':False]['text':' Because of grouping, we may need fewer than expected digits to','line_number':1447,'multiline':False]['text':' achieve the length we need.','line_number':1448,'multiline':False]['text':' In this case, we achieved the exact length that we want.','line_number':1456,'multiline':False]['text':' Having digitsNeeded digits goes over desired length which','line_number':1460,'multiline':False]['text':' means that to have desired length would mean starting on a','line_number':1461,'multiline':False]['text':' grouping sepearator e.g ,###,### so add a '#' and use one','line_number':1462,'multiline':False]['text':' less digit. This trick gives ####,### but that is the best','line_number':1463,'multiline':False]['text':' we can do.','line_number':1464,'multiline':False]['text':' Use digit symbol','line_number':1476,'multiline':False]['text':' #if !UCONFIG_NO_FORMATTING ','line_number':1593,'multiline':True]