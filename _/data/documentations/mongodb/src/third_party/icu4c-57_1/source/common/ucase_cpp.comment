['text':'
*******************************************************************************
*
*   Copyright (C) 2004-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  ucase.cpp
*   encoding:   US-ASCII
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2004aug30
*   created by: Markus W. Scherer
*
*   Low-level Unicode character/string case mapping code.
*   Much code moved here (and modified) from uchar.c.
','line_number':1,'multiline':True]['text':' UDataInfo ','line_number':23,'multiline':True]['text':' DataHeader ','line_number':25,'multiline':True]['text':' ucase_props_data.h is machine-generated by gencase --csource ','line_number':43,'multiline':True]['text':' UCaseProps singleton ----------------------------------------------------- ','line_number':47,'multiline':True]['text':' set of property starts for UnicodeSet ------------------------------------ ','line_number':54,'multiline':True]['text':'end','line_number':57,'multiline':True]['text':'value','line_number':57,'multiline':True]['text':' add the start code point to the USet ','line_number':58,'multiline':True]['text':' add the start code point of each same-value range of the trie ','line_number':70,'multiline':True]['text':' add code points with hardcoded properties, plus the ones following them ','line_number':73,'multiline':True]['text':' (none right now, see comment below) ','line_number':75,'multiline':True]['text':'
     * Omit code points with hardcoded specialcasing properties
     * because we do not build property UnicodeSets for them right now.
     ','line_number':77,'multiline':True]['text':' data access primitives --------------------------------------------------- ','line_number':83,'multiline':True]['text':' number of bits in an 8-bit integer value ','line_number':89,'multiline':True]['text':'
 * Get the value of an optional-value slot where HAS_SLOT(excWord, idx).
 *
 * @param excWord (in) initial exceptions word
 * @param idx (in) desired slot index
 * @param pExc16 (in/out) const uint16_t * after excWord=*pExc16++;
 *               moved to the last uint16_t of the value, use +1 for beginning of next slot
 * @param value (out) int32_t or uint32_t output if hasSlot, otherwise not modified
 ','line_number':112,'multiline':True]['text':' simple case mappings ----------------------------------------------------- ','line_number':131,'multiline':True]['text':'
     * Hardcode the case closure of i and its relatives and ignore the
     * data file data for these characters.
     * The Turkic dotless i and dotted I with their case mapping conditions
     * and case folding option make the related characters behave specially.
     * This code matches their closure behavior to their case folding behavior.
     ','line_number':202,'multiline':True]['text':' regular i and I are in one equivalence class ','line_number':212,'multiline':True]['text':' dotted I is in a class with <0069 0307> (for canonical equivalence with <0049 0307>) ','line_number':219,'multiline':True]['text':' dotless i is in a class by itself ','line_number':223,'multiline':True]['text':' otherwise use the data file data ','line_number':226,'multiline':True]['text':' add the one simple case mapping, no matter what type it is ','line_number':233,'multiline':True]['text':'
         * c has exceptions, so there may be multiple simple and/or
         * full case mappings. Add them all.
         ','line_number':240,'multiline':True]['text':' add all simple case mappings ','line_number':251,'multiline':True]['text':' get the closure string pointer & length ','line_number':260,'multiline':True]['text':' higher bits are reserved ','line_number':264,'multiline':True]['text':' behind this slot, unless there are full case mappings ','line_number':265,'multiline':True]['text':' add the full case folding ','line_number':271,'multiline':True]['text':' start of full case mapping strings ','line_number':276,'multiline':True]['text':' bits 16 and higher are reserved ','line_number':279,'multiline':True]['text':' skip the lowercase result string ','line_number':281,'multiline':True]['text':' add the full case folding string ','line_number':285,'multiline':True]['text':' skip the uppercase and titlecase strings ','line_number':292,'multiline':True]['text':' behind full case mappings ','line_number':298,'multiline':True]['text':' add each code point in the closure string ','line_number':301,'multiline':True]['text':'
 * compare s, which has a length, with t, which has a maximum length or is NUL-terminated
 * must be length>0 and max>0 and length<=max
 ','line_number':309,'multiline':True]['text':' we require length<=max, so no need to decrement max in the loop ','line_number':317,'multiline':True]['text':' reached the end of t but not of s ','line_number':322,'multiline':True]['text':' return difference result ','line_number':326,'multiline':True]['text':' ends with length==0 ','line_number':329,'multiline':True]['text':' equal to length of both strings ','line_number':332,'multiline':True]['text':' return lengh difference ','line_number':334,'multiline':True]['text':' no reverse case folding data, or no string ','line_number':343,'multiline':True]['text':' the string is too short to find any match ','line_number':346,'multiline':True]['text':'
         * more precise would be:
         * if(!u_strHasMoreChar32Than(s, length, 1))
         * but this does not make much practical difference because
         * a single supplementary code point would just not be found
         ','line_number':347,'multiline':True]['text':' the string is too long to find any match ','line_number':363,'multiline':True]['text':' do a binary search for the string ','line_number':367,'multiline':True]['text':' found the string: add each code point, and its case closure ','line_number':376,'multiline':True]['text':' result>0 ','line_number':387,'multiline':True]['text':' string not found ','line_number':392,'multiline':True]['text':' Advance past the last-delivered code point.','line_number':409,'multiline':False]['text':' Set "full" to the NUL-terminated string in the first unfold column.','line_number':417,'multiline':False]['text':' Return the code point.','line_number':421,'multiline':False]['text':'* @return UCASE_NONE, UCASE_LOWER, UCASE_UPPER, UCASE_TITLE ','line_number':429,'multiline':True]['text':'* @return same as ucase_getType() and set bit 2 if c is case-ignorable ','line_number':436,'multiline':True]['text':'* @return UCASE_NO_DOT, UCASE_SOFT_DOTTED, UCASE_ABOVE, UCASE_OTHER_ACCENT ','line_number':443,'multiline':True]['text':' string casing ------------------------------------------------------------ ','line_number':466,'multiline':True]['text':'
 * These internal functions form the core of string case mappings.
 * They map single code points to result code points or strings and take
 * all necessary conditions (context, locale ID, options) into account.
 *
 * They do not iterate over the source or write to the destination
 * so that the same functions are useful for non-standard string storage,
 * such as in a Replaceable (for Transliterator) or UTF-8/32 strings etc.
 * For the same reason, the "surrounding text" context is passed in as a
 * UCaseContextIterator which does not make any assumptions about
 * the underlying storage.
 *
 * This section contains helper functions that check for conditions
 * in the input text surrounding the current code point
 * according to SpecialCasing.txt.
 *
 * Each helper function gets the index
 * - after the current code point if it looks at following text
 * - before the current code point if it looks at preceding text
 *
 * Unicode 3.2 UAX 21 "Case Mappings" defines the conditions as follows:
 *
 * Final_Sigma
 *   C is preceded by a sequence consisting of
 *     a cased letter and a case-ignorable sequence,
 *   and C is not followed by a sequence consisting of
 *     an ignorable sequence and then a cased letter.
 *
 * More_Above
 *   C is followed by one or more characters of combining class 230 (ABOVE)
 *   in the combining character sequence.
 *
 * After_Soft_Dotted
 *   The last preceding character with combining class of zero before C
 *   was Soft_Dotted,
 *   and there is no intervening combining character class 230 (ABOVE).
 *
 * Before_Dot
 *   C is followed by combining dot above (U+0307).
 *   Any sequence of characters with a combining class that is neither 0 nor 230
 *   may intervene between the current character and the combining dot above.
 *
 * The erratum from 2002-10-31 adds the condition
 *
 * After_I
 *   The last preceding base character was an uppercase I, and there is no
 *   intervening combining character class 230 (ABOVE).
 *
 *   (See Jitterbug 2344 and the comments on After_I below.)
 *
 * Helper definitions in Unicode 3.2 UAX 21:
 *
 * D1. A character C is defined to be cased
 *     if it meets any of the following criteria:
 *
 *   - The general category of C is Titlecase Letter (Lt)
 *   - In [CoreProps], C has one of the properties Uppercase, or Lowercase
 *   - Given D = NFD(C), then it is not the case that:
 *     D = UCD_lower(D) = UCD_upper(D) = UCD_title(D)
 *     (This third criterium does not add any characters to the list
 *      for Unicode 3.2. Ignored.)
 *
 * D2. A character C is defined to be case-ignorable
 *     if it meets either of the following criteria:
 *
 *   - The general category of C is
 *     Nonspacing Mark (Mn), or Enclosing Mark (Me), or Format Control (Cf), or
 *     Letter Modifier (Lm), or Symbol Modifier (Sk)
 *   - C is one of the following characters 
 *     U+0027 APOSTROPHE
 *     U+00AD SOFT HYPHEN (SHY)
 *     U+2019 RIGHT SINGLE QUOTATION MARK
 *            (the preferred character for apostrophe)
 *
 * D3. A case-ignorable sequence is a sequence of
 *     zero or more case-ignorable characters.
 ','line_number':468,'multiline':True]['text':' separator? ','line_number':557,'multiline':True]['text':'*
 * Requires non-NULL locale ID but otherwise does the equivalent of
 * checking for language codes as if uloc_getLanguage() were called:
 * Accepts both 2- and 3-letter codes and accepts case variants.
 ','line_number':560,'multiline':True]['text':'
     * This function used to use uloc_getLanguage(), but the current code
     * removes the dependency of this low-level code on uloc implementation code
     * and is faster because not the whole locale ID has to be
     * examined and copied/transformed.
     *
     * Because this code does not want to depend on uloc, the caller must
     * pass in a non-NULL locale, i.e., may need to call uloc_getDefault().
     ','line_number':576,'multiline':True]['text':' tr or tur? ','line_number':587,'multiline':True]['text':' az or aze? ','line_number':599,'multiline':True]['text':' lt or lit? ','line_number':611,'multiline':True]['text':' nl or nld? ','line_number':623,'multiline':True]['text':'
 * Is followed by
 *   {case-ignorable}* cased
 * ?
 * (dir determines looking forward/backward)
 * If a character is case-ignorable, it is skipped regardless of whether
 * it is also cased or not.
 ','line_number':642,'multiline':True]['text':' dir!=0 sets direction ','line_number':658,'multiline':True]['text':' case-ignorable, continue with the loop ','line_number':661,'multiline':True]['text':' followed by cased letter ','line_number':663,'multiline':True]['text':' uncased and not case-ignorable ','line_number':665,'multiline':True]['text':' not followed by cased letter ','line_number':669,'multiline':True]['text':' Is preceded by Soft_Dotted character with no intervening cc=230 ? ','line_number':672,'multiline':True]['text':' preceded by TYPE_i ','line_number':686,'multiline':True]['text':' preceded by different base character (not TYPE_i), or intervening cc==230 ','line_number':688,'multiline':True]['text':' not preceded by TYPE_i ','line_number':692,'multiline':True]['text':'
 * See Jitterbug 2344:
 * The condition After_I for Turkic-lowercasing of U+0307 combining dot above
 * is checked in ICU 2.0, 2.1, 2.6 but was not in 2.2 & 2.4 because
 * we made those releases compatible with Unicode 3.2 which had not fixed
 * a related bug in SpecialCasing.txt.
 *
 * From the Jitterbug 2344 text:
 * ... this bug is listed as a Unicode erratum
 * from 2002-10-31 at http://www.unicode.org/uni2errata/UnicodeErrata.html
 * <quote>
 * There are two errors in SpecialCasing.txt.
 * 1. Missing semicolons on two lines. ... [irrelevant for ICU]
 * 2. An incorrect context definition. Correct as follows:
 * < 0307; ; 0307; 0307; tr After_Soft_Dotted; # COMBINING DOT ABOVE
 * < 0307; ; 0307; 0307; az After_Soft_Dotted; # COMBINING DOT ABOVE
 * ---
 * > 0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
 * > 0307; ; 0307; 0307; az After_I; # COMBINING DOT ABOVE
 * where the context After_I is defined as:
 * The last preceding base character was an uppercase I, and there is no
 * intervening combining character class 230 (ABOVE).
 * </quote>
 *
 * Note that SpecialCasing.txt even in Unicode 3.2 described the condition as:
 *
 * # When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
 * # This matches the behavior of the canonically equivalent I-dot_above
 *
 * See also the description in this place in older versions of uchar.c (revision 1.100).
 *
 * Markus W. Scherer 2003-feb-15
 ','line_number':695,'multiline':True]['text':' Is preceded by base character 'I' with no intervening cc=230 ? ','line_number':729,'multiline':True]['text':' preceded by I ','line_number':742,'multiline':True]['text':' preceded by different base character (not I), or intervening cc==230 ','line_number':746,'multiline':True]['text':' not preceded by I ','line_number':750,'multiline':True]['text':' Is followed by one or more cc==230 ? ','line_number':753,'multiline':True]['text':' at least one cc==230 following ','line_number':767,'multiline':True]['text':' next base character, no more cc==230 following ','line_number':769,'multiline':True]['text':' no more cc==230 following ','line_number':773,'multiline':True]['text':' Is followed by a dot above (without cc==230 in between) ? ','line_number':776,'multiline':True]['text':' next base character or cc==230 in between ','line_number':793,'multiline':True]['text':' no dot above following ','line_number':797,'multiline':True]['text':' use hardcoded conditions and mappings ','line_number':820,'multiline':True]['text':'
             * Test for conditional mappings first
             *   (otherwise the unconditional default mappings are always taken),
             * then test for characters that have unconditional mappings in SpecialCasing.txt,
             * then get the UnicodeData.txt mappings.
             ','line_number':823,'multiline':True]['text':' base characters, find accents above ','line_number':830,'multiline':True]['text':' precomposed with accent above, no need to find one ','line_number':833,'multiline':True]['text':'
                    # Lithuanian

                    # Lithuanian retains the dot in a lowercase i when followed by accents.

                    # Introduce an explicit dot above when lowercasing capital I's and J's
                    # whenever there are more accents above.
                    # (of the accents used in Lithuanian: grave, acute, tilde above, and ogonek)

                    0049; 0069 0307; 0049; 0049; lt More_Above; # LATIN CAPITAL LETTER I
                    004A; 006A 0307; 004A; 004A; lt More_Above; # LATIN CAPITAL LETTER J
                    012E; 012F 0307; 012E; 012E; lt More_Above; # LATIN CAPITAL LETTER I WITH OGONEK
                    00CC; 0069 0307 0300; 00CC; 00CC; lt; # LATIN CAPITAL LETTER I WITH GRAVE
                    00CD; 0069 0307 0301; 00CD; 00CD; lt; # LATIN CAPITAL LETTER I WITH ACUTE
                    0128; 0069 0307 0303; 0128; 0128; lt; # LATIN CAPITAL LETTER I WITH TILDE
                 ','line_number':836,'multiline':True]['text':' LATIN CAPITAL LETTER I ','line_number':853,'multiline':True]['text':' LATIN CAPITAL LETTER J ','line_number':856,'multiline':True]['text':' LATIN CAPITAL LETTER I WITH OGONEK ','line_number':859,'multiline':True]['text':' LATIN CAPITAL LETTER I WITH GRAVE ','line_number':862,'multiline':True]['text':' LATIN CAPITAL LETTER I WITH ACUTE ','line_number':865,'multiline':True]['text':' LATIN CAPITAL LETTER I WITH TILDE ','line_number':868,'multiline':True]['text':' will not occur ','line_number':872,'multiline':True]['text':' # Turkish and Azeri ','line_number':874,'multiline':True]['text':'
                    # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
                    # The following rules handle those cases.

                    0130; 0069; 0130; 0130; tr # LATIN CAPITAL LETTER I WITH DOT ABOVE
                    0130; 0069; 0130; 0130; az # LATIN CAPITAL LETTER I WITH DOT ABOVE
                 ','line_number':876,'multiline':True]['text':'
                    # When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
                    # This matches the behavior of the canonically equivalent I-dot_above

                    0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
                    0307; ; 0307; 0307; az After_I; # COMBINING DOT ABOVE
                 ','line_number':885,'multiline':True]['text':' remove the dot (continue without output) ','line_number':892,'multiline':True]['text':'
                    # When lowercasing, unless an I is before a dot_above, it turns into a dotless i.

                    0049; 0131; 0049; 0049; tr Not_Before_Dot; # LATIN CAPITAL LETTER I
                    0049; 0131; 0049; 0049; az Not_Before_Dot; # LATIN CAPITAL LETTER I
                 ','line_number':894,'multiline':True]['text':'
                    # Preserve canonical equivalence for I with dot. Turkic is handled below.

                    0130; 0069 0307; 0130; 0130; # LATIN CAPITAL LETTER I WITH DOT ABOVE
                 ','line_number':902,'multiline':True]['text':' -1=preceded ','line_number':911,'multiline':True]['text':' greek capital sigma maps depending on surrounding cased letters (see SpecialCasing.txt) ','line_number':913,'multiline':True]['text':'
                    # Special case for final form of sigma

                    03A3; 03C2; 03A3; 03A3; Final_Sigma; # GREEK CAPITAL LETTER SIGMA
                 ','line_number':914,'multiline':True]['text':' greek small final sigma ','line_number':919,'multiline':True]['text':' no known conditional special case mapping, use a normal mapping ','line_number':921,'multiline':True]['text':' set the output pointer to the lowercase mapping ','line_number':927,'multiline':True]['text':' return the string length ','line_number':930,'multiline':True]['text':' internal ','line_number':943,'multiline':True]['text':' use hardcoded conditions and mappings ','line_number':964,'multiline':True]['text':'
                    # Turkish and Azeri

                    # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
                    # The following rules handle those cases.

                    # When uppercasing, i turns into a dotted capital I

                    0069; 0069; 0130; 0130; tr; # LATIN SMALL LETTER I
                    0069; 0069; 0130; 0130; az; # LATIN SMALL LETTER I
                ','line_number':968,'multiline':True]['text':'
                    # Lithuanian

                    # Lithuanian retains the dot in a lowercase i when followed by accents.

                    # Remove DOT ABOVE after "i" with upper or titlecase

                    0307; 0307; ; ; lt After_Soft_Dotted; # COMBINING DOT ABOVE
                 ','line_number':981,'multiline':True]['text':' remove the dot (continue without output) ','line_number':990,'multiline':True]['text':' no known conditional special case mapping, use a normal mapping ','line_number':992,'multiline':True]['text':' start of full case mapping strings ','line_number':997,'multiline':True]['text':' skip the lowercase and case-folding result strings ','line_number':1000,'multiline':True]['text':' skip the uppercase result string ','line_number':1009,'multiline':True]['text':' set the output pointer to the result string ','line_number':1015,'multiline':True]['text':' return the string length ','line_number':1018,'multiline':True]['text':' here, titlecase is same as uppercase ','line_number':1026,'multiline':True]['text':' case folding ------------------------------------------------------------- ','line_number':1053,'multiline':True]['text':'
 * Case folding is similar to lowercasing.
 * The result may be a simple mapping, i.e., a single code point, or
 * a full mapping, i.e., a string.
 * If the case folding for a code point is the same as its simple (1:1) lowercase mapping,
 * then only the lowercase mapping is stored.
 *
 * Some special cases are hardcoded because their conditions cannot be
 * parsed and processed from CaseFolding.txt.
 *
 * Unicode 3.2 CaseFolding.txt specifies for its status field:

# C: common case folding, common mappings shared by both simple and full mappings.
# F: full case folding, mappings that cause strings to grow in length. Multiple characters are separated by spaces.
# S: simple case folding, mappings to single characters where different from F.
# T: special case for uppercase I and dotted uppercase I
#    - For non-Turkic languages, this mapping is normally not used.
#    - For Turkic languages (tr, az), this mapping can be used instead of the normal mapping for these characters.
#
# Usage:
#  A. To do a simple case folding, use the mappings with status C + S.
#  B. To do a full case folding, use the mappings with status C + F.
#
#    The mappings with status T can be used or omitted depending on the desired case-folding
#    behavior. (The default option is to exclude them.)

 * Unicode 3.2 has 'T' mappings as follows:

0049; T; 0131; # LATIN CAPITAL LETTER I
0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE

 * while the default mappings for these code points are:

0049; C; 0069; # LATIN CAPITAL LETTER I
0130; F; 0069 0307; # LATIN CAPITAL LETTER I WITH DOT ABOVE

 * U+0130 has no simple case folding (simple-case-folds to itself).
 ','line_number':1055,'multiline':True]['text':' return the simple case folding mapping for c ','line_number':1094,'multiline':True]['text':' special case folding mappings, hardcoded ','line_number':1107,'multiline':True]['text':' default mappings ','line_number':1109,'multiline':True]['text':' 0049; C; 0069; # LATIN CAPITAL LETTER I ','line_number':1111,'multiline':True]['text':' no simple case folding for U+0130 ','line_number':1114,'multiline':True]['text':' Turkic mappings ','line_number':1118,'multiline':True]['text':' 0049; T; 0131; # LATIN CAPITAL LETTER I ','line_number':1120,'multiline':True]['text':' 0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE ','line_number':1123,'multiline':True]['text':'
 * Issue for canonical caseless match (UAX #21):
 * Turkic casefolding (using "T" mappings in CaseFolding.txt) does not preserve
 * canonical equivalence, unlike default-option casefolding.
 * For example, I-grave and I + grave fold to strings that are not canonically
 * equivalent.
 * For more details, see the comment in unorm_compare() in unorm.cpp
 * and the intermediate prototype changes for Jitterbug 2021.
 * (For example, revision 1.104 of uchar.c and 1.4 of CaseFolding.txt.)
 *
 * This did not get fixed because it appears that it is not possible to fix
 * it for uppercase and lowercase characters (I-grave vs. i-grave)
 * together in a way that they still fold to common result strings.
 ','line_number':1140,'multiline':True]['text':' use hardcoded conditions and mappings ','line_number':1174,'multiline':True]['text':' default mappings ','line_number':1176,'multiline':True]['text':' 0049; C; 0069; # LATIN CAPITAL LETTER I ','line_number':1178,'multiline':True]['text':' 0130; F; 0069 0307; # LATIN CAPITAL LETTER I WITH DOT ABOVE ','line_number':1181,'multiline':True]['text':' Turkic mappings ','line_number':1186,'multiline':True]['text':' 0049; T; 0131; # LATIN CAPITAL LETTER I ','line_number':1188,'multiline':True]['text':' 0130; T; 0069; # LATIN CAPITAL LETTER I WITH DOT ABOVE ','line_number':1191,'multiline':True]['text':' start of full case mapping strings ','line_number':1198,'multiline':True]['text':' skip the lowercase result string ','line_number':1201,'multiline':True]['text':' set the output pointer to the result string ','line_number':1206,'multiline':True]['text':' return the string length ','line_number':1209,'multiline':True]['text':' case mapping properties API ---------------------------------------------- ','line_number':1227,'multiline':True]['text':' public API (see uchar.h) ','line_number':1231,'multiline':True]['text':' Transforms the Unicode character to its lower case equivalent.','line_number':1243,'multiline':True]['text':' Transforms the Unicode character to its upper case equivalent.','line_number':1249,'multiline':True]['text':' Transforms the Unicode character to its title case equivalent.','line_number':1255,'multiline':True]['text':' return the simple case folding mapping for c ','line_number':1261,'multiline':True]['text':' case mapping properties ','line_number':1269,'multiline':True]['text':'
     * Note: The following Changes_When_Xyz are defined as testing whether
     * the NFD form of the input changes when Xyz-case-mapped.
     * However, this simpler implementation of these properties,
     * ignoring NFD, passes the tests.
     * The implementation needs to be changed if the tests start failing.
     * When that happens, optimizations should be used to work with the
     * per-single-code point ucase_toFullXyz() functions unless
     * the NFD form has more than one code point,
     * and the property starts set needs to be the union of the
     * start sets for normalization and case mappings.
     ','line_number':1289,'multiline':True]['text':' case UCHAR_CHANGES_WHEN_CASEFOLDED: -- in uprops.c ','line_number':1310,'multiline':True]