['text':' Copyright 2011 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':3,'multiline':False]['text':' modification, are permitted provided that the following conditions are','line_number':4,'multiline':False]['text':' met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'     * Redistributions of source code must retain the above copyright','line_number':7,'multiline':False]['text':' notice, this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'     * Redistributions in binary form must reproduce the above','line_number':9,'multiline':False]['text':' copyright notice, this list of conditions and the following disclaimer','line_number':10,'multiline':False]['text':' in the documentation and/or other materials provided with the','line_number':11,'multiline':False]['text':' distribution.','line_number':12,'multiline':False]['text':'     * Neither the name of Google Inc. nor the names of its','line_number':13,'multiline':False]['text':' contributors may be used to endorse or promote products derived from','line_number':14,'multiline':False]['text':' this software without specific prior written permission.','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':17,'multiline':False]['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':18,'multiline':False]['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':19,'multiline':False]['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':20,'multiline':False]['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':21,'multiline':False]['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':22,'multiline':False]['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':23,'multiline':False]['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':24,'multiline':False]['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':25,'multiline':False]['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':26,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' Various stubs for the open-source version of Snappy.','line_number':29,'multiline':False]['text':' defined(_MSC_VER)','line_number':54,'multiline':False]['text':' Enable 64-bit optimized versions of some routines.','line_number':60,'multiline':False]['text':' Needed by OS X, among others.','line_number':73,'multiline':False]['text':' The size of an array, if known at compile-time.','line_number':78,'multiline':False]['text':' Will give unexpected results if used on a pointer.','line_number':79,'multiline':False]['text':' We undefine it first, since some compilers already have a definition.','line_number':80,'multiline':False]['text':' Static prediction hints.','line_number':86,'multiline':False]['text':' This is only used for recomputing the tag byte table used during','line_number':95,'multiline':False]['text':' decompression; for simplicity we just remove it from the open-source','line_number':96,'multiline':False]['text':' version (anyone who wants to regenerate it can just do the call','line_number':97,'multiline':False]['text':' themselves within main()).','line_number':98,'multiline':False]['text':' Potentially unaligned loads and stores.','line_number':109,'multiline':False]['text':' x86, PowerPC, and ARM64 can simply do these loads and stores native.','line_number':111,'multiline':False]['text':' MongoDB customization: Prefer memcpy on all architectures. Using reinterpret_cast is undefined','line_number':113,'multiline':False]['text':' behavior.','line_number':114,'multiline':False]['text':' ARMv7 and newer support native unaligned accesses, but only of 16-bit','line_number':126,'multiline':False]['text':' and 32-bit values (not 64-bit); older versions either raise a fatal signal,','line_number':127,'multiline':False]['text':' do an unaligned read and rotate the words around a bit, or do the reads very','line_number':128,'multiline':False]['text':' slowly (trip through kernel mode). There's no simple #define that says just','line_number':129,'multiline':False]['text':' “ARMv7 or higher”, so we have to filter away all ARMv5 and ARMv6','line_number':130,'multiline':False]['text':' sub-architectures.','line_number':131,'multiline':False]['text':'','line_number':132,'multiline':False]['text':' This is a mess, but there's not much we can do about it.','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':' To further complicate matters, only LDR instructions (single reads) are','line_number':135,'multiline':False]['text':' allowed to be unaligned, not LDRD (two reads) or LDM (many reads). Unless we','line_number':136,'multiline':False]['text':' explicitly tell the compiler that these accesses can be unaligned, it can and','line_number':137,'multiline':False]['text':' will combine accesses. On armcc, the way to signal this is done by accessing','line_number':138,'multiline':False]['text':' through the type (uint32 __packed *), but GCC has no such attribute','line_number':139,'multiline':False]['text':' (it ignores __attribute__((packed)) on individual variables). However,','line_number':140,'multiline':False]['text':' we can tell it that a _struct_ is unaligned, which has the same effect,','line_number':141,'multiline':False]['text':' so we do that.','line_number':142,'multiline':False]['text':' MongoDB customization: See memcpy notes above','line_number':144,'multiline':False]['text':' To make the size non-power-of-two.','line_number':170,'multiline':False]['text':' To make the size non-power-of-two.','line_number':175,'multiline':False]['text':' namespace internal','line_number':178,'multiline':False]['text':' namespace base','line_number':179,'multiline':False]['text':' TODO(user): NEON supports unaligned 64-bit loads and stores.','line_number':193,'multiline':False]['text':' See if that would be more efficient on platforms supporting it,','line_number':194,'multiline':False]['text':' at least for copies.','line_number':195,'multiline':False]['text':' These functions are provided for architectures that don't support','line_number':209,'multiline':False]['text':' unaligned loads and stores.','line_number':210,'multiline':False]['text':' The following guarantees declaration of the byte swap functions.','line_number':244,'multiline':False]['text':' Mac OS X / Darwin features','line_number':262,'multiline':False]['text':' FreeBSD defines bswap{16,32,64} in <sys/endian.h> (already #included).','line_number':272,'multiline':False]['text':' Solaris 10 defines BSWAP_{16,32,64} in <sys/byteorder.h> (already #included).','line_number':278,'multiline':False]['text':' defined(SNAPPY_IS_BIG_ENDIAN)','line_number':302,'multiline':False]['text':' Convert to little-endian storage, opposite of network format.','line_number':304,'multiline':False]['text':' Convert x from host to little endian: x = LittleEndian.FromHost(x);','line_number':305,'multiline':False]['text':' convert x from little endian to host: x = LittleEndian.ToHost(x);','line_number':306,'multiline':False]['text':'','line_number':307,'multiline':False]['text':'  Store values into unaligned memory converting to little endian order:','line_number':308,'multiline':False]['text':'    LittleEndian.Store16(p, x);','line_number':309,'multiline':False]['text':'','line_number':310,'multiline':False]['text':'  Load unaligned values stored in little endian converting to host order:','line_number':311,'multiline':False]['text':'    x = LittleEndian.Load16(p);','line_number':312,'multiline':False]['text':' Conversion functions.','line_number':315,'multiline':False]['text':' !defined(SNAPPY_IS_BIG_ENDIAN)','line_number':326,'multiline':False]['text':' !defined(SNAPPY_IS_BIG_ENDIAN)','line_number':336,'multiline':False]['text':' Functions to do unaligned loads and stores in little-endian order.','line_number':338,'multiline':False]['text':' Some bit-manipulation functions.','line_number':356,'multiline':False]['text':' Return floor(log2(n)) for positive integer n.  Returns -1 iff n == 0.','line_number':359,'multiline':False]['text':' Return the first set least / most significant bit, 0-indexed.  Returns an','line_number':362,'multiline':False]['text':' undefined value if n == 0.  FindLSBSetNonZero() is similar to ffs() except','line_number':363,'multiline':False]['text':' that it's 0-indexed.','line_number':364,'multiline':False]['text':' defined(ARCH_K8) || defined(ARCH_PPC) || defined(ARCH_ARM)','line_number':369,'multiline':False]['text':' No copying','line_number':372,'multiline':False]['text':' defined(ARCH_K8) || defined(ARCH_PPC) || defined(ARCH_ARM)','line_number':391,'multiline':False]['text':' defined(ARCH_K8) || defined(ARCH_PPC) || defined(ARCH_ARM)','line_number':416,'multiline':False]['text':' Portable versions.','line_number':418,'multiline':False]['text':' FindLSBSetNonZero64() is defined in terms of FindLSBSetNonZero().','line_number':451,'multiline':False]['text':' Bottom bits are zero, so scan in top bits','line_number':455,'multiline':False]['text':' defined(ARCH_K8) || defined(ARCH_PPC) || defined(ARCH_ARM)','line_number':461,'multiline':False]['text':' End portable versions.','line_number':463,'multiline':False]['text':' Variable-length integer encoding.','line_number':465,'multiline':False]['text':' Maximum lengths of varint encoding of uint32.','line_number':468,'multiline':False]['text':' Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].','line_number':471,'multiline':False]['text':' Never reads a character at or beyond limit.  If a valid/terminated varint32','line_number':472,'multiline':False]['text':' was found in the range, stores it in *OUTPUT and returns a pointer just','line_number':473,'multiline':False]['text':' past the last byte of the varint32. Else returns NULL.  On success,','line_number':474,'multiline':False]['text':' "result <= limit".','line_number':475,'multiline':False]['text':' REQUIRES   "ptr" points to a buffer of length sufficient to hold "v".','line_number':479,'multiline':False]['text':' EFFECTS    Encodes "v" into "ptr" and returns a pointer to the','line_number':480,'multiline':False]['text':'            byte just past the last encoded byte.','line_number':481,'multiline':False]['text':' EFFECTS    Appends the varint representation of "value" to "*s".','line_number':484,'multiline':False]['text':' Value is too long to be a varint32','line_number':504,'multiline':False]['text':' Operate on characters as unsigneds','line_number':511,'multiline':False]['text':' If you know the internal layout of the std::string in use, you can','line_number':538,'multiline':False]['text':' replace this function with one that resizes the string without','line_number':539,'multiline':False]['text':' filling the new space with zeros (if applicable) --','line_number':540,'multiline':False]['text':' it will be non-portable but faster.','line_number':541,'multiline':False]['text':' Return a mutable char* pointing to a string's internal buffer,','line_number':546,'multiline':False]['text':' which may not be null-terminated. Writing through this pointer will','line_number':547,'multiline':False]['text':' modify the string.','line_number':548,'multiline':False]['text':'','line_number':549,'multiline':False]['text':' string_as_array(&str)[i] is valid for 0 <= i < str.size() until the','line_number':550,'multiline':False]['text':' next call to a string method that invalidates iterators.','line_number':551,'multiline':False]['text':'','line_number':552,'multiline':False]['text':' As of 2006-04, there is no standard-blessed way of getting a','line_number':553,'multiline':False]['text':' mutable reference to a string's internal buffer. However, issue 530','line_number':554,'multiline':False]['text':' (http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-defects.html#530)','line_number':555,'multiline':False]['text':' proposes this as the method. It will officially be part of the standard','line_number':556,'multiline':False]['text':' for C++0x. This should already work on all current implementations.','line_number':557,'multiline':False]['text':' namespace snappy','line_number':562,'multiline':False]['text':' THIRD_PARTY_SNAPPY_OPENSOURCE_SNAPPY_STUBS_INTERNAL_H_','line_number':564,'multiline':False]