['text':' Copyright 2005 and onwards Google Inc.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':3,'multiline':False]['text':' modification, are permitted provided that the following conditions are','line_number':4,'multiline':False]['text':' met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'     * Redistributions of source code must retain the above copyright','line_number':7,'multiline':False]['text':' notice, this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'     * Redistributions in binary form must reproduce the above','line_number':9,'multiline':False]['text':' copyright notice, this list of conditions and the following disclaimer','line_number':10,'multiline':False]['text':' in the documentation and/or other materials provided with the','line_number':11,'multiline':False]['text':' distribution.','line_number':12,'multiline':False]['text':'     * Neither the name of Google Inc. nor the names of its','line_number':13,'multiline':False]['text':' contributors may be used to endorse or promote products derived from','line_number':14,'multiline':False]['text':' this software without specific prior written permission.','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':17,'multiline':False]['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':18,'multiline':False]['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':19,'multiline':False]['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':20,'multiline':False]['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':21,'multiline':False]['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':22,'multiline':False]['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':23,'multiline':False]['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':24,'multiline':False]['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':25,'multiline':False]['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':26,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':27,'multiline':False]['text':' To test against code that reads beyond its input, this class copies a','line_number':68,'multiline':False]['text':' string to a newly allocated group of pages, the last of which','line_number':69,'multiline':False]['text':' is made unreadable via mprotect. Note that we need to allocate the','line_number':70,'multiline':False]['text':' memory with mmap(), as POSIX allows mprotect() only on memory allocated','line_number':71,'multiline':False]['text':' with mmap(), and some malloc/posix_memalign implementations expect to','line_number':72,'multiline':False]['text':' be able to read previously allocated memory while doing heap allocations.','line_number':73,'multiline':False]['text':' Round up space for string to a multiple of page_size.','line_number':79,'multiline':False]['text':' Make guard page unreadable.','line_number':90,'multiline':False]['text':' Undo the mprotect.','line_number':96,'multiline':False]['text':' defined(HAVE_FUNC_MMAP) && defined(HAVE_FUNC_SYSCONF)','line_number':112,'multiline':False]['text':' Fallback for systems without mmap.','line_number':114,'multiline':False]['text':' ZLIB_VERSION','line_number':133,'multiline':False]['text':' LZO_VERSION','line_number':138,'multiline':False]['text':' Returns true if we successfully compressed, false otherwise.','line_number':149,'multiline':False]['text':'','line_number':150,'multiline':False]['text':' If compressed_is_preallocated is set, do not resize the compressed buffer.','line_number':151,'multiline':False]['text':' This is typically what you want for a benchmark, in order to not spend','line_number':152,'multiline':False]['text':' time in the memory allocator. If you do set this flag, however,','line_number':153,'multiline':False]['text':' "compressed" must be preinitialized to at least MinCompressbufSize(comp)','line_number':154,'multiline':False]['text':' number of bytes, and may contain junk bytes at the end after return.','line_number':155,'multiline':False]['text':' ZLIB_VERSION','line_number':178,'multiline':False]['text':' LZO_VERSION','line_number':197,'multiline':False]['text':' the asked-for library wasn't compiled in','line_number':212,'multiline':False]['text':' ZLIB_VERSION','line_number':235,'multiline':False]['text':' LZO_VERSION','line_number':251,'multiline':False]['text':' the asked-for library wasn't compiled in','line_number':260,'multiline':False]['text':' Run tests a few time and pick median running times','line_number':271,'multiline':False]['text':' Chop the input into blocks','line_number':278,'multiline':False]['text':' Pre-grow the output buffer so we don't measure string append time.','line_number':290,'multiline':False]['text':' First, try one trial compression to make sure the code is compiled in','line_number':294,'multiline':False]['text':' Pre-grow the output buffer so we don't measure string append time.','line_number':305,'multiline':False]['text':' Compress once more, with resizing, so we don't leave junk','line_number':315,'multiline':False]['text':' at the end that will confuse the decompressor.','line_number':316,'multiline':False]['text':' Try uncompressing into an iovec containing a random number of entries','line_number':405,'multiline':False]['text':' ranging from 1 to 10.','line_number':406,'multiline':False]['text':' Randomly choose to insert a 0 byte entry.','line_number':420,'multiline':False]['text':' Test that data compressed by a compressor that does not','line_number':436,'multiline':False]['text':' obey block sizes is uncompressed properly.','line_number':437,'multiline':False]['text':' We cannot test larger blocks than the maximum block size, obviously.','line_number':440,'multiline':False]['text':' Setup compression table','line_number':447,'multiline':False]['text':' Compress entire input in one shot','line_number':452,'multiline':False]['text':' Uncompress into string','line_number':461,'multiline':False]['text':' Uncompress using source/sink','line_number':466,'multiline':False]['text':' Uncompress into iovec','line_number':474,'multiline':False]['text':' Expand the input so that it is at least K times as big as block size','line_number':490,'multiline':False]['text':' Compress using string based routines','line_number':503,'multiline':False]['text':' Verify using sink based routines','line_number':506,'multiline':False]['text':' This test checks to ensure that snappy doesn't coredump if it gets','line_number':528,'multiline':False]['text':' corrupted data.','line_number':529,'multiline':False]['text':' Mess around with the data. It's hard to simulate all possible','line_number':537,'multiline':False]['text':' corruptions; this is just one example ...','line_number':538,'multiline':False]['text':' this really ought to fail.','line_number':542,'multiline':False]['text':' This is testing for a security bug - a buffer that decompresses to 100k','line_number':546,'multiline':False]['text':' but we lie in the snappy header and only reserve 0 bytes of memory :)','line_number':547,'multiline':False]['text':' Another security check; check a crazy big length can't DoS us with an','line_number':558,'multiline':False]['text':' over-allocation.','line_number':559,'multiline':False]['text':' Currently this is done only for 32-bit builds.  On 64-bit builds,','line_number':560,'multiline':False]['text':' where 3 GB might be an acceptable allocation size, Uncompress()','line_number':561,'multiline':False]['text':' attempts to decompress, and sometimes causes the test to run out of','line_number':562,'multiline':False]['text':' memory.','line_number':563,'multiline':False]['text':' This decodes to a really large size, i.e., about 3 GB.','line_number':565,'multiline':False]['text':' This decodes to about 2 MB; much smaller, but should still fail.','line_number':573,'multiline':False]['text':' try reading stuff in from a bad file.','line_number':579,'multiline':False]['text':' check that we don't return a crazy length','line_number':584,'multiline':False]['text':' Helper routines to construct arbitrary compressed strings.','line_number':597,'multiline':False]['text':' These mirror the compression code in snappy.cc, but are copied','line_number':598,'multiline':False]['text':' here so that we can bypass some limitations in the how snappy.cc','line_number':599,'multiline':False]['text':' invokes these routines.','line_number':600,'multiline':False]['text':' Fit length in tag byte','line_number':605,'multiline':False]['text':' Encode in upcoming bytes','line_number':608,'multiline':False]['text':' Figure out how much to copy in one shot','line_number':623,'multiline':False]['text':' Must fit in 3 bits','line_number':635,'multiline':False]['text':' Verify max blowup (lots of four-byte copies)','line_number':665,'multiline':False]['text':' The new compressor cannot generate four-byte offsets since','line_number':711,'multiline':False]['text':' it chops up the input into 32KB pieces.  So we hand-emit the','line_number':712,'multiline':False]['text':' copy manually.','line_number':713,'multiline':False]['text':' The two fragments that make up the input string.','line_number':715,'multiline':False]['text':' How many times each fragment is emitted.','line_number':719,'multiline':False]['text':' Test some tricky edge cases in the iovec output that are not necessarily','line_number':745,'multiline':False]['text':' exercised by random tests.','line_number':746,'multiline':False]['text':' Our output blocks look like this initially (the last iovec is bigger','line_number':748,'multiline':False]['text':' than depicted):','line_number':749,'multiline':False]['text':' [  ] [ ] [    ] [        ] [        ]','line_number':750,'multiline':False]['text':' A literal whose output crosses three blocks.','line_number':762,'multiline':False]['text':' [ab] [c] [123 ] [        ] [        ]','line_number':763,'multiline':False]['text':' A copy whose output crosses two blocks (source and destination','line_number':766,'multiline':False]['text':' segments marked).','line_number':767,'multiline':False]['text':' [ab] [c] [1231] [23      ] [        ]','line_number':768,'multiline':False]['text':'           ^--^   --','line_number':769,'multiline':False]['text':' A copy where the input is, at first, in the block before the output:','line_number':772,'multiline':False]['text':'','line_number':773,'multiline':False]['text':' [ab] [c] [1231] [231231  ] [        ]','line_number':774,'multiline':False]['text':'           ^---     ^---','line_number':775,'multiline':False]['text':' Then during the copy, the pointers move such that the input and','line_number':776,'multiline':False]['text':' output pointers are in the same block:','line_number':777,'multiline':False]['text':'','line_number':778,'multiline':False]['text':' [ab] [c] [1231] [23123123] [        ]','line_number':779,'multiline':False]['text':'                  ^-    ^-','line_number':780,'multiline':False]['text':' And then they move again, so that the output pointer is no longer','line_number':781,'multiline':False]['text':' in the same block as the input pointer:','line_number':782,'multiline':False]['text':' [ab] [c] [1231] [23123123] [123     ]','line_number':783,'multiline':False]['text':'                    ^--      ^--','line_number':784,'multiline':False]['text':' Finally, a copy where the input is from several blocks back,','line_number':787,'multiline':False]['text':' and it also crosses three blocks:','line_number':788,'multiline':False]['text':'','line_number':789,'multiline':False]['text':' [ab] [c] [1231] [23123123] [123b    ]','line_number':790,'multiline':False]['text':'   ^                            ^','line_number':791,'multiline':False]['text':' [ab] [c] [1231] [23123123] [123bc   ]','line_number':792,'multiline':False]['text':'       ^                         ^','line_number':793,'multiline':False]['text':' [ab] [c] [1231] [23123123] [123bc12 ]','line_number':794,'multiline':False]['text':'           ^-                     ^-','line_number':795,'multiline':False]['text':' Check that we do not read past end of input','line_number':909,'multiline':False]['text':' Make a compressed string that ends with a single-byte literal','line_number':911,'multiline':False]['text':' Check for an infinite loop caused by a copy with offset==0','line_number':922,'multiline':False]['text':'  \x40              Length (must be > kMaxIncrementCopyOverflow)','line_number':925,'multiline':False]['text':'  \x12\x00\x00      Copy with offset==0, length==5','line_number':926,'multiline':False]['text':'  \x05              Length','line_number':933,'multiline':False]['text':'  \x12\x00\x00      Copy with offset==0, length==5','line_number':934,'multiline':False]['text':' namespace','line_number':947,'multiline':False]['text':' Exercise all different code paths through the function.','line_number':950,'multiline':False]['text':' 64-bit version:','line_number':951,'multiline':False]['text':' Hit s1_limit in 64-bit loop, hit s1_limit in single-character loop.','line_number':953,'multiline':False]['text':' Hit s1_limit in 64-bit loop, find a non-match in single-character loop.','line_number':957,'multiline':False]['text':' Same, but edge cases.','line_number':960,'multiline':False]['text':' Find non-match at once in first loop.','line_number':964,'multiline':False]['text':' Find non-match in first loop after one block.','line_number':970,'multiline':False]['text':' 32-bit version:','line_number':980,'multiline':False]['text':' Short matches.','line_number':982,'multiline':False]['text':' Hit s1_limit in 32-bit loop, hit s1_limit in single-character loop.','line_number':994,'multiline':False]['text':' Same, but edge cases.','line_number':999,'multiline':False]['text':' Hit s1_limit in 32-bit loop, find a non-match in single-character loop.','line_number':1003,'multiline':False]['text':' Find non-match at once in first loop.','line_number':1006,'multiline':False]['text':' Same, but edge cases.','line_number':1016,'multiline':False]['text':' Find non-match in first loop after one block.','line_number':1022,'multiline':False]['text':' Same, but edge cases.','line_number':1032,'multiline':False]['text':' Check that all of the fields fit within the allocated space','line_number':1069,'multiline':False]['text':' At most 3 bits','line_number':1070,'multiline':False]['text':' At most 3 bits','line_number':1071,'multiline':False]['text':' At most 7 bits','line_number':1072,'multiline':False]['text':' Check that the decompression table is correct, and optionally print out','line_number':1076,'multiline':False]['text':' the computed one.','line_number':1077,'multiline':False]['text':' Place invalid entries in all places to detect missing initialization','line_number':1087,'multiline':False]['text':' Small LITERAL entries.  We store (len-1) in the top 6 bits.','line_number':1093,'multiline':False]['text':' Large LITERAL entries.  We use 60..63 in the high 6 bits to','line_number':1099,'multiline':False]['text':' encode the number of bytes of length info that follow the opcode.','line_number':1100,'multiline':False]['text':' We set the length field in the lookup table to 1 because extra','line_number':1102,'multiline':False]['text':' bytes encode len-1.','line_number':1103,'multiline':False]['text':' COPY_1_BYTE_OFFSET.','line_number':1108,'multiline':False]['text':'','line_number':1109,'multiline':False]['text':' The tag byte in the compressed data stores len-4 in 3 bits, and','line_number':1110,'multiline':False]['text':' offset/256 in 5 bits.  offset%256 is stored in the next byte.','line_number':1111,'multiline':False]['text':'','line_number':1112,'multiline':False]['text':' This format is used for length in range [4..11] and offset in','line_number':1113,'multiline':False]['text':' range [0..2047]','line_number':1114,'multiline':False]['text':' COPY_2_BYTE_OFFSET.','line_number':1123,'multiline':False]['text':' Tag contains len-1 in top 6 bits, and offset in next two bytes.','line_number':1124,'multiline':False]['text':' COPY_4_BYTE_OFFSET.','line_number':1130,'multiline':False]['text':' Tag contents len-1 in top 6 bits, and offset in next four bytes.','line_number':1131,'multiline':False]['text':' Check that each entry was initialized exactly once.','line_number':1137,'multiline':False]['text':' Check that computed table matched recorded table.','line_number':1153,'multiline':False]['text':' For block-size based measurements','line_number':1202,'multiline':False]['text':' Pick file to process based on "arg"','line_number':1236,'multiline':False]['text':' Pick file to process based on "arg"','line_number':1262,'multiline':False]['text':' Pick file to process based on "arg"','line_number':1285,'multiline':False]['text':' Uncompress into an iovec containing ten entries.','line_number':1294,'multiline':False]['text':' Pick file to process based on "arg"','line_number':1331,'multiline':False]['text':' Pick file to process based on "arg"','line_number':1363,'multiline':False]['text':' namespace snappy','line_number':1390,'multiline':False]