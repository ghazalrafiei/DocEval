['text':' Copyright 2005 and onwards Google Inc.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Redistribution and use in source and binary forms, with or without','line_number':3,'multiline':False]['text':' modification, are permitted provided that the following conditions are','line_number':4,'multiline':False]['text':' met:','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'     * Redistributions of source code must retain the above copyright','line_number':7,'multiline':False]['text':' notice, this list of conditions and the following disclaimer.','line_number':8,'multiline':False]['text':'     * Redistributions in binary form must reproduce the above','line_number':9,'multiline':False]['text':' copyright notice, this list of conditions and the following disclaimer','line_number':10,'multiline':False]['text':' in the documentation and/or other materials provided with the','line_number':11,'multiline':False]['text':' distribution.','line_number':12,'multiline':False]['text':'     * Neither the name of Google Inc. nor the names of its','line_number':13,'multiline':False]['text':' contributors may be used to endorse or promote products derived from','line_number':14,'multiline':False]['text':' this software without specific prior written permission.','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':17,'multiline':False]['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':18,'multiline':False]['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':19,'multiline':False]['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':20,'multiline':False]['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':21,'multiline':False]['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':22,'multiline':False]['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':23,'multiline':False]['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':24,'multiline':False]['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':25,'multiline':False]['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':26,'multiline':False]['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' A light-weight compression algorithm.  It is designed for speed of','line_number':29,'multiline':False]['text':' compression and decompression, rather than for the utmost in space','line_number':30,'multiline':False]['text':' savings.','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' For getting better compression ratios when you are compressing data','line_number':33,'multiline':False]['text':' with long repeated sequences or compressing data that is similar to','line_number':34,'multiline':False]['text':' other data, while still compressing fast, you might look at first','line_number':35,'multiline':False]['text':' using BMDiff and then compressing the output of BMDiff with','line_number':36,'multiline':False]['text':' Snappy.','line_number':37,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':51,'multiline':False]['text':' Generic compression/decompression routines.','line_number':52,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':53,'multiline':False]['text':' Compress the bytes read from "*source" and append to "*sink". Return the','line_number':55,'multiline':False]['text':' number of bytes written.','line_number':56,'multiline':False]['text':' Find the uncompressed length of the given stream, as given by the header.','line_number':59,'multiline':False]['text':' Note that the true length could deviate from this; the stream could e.g.','line_number':60,'multiline':False]['text':' be truncated.','line_number':61,'multiline':False]['text':'','line_number':62,'multiline':False]['text':' Also note that this leaves "*source" in a state that is unsuitable for','line_number':63,'multiline':False]['text':' further operations, such as RawUncompress(). You will need to rewind','line_number':64,'multiline':False]['text':' or recreate the source yourself before attempting any further calls.','line_number':65,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':68,'multiline':False]['text':' Higher-level string based routines (should be sufficient for most users)','line_number':69,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':70,'multiline':False]['text':' Sets "*output" to the compressed version of "input[0,input_length-1]".','line_number':72,'multiline':False]['text':' Original contents of *output are lost.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' REQUIRES: "input[]" is not an alias of "*output".','line_number':75,'multiline':False]['text':' Decompresses "compressed[0,compressed_length-1]" to "*uncompressed".','line_number':78,'multiline':False]['text':' Original contents of "*uncompressed" are lost.','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' REQUIRES: "compressed[]" is not an alias of "*uncompressed".','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':' returns false if the message is corrupted and could not be decompressed','line_number':83,'multiline':False]['text':' Decompresses "compressed" to "*uncompressed".','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' returns false if the message is corrupted and could not be decompressed','line_number':89,'multiline':False]['text':' This routine uncompresses as much of the "compressed" as possible','line_number':92,'multiline':False]['text':' into sink.  It returns the number of valid bytes added to sink','line_number':93,'multiline':False]['text':' (extra invalid bytes may have been added due to errors; the caller','line_number':94,'multiline':False]['text':' should ignore those). The emitted data typically has length','line_number':95,'multiline':False]['text':' GetUncompressedLength(), but may be shorter if an error is','line_number':96,'multiline':False]['text':' encountered.','line_number':97,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':100,'multiline':False]['text':' Lower-level character array based routines.  May be useful for','line_number':101,'multiline':False]['text':' efficiency reasons in certain circumstances.','line_number':102,'multiline':False]['text':' ------------------------------------------------------------------------','line_number':103,'multiline':False]['text':' REQUIRES: "compressed" must point to an area of memory that is at','line_number':105,'multiline':False]['text':' least "MaxCompressedLength(input_length)" bytes in length.','line_number':106,'multiline':False]['text':'','line_number':107,'multiline':False]['text':' Takes the data stored in "input[0..input_length]" and stores','line_number':108,'multiline':False]['text':' it in the array pointed to by "compressed".','line_number':109,'multiline':False]['text':'','line_number':110,'multiline':False]['text':' "*compressed_length" is set to the length of the compressed output.','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':' Example:','line_number':113,'multiline':False]['text':'    char* output = new char[snappy::MaxCompressedLength(input_length)];','line_number':114,'multiline':False]['text':'    size_t output_length;','line_number':115,'multiline':False]['text':'    RawCompress(input, input_length, output, &output_length);','line_number':116,'multiline':False]['text':'    ... Process(output, output_length) ...','line_number':117,'multiline':False]['text':'    delete [] output;','line_number':118,'multiline':False]['text':' Given data in "compressed[0..compressed_length-1]" generated by','line_number':124,'multiline':False]['text':' calling the Snappy::Compress routine, this routine','line_number':125,'multiline':False]['text':' stores the uncompressed data to','line_number':126,'multiline':False]['text':'    uncompressed[0..GetUncompressedLength(compressed)-1]','line_number':127,'multiline':False]['text':' returns false if the message is corrupted and could not be decrypted','line_number':128,'multiline':False]['text':' Given data from the byte source 'compressed' generated by calling','line_number':132,'multiline':False]['text':' the Snappy::Compress routine, this routine stores the uncompressed','line_number':133,'multiline':False]['text':' data to','line_number':134,'multiline':False]['text':'    uncompressed[0..GetUncompressedLength(compressed,compressed_length)-1]','line_number':135,'multiline':False]['text':' returns false if the message is corrupted and could not be decrypted','line_number':136,'multiline':False]['text':' Given data in "compressed[0..compressed_length-1]" generated by','line_number':139,'multiline':False]['text':' calling the Snappy::Compress routine, this routine','line_number':140,'multiline':False]['text':' stores the uncompressed data to the iovec "iov". The number of physical','line_number':141,'multiline':False]['text':' buffers in "iov" is given by iov_cnt and their cumulative size','line_number':142,'multiline':False]['text':' must be at least GetUncompressedLength(compressed). The individual buffers','line_number':143,'multiline':False]['text':' in "iov" must not overlap with each other.','line_number':144,'multiline':False]['text':'','line_number':145,'multiline':False]['text':' returns false if the message is corrupted and could not be decrypted','line_number':146,'multiline':False]['text':' Given data from the byte source 'compressed' generated by calling','line_number':150,'multiline':False]['text':' the Snappy::Compress routine, this routine stores the uncompressed','line_number':151,'multiline':False]['text':' data to the iovec "iov". The number of physical','line_number':152,'multiline':False]['text':' buffers in "iov" is given by iov_cnt and their cumulative size','line_number':153,'multiline':False]['text':' must be at least GetUncompressedLength(compressed). The individual buffers','line_number':154,'multiline':False]['text':' in "iov" must not overlap with each other.','line_number':155,'multiline':False]['text':'','line_number':156,'multiline':False]['text':' returns false if the message is corrupted and could not be decrypted','line_number':157,'multiline':False]['text':' Returns the maximal size of the compressed representation of','line_number':161,'multiline':False]['text':' input data that is "source_bytes" bytes in length;','line_number':162,'multiline':False]['text':' REQUIRES: "compressed[]" was produced by RawCompress() or Compress()','line_number':165,'multiline':False]['text':' Returns true and stores the length of the uncompressed data in','line_number':166,'multiline':False]['text':' *result normally.  Returns false on parsing error.','line_number':167,'multiline':False]['text':' This operation takes O(1) time.','line_number':168,'multiline':False]['text':' Returns true iff the contents of "compressed[]" can be uncompressed','line_number':172,'multiline':False]['text':' successfully.  Does not return the uncompressed data.  Takes','line_number':173,'multiline':False]['text':' time proportional to compressed_length, but is usually at least','line_number':174,'multiline':False]['text':' a factor of four faster than actual decompression.','line_number':175,'multiline':False]['text':' Returns true iff the contents of "compressed" can be uncompressed','line_number':179,'multiline':False]['text':' successfully.  Does not return the uncompressed data.  Takes','line_number':180,'multiline':False]['text':' time proportional to *compressed length, but is usually at least','line_number':181,'multiline':False]['text':' a factor of four faster than actual decompression.','line_number':182,'multiline':False]['text':' On success, consumes all of *compressed.  On failure, consumes an','line_number':183,'multiline':False]['text':' unspecified prefix of *compressed.','line_number':184,'multiline':False]['text':' The size of a compression block. Note that many parts of the compression','line_number':187,'multiline':False]['text':' code assumes that kBlockSize <= 65536; in particular, the hash table','line_number':188,'multiline':False]['text':' can only store 16-bit offsets, and EmitCopy() also assumes the offset','line_number':189,'multiline':False]['text':' is 65535 bytes or less. Note also that if you change this, it will','line_number':190,'multiline':False]['text':' affect the framing format (see framing_format.txt).','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' Note that there might be older data around that is compressed with larger','line_number':193,'multiline':False]['text':' block sizes, so the decompression code should not rely on the','line_number':194,'multiline':False]['text':' non-existence of long backreferences.','line_number':195,'multiline':False]['text':' end namespace snappy','line_number':201,'multiline':False]['text':' THIRD_PARTY_SNAPPY_SNAPPY_H__','line_number':203,'multiline':False]