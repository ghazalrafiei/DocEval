['text':'************************************************
*             PCRE2 testing program              *
************************************************','line_number':1,'multiline':True]['text':' PCRE2 is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language. In 2014
the API was completely revised and '2' was added to the name, because the old
API, which had lasted for 16 years, could not accommodate new requirements. At
the same time, this testing program was re-designed because its original
hacked-up (non-) design had also run out of steam.

                       Written by Philip Hazel
     Original code Copyright (c) 1997-2012 University of Cambridge
    Rewritten code Copyright (c) 2016-2022 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
','line_number':5,'multiline':True]['text':' This program supports testing of the 8-bit, 16-bit, and 32-bit PCRE2
libraries in a single program, though its input and output are always 8-bit.
It is different from modules such as pcre2_compile.c in the library itself,
which are compiled separately for each code unit width. If two widths are
enabled, for example, pcre2_compile.c is compiled twice. In contrast,
pcre2test.c is compiled only once, and linked with all the enabled libraries.
Therefore, it must not make use of any of the macros from pcre2.h or
pcre2_internal.h that depend on PCRE2_CODE_UNIT_WIDTH. It does, however, make
use of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16, and SUPPORT_PCRE2_32, to ensure that
it references only the enabled library functions. ','line_number':46,'multiline':True]['text':' That header is not included in the main PCRE2 distribution because other
apparatus is needed to compile pcre2test for z/OS. The header can be found in
the special z/OS distribution, which is available from www.zaconsultants.net or
from www.cbttape.org. ','line_number':71,'multiline':True]['text':' Debugging code enabler ','line_number':81,'multiline':True]['text':' #define DEBUG_SHOW_MALLOC_ADDRESSES ','line_number':83,'multiline':True]['text':' Both libreadline and libedit are optionally supported ','line_number':85,'multiline':True]['text':' GNU readline defines this macro but libedit doesn't, if that ever changes
this needs to be updated or the build could break ','line_number':97,'multiline':True]['text':' Put the test for interactive input into a macro so that it can be changed if
required for different environments. ','line_number':106,'multiline':True]['text':' ---------------------- System-specific definitions ---------------------- ','line_number':112,'multiline':True]['text':' A number of things vary for Windows builds. Originally, pcretest opened its
input and output without "b"; then I was told that "b" was needed in some
environments, so it was added for release 5.0 to both the input and output. (It
makes no difference on Unix-like systems.) Later I was told that it is wrong
for the input on Windows. I've now abstracted the modes into macros that are
set here, to make it easier to fiddle with them, and removed "b" from the input
mode under Windows. The BINARY versions are used when saving/restoring compiled
patterns. ','line_number':114,'multiline':True]['text':' For _setmode() ','line_number':124,'multiline':True]['text':' For _O_BINARY ','line_number':125,'multiline':True]['text':' This is what Windows calls them, I'm told, ','line_number':132,'multiline':True]['text':' though in some environments they seem to   ','line_number':133,'multiline':True]['text':' be already defined, hence the #ifndefs.    ','line_number':134,'multiline':True]['text':' A user sent this fix for Borland Builder 5 under Windows. ','line_number':139,'multiline':True]['text':' Not Windows ','line_number':145,'multiline':True]['text':' These two includes are needed ','line_number':148,'multiline':True]['text':' for setrlimit(). ','line_number':149,'multiline':True]['text':' z/OS uses non-binary I/O ','line_number':150,'multiline':True]['text':' VMS-specific code was included as suggested by a VMS user [1]. Another VMS
user [2] provided alternative code which worked better for him. I have
commented out the original, but kept it around just in case. ','line_number':163,'multiline':True]['text':' These two includes came from [2]. ','line_number':169,'multiline':True]['text':' void vms_setsymbol( char *, char *, int ); Original code from [1]. ','line_number':172,'multiline':True]['text':' old VC and older compilers don't support %td or %zu, and even some that
claim to be C99 don't support it (hence DISABLE_PERCENT_ZT). ','line_number':175,'multiline':True]['text':' ------------------End of system-specific definitions -------------------- ','line_number':192,'multiline':True]['text':' Glueing macros that are used in several places below. ','line_number':194,'multiline':True]['text':' Miscellaneous parameters and manifests ','line_number':199,'multiline':True]['text':' Unset value for startend/cfail/cerror fields ','line_number':209,'multiline':True]['text':' Unset value for convert_type field ','line_number':210,'multiline':True]['text':' Size of DFA workspace ','line_number':211,'multiline':True]['text':' Default ovector count ','line_number':212,'multiline':True]['text':' For initializing ovector ','line_number':213,'multiline':True]['text':' Size of locale name ','line_number':214,'multiline':True]['text':' Default loop count for timing ','line_number':215,'multiline':True]['text':' For remembering mallocs ','line_number':216,'multiline':True]['text':' Default parentheses nest limit ','line_number':217,'multiline':True]['text':' Pattern stack for save/restore testing ','line_number':218,'multiline':True]['text':' Field for reading 8-bit replacement ','line_number':219,'multiline':True]['text':' Size of buffer for the version strings ','line_number':220,'multiline':True]['text':' Default JIT compile options ','line_number':222,'multiline':True]['text':' Make sure the buffer into which replacement strings are copied is big enough
to hold them as 32-bit code units. ','line_number':228,'multiline':True]['text':' This is a byte value ','line_number':231,'multiline':True]['text':' Execution modes ','line_number':233,'multiline':True]['text':' Processing returns ','line_number':239,'multiline':True]['text':' The macro PRINTABLE determines whether to print an output character as-is or
as a hex value when showing compiled patterns. is We use it in cases when the
locale has not been explicitly changed, so as to get consistent output from
systems that differ in their output from isprint() even in the "C" locale. ','line_number':243,'multiline':True]['text':' We have to include some of the library source files because we need
to use some of the macros, internal structure definitions, and other internal
values - pcre2test has "inside information" compared to an application program
that strictly follows the PCRE2 API.

Before including pcre2_internal.h we define PRIV so that it does not get
defined therein. This ensures that PRIV names in the included files do not
clash with those in the libraries. Also, although pcre2_internal.h does itself
include pcre2.h, we explicitly include it beforehand, along with pcre2posix.h,
so that the PCRE2_EXP_xxx macros get set appropriately for an application, not
for building the library. ','line_number':256,'multiline':True]['text':' We need access to some of the data tables that PCRE2 uses. Defining
PCRE2_PCRETEST makes some minor changes in the files. The previous definition
of PRIV avoids name clashes. ','line_number':274,'multiline':True]['text':' 32-bit integer values in the input are read by strtoul() or strtol(). The
check needed for overflow depends on whether long ints are in fact longer than
ints. They are defined not to be shorter. ','line_number':282,'multiline':True]['text':' When PCRE2_CODE_UNIT_WIDTH is zero, pcre2_internal.h does not include
pcre2_intmodedep.h, which is where mode-dependent macros and structures are
defined. We can now include it for each supported code unit width. Because
PCRE2_CODE_UNIT_WIDTH was defined as zero before including pcre2.h, it will
have left PCRE2_SUFFIX defined as a no-op. We must re-define it appropriately
while including these files, and then restore it to a no-op. Because LINK_SIZE
may be changed in 16-bit mode and forced to 1 in 32-bit mode, the order of
these inclusions should not be changed. ','line_number':298,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':317,'multiline':True]['text':' SUPPORT_PCRE2_16 ','line_number':326,'multiline':True]['text':' SUPPORT_PCRE2_32 ','line_number':335,'multiline':True]['text':' We need to be able to check input text for UTF-8 validity, whatever code
widths are actually available, because the input to pcre2test is always in
8-bit code units. So we include the UTF validity checking function for 8-bit
code units. ','line_number':339,'multiline':True]['text':' If we have 8-bit support, default to it; if there is also 16-or 32-bit
support, it can be selected by a command-line option. If there is no 8-bit
support, there must be 16-bit or 32-bit support, so default to one of them. The
config function, JIT stack, contexts, and version string are the same in all
modes, so use the form of the first that is available. ','line_number':353,'multiline':True]['text':' ------------- Structure and table for handling #-commands ------------- ','line_number':390,'multiline':True]['text':' ------------- Structures and tables for handling modifiers -------------- ','line_number':415,'multiline':True]['text':' Table of names for newline types. Must be kept in step with the definitions
of PCRE2_NEWLINE_xx in pcre2.h. ','line_number':417,'multiline':True]['text':' Structure and table for handling pattern conversion types. ','line_number':423,'multiline':True]['text':' Modifier types and applicability ','line_number':440,'multiline':True]['text':' Applies to a compile context ','line_number':442,'multiline':True]['text':' Applies to a match context ','line_number':443,'multiline':True]['text':' Applies to a pattern ','line_number':444,'multiline':True]['text':' Ditto, OK for Perl test ','line_number':445,'multiline':True]['text':' Applies to a data line ','line_number':446,'multiline':True]['text':' Ditto, OK for Perl test ','line_number':447,'multiline':True]['text':' Applies to a pattern or a data line ','line_number':448,'multiline':True]['text':' As MOD_PD, OK for Perl test ','line_number':449,'multiline':True]['text':' As MOD_PD, but not for a default pattern ','line_number':450,'multiline':True]['text':' As MOD_PND, OK for Perl test ','line_number':451,'multiline':True]['text':' Is a single character ','line_number':452,'multiline':True]['text':' Is a "convert" type/options list ','line_number':453,'multiline':True]['text':' Is a control bit ','line_number':454,'multiline':True]['text':' Is a BSR value ','line_number':455,'multiline':True]['text':' Is one or two unsigned integers ','line_number':456,'multiline':True]['text':' Is a signed integer ','line_number':457,'multiline':True]['text':' Is an unsigned integer ','line_number':458,'multiline':True]['text':' Is an unsigned integer, but no value => default ','line_number':459,'multiline':True]['text':' Is a newline value ','line_number':460,'multiline':True]['text':' Is a number or a name; more than one may occur ','line_number':461,'multiline':True]['text':' Is an option bit ','line_number':462,'multiline':True]['text':' Is a PCRE2_SIZE value ','line_number':463,'multiline':True]['text':' Is a string ','line_number':464,'multiline':True]['text':' Control bits. Some apply to compiling, some to matching, but some can be set
either on a pattern or a data line, so they must all be distinct. There are now
so many of them that they are split into two fields. ','line_number':466,'multiline':True]['text':' Same word as USE_LENGTH ','line_number':486,'multiline':True]['text':' These three must be ','line_number':495,'multiline':True]['text':'   all in the same ','line_number':496,'multiline':True]['text':'     word. ','line_number':497,'multiline':True]['text':' Same word as HEXPAT ','line_number':499,'multiline':True]['text':' Combinations ','line_number':503,'multiline':True]['text':' For setting ','line_number':505,'multiline':True]['text':' Second control word ','line_number':509,'multiline':True]['text':' Informational ','line_number':526,'multiline':True]['text':' Informational ','line_number':527,'multiline':True]['text':' These are the matching controls that may be set either on a pattern or on a
data line. They are copied from the pattern controls as initial settings for
data line controls. Note that CTL_MEMORY is not included here, because it does
different things in the two cases. ','line_number':529,'multiline':True]['text':' Structures for holding modifier information for patterns and subject strings
(data). Fields containing modifiers that can be set either for a pattern or a
subject must be at the start and in the same order in both cases so that the
same offset in the big table below works for both. ','line_number':554,'multiline':True]['text':' Structure for pattern modifiers. ','line_number':559,'multiline':True]['text':' Must be in same position as datctl ','line_number':560,'multiline':True]['text':' Must be in same position as datctl ','line_number':561,'multiline':True]['text':' Must be in same position as datctl ','line_number':562,'multiline':True]['text':' Must be in same position as datctl ','line_number':563,'multiline':True]['text':' So must this ','line_number':564,'multiline':True]['text':' Must be in same position as patctl ','line_number':565,'multiline':True]['text':' Must be in same position as patctl ','line_number':566,'multiline':True]['text':' Structure for data line modifiers. ','line_number':581,'multiline':True]['text':' Must be in same position as patctl ','line_number':582,'multiline':True]['text':' Must be in same position as patctl ','line_number':583,'multiline':True]['text':' Must be in same position as patctl ','line_number':584,'multiline':True]['text':' Must be in same position as patctl ','line_number':585,'multiline':True]['text':' So must this ','line_number':586,'multiline':True]['text':' Must be in same position as patctl ','line_number':587,'multiline':True]['text':' Must be in same position as patctl ','line_number':588,'multiline':True]['text':' Ids for which context to modify. ','line_number':601,'multiline':True]['text':' Active pattern context ','line_number':603,'multiline':True]['text':' Ditto, for a popped pattern ','line_number':604,'multiline':True]['text':' Default pattern context ','line_number':605,'multiline':True]['text':' Active data (match) context ','line_number':606,'multiline':True]['text':' Default data (match) context ','line_number':607,'multiline':True]['text':' Macros to simplify the big table below. ','line_number':609,'multiline':True]['text':' Table of all long-form modifiers. Must be in collating sequence of modifier
name because it is searched by binary chop. ','line_number':617,'multiline':True]['text':' Obsolete synonym ','line_number':731,'multiline':True]['text':' Controls and options that are supported for use with the POSIX interface. ','line_number':760,'multiline':True]['text':' Control bits that are not ignored with 'push'. ','line_number':780,'multiline':True]['text':' Controls that apply only at compile time with 'push'. ','line_number':789,'multiline':True]['text':' Controls that are forbidden with #pop or #popcopy. ','line_number':794,'multiline':True]['text':' Pattern controls that are mutually exclusive. At present these are all in
the first control word. Note that CTL_POSIX_NOSUB is always accompanied by
CTL_POSIX, so it doesn't need its own entries. ','line_number':799,'multiline':True]['text':' Data controls that are mutually exclusive. At present these are all in the
first control word. ','line_number':812,'multiline':True]['text':' Table of single-character abbreviated modifiers. The index field is
initialized to -1, but the first time the modifier is encountered, it is filled
in with the index of the full entry in modlist, to save repeated searching when
processing multiple test items. This short list is searched serially, so its
order does not matter. ','line_number':819,'multiline':True]['text':' Table of arguments for the -C command line option. Use macros to make the
table itself easier to read. ','line_number':844,'multiline':True]['text':' ----------------------- Static variables ------------------------ ','line_number':916,'multiline':True]['text':' Bytes ','line_number':930,'multiline':True]['text':' Return from JIT compile ','line_number':931,'multiline':True]['text':' For binary-loaded tables ','line_number':973,'multiline':True]['text':' We need buffers for building 16/32-bit strings; 8-bit strings don't need
rebuilding, but set up the same naming scheme for use in macros. The "buffer"
buffer is where all input lines are read. Its size is the same as pbuffer8.
Pattern lines are always copied to pbuffer8 for use in callouts, even if they
are actually compiled from pbuffer16 or pbuffer32. ','line_number':976,'multiline':True]['text':' Initial size, bytes ','line_number':982,'multiline':True]['text':' The dbuffer is where all processed data lines are put. In non-8-bit modes it
is cast as needed. For long data lines it grows as necessary. ','line_number':986,'multiline':True]['text':' Initial size, bytes ','line_number':989,'multiline':True]['text':' ---------------- Mode-dependent variables -------------------','line_number':993,'multiline':True]['text':' Set only when needed ','line_number':1011,'multiline':True]['text':' Set only when needed ','line_number':1022,'multiline':True]['text':' ---------------- Macros that work in all modes ----------------- ','line_number':1027,'multiline':True]['text':' ---------------- Mode-dependent, runtime-testing macros ------------------','line_number':1035,'multiline':True]['text':' Define macros for variables and functions that must be selected dynamically
depending on the mode setting (8, 16, 32). These are dependent on which modes
are supported. ','line_number':1037,'multiline':True]['text':' ----- All three modes supported ----- ','line_number':1044,'multiline':True]['text':' ----- Two out of three modes are supported ----- ','line_number':1564,'multiline':True]['text':' We can use some macro trickery to make a single set of definitions work in
the three different cases. ','line_number':1568,'multiline':True]['text':' ----- 32-bit and 16-bit but not 8-bit supported ----- ','line_number':1571,'multiline':True]['text':' ----- 32-bit and 8-bit but not 16-bit supported ----- ','line_number':1577,'multiline':True]['text':' ----- 16-bit and 8-bit but not 32-bit supported ----- ','line_number':1583,'multiline':True]['text':' ----- Common macros for two-mode cases ----- ','line_number':1591,'multiline':True]['text':' Two out of three modes ','line_number':2025,'multiline':True]['text':' ----- End of cases where more than one mode is supported ----- ','line_number':2027,'multiline':True]['text':' ----- Only 8-bit mode is supported ----- ','line_number':2030,'multiline':True]['text':' ----- Only 16-bit mode is supported ----- ','line_number':2137,'multiline':True]['text':' ----- Only 32-bit mode is supported ----- ','line_number':2244,'multiline':True]['text':' ----- End of mode-specific function call macros ----- ','line_number':2352,'multiline':True]['text':'************************************************
*         Alternate character tables             *
************************************************','line_number':2357,'multiline':True]['text':' By default, the "tables" pointer in the compile context when calling
pcre2_compile() is not set (= NULL), thereby using the default tables of the
library. However, the tables modifier can be used to select alternate sets of
tables, for different kinds of testing. Note that the locale modifier also
adjusts the tables. ','line_number':2361,'multiline':True]['text':' This is the set of tables distributed as default with PCRE2. It recognizes
only ASCII characters. ','line_number':2367,'multiline':True]['text':' This table is a lower casing table. ','line_number':2372,'multiline':True]['text':' This table is a case flipping table. ','line_number':2407,'multiline':True]['text':' This table contains bit maps for various character classes. Each map is 32
bytes long and the bits run from the least significant end of each byte. The
classes that have their own maps are: space, xdigit, digit, upper, lower, word,
graph, print, punct, and cntrl. Other classes are built from combinations. ','line_number':2442,'multiline':True]['text':' This table identifies various classes of character by individual bits:
  0x01   white space character
  0x02   letter
  0x04   decimal digit
  0x08   hexadecimal digit
  0x10   alphanumeric or '_'
  0x80   regular expression metacharacter or binary zero
','line_number':2497,'multiline':True]['text':'   0-  7 ','line_number':2506,'multiline':True]['text':'   8- 15 ','line_number':2507,'multiline':True]['text':'  16- 23 ','line_number':2508,'multiline':True]['text':'  24- 31 ','line_number':2509,'multiline':True]['text':'    - '  ','line_number':2510,'multiline':True]['text':'  ( - /  ','line_number':2511,'multiline':True]['text':'  0 - 7  ','line_number':2512,'multiline':True]['text':'  8 - ?  ','line_number':2513,'multiline':True]['text':'  @ - G  ','line_number':2514,'multiline':True]['text':'  H - O  ','line_number':2515,'multiline':True]['text':'  P - W  ','line_number':2516,'multiline':True]['text':'  X - _  ','line_number':2517,'multiline':True]['text':'  ` - g  ','line_number':2518,'multiline':True]['text':'  h - o  ','line_number':2519,'multiline':True]['text':'  p - w  ','line_number':2520,'multiline':True]['text':'  x -127 ','line_number':2521,'multiline':True]['text':' 128-135 ','line_number':2522,'multiline':True]['text':' 136-143 ','line_number':2523,'multiline':True]['text':' 144-151 ','line_number':2524,'multiline':True]['text':' 152-159 ','line_number':2525,'multiline':True]['text':' 160-167 ','line_number':2526,'multiline':True]['text':' 168-175 ','line_number':2527,'multiline':True]['text':' 176-183 ','line_number':2528,'multiline':True]['text':' 184-191 ','line_number':2529,'multiline':True]['text':' 192-199 ','line_number':2530,'multiline':True]['text':' 200-207 ','line_number':2531,'multiline':True]['text':' 208-215 ','line_number':2532,'multiline':True]['text':' 216-223 ','line_number':2533,'multiline':True]['text':' 224-231 ','line_number':2534,'multiline':True]['text':' 232-239 ','line_number':2535,'multiline':True]['text':' 240-247 ','line_number':2536,'multiline':True]['text':' 248-255 ','line_number':2537,'multiline':True]['text':' This is a set of tables that came originally from a Windows user. It seems
to be at least an approximation of ISO 8859. In particular, there are
characters greater than 128 that are marked as spaces, letters, etc. ','line_number':2539,'multiline':True]['text':'************************************************
*    Emulated memmove() for systems without it   *
************************************************','line_number':2685,'multiline':True]['text':' This function can make use of bcopy() if it is available. Otherwise do it by
steam, as there are some non-Unix environments that lack both memmove() and
bcopy(). ','line_number':2689,'multiline':True]['text':' not HAVE_BCOPY ','line_number':2715,'multiline':True]['text':' not VPCOMPAT && not HAVE_MEMMOVE ','line_number':2719,'multiline':True]['text':'************************************************
*     Provide strerror() for non-ANSI libraries  *
************************************************','line_number':2724,'multiline':True]['text':' Some old-fashioned systems (e.g. SunOS4) didn't have strerror() in their
libraries. They may no longer be around, but just in case, we can try to
provide the same facility by this simple alternative function. ','line_number':2728,'multiline':True]['text':' HAVE_STRERROR ','line_number':2741,'multiline':True]['text':'************************************************
*            Local memory functions              *
************************************************','line_number':2745,'multiline':True]['text':' Alternative memory functions, to test functionality. ','line_number':2749,'multiline':True]['text':' Not portable ','line_number':2765,'multiline':True]['text':' Not portable ','line_number':2806,'multiline':True]['text':'************************************************
*       Callback function for stack guard        *
************************************************','line_number':2815,'multiline':True]['text':' This is set up to be called from pcre2_compile() when the stackguard=n
modifier sets a value greater than zero. The test we do is whether the
parenthesis nesting depth is greater than the value set by the modifier.

Argument:  the current parenthesis nesting depth
Returns:   non-zero to kill the compilation
','line_number':2819,'multiline':True]['text':'************************************************
*         JIT memory callback                    *
************************************************','line_number':2835,'multiline':True]['text':'************************************************
*      Convert UTF-8 character to code point     *
************************************************','line_number':2847,'multiline':True]['text':' This function reads one or more bytes that represent a UTF-8 character,
and returns the codepoint of that character. Note that the function supports
the original UTF-8 definition of RFC 2279, allowing for values in the range 0
to 0x7fffffff, up to 6 bytes long. This makes it possible to generate
codepoints greater than 0x10ffff which are useful for testing PCRE2's error
checking, and also for generating 32-bit non-UTF data values above the UTF
limit.

Argument:
  utf8bytes   a pointer to the byte vector
  vptr        a pointer to an int to receive the value

Returns:      >  0 => the number of bytes consumed
              -6 to 0 => malformed UTF-8 character at offset = (-return)
','line_number':2851,'multiline':True]['text':' i is number of additional bytes ','line_number':2874,'multiline':True]['text':' ascii character ','line_number':2880,'multiline':True]['text':' invalid UTF-8 ','line_number':2881,'multiline':True]['text':' i now has a value in the range 1-5 ','line_number':2883,'multiline':True]['text':' Check that encoding was the correct unique one ','line_number':2896,'multiline':True]['text':' Valid value ','line_number':2902,'multiline':True]['text':'************************************************
*             Print one character                *
************************************************','line_number':2910,'multiline':True]['text':' Print a single character either literally, or as a hex escape, and count how
many printed characters are used.

Arguments:
  c            the character
  utf          TRUE in UTF mode
  f            the FILE to print to, or NULL just to count characters

Returns:       number of characters written
','line_number':2914,'multiline':True]['text':'************************************************
*    Find length of 0-terminated 16-bit string   *
************************************************','line_number':2960,'multiline':True]['text':' SUPPORT_PCRE2_16 ','line_number':2970,'multiline':True]['text':'************************************************
*    Find length of 0-terminated 32-bit string   *
************************************************','line_number':2975,'multiline':True]['text':' SUPPORT_PCRE2_32 ','line_number':2985,'multiline':True]['text':'************************************************
*         Print 8-bit character string           *
************************************************','line_number':2989,'multiline':True]['text':' Must handle UTF-8 strings in utf8 mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, this function just
counts chars without printing (because pchar() does that). ','line_number':2993,'multiline':True]['text':' Mustn't run over the end ','line_number':3008,'multiline':True]['text':'************************************************
*           Print 16-bit character string        *
************************************************','line_number':3026,'multiline':True]['text':' Must handle UTF-16 strings in utf mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, just counts chars
without printing. ','line_number':3030,'multiline':True]['text':' SUPPORT_PCRE2_16 ','line_number':3056,'multiline':True]['text':'************************************************
*           Print 32-bit character string        *
************************************************','line_number':3061,'multiline':True]['text':' Must handle UTF-32 strings in utf mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, just counts chars
without printing. ','line_number':3065,'multiline':True]['text':' Avoid compiler warning ','line_number':3073,'multiline':True]['text':' SUPPORT_PCRE2_32 ','line_number':3082,'multiline':True]['text':'************************************************
*       Convert character value to UTF-8         *
************************************************','line_number':3087,'multiline':True]['text':' This function takes an integer value in the range 0 - 0x7fffffff
and encodes it as a UTF-8 character in 0 to 6 bytes. It is needed even when the
8-bit library is not supported, to generate UTF-8 output for non-ASCII
characters.

Arguments:
  cvalue     the character value
  utf8bytes  pointer to buffer for result - at least 6 bytes long

Returns:     number of characters placed in the buffer
','line_number':3091,'multiline':True]['text':'************************************************
*           Convert string to 16-bit             *
************************************************','line_number':3124,'multiline':True]['text':' In UTF mode the input is always interpreted as a string of UTF-8 bytes using
the original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and
code values from 0 to 0x7fffffff. However, values greater than the later UTF
limit of 0x10ffff cause an error. In non-UTF mode the input is interpreted as
UTF-8 if the utf8_input modifier is set, but an error is generated for values
greater than 0xffff.

If all the input bytes are ASCII, the space needed for a 16-bit string is
exactly double the 8-bit size. Otherwise, the size needed for a 16-bit string
is no more than double, because up to 0xffff uses no more than 3 bytes in UTF-8
but possibly 4 in UTF-16. Higher values use 4 bytes in UTF-8 and up to 4 bytes
in UTF-16. The result is always left in pbuffer16. Impose a minimum size to
save repeated re-sizing.

Note that this function does not object to surrogate values. This is
deliberate; it makes it possible to construct UTF-16 strings that are invalid,
for the purpose of testing that they are correctly faulted.

Arguments:
  p          points to a byte string
  utf        true in UTF mode
  lenptr     points to number of bytes in the string (excluding trailing zero)

Returns:     0 on success, with the length updated to the number of 16-bit
               data items used (excluding the trailing zero)
             OR -1 if a UTF-8 string is malformed
             OR -2 if a value > 0x10ffff is encountered in UTF mode
             OR -3 if a value > 0xffff is encountered when not in UTF mode
','line_number':3128,'multiline':True]['text':'************************************************
*           Convert string to 32-bit             *
************************************************','line_number':3209,'multiline':True]['text':' In UTF mode the input is always interpreted as a string of UTF-8 bytes using
the original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and
code values from 0 to 0x7fffffff. However, values greater than the later UTF
limit of 0x10ffff cause an error.

In non-UTF mode the input is interpreted as UTF-8 if the utf8_input modifier
is set, and no limit is imposed. There is special interpretation of the 0xff
byte (which is illegal in UTF-8) in this case: it causes the top bit of the
next character to be set. This provides a way of generating 32-bit characters
greater than 0x7fffffff.

If all the input bytes are ASCII, the space needed for a 32-bit string is
exactly four times the 8-bit size. Otherwise, the size needed for a 32-bit
string is no more than four times, because the number of characters must be
less than the number of bytes. The result is always left in pbuffer32. Impose a
minimum size to save repeated re-sizing.

Note that this function does not object to surrogate values. This is
deliberate; it makes it possible to construct UTF-32 strings that are invalid,
for the purpose of testing that they are correctly faulted.

Arguments:
  p          points to a byte string
  utf        true in UTF mode
  lenptr     points to number of bytes in the string (excluding trailing zero)

Returns:     0 on success, with the length updated to the number of 32-bit
               data items used (excluding the trailing zero)
             OR -1 if a UTF-8 string is malformed
             OR -2 if a value > 0x10ffff is encountered in UTF mode
','line_number':3213,'multiline':True]['text':' SUPPORT_PCRE2_32 ','line_number':3295,'multiline':True]['text':' This function is no longer used. Keep it around for a while, just in case it
needs to be re-instated. ','line_number':3299,'multiline':True]['text':'************************************************
*         Move back by so many characters        *
************************************************','line_number':3304,'multiline':True]['text':' Given a code unit offset in a subject string, move backwards by a number of
characters, and return the resulting offset.

Arguments:
  subject   pointer to the string
  offset    start offset
  count     count to move back by
  utf       TRUE if in UTF mode

Returns:   a possibly changed offset
','line_number':3308,'multiline':True]['text':' 16-bit mode ','line_number':3337,'multiline':True]['text':' NEVERNEVERNEVER ','line_number':3348,'multiline':True]['text':'************************************************
*           Expand input buffers                 *
************************************************','line_number':3352,'multiline':True]['text':' This function doubles the size of the input buffer and the buffer for
keeping an 8-bit copy of patterns (pbuffer8), and copies the current buffers to
the new ones.

Arguments: none
Returns:   nothing (aborts if malloc() fails)
','line_number':3356,'multiline':True]['text':'************************************************
*        Read or extend an input line            *
************************************************','line_number':3391,'multiline':True]['text':' Input lines are read into buffer, but both patterns and data lines can be
continued over multiple input lines. In addition, if the buffer fills up, we
want to automatically expand it so as to be able to handle extremely large
lines that are needed for certain stress tests, although this is less likely
now that there are repetition features for both patterns and data. When the
input buffer is expanded, the other two buffers must also be expanded likewise,
and the contents of pbuffer, which are a copy of the input for callouts, must
be preserved (for when expansion happens for a data line). This is not the most
optimal way of handling this, but hey, this is just a test program!

Arguments:
  f            the file to read
  start        where in buffer to start (this *must* be within buffer)
  prompt       for stdin or readline()

Returns:       pointer to the start of new data
               could be a copy of start, or could be moved
               NULL if no data read and EOF reached
','line_number':3395,'multiline':True]['text':' If libreadline or libedit support is required, use readline() to read a
    line if the input is a terminal. Note that readline() removes the trailing
    newline, so we must put it back again, to be compatible with fgets(). ','line_number':3428,'multiline':True]['text':' Read the next line by normal means, prompting if the file is a tty. ','line_number':3449,'multiline':True]['text':' Check for end of line reached. Take care not to read data from before
    start (dlen will be zero for a file starting with a binary zero). ','line_number':3460,'multiline':True]['text':' If we have not read a newline when reading a file, we have either filled
    the buffer or reached the end of the file. We can detect the former by
    checking that the string fills the buffer, and the latter by feof(). If
    neither of these is true, it means we read a binary zero which has caused
    strlen() to give a short length. This is a hard error because pcre2test
    expects to work with C strings. ','line_number':3465,'multiline':True]['text':' Control never gets here ','line_number':3490,'multiline':True]['text':'************************************************
*         Case-independent strncmp() function    *
************************************************','line_number':3495,'multiline':True]['text':'
Arguments:
  s         first string
  t         second string
  n         number of characters to compare

Returns:    < 0, = 0, or > 0, according to the comparison
','line_number':3499,'multiline':True]['text':'************************************************
*          Scan the main modifier list           *
************************************************','line_number':3521,'multiline':True]['text':' This function searches the modifier list for a long modifier name.

Argument:
  p         start of the name
  lenp      length of the name

Returns:    an index in the modifier list, or -1 on failure
','line_number':3525,'multiline':True]['text':'************************************************
*        Check a modifer and find its field      *
************************************************','line_number':3559,'multiline':True]['text':' This function is called when a modifier has been identified. We check that
it is allowed here and find the field that is to be changed.

Arguments:
  m          the modifier list entry
  ctx        CTX_PAT     => pattern context
             CTX_POPPAT  => pattern context for popped pattern
             CTX_DEFPAT  => default pattern context
             CTX_DAT     => data context
             CTX_DEFDAT  => default data context
  pctl       point to pattern control block
  dctl       point to data control block
  c          a single character or 0

Returns:     a field pointer or NULL
','line_number':3563,'multiline':True]['text':' Compile context modifier ','line_number':3602,'multiline':True]['text':' Match context modifier ','line_number':3607,'multiline':True]['text':' Data line modifier ','line_number':3612,'multiline':True]['text':' Allowed for Perl test ','line_number':3613,'multiline':True]['text':' Pattern modifier ','line_number':3617,'multiline':True]['text':' Allowed for Perl test ','line_number':3618,'multiline':True]['text':' Pattern or data line modifier ','line_number':3622,'multiline':True]['text':' Ditto, allowed for Perl test ','line_number':3623,'multiline':True]['text':' Ditto, but not default pattern ','line_number':3624,'multiline':True]['text':' Ditto, allowed for Perl test ','line_number':3625,'multiline':True]['text':'************************************************
*            Decode a modifier list              *
************************************************','line_number':3647,'multiline':True]['text':' A pointer to a control block is NULL when called in cases when that block is
not relevant. They are never all relevant in one call. At least one of patctl
and datctl is NULL. The second argument specifies which context to use for
modifiers that apply to contexts.

Arguments:
  p          point to modifier string
  ctx        CTX_PAT     => pattern context
             CTX_POPPAT  => pattern context for popped pattern
             CTX_DEFPAT  => default pattern context
             CTX_DAT     => data context
             CTX_DEFDAT  => default data context
  pctl       point to pattern control block
  dctl       point to data control block

Returns: TRUE if successful decode, FALSE otherwise
','line_number':3651,'multiline':True]['text':' Skip white space and commas. ','line_number':3686,'multiline':True]['text':' Find the end of the item; lose trailing whitespace at end of line. ','line_number':3691,'multiline':True]['text':' Remember if the first character is '-'. ','line_number':3700,'multiline':True]['text':' Find the length of a full-length modifier name, and scan for it. ','line_number':3708,'multiline':True]['text':' If the first modifier is unrecognized, try to interpret it as a sequence
  of single-character abbreviated modifiers. None of these modifiers have any
  associated data. They just set options or control bits. ','line_number':3714,'multiline':True]['text':' Cache for next time ','line_number':3758,'multiline':True]['text':' /x is a special case; a second appearance changes PCRE2_EXTENDED to
      PCRE2_EXTENDED_MORE. ','line_number':3764,'multiline':True]['text':' With tne next (fullname) modifier ','line_number':3776,'multiline':True]['text':' We have a match on a full-name modifier. Check for the existence of data
  when needed. ','line_number':3779,'multiline':True]['text':' Save typing ','line_number':3782,'multiline':True]['text':' These on/off types have no data. ','line_number':3798,'multiline':True]['text':' Set the data length for those types that have data. Then find the field
  that is to be set. If check_modifier() returns NULL, it has already output an
  error message. ','line_number':3806,'multiline':True]['text':' Process according to data type. ','line_number':3814,'multiline':True]['text':' A single character ','line_number':3848,'multiline':True]['text':' A convert type/options list ','line_number':3852,'multiline':True]['text':' One or two unsigned integers ','line_number':3874,'multiline':True]['text':' PCRE2_SIZE_MAX is usually SIZE_MAX, which may be greater, equal to, or
    less than ULONG_MAX. So first test for overflowing the long int, and then
    test for overflowing PCRE2_SIZE_MAX if it is smaller than ULONG_MAX. ','line_number':3889,'multiline':True]['text':' PCRE2_SIZE value ','line_number':3893,'multiline':True]['text':' Unsigned integer with default ','line_number':3904,'multiline':True]['text':' Fall through ','line_number':3910,'multiline':True]['text':' Unsigned integer ','line_number':3912,'multiline':True]['text':' Signed integer ','line_number':3920,'multiline':True]['text':' Name or (signed) number; may be several ','line_number':3948,'multiline':True]['text':' Adjust field ptr ','line_number':3956,'multiline':True]['text':' Add new number ','line_number':3957,'multiline':True]['text':' Skip previous ','line_number':3959,'multiline':True]['text':' Multiple strings are put end to end. ','line_number':3972,'multiline':True]['text':' Add new name ','line_number':3977,'multiline':True]['text':'************************************************
*             Get info from a pattern            *
************************************************','line_number':4040,'multiline':True]['text':' A wrapped call to pcre2_pattern_info(), applied to the current compiled
pattern.

Arguments:
  what        code for the required information
  where       where to put the answer
  unsetok     PCRE2_ERROR_UNSET is an "expected" result

Returns:      the return from pcre2_pattern_info()
','line_number':4044,'multiline':True]['text':' Exercise the code ','line_number':4059,'multiline':True]['text':'************************************************
*             Show something in a list           *
************************************************','line_number':4077,'multiline':True]['text':' This function just helps to keep the code that uses it tidier. It's used for
various lists of things where there needs to be introductory text before the
first item. As these calls are all in the POSIX-support code, they happen only
when 8-bit mode is supported. ','line_number':4081,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':4092,'multiline':True]['text':'************************************************
*                Show control bits               *
************************************************','line_number':4096,'multiline':True]['text':' Called for mutually exclusive controls and for unsupported POSIX controls.
Because the bits are unique, this can be used for both pattern and data control
words.

Arguments:
  controls    control bits
  controls2   more control bits
  before      text to print before

Returns:      nothing
','line_number':4100,'multiline':True]['text':'************************************************
*                Show compile options            *
************************************************','line_number':4168,'multiline':True]['text':' Called from show_pattern_info() and for unsupported POSIX options.

Arguments:
  options     an options word
  before      text to print before
  after       text to print after

Returns:      nothing
','line_number':4172,'multiline':True]['text':'************************************************
*           Show compile extra options           *
************************************************','line_number':4222,'multiline':True]['text':' Called from show_pattern_info() and for unsupported POSIX options.

Arguments:
  options     an options word
  before      text to print before
  after       text to print after

Returns:      nothing
','line_number':4226,'multiline':True]['text':'************************************************
*                Show match options              *
************************************************','line_number':4255,'multiline':True]['text':' Called for unsupported POSIX options. ','line_number':4259,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':4279,'multiline':True]['text':'************************************************
*      Show memory usage info for a pattern      *
************************************************','line_number':4283,'multiline':True]['text':' One of the test_mode values will always be true, but to stop a compiler
warning we must initialize cblock_size. ','line_number':4293,'multiline':True]['text':'************************************************
*       Show frame size info for a pattern       *
************************************************','line_number':4321,'multiline':True]['text':'************************************************
*         Get and output an error message        *
************************************************','line_number':4335,'multiline':True]['text':'************************************************
*     Callback function for callout enumeration  *
************************************************','line_number':4359,'multiline':True]['text':' The only differences in the callout emumeration block for different code
unit widths are that the pointers to the subject, the most recent MARK, and a
callout argument string point to strings of the appropriate width. Casts can be
used to deal with this.

Argument:
  cb            pointer to enumerate block
  callout_data  user data

Returns:    0
','line_number':4363,'multiline':True]['text':' Not currently displayed ','line_number':4381,'multiline':True]['text':'************************************************
*        Show information about a pattern        *
************************************************','line_number':4409,'multiline':True]['text':' This function is called after a pattern has been compiled if any of the
information-requesting controls have been set.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
','line_number':4413,'multiline':True]['text':' Exercise the error route. ','line_number':4446,'multiline':True]['text':' These info requests may return PCRE2_ERROR_UNSET. ','line_number':4451,'multiline':True]['text':' These info requests should always succeed. ','line_number':4495,'multiline':True]['text':' In UTF mode the name may be a UTF string containing non-ASCII
      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,
      use the normal string printing functions, which use escapes for all
      non-ASCII characters. ','line_number':4543,'multiline':True]['text':' Not UTF mode ','line_number':4583,'multiline':True]['text':' Remove UTF/UCP if they were there only because of forbid_utf. This saves
  cluttering up the verification output of non-UTF test files. ','line_number':4616,'multiline':True]['text':'************************************************
*              Handle serialization error        *
************************************************','line_number':4786,'multiline':True]['text':' Print an error message after a serialization failure.

Arguments:
  rc         the error code
  msg        an initial message for what failed

Returns:     FALSE if print_error_message() fails
','line_number':4790,'multiline':True]['text':'************************************************
*        Open file for save/load commands        *
************************************************','line_number':4808,'multiline':True]['text':' This function decodes the file name and opens the file.

Arguments:
  buffptr     point after the #command
  mode        open mode
  fptr        points to the FILE variable
  name        name of # command

Returns:      PR_OK or PR_ABEND
','line_number':4812,'multiline':True]['text':'************************************************
*               Process command line             *
************************************************','line_number':4851,'multiline':True]['text':' This function is called for lines beginning with # and a character that is
not ! or whitespace, when encountered between tests, which means that there is
no compiled pattern (compiled_code is NULL). The line is in buffer.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
','line_number':4855,'multiline':True]['text':' Set default pattern modifiers ','line_number':4915,'multiline':True]['text':' Set default subject modifiers ','line_number':4923,'multiline':True]['text':' Check the default newline, and if not one of those listed, set up the
  first one to be forced. An empty list unsets. ','line_number':4929,'multiline':True]['text':' Unset ','line_number':4933,'multiline':True]['text':' Default is valid ','line_number':4945,'multiline':True]['text':' Pop or copy a compiled pattern off the stack. Modifiers that do not affect
  the compiled pattern (e.g. to give information) are permitted. The default
  pattern modifiers are ignored. ','line_number':4954,'multiline':True]['text':' Completely unset ','line_number':4965,'multiline':True]['text':' Save the stack of compiled patterns to a file, then empty the stack. ','line_number':4991,'multiline':True]['text':' Write the length at the start of the file to make it straightforward to
  get the right memory when re-loading. This saves having to read the file size
  in different operating systems. To allow for different endianness (even
  though reloading with the opposite endianness does not work), write the
  length byte-by-byte. ','line_number':5012,'multiline':True]['text':' Load a set of compiled patterns from a file onto the stack ','line_number':5036,'multiline':True]['text':' Load a set of binary tables into tables3. ','line_number':5092,'multiline':True]['text':'************************************************
*               Process pattern line             *
************************************************','line_number':5124,'multiline':True]['text':' This function is called when the input buffer contains the start of a
pattern. The first character is known to be a valid delimiter. The pattern is
read, modifiers are interpreted, and a suitable local context is set up for
this test. The pattern is then compiled.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
','line_number':5128,'multiline':True]['text':' The perltest.sh script supports only / as a delimiter. ','line_number':5154,'multiline':True]['text':' Initialize the context and pattern/data controls for this test from the
defaults. ','line_number':5162,'multiline':True]['text':' Find the end of the pattern, reading more lines if necessary. ','line_number':5168,'multiline':True]['text':' If the first character after the delimiter is backslash, make the pattern
end with backslash. This is purely to provide a way of testing for the error
message when a pattern ends with backslash. ','line_number':5187,'multiline':True]['text':' Terminate the pattern at the delimiter, and compute the length. ','line_number':5193,'multiline':True]['text':' Look for modifiers and options after the final delimiter. ','line_number':5198,'multiline':True]['text':' Note that the match_invalid_utf option also sets utf when passed to
pcre2_compile(). ','line_number':5202,'multiline':True]['text':' The utf8_input modifier is not allowed in 8-bit mode, and is mutually
exclusive with the utf modifier. ','line_number':5207,'multiline':True]['text':' The convert and posix modifiers are mutually exclusive. ','line_number':5224,'multiline':True]['text':' Check for mutually exclusive control modifiers. At present, these are all in
the first control word. ','line_number':5233,'multiline':True]['text':' Assume full JIT compile for jitverify and/or jitfast if nothing else was
specified. ','line_number':5247,'multiline':True]['text':' Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting
in callouts. Convert from hex if requested (literal strings in quotes may be
present within the hexadecimal pairs). The result must necessarily be fewer
characters so will always fit in pbuffer8. ','line_number':5254,'multiline':True]['text':' Handle a literal substring ','line_number':5270,'multiline':True]['text':' Expect a hex pair ','line_number':5289,'multiline':True]['text':' If not a hex string, process for repetition expansion if requested. ','line_number':5321,'multiline':True]['text':' Check for replication syntax; if not found, the defaults just set will
    prevail and one character will be copied. ','line_number':5334,'multiline':True]['text':' Add to output. If the buffer is too small expand it. The function for
    expanding buffers always keeps buffer and pbuffer8 in step as far as their
    size goes. ','line_number':5376,'multiline':True]['text':' Neither hex nor expanded, just copy the input verbatim. ','line_number':5405,'multiline':True]['text':' Sort out character tables ','line_number':5412,'multiline':True]['text':' Set up for the stackguard test. ','line_number':5458,'multiline':True]['text':' Handle compiling via the POSIX interface, which doesn't support the
timing, showing, or debugging options, nor the ability to pass over
local character tables. Neither does it have 16-bit or 32-bit support. ','line_number':5465,'multiline':True]['text':' Check for features that the POSIX interface does not support. ','line_number':5484,'multiline':True]['text':' Translate PCRE2 options to POSIX options and then compile. ','line_number':5528,'multiline':True]['text':' Compiling failed ','line_number':5547,'multiline':True]['text':' In case something was left in there ','line_number':5554,'multiline':True]['text':' Inside regerror(), snprintf() is used. If the buffer is too small, some
    versions of snprintf() put a zero byte at the end, but others do not.
    Therefore, we print a maximum of one less than the size of the buffer. ','line_number':5563,'multiline':True]['text':' Compiling succeeded. Check that the values in the preg block are sensible.
  It can happen that pcre2test is accidentally linked with a different POSIX
  library which succeeds, but of course puts different things into preg. In
  this situation, calling regfree() may cause a segfault (or invalid free() in
  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the
  calling of regfree() on exit. ','line_number':5578,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':5601,'multiline':True]['text':' Handle compiling via the native interface. Controls that act later are
ignored with "push". Replacements are locked out. ','line_number':5604,'multiline':True]['text':' Convert the input in non-8-bit modes. ','line_number':5632,'multiline':True]['text':' The pattern is now in pbuffer[8|16|32], with the length in code units in
patlen. If it is to be converted, copy the result back afterwards so that it
ends up back in the usual place. ','line_number':5665,'multiline':True]['text':' Let the library allocate ','line_number':5687,'multiline':True]['text':' Output the converted pattern, then copy it. ','line_number':5731,'multiline':True]['text':' Free the converted pattern. ','line_number':5741,'multiline':True]['text':' Return if conversion was unsuccessful. ','line_number':5749,'multiline':True]['text':' By default we pass a zero-terminated pattern, but a length is passed if
"use_length" was specified or this is a hex pattern (which might contain binary
zeros). When valgrind is supported, arrange for the unused part of the buffer
to be marked as no access. ','line_number':5754,'multiline':True]['text':' For the terminating zero ','line_number':5763,'multiline':True]['text':' Valgrind not supported ','line_number':5788,'multiline':True]['text':' Avoid compiler warning ','line_number':5789,'multiline':True]['text':' If #newline_default has been used and the library was not compiled with an
appropriate default newline setting, local_newline_default will be non-zero. We
use this if there is no explicit newline modifier. ','line_number':5792,'multiline':True]['text':' The null_context modifier is used to test calling pcre2_compile() with a
NULL context. ','line_number':5801,'multiline':True]['text':' If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF
and PCRE2_NEVER_UCP are invalid with it. ','line_number':5807,'multiline':True]['text':' Compile many times when timing. ','line_number':5812,'multiline':True]['text':' A final compile that is used "for real". ','line_number':5834,'multiline':True]['text':' Call the JIT compiler if requested. When timing, we must free and recompile
the pattern each time because that is the only way to free the JIT compiled
code. We know that compilation will always succeed. ','line_number':5839,'multiline':True]['text':' If valgrind is supported, mark the pbuffer as accessible again. The 16-bit
and 32-bit buffers can be marked completely undefined, but we must leave the
pattern in the 8-bit buffer defined because it may be read from a callout
during matching. ','line_number':5872,'multiline':True]['text':' Compilation failed; go back for another re, skipping to blank line
if non-interactive. ','line_number':5899,'multiline':True]['text':' If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are
locked out at compile time, but we must also check for occurrences of \P, \p,
and \X, which are only supported when Unicode is supported. ','line_number':5910,'multiline':True]['text':' Remember the maximum lookbehind, for partial matching. ','line_number':5924,'multiline':True]['text':' Remember the number of captures. ','line_number':5929,'multiline':True]['text':' If an explicit newline modifier was given, set the information flag in the
pattern so that it is preserved over push/pop. ','line_number':5934,'multiline':True]['text':' Output code size and other information if requested. ','line_number':5942,'multiline':True]['text':' The "push" control requests that the compiled pattern be remembered on a
stack. This is mainly for testing the serialization functionality. ','line_number':5952,'multiline':True]['text':' The "pushcopy" and "pushtablescopy" controls are similar, but push a
copy of the pattern, the latter with a copy of its character tables. This tests
the pcre2_code_copy() and pcre2_code_copy_with_tables() functions. ','line_number':5966,'multiline':True]['text':'************************************************
*          Check heap, match or depth limit      *
************************************************','line_number':5992,'multiline':True]['text':' This is used for DFA, normal, and JIT fast matching. For DFA matching it
should only be called with the third argument set to PCRE2_ERROR_DEPTHLIMIT.

Arguments:
  pp        the subject string
  ulen      length of subject or PCRE2_ZERO_TERMINATED
  errnumber defines which limit to test
  msg       string to include in final message

Returns:    the return from the final match function call
','line_number':5996,'multiline':True]['text':' To catch bad restart ','line_number':6043,'multiline':True]['text':' If we've not hit the error with a heap limit less than the size of the
    initial stack frame vector (for pcre2_match()) or the initial stack
    workspace vector (for pcre2_dfa_match()), the heap is not being used, so
    the minimum limit is zero; there's no need to go on. The other limits are
    always greater than zero. ','line_number':6076,'multiline':True]['text':' Some other error ','line_number':6095,'multiline':True]['text':'************************************************
*        Substitute callout function             *
************************************************','line_number':6103,'multiline':True]['text':' Called from pcre2_substitute() when the substitute_callout modifier is set.
Print out the data that is passed back. The substitute callout block is
identical for all code unit widths, so we just pick one.

Arguments:
  scb         pointer to substitute callout block
  data_ptr    callout data

Returns:      nothing
','line_number':6107,'multiline':True]['text':' Not used ','line_number':6124,'multiline':True]['text':'************************************************
*              Callout function                  *
************************************************','line_number':6155,'multiline':True]['text':' Called from a PCRE2 library as a result of the (?C) item. We print out where
we are in the match (unless suppressed). Yield zero unless more callouts than
the fail count, or the callout data is not zero. The only differences in the
callout block for different code unit widths are that the pointers to the
subject, the most recent MARK, and a callout argument string point to strings
of the appropriate width. Casts can be used to deal with this.

Arguments:
  cb                a pointer to a callout block
  callout_data_ptr  the provided callout data

Returns:            0 or 1 or an error, as determined by settings
','line_number':6159,'multiline':True]['text':' The FILE f is used for echoing the subject string if it is non-NULL. This
happens only once in simple cases, but we want to repeat after any additional
output caused by CALLOUT_EXTRA. ','line_number':6183,'multiline':True]['text':' Fall through ','line_number':6201,'multiline':True]['text':' For a callout with a string argument, show the string first because there
isn't a tidy way to fit it in the rest of the data. ','line_number':6214,'multiline':True]['text':' Show captured strings if required ','line_number':6234,'multiline':True]['text':' Unless suppressed, re-print the subject in canonical form (with escapes for
non-printing characters), the first time, or if giving full details. On
subsequent calls in the same match, we use PCHARS() just to find the printed
lengths of the substrings. ','line_number':6255,'multiline':True]['text':' The subject before the match start. ','line_number':6264,'multiline':True]['text':' If a lookbehind is involved, the current position may be earlier than the
  match start. If so, use the match start instead. ','line_number':6268,'multiline':True]['text':' The subject between the match start and the current position. ','line_number':6274,'multiline':True]['text':' Print from the current position to the end. ','line_number':6279,'multiline':True]['text':' Calculate the total subject printed length (no print). ','line_number':6284,'multiline':True]['text':' For automatic callouts, show the pattern offset. Otherwise, for a
  numerical callout whose number has not already been shown with captured
  strings, show the number here. A callout with a string argument has been
  displayed above. ','line_number':6290,'multiline':True]['text':' Now show position indicators ','line_number':6306,'multiline':True]['text':' Show any mark info ','line_number':6331,'multiline':True]['text':' Show callout data ','line_number':6346,'multiline':True]['text':' Keep count and give the appropriate return code ','line_number':6358,'multiline':True]['text':'************************************************
*       Handle *MARK and copy/get tests          *
************************************************','line_number':6375,'multiline':True]['text':' This function is called after complete and partial matches. It runs the
tests for substring extraction.

Arguments:
  utf       TRUE for utf
  capcount  return from pcre2_match()

Returns:    FALSE if print_error_message() fails
','line_number':6379,'multiline':True]['text':' Test copy strings by number ','line_number':6395,'multiline':True]['text':' Test copy strings by name ','line_number':6429,'multiline':True]['text':' Test get strings by number ','line_number':6487,'multiline':True]['text':' Test get strings by name ','line_number':6510,'multiline':True]['text':' Test getting the complete list of captured strings. ','line_number':6557,'multiline':True]['text':'************************************************
*            Show an entire ovector              *
************************************************','line_number':6589,'multiline':True]['text':' This function is called after partial matching or match failure, when the
"allvector" modifier is set. It is a means of checking the contents of the
entire ovector, to ensure no modification of fields that should be unchanged.

Arguments:
  ovector      points to the ovector
  oveccount    number of pairs

Returns:       nothing
','line_number':6593,'multiline':True]['text':'************************************************
*               Process a data line              *
************************************************','line_number':6625,'multiline':True]['text':' The line is in buffer; it will not be empty.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
','line_number':6629,'multiline':True]['text':' Copy the default context and data control blocks to the active ones. Then
copy from the pattern the controls that can be set in either the pattern or the
data. This allows them to be overridden in the data line. We do not do this for
options because those that are common apply separately to compiling and
matching. ','line_number':6667,'multiline':True]['text':' Initialize for scanning the data line. ','line_number':6685,'multiline':True]['text':' Check that the data is well-formed UTF-8 if we're in UTF mode. To create
invalid input to pcre2_match(), you must use \x?? or \x{} sequences. ','line_number':6702,'multiline':True]['text':' Mark the dbuffer as addressable but undefined again. ','line_number':6720,'multiline':True]['text':' Allocate a buffer to hold the data line; len+1 is an upper bound on
the number of code units that will be needed (though the buffer may have to be
extended if replication is involved). ','line_number':6727,'multiline':True]['text':' Sets q8, q16, or q32, as appropriate. ','line_number':6742,'multiline':True]['text':' Scan the data line, interpreting data escapes, and put the result into a
buffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,
in 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.
','line_number':6744,'multiline':True]['text':' ] may mark the end of a replicated sequence ','line_number':6754,'multiline':True]['text':' Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input
  set, do the fudge for setting the top bit. ','line_number':6816,'multiline':True]['text':' Handle backslash escapes ','line_number':6832,'multiline':True]['text':' We used to have "while (isxdigit(*(++pt)))" here, but it fails
      when isxdigit() is a macro that refers to its argument more than
      once. This is banned by the C Standard, but apparently happens in at
      least one MacOS environment. ','line_number':6876,'multiline':True]['text':' Not correct form for \x{...}; fall through ','line_number':6893,'multiline':True]['text':' \x without {} always defines just one byte in 8-bit mode. This
    allows UTF-8 characters to be constructed byte by byte, and also allows
    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.
    Otherwise, pass it down as data. ','line_number':6896,'multiline':True]['text':' \ followed by EOF allows for an empty line ','line_number':6916,'multiline':True]['text':' \= terminates the data, starts modifiers ','line_number':6920,'multiline':True]['text':' \[ introduces a replicated character sequence ','line_number':6923,'multiline':True]['text':' We now have a character value in c that may be greater than 255.
  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater
  than 127 in UTF mode must have come from \x{...} or octal constructs
  because values from \x.. get this far only in non-UTF mode. ','line_number':6940,'multiline':True]['text':' Length in bytes ','line_number':7015,'multiline':True]['text':' Length in code units ','line_number':7016,'multiline':True]['text':' Value to use in match arg ','line_number':7017,'multiline':True]['text':' If the string was terminated by \= we must now interpret modifiers. ','line_number':7019,'multiline':True]['text':' Setting substitute_{skip,fail} implies a substitute callout. ','line_number':7024,'multiline':True]['text':' Check for mutually exclusive modifiers. At present, these are all in the
first control word. ','line_number':7029,'multiline':True]['text':' Warn for modifiers that are ignored for DFA. ','line_number':7056,'multiline':True]['text':' We now have the subject in dbuffer, with len containing the byte length, and
ulen containing the code unit length, with a copy in arg_ulen for use in match
function arguments (this gets changed to PCRE2_ZERO_TERMINATED when the
zero_terminate modifier is present).

Move the data to the end of the buffer so that a read over the end can be
caught by valgrind or other means. If we have explicit valgrind support, mark
the unused start of the buffer unaddressable. If we are using the POSIX
interface, or testing zero-termination, we must include the terminating zero in
the usable data. ','line_number':7064,'multiline':True]['text':' Now pp points to the subject string, but if null_subject was specified, set
it to NULL to test PCRE2's behaviour. ','line_number':7082,'multiline':True]['text':' POSIX matching is only possible in 8-bit mode, and it does not support
timing or other fancy features. Some were checked at compile time, but we need
to check the match-time settings here. ','line_number':7087,'multiline':True]['text':' Note: don't use the start/end variables here because we want to
          show the text from what is reported as the end. ','line_number':7187,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':7197,'multiline':True]['text':' Handle matching via the native interface. Check for consistency of
modifiers. ','line_number':7199,'multiline':True]['text':' ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA
matching, even if the JIT compiler was used. ','line_number':7205,'multiline':True]['text':' Handle passing the subject as zero-terminated. ','line_number':7215,'multiline':True]['text':' The nullcontext modifier is used to test calling pcre2_[jit_]match() with a
NULL context. ','line_number':7220,'multiline':True]['text':' Enable display of malloc/free if wanted. We can do this only if either the
pattern or the subject is processed with a context. ','line_number':7226,'multiline':True]['text':' Create and assign a JIT stack if requested. ','line_number':7236,'multiline':True]['text':' Or de-assign ','line_number':7249,'multiline':True]['text':' When no JIT stack is assigned, we must ensure that there is a JIT callback
if we want to verify that JIT was actually used. ','line_number':7259,'multiline':True]['text':' Adjust match_data according to size of offsets required. A size of zero
causes a new match data block to be obtained that exactly fits the pattern. ','line_number':7267,'multiline':True]['text':' Replacement processing is ignored for DFA matching. ','line_number':7298,'multiline':True]['text':' If a replacement string is provided, call pcre2_substitute() instead of one
of the matching functions. First we have to convert the replacement string to
the appropriate width. ','line_number':7306,'multiline':True]['text':' External match option ','line_number':7318,'multiline':True]['text':' Fill the ovector with junk to detect elements that do not get set
  when they should be (relevant only when "allvector" is specified). ','line_number':7332,'multiline':True]['text':' Check for a test that does substitution after an initial external match.
  If this is set, we run the external match, but leave the interpretation of
  its output to pcre2_substitute(). ','line_number':7343,'multiline':True]['text':' Sets r8, r16, or r32, as appropriate. ','line_number':7372,'multiline':True]['text':' If the replacement starts with '[<number>]' we interpret that as length
  value for the replacement buffer. ','line_number':7375,'multiline':True]['text':' Now copy the replacement string to a buffer of the appropriate width. No
  escape processing is done for replacements. In UTF mode, check for an invalid
  UTF-8 input string, and if it is invalid, just copy its code units without
  UTF interpretation. This provides a means of checking that an invalid string
  is detected. Otherwise, UTF-8 can be used to include wide characters in a
  replacement. ','line_number':7397,'multiline':True]['text':' Not UTF or invalid UTF-8: just copy the code units. ','line_number':7406,'multiline':True]['text':' Valid UTF-8 replacement string ','line_number':7424,'multiline':True]['text':' No callout ','line_number':7464,'multiline':True]['text':' There is a special option to set the replacement to NULL in order to test
  that case. ','line_number':7467,'multiline':True]['text':' Show final ovector contents if requested. ','line_number':7496,'multiline':True]['text':' End of substitution handling ','line_number':7502,'multiline':True]['text':' When a replacement string is not provided, run a loop for global matching
with one of the basic matching functions. For altglobal (or first time round
the loop), set an "unset" value for the previous match info. ','line_number':7504,'multiline':True]['text':' Fill the ovector with junk to detect elements that do not get set
  when they should be. ','line_number':7515,'multiline':True]['text':' When matching is via pcre2_match(), we will detect the use of JIT via the
  stack callback function. ','line_number':7520,'multiline':True]['text':' Do timing if required. ','line_number':7525,'multiline':True]['text':' Find the heap, match and depth limits if requested. The depth and heap
  limits are not relevant for JIT. The return from check_match_limit() is the
  return from the final call to pcre2_match() or pcre2_dfa_match(). ','line_number':7577,'multiline':True]['text':' This stops compiler warnings ','line_number':7583,'multiline':True]['text':' Otherwise just run a single match, setting up a callout if required (the
  default). There is a copy of the pattern in pbuffer8 for use by callouts. ','line_number':7609,'multiline':True]['text':' No callout ','line_number':7624,'multiline':True]['text':' Run a single DFA or NFA match. ','line_number':7627,'multiline':True]['text':' To catch bad restart ','line_number':7634,'multiline':True]['text':' The result of the match is now in capcount. First handle a successful
  match. If pp was forced to be NULL (to test NULL handling) it will have been
  treated as an empty string if the length was zero. So re-create that for
  outputting. ','line_number':7660,'multiline':True]['text':' Check for lunatic return value ','line_number':7671,'multiline':True]['text':' Break g/G loop ','line_number':7680,'multiline':True]['text':' If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they
    should be, but not for fast JIT, where it isn't supported. ','line_number':7684,'multiline':True]['text':' If this is not the first time round a global loop, check that the
    returned string has changed. If it has not, check for an empty string match
    at different starting offset from the previous match. This is a failed test
    retry for null-matching patterns that don't match at their starting offset,
    for example /(?<=\G.)/. A repeated match at the same point is not such a
    pattern, and must be discarded, and we then proceed to seek a non-null
    match at the current point. For any other repeated match, there is a bug
    somewhere and we must break the loop because it will go on for ever. We
    know that there are always at least two elements in the ovector. ','line_number':7703,'multiline':True]['text':' Back to the top of the loop ','line_number':7719,'multiline':True]['text':' Break g/G loop ','line_number':7724,'multiline':True]['text':' "allcaptures" requests showing of all captures in the pattern, to check
    unset ones at the end. It may be set on the pattern or the data. Implement
    by setting capcount to the maximum. This is not relevant for DFA matching,
    so ignore it (warning given above). ','line_number':7727,'multiline':True]['text':' Allow for full match ','line_number':7734,'multiline':True]['text':' "allvector" request showing the entire ovector. ','line_number':7738,'multiline':True]['text':' Output the captured substrings. Note that, for the matched string,
    the use of \K in an assertion can make the start later than the end. ','line_number':7742,'multiline':True]['text':' Check for an unset group ','line_number':7761,'multiline':True]['text':' Check for silly offsets, in particular, values that have not been
      set when they should have been. However, if we are past the end of the
      captures for this pattern ("allvector" causes this), or if we are DFA
      matching, it isn't an error if the entry is unchanged. ','line_number':7769,'multiline':True]['text':' When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with
      JIT, it is disabled above, with a comment.) When the match is done by the
      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is
      set, and if the leftmost consulted character is before the start of the
      match or the rightmost consulted character is past the end of the match,
      we want to show all consulted characters for the main matched string, and
      indicate which were lookarounds. ','line_number':7786,'multiline':True]['text':' When a pattern contains \K, the start of match position may be
        different to the start of the matched string. When this is the case,
        show it when requested. ','line_number':7820,'multiline':True]['text':' Otherwise, just show the matched string. ','line_number':7839,'multiline':True]['text':' Not the main matched string. Just show it unadorned. ','line_number':7849,'multiline':True]['text':' Note: don't use the start/end variables here because we want to
      show the text from what is reported as the end. ','line_number':7858,'multiline':True]['text':' Output (*MARK) data if requested ','line_number':7870,'multiline':True]['text':' Process copy/get strings ','line_number':7880,'multiline':True]['text':' End of handling a successful match ','line_number':7884,'multiline':True]['text':' There was a partial match. The value of ovector[0] is the bumpalong point,
  that is, startchar, not any \K point that might have been passed. When JIT is
  not in use, "allusedtext" may be set, in which case we indicate the leftmost
  consulted character. ','line_number':7886,'multiline':True]['text':' Process copy/get strings ','line_number':7934,'multiline':True]['text':' "allvector" outputs the entire vector ','line_number':7938,'multiline':True]['text':' Out of the /g loop ','line_number':7943,'multiline':True]['text':' End of handling partial match ','line_number':7944,'multiline':True]['text':' Failed to match. If this is a /g or /G loop, we might previously have
  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.
  If that is the case, this is not necessarily the end. We want to advance the
  start offset, and continue. We won't be at the end of the string - that was
  checked before setting g_notempty. We achieve the effect by pretending that a
  single character was matched.

  Complication arises in the case when the newline convention is "any", "crlf",
  or "anycrlf". If the previous match was at the end of a line terminated by
  CRLF, an advance of one character just passes the CR, whereas we should
  prefer the longer newline sequence, as does the code in pcre2_match().

  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one
  character, not one byte. ','line_number':7946,'multiline':True]['text':' There was a previous null match ','line_number':7961,'multiline':True]['text':' Where the match was ','line_number':7964,'multiline':True]['text':' 16-bit mode ','line_number':7981,'multiline':True]['text':' End of handling null match in a global loop ','line_number':7990,'multiline':True]['text':' A "normal" match failure. There will be a negative error number in
  capcount. ','line_number':7992,'multiline':True]['text':' "allvector" outputs the entire vector ','line_number':8013,'multiline':True]['text':' Out of the /g loop ','line_number':8038,'multiline':True]['text':' End of failed match handling ','line_number':8039,'multiline':True]['text':' Control reaches here in two circumstances: (a) after a match, and (b)
  after a non-match that immediately followed a match on an empty string when
  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and
  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match
  of one character. So effectively we get here only after a match. If we
  are not doing a global search, we are done. ','line_number':8041,'multiline':True]['text':' We must now set up for the next iteration of a global search. If we have
    matched an empty string, first check to see if we are at the end of the
    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option
    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again
    at the same point. If this fails it will be picked up above, where a fake
    match is set up so that at this point we advance to the next character.

    However, in order to cope with patterns that never match at their starting
    offset (e.g. /(?<=\G.)/) we don't do this when the match offset is greater
    than the starting offset. This means there will be a retry with the
    starting offset at the match offset. If this returns the same match again,
    it is picked up above and ignored, and the special action is then taken. ','line_number':8053,'multiline':True]['text':' End of subject ','line_number':8068,'multiline':True]['text':' However, even after matching a non-empty string, there is still one
    tricky case. If a pattern contains \K within a lookbehind assertion at the
    start, the end of the matched string can be at the offset where the match
    started. In the case of a normal /g iteration without special action, this
    leads to a loop that keeps on returning the same substring. The loop would
    be caught above, but we really want to move on to the next match. ','line_number':8073,'multiline':True]['text':' Set for a "normal" repeat ','line_number':8082,'multiline':True]['text':' End of subject ','line_number':8089,'multiline':True]['text':' 16-bit mode ','line_number':8098,'multiline':True]['text':' For a normal global (/g) iteration, save the current ovector[0,1] and
    the starting offset so that we can check that they do change each time.
    Otherwise a matching bug that returns the same string causes an infinite
    loop. It has happened! Then update the start offset, leaving other
    parameters alone. ','line_number':8108,'multiline':True]['text':' For altglobal, just update the pointer and length. ','line_number':8122,'multiline':True]['text':' End of global loop ','line_number':8132,'multiline':True]['text':'************************************************
*               Print PCRE2 version              *
************************************************','line_number':8141,'multiline':True]['text':'************************************************
*               Print Unicode version            *
************************************************','line_number':8156,'multiline':True]['text':'************************************************
*               Print JIT target                 *
************************************************','line_number':8170,'multiline':True]['text':'************************************************
*       Print newline configuration              *
************************************************','line_number':8183,'multiline':True]['text':' Output is always to stdout.

Arguments:
  rc         the return code from PCRE2_CONFIG_NEWLINE
  isc        TRUE if called from "-C newline"
Returns:     nothing
','line_number':8187,'multiline':True]['text':'************************************************
*             Usage function                     *
************************************************','line_number':8207,'multiline':True]['text':'************************************************
*             Handle -C option                   *
************************************************','line_number':8272,'multiline':True]['text':' This option outputs configuration options and sets an appropriate return
code when asked for a single option. The code is abstracted into a separate
function because of its size. Use whichever pcre2_config() function is
available.

Argument:   an option name or NULL
Returns:    the return code
','line_number':8276,'multiline':True]['text':' For VMS, return the value by setting a symbol, for certain values only. This
is contributed code which the PCRE2 developers have no means of testing. ','line_number':8331,'multiline':True]['text':' This is the original code provided by the first VMS contributor. ','line_number':8336,'multiline':True]['text':' This is the new code, provided by a second VMS contributor. ','line_number':8347,'multiline':True]['text':' __VMS ','line_number':8361,'multiline':True]['text':' No argument for -C: output all configuration information. ','line_number':8366,'multiline':True]['text':'************************************************
*      Format one property/script list item      *
************************************************','line_number':8439,'multiline':True]['text':' Find the name to put first. For scripts, any 3-character name is chosen.
For non-scripts, or if there is no 3-character name, take the longest. ','line_number':8454,'multiline':True]['text':' SUPPORT_UNICODE ','line_number':8491,'multiline':True]['text':'************************************************
*        Display scripts or properties           *
************************************************','line_number':8495,'multiline':True]['text':' SUPPORT_UNICODE ','line_number':8596,'multiline':True]['text':'************************************************
*              Display one modifier              *
************************************************','line_number':8601,'multiline':True]['text':'************************************************
*       Display pattern or subject modifiers     *
************************************************','line_number':8620,'multiline':True]['text':' In order to print in two columns, first scan without printing to get a list
of the modifiers that are required.

Arguments:
  for_pattern   TRUE for pattern modifiers, FALSE for subject modifiers
  title         string to be used in title

Returns:        nothing
','line_number':8624,'multiline':True]['text':' Compile context ','line_number':8649,'multiline':True]['text':' Pattern ','line_number':8650,'multiline':True]['text':' Pattern, OK for Perl-compatible test ','line_number':8651,'multiline':True]['text':' The MOD_PND and MOD_PNDP modifiers are precisely those that affect
    subjects, but can be given with a pattern. We list them as subject
    modifiers, but marked with an asterisk.','line_number':8654,'multiline':True]['text':' Match context ','line_number':8658,'multiline':True]['text':' Subject line ','line_number':8659,'multiline':True]['text':' Subject line, OK for Perl-compatible test ','line_number':8660,'multiline':True]['text':' As PD, but not default pattern ','line_number':8661,'multiline':True]['text':' As PND, OK for Perl-compatible test ','line_number':8662,'multiline':True]['text':' Fall through ','line_number':8667,'multiline':True]['text':' Pattern or subject ','line_number':8668,'multiline':True]['text':' As PD, OK for Perl-compatible test ','line_number':8669,'multiline':True]['text':' Now print from the list in two columns. ','line_number':8689,'multiline':True]['text':'************************************************
*          Display the list of modifiers         *
************************************************','line_number':8709,'multiline':True]['text':'************************************************
*                Main Program                    *
************************************************','line_number':8728,'multiline':True]['text':' The offsets to the options and control bits fields of the pattern and data
control blocks must be the same so that common options and controls such as
"anchored" or "memory" can work for either of them from a single table entry.
We cannot test this till runtime because "offsetof" does not work in the
preprocessor. ','line_number':8746,'multiline':True]['text':' Get the PCRE2 and Unicode version number and JIT target information, at the
same time checking that a request for the length gives the same answer. Also
check lengths for non-string items. ','line_number':8760,'multiline':True]['text':' Check that bad options are diagnosed. ','line_number':8780,'multiline':True]['text':' This configuration option is now obsolete, but running a quick check ensures
that its code is covered. ','line_number':8789,'multiline':True]['text':' Get buffers from malloc() so that valgrind will check their misuse when
debugging. They grow automatically when very long lines are read. The 16-
and 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. ','line_number':8794,'multiline':True]['text':' The following  _setmode() stuff is some Windows magic that tells its runtime
library to translate CRLF into a single LF character. At least, that's what
I've been told: never having used Windows I take this all on trust. Originally
it set 0x8000, but then I was advised that _O_BINARY was better. ','line_number':8801,'multiline':True]['text':' Initialization that does not depend on the running mode. ','line_number':8810,'multiline':True]['text':' Scan command line options. ','line_number':8825,'multiline':True]['text':' List modifiers and exit. ','line_number':8833,'multiline':True]['text':' List properties and exit ','line_number':8841,'multiline':True]['text':' List scripts and exit ','line_number':8849,'multiline':True]['text':' Display and/or set return code for configuration options. ','line_number':8857,'multiline':True]['text':' Select operating mode. Ensure that pcre2_config() is called in 16-bit
  and 32-bit modes because that won't happen naturally when 8-bit is also
  configured. Also call some other functions that are not otherwise used. This
  means that a coverage report won't claim there are uncalled functions. ','line_number':8865,'multiline':True]['text':' Set quiet (no version verification) ','line_number':8911,'multiline':True]['text':' Set system stack size ','line_number':8915,'multiline':True]['text':' Set some common pattern and subject controls ','line_number':8955,'multiline':True]['text':' full & partial ','line_number':8972,'multiline':True]['text':' Set timing parameters ','line_number':8979,'multiline':True]['text':' Give help ','line_number':9006,'multiline':True]['text':' Show version ','line_number':9015,'multiline':True]['text':' The following options save their data for processing once we know what
  the running mode is. ','line_number':9024,'multiline':True]['text':' Unrecognized option ','line_number':9053,'multiline':True]['text':' If -error was present, get the error numbers, show the messages, and exit.
We wait to do this until we know which mode we are in. ','line_number':9066,'multiline':True]['text':' Ensure the relevant non-8-bit buffer is available. Ensure that it is at
least 128 code units, because it is used for retrieving error messages. ','line_number':9075,'multiline':True]['text':' Loop along a list of error numbers. ','line_number':9108,'multiline':True]['text':' Control never reaches here ','line_number':9146,'multiline':True]['text':' End of -error handling ','line_number':9147,'multiline':True]['text':' Initialize things that cannot be done until we know which test mode we are
running in. Exercise the general context copying and match data size functions,
which are not otherwise used. ','line_number':9149,'multiline':True]['text':' Use macros to save a lot of duplication. ','line_number':9156,'multiline':True]['text':' Call the appropriate functions for the current mode, and exercise some
functions that are not otherwise called. ','line_number':9177,'multiline':True]['text':' Set a default parentheses nest limit that is large enough to run the
standard tests (this also exercises the function). ','line_number':9210,'multiline':True]['text':' Handle command line modifier settings, sending any error messages to
stderr. We need to know the mode before modifying the context, and it is tidier
to do them all in the same way. ','line_number':9215,'multiline':True]['text':' Sort out the input and output files, defaulting to stdin/stdout. ','line_number':9229,'multiline':True]['text':' Output a heading line unless quiet, then process input lines. ','line_number':9260,'multiline':True]['text':' If we have a pattern set up for testing, or we are skipping after a
  compile failure, a blank line terminates this test. ','line_number':9286,'multiline':True]['text':' SUPPORT_PCRE2_8 ','line_number':9301,'multiline':True]['text':' Otherwise, if we are not skipping, and the line is not a data comment
    line starting with "\=", process a data line. ','line_number':9311,'multiline':True]['text':' We do not have a pattern set up for testing. Lines starting with # are
  either comments or special commands. Blank lines are ignored. Otherwise, the
  line must start with a valid delimiter. It is then processed as a pattern
  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under
  valgrind, make the unused part of the buffer undefined, to catch overruns. ','line_number':9320,'multiline':True]['text':' Finish off a normal run. ','line_number':9358,'multiline':True]['text':' Return values via DCL symbols ','line_number':9445,'multiline':True]['text':' End of pcre2test.c ','line_number':9451,'multiline':True]