['text':'*****************************************************************************
  Copyright (c) 2007-2011, Intel Corp.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors 
      may be used to endorse or promote products derived from this software 
      without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************','line_number':1,'multiline':True]['text':'****************************************************************************
 * 
 *  BID128 fma   x * y + z
 * 
 ***************************************************************************','line_number':30,'multiline':True]['text':' unbiased true exponent unbexp may be larger than emax','line_number':46,'multiline':False]['text':' expected to have the correct sign and coefficient','line_number':48,'multiline':False]['text':' (the exponent field is ignored, as unbexp is used instead)','line_number':49,'multiline':False]['text':' general correction from RN to RA, RM, RP, RZ','line_number':53,'multiline':False]['text':' Note: if the result is negative, then is_inexact_lt_midpoint, ','line_number':54,'multiline':False]['text':' is_inexact_gt_midpoint, is_midpoint_lt_even, and is_midpoint_gt_even ','line_number':55,'multiline':False]['text':' have to be considered as if determined for the absolute value of the ','line_number':56,'multiline':False]['text':' result (so they seem to be reversed)','line_number':57,'multiline':False]['text':' apply correction to result calculated with unbounded exponent','line_number':63,'multiline':False]['text':' valid only if expmin<=unbexp<=expmax','line_number':65,'multiline':False]['text':' C = C + 1','line_number':74,'multiline':False]['text':' C = 10^34 => rounding overflow','line_number':79,'multiline':False]['text':' 10^33','line_number':81,'multiline':False]['text':' exp = exp + EXP_P1;','line_number':82,'multiline':False]['text':' C = C - 1','line_number':89,'multiline':False]['text':' check if we crossed into the lower decade','line_number':93,'multiline':False]['text':' C = 10^33 - 1','line_number':95,'multiline':False]['text':' 10^34 - 1','line_number':97,'multiline':False]['text':' exp = exp - EXP_P1;','line_number':99,'multiline':False]['text':' if exp = 0 the result is tiny & inexact','line_number':102,'multiline':False]['text':' the result is already correct','line_number':107,'multiline':False]['text':' 6111','line_number':109,'multiline':False]['text':' result is positive','line_number':112,'multiline':False]['text':' +inf','line_number':113,'multiline':False]['text':' res = +MAXFP = (10^34-1) * 10^emax','line_number':116,'multiline':False]['text':' result is negative','line_number':120,'multiline':False]['text':' -inf','line_number':121,'multiline':False]['text':' res = -MAXFP = -(10^34-1) * 10^emax','line_number':124,'multiline':False]['text':' assemble the result','line_number':130,'multiline':False]['text':' *z = x + yl assume the sum fits in 256 bits','line_number':138,'multiline':False]['text':' it was assumed that no carry is possible','line_number':161,'multiline':False]['text':' *z = x - y; assume x >= y','line_number':167,'multiline':False]['text':' no borrow possible, because x >= y','line_number':190,'multiline':False]['text':' determine the number of decimal digits in R256','line_number':198,'multiline':False]['text':' between 1 and 19 digits','line_number':200,'multiline':False]['text':' ind digits','line_number':206,'multiline':False]['text':' 20 digits','line_number':211,'multiline':False]['text':' between 21 and 38 digits','line_number':214,'multiline':False]['text':' ind + 20 digits','line_number':222,'multiline':False]['text':' 39 digits','line_number':231,'multiline':False]['text':' between 40 and 68 digits','line_number':234,'multiline':False]['text':' ind + 39 digits','line_number':249,'multiline':False]['text':' add/subtract C4 and C3 * 10^scale; this may follow a previous rounding, so','line_number':255,'multiline':False]['text':' use the rounding information from ptr_is_* to avoid a double rounding error','line_number':256,'multiline':False]['text':' int gt_half_ulp = 0;','line_number':293,'multiline':False]['text':' scale C3 up by 10^(q4-delta-q3), 0 <= q4-delta-q3 <= 2*P34-2 = 66','line_number':296,'multiline':False]['text':' 0 <= scale <= 66 (or 0 <= scale <= 68 if this','line_number':297,'multiline':False]['text':' comes from Cases (2), (3), (4), (5), (6), with 0 <= |delta| <= 1','line_number':298,'multiline':False]['text':' calculate C3 * 10^scale in R256 (it has at most 67 decimal digits for','line_number':300,'multiline':False]['text':' Cases (15),(16),(17) and at most 69 for Cases (2),(3),(4),(5),(6))','line_number':301,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':307,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':311,'multiline':False]['text':' 39 <= scale <= 57 ','line_number':313,'multiline':False]['text':' 10^scale fits in 192 bits but C3 * 10^scale fits in 223 or 230 bits','line_number':314,'multiline':False]['text':' (10^67 has 223 bits; 10^69 has 230 bits);  ','line_number':315,'multiline':False]['text':' must split the computation:  ','line_number':316,'multiline':False]['text':' 10^scale * C3 = 10*38 * 10^(scale-38) * C3 where 10^38 takes 127','line_number':317,'multiline':False]['text':' bits and so 10^(scale-38) * C3 fits in 128 bits with certainty','line_number':318,'multiline':False]['text':' Note that 1 <= scale - 38 <= 19 => 10^(scale-38) fits in 64 bits','line_number':319,'multiline':False]['text':' now multiply R128 by 10^38','line_number':321,'multiline':False]['text':' 58 <= scale <= 66','line_number':323,'multiline':False]['text':' 10^scale takes between 193 and 220 bits,','line_number':324,'multiline':False]['text':' and C3 * 10^scale fits in 223 bits (10^67/10^69 has 223/230 bits)','line_number':325,'multiline':False]['text':' must split the computation: ','line_number':326,'multiline':False]['text':' 10^scale * C3 = 10*38 * 10^(scale-38) * C3 where 10^38 takes 127','line_number':327,'multiline':False]['text':' bits and so 10^(scale-38) * C3 fits in 128 bits with certainty ','line_number':328,'multiline':False]['text':' Note that 20 <= scale - 38 <= 30 => 10^(scale-38) fits in 128 bits','line_number':329,'multiline':False]['text':' Calculate first 10^(scale-38) * C3, which fits in 128 bits; because','line_number':330,'multiline':False]['text':' 10^(scale-38) takes more than 64 bits, C3 will take less than 64','line_number':331,'multiline':False]['text':' now calculate 10*38 * 10^(scale-38) * C3 ','line_number':333,'multiline':False]['text':' C3 * 10^scale is now in R256 ','line_number':336,'multiline':False]['text':' for Cases (15), (16), (17) C4 > C3 * 10^scale because C4 has at least ','line_number':338,'multiline':False]['text':' one extra digit; for Cases (2), (3), (4), (5), or (6) any order is ','line_number':339,'multiline':False]['text':' possible ','line_number':340,'multiline':False]['text':' add/subtract C4 and C3 * 10^scale; the exponent is e4','line_number':341,'multiline':False]['text':' R256 = C4 + R256','line_number':342,'multiline':False]['text':' calculate R256 = C4 + C3 * 10^scale = C4 + R256 which is exact,','line_number':343,'multiline':False]['text':' but may require rounding','line_number':344,'multiline':False]['text':' if (p_sign != z_sign) { // R256 = C4 - R256','line_number':346,'multiline':False]['text':' calculate R256 = C4 - C3 * 10^scale = C4 - R256 or','line_number':347,'multiline':False]['text':' R256 = C3 * 10^scale - C4 = R256 - C4 which is exact,','line_number':348,'multiline':False]['text':' but may require rounding','line_number':349,'multiline':False]['text':' compare first R256 = C3 * 10^scale and C4 ','line_number':351,'multiline':False]['text':' C3 * 10^scale >= C4','line_number':355,'multiline':False]['text':' calculate R256 = C3 * 10^scale - C4 = R256 - C4, which is exact,','line_number':356,'multiline':False]['text':' but may require rounding ','line_number':357,'multiline':False]['text':' flip p_sign too, because the result has the sign of z ','line_number':359,'multiline':False]['text':' if C4 > C3 * 10^scale','line_number':361,'multiline':False]['text':' calculate R256 = C4 - C3 * 10^scale = C4 - R256, which is exact,','line_number':362,'multiline':False]['text':' but may require rounding  ','line_number':363,'multiline':False]['text':' if the result is pure zero, the sign depends on the rounding mode','line_number':366,'multiline':False]['text':' (x*y and z had opposite signs) ','line_number':367,'multiline':False]['text':' the exponent is max (e4, expmin)','line_number':374,'multiline':False]['text':' assemble result ','line_number':377,'multiline':False]['text':' determine the number of decimal digits in R256','line_number':385,'multiline':False]['text':' the exact result is (-1)^p_sign * R256 * 10^e4 where q (R256) = ind;','line_number':388,'multiline':False]['text':' round to the destination precision, with unbounded exponent','line_number':389,'multiline':False]['text':' result rounded to the destination precision with unbounded exponent','line_number':392,'multiline':False]['text':' is exact','line_number':393,'multiline':False]['text':' applies to all rounding modes ','line_number':395,'multiline':False]['text':' (regardless of the tininess detection method)','line_number':396,'multiline':False]['text':' Note: res is correct only if expmin <= e4 <= expmax','line_number':400,'multiline':False]['text':' if (ind > p34)','line_number':401,'multiline':False]['text':' if more than P digits, round to nearest to P digits','line_number':402,'multiline':False]['text':' round R256 to p34 digits','line_number':403,'multiline':False]['text':' 1 <= x0 <= 34 as 35 <= ind <= 68','line_number':404,'multiline':False]['text':' if (ind <= 68)','line_number':420,'multiline':False]['text':' for all rounding modes','line_number':428,'multiline':False]['text':' the rounded result has p34 = 34 digits','line_number':432,'multiline':False]['text':' for other rounding modes apply correction','line_number':437,'multiline':False]['text':' for RM, RP, RZ, RA apply correction in order to determine tininess','line_number':441,'multiline':False]['text':' but do not save the result; apply the correction to ','line_number':442,'multiline':False]['text':' (-1)^p_sign * significand * 10^0','line_number':443,'multiline':False]['text':' -1, 0, or +1','line_number':450,'multiline':False]['text':' the number of digits in the significand is p34 = 34','line_number':451,'multiline':False]['text':' the number of decimal digits in the signifcand of res','line_number':458,'multiline':False]['text':' RN','line_number':459,'multiline':False]['text':' Note: res is correct only if expmin <= e4 <= expmax','line_number':461,'multiline':False]['text':' set the inexact flag after rounding with bounded exponent, if any','line_number':462,'multiline':False]['text':' at this point we have the result rounded with unbounded exponent in','line_number':464,'multiline':False]['text':' res and we know its tininess:','line_number':465,'multiline':False]['text':' res = (-1)^p_sign * significand * 10^e4, ','line_number':466,'multiline':False]['text':' where q (significand) = ind <= p34','line_number':467,'multiline':False]['text':' Note: res is correct only if expmin <= e4 <= expmax','line_number':468,'multiline':False]['text':' check for overflow if RN','line_number':470,'multiline':False]['text':' BID_RETURN (res)','line_number':476,'multiline':False]['text':' else not overflow or not RN, so continue','line_number':477,'multiline':False]['text':' if (e4 >= expmin) we have the result rounded with bounded exponent','line_number':479,'multiline':False]['text':' x0 >= 1; the number of digits to chop off of res','line_number':481,'multiline':False]['text':' where the result rounded [at most] once is','line_number':482,'multiline':False]['text':'   (-1)^p_sign * significand_res * 10^e4','line_number':483,'multiline':False]['text':' avoid double rounding error','line_number':485,'multiline':False]['text':' nothing is left of res when moving the decimal point left x0 digits','line_number':496,'multiline':False]['text':' 1 <= x0 = ind <= p34 = 34','line_number':501,'multiline':False]['text':' this is <, =, or > 1/2 ulp','line_number':502,'multiline':False]['text':' compare the ind-digit value in the significand of res with','line_number':503,'multiline':False]['text':' 1/2 ulp = 5*10^(ind-1), i.e. determine whether it is ','line_number':504,'multiline':False]['text':' less than, equal to, or greater than 1/2 ulp (significand of res)','line_number':505,'multiline':False]['text':' < 1/2 ulp','line_number':509,'multiline':False]['text':' = 1/2 ulp','line_number':512,'multiline':False]['text':' > 1/2 ulp','line_number':515,'multiline':False]['text':' gt_half_ulp = 1;','line_number':516,'multiline':False]['text':' if (ind <= 38) {','line_number':519,'multiline':False]['text':' < 1/2 ulp','line_number':522,'multiline':False]['text':' = 1/2 ulp','line_number':526,'multiline':False]['text':' > 1/2 ulp','line_number':529,'multiline':False]['text':' gt_half_ulp = 1;','line_number':530,'multiline':False]['text':' res = +0.0 * 10^expmin','line_number':535,'multiline':False]['text':' if (gt_half_ulp)','line_number':538,'multiline':False]['text':' res = +1 * 10^expmin','line_number':539,'multiline':False]['text':' if (1 <= x0 <= ind - 1 <= 33)','line_number':545,'multiline':False]['text':' round the ind-digit result to ind - x0 digits','line_number':546,'multiline':False]['text':' 2 <= ind <= 18','line_number':548,'multiline':False]['text':' expmin','line_number':562,'multiline':False]['text':' we want the exponent to be expmin, so if incr_exp = 1 then','line_number':563,'multiline':False]['text':' multiply the rounded result by 10 - it will still fit in 113 bits','line_number':564,'multiline':False]['text':' 64 x 128 -> 128','line_number':566,'multiline':False]['text':' avoid a double rounding error','line_number':573,'multiline':False]['text':' double rounding error upward','line_number':575,'multiline':False]['text':' res = res - 1','line_number':576,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':580,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':581,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':582,'multiline':False]['text':' is not possible in Cases (2)-(6) or (15)-(17) which may get here','line_number':583,'multiline':False]['text':' double rounding error downward','line_number':587,'multiline':False]['text':' res = res + 1','line_number':588,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':596,'multiline':False]['text':' inexact because of the first rounding','line_number':597,'multiline':False]['text':' pulled up to a midpoint','line_number':606,'multiline':False]['text':' pulled down to a midpoint','line_number':613,'multiline':False]['text':' res contains the correct result','line_number':623,'multiline':False]['text':' apply correction if not rounding to nearest','line_number':624,'multiline':False]['text':' set the inexact flag','line_number':633,'multiline':False]['text':' used to modify the limit on the number of digits','line_number':681,'multiline':False]['text':' the following are based on the table of special cases for fma; the NaN','line_number':703,'multiline':False]['text':' behavior is similar to that of the IA-64 Architecture fma ','line_number':704,'multiline':False]['text':' identify cases where at least one operand is NaN','line_number':706,'multiline':False]['text':' y is NAN','line_number':711,'multiline':False]['text':' if x = {0, f, inf, NaN}, y = NaN, z = {0, f, inf, NaN} then res = Q (y)','line_number':712,'multiline':False]['text':' check first for non-canonical NaN payload','line_number':713,'multiline':False]['text':' y is SNAN','line_number':720,'multiline':False]['text':' set invalid flag','line_number':721,'multiline':False]['text':' return quiet (y)','line_number':723,'multiline':False]['text':' clear out also G[6]-G[16]','line_number':724,'multiline':False]['text':' y is QNaN','line_number':726,'multiline':False]['text':' return y','line_number':727,'multiline':False]['text':' clear out G[6]-G[16]','line_number':728,'multiline':False]['text':' if z = SNaN or x = SNaN signal invalid exception','line_number':730,'multiline':False]['text':' set invalid flag','line_number':733,'multiline':False]['text':' z is NAN','line_number':743,'multiline':False]['text':' if x = {0, f, inf, NaN}, y = {0, f, inf}, z = NaN then res = Q (z)','line_number':744,'multiline':False]['text':' check first for non-canonical NaN payload','line_number':745,'multiline':False]['text':' z is SNAN ','line_number':752,'multiline':False]['text':' set invalid flag ','line_number':753,'multiline':False]['text':' return quiet (z) ','line_number':755,'multiline':False]['text':' clear out also G[6]-G[16]','line_number':756,'multiline':False]['text':' z is QNaN ','line_number':758,'multiline':False]['text':' return z  ','line_number':759,'multiline':False]['text':' clear out G[6]-G[16]','line_number':760,'multiline':False]['text':' if x = SNaN signal invalid exception','line_number':762,'multiline':False]['text':' set invalid flag','line_number':764,'multiline':False]['text':' x is NAN','line_number':774,'multiline':False]['text':' if x = NaN, y = {0, f, inf}, z = {0, f, inf} then res = Q (x)','line_number':775,'multiline':False]['text':' check first for non-canonical NaN payload','line_number':776,'multiline':False]['text':' x is SNAN ','line_number':783,'multiline':False]['text':' set invalid flag ','line_number':784,'multiline':False]['text':' return quiet (x) ','line_number':786,'multiline':False]['text':' clear out also G[6]-G[16]','line_number':787,'multiline':False]['text':' x is QNaN ','line_number':789,'multiline':False]['text':' return x  ','line_number':790,'multiline':False]['text':' clear out G[6]-G[16]','line_number':791,'multiline':False]['text':' x, y, z are 0, f, or inf but not NaN => unpack the arguments and check','line_number':801,'multiline':False]['text':' for non-canonical values','line_number':802,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':804,'multiline':False]['text':' x != inf','line_number':807,'multiline':False]['text':' if x is not infinity check for non-canonical values - treated as zero','line_number':808,'multiline':False]['text':' G0_G1=11','line_number':809,'multiline':False]['text':' non-canonical','line_number':810,'multiline':False]['text':' biased and shifted left 49 bits','line_number':811,'multiline':False]['text':' significand high','line_number':812,'multiline':False]['text':' significand low','line_number':813,'multiline':False]['text':' G0_G1 != 11','line_number':814,'multiline':False]['text':' biased and shifted left 49 bits','line_number':815,'multiline':False]['text':' x is non-canonical if coefficient is larger than 10^34 -1','line_number':819,'multiline':False]['text':' canonical          ','line_number':822,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':827,'multiline':False]['text':' y != inf','line_number':830,'multiline':False]['text':' if y is not infinity check for non-canonical values - treated as zero','line_number':831,'multiline':False]['text':' G0_G1=11','line_number':832,'multiline':False]['text':' non-canonical','line_number':833,'multiline':False]['text':' biased and shifted left 49 bits','line_number':834,'multiline':False]['text':' significand high','line_number':835,'multiline':False]['text':' significand low ','line_number':836,'multiline':False]['text':' G0_G1 != 11','line_number':837,'multiline':False]['text':' biased and shifted left 49 bits','line_number':838,'multiline':False]['text':' y is non-canonical if coefficient is larger than 10^34 -1','line_number':842,'multiline':False]['text':' canonical','line_number':845,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':850,'multiline':False]['text':' z != inf','line_number':853,'multiline':False]['text':' if z is not infinity check for non-canonical values - treated as zero','line_number':854,'multiline':False]['text':' G0_G1=11','line_number':855,'multiline':False]['text':' non-canonical','line_number':856,'multiline':False]['text':' biased and shifted left 49 bits','line_number':857,'multiline':False]['text':' significand high','line_number':858,'multiline':False]['text':' significand low ','line_number':859,'multiline':False]['text':' G0_G1 != 11','line_number':860,'multiline':False]['text':' biased and shifted left 49 bits','line_number':861,'multiline':False]['text':' z is non-canonical if coefficient is larger than 10^34 -1','line_number':865,'multiline':False]['text':' canonical','line_number':868,'multiline':False]['text':' sign of the product','line_number':874,'multiline':False]['text':' identify cases where at least one operand is infinity','line_number':876,'multiline':False]['text':' x = inf','line_number':878,'multiline':False]['text':' y = inf','line_number':879,'multiline':False]['text':' z = inf','line_number':880,'multiline':False]['text':' return QNaN Indefinite','line_number':885,'multiline':False]['text':' set invalid flag','line_number':888,'multiline':False]['text':' z = 0 or z = f','line_number':891,'multiline':False]['text':' y = f','line_number':895,'multiline':False]['text':' z = inf','line_number':896,'multiline':False]['text':' return QNaN Indefinite ','line_number':901,'multiline':False]['text':' set invalid flag','line_number':904,'multiline':False]['text':' z = 0 or z = f','line_number':907,'multiline':False]['text':' y = 0','line_number':911,'multiline':False]['text':' return QNaN Indefinite','line_number':912,'multiline':False]['text':' set invalid flag','line_number':915,'multiline':False]['text':' y = inf','line_number':924,'multiline':False]['text':' z = inf','line_number':925,'multiline':False]['text':' x = f, necessarily','line_number':926,'multiline':False]['text':' return QNaN Indefinite','line_number':929,'multiline':False]['text':' set invalid flag','line_number':932,'multiline':False]['text':' x = 0','line_number':938,'multiline':False]['text':' z = 0, f, inf','line_number':939,'multiline':False]['text':' return QNaN Indefinite','line_number':940,'multiline':False]['text':' set invalid flag','line_number':943,'multiline':False]['text':' x = f and z = 0, f, necessarily','line_number':946,'multiline':False]['text':' z = inf','line_number':956,'multiline':False]['text':' x = 0, f and y = 0, f, necessarily','line_number':957,'multiline':False]['text':' cannot be less than EXP_MIN','line_number':970,'multiline':False]['text':' (x = 0 or y = 0) and z = 0','line_number':974,'multiline':False]['text':' the result is 0','line_number':975,'multiline':False]['text':' preferred exponent','line_number':977,'multiline':False]['text':' preferred exponent','line_number':979,'multiline':False]['text':' x * y and z have opposite signs','line_number':983,'multiline':False]['text':' res = -0.0','line_number':985,'multiline':False]['text':' res = +0.0','line_number':989,'multiline':False]['text':' res.w[1] |= 0x0;','line_number':990,'multiline':False]['text':' from this point on, we may need to know the number of decimal digits','line_number':1001,'multiline':False]['text':' in the significands of x, y, z when x, y, z != 0','line_number':1002,'multiline':False]['text':' x = f (non-zero finite)','line_number':1004,'multiline':False]['text':' q1 = nr. of decimal digits in x','line_number':1005,'multiline':False]['text':' determine first the nr. of bits in x','line_number':1006,'multiline':False]['text':' x >= 2^53','line_number':1008,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1009,'multiline':False]['text':' exact conversion','line_number':1010,'multiline':False]['text':' if x < 2^53','line_number':1013,'multiline':False]['text':' exact conversion','line_number':1014,'multiline':False]['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':1018,'multiline':False]['text':' exact conversion','line_number':1019,'multiline':False]['text':' y = f (non-zero finite)','line_number':1033,'multiline':False]['text':' q2 = nr. of decimal digits in y','line_number':1034,'multiline':False]['text':' determine first the nr. of bits in y','line_number':1035,'multiline':False]['text':' y >= 2^53','line_number':1037,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1038,'multiline':False]['text':' exact conversion','line_number':1039,'multiline':False]['text':' if y < 2^53','line_number':1042,'multiline':False]['text':' exact conversion','line_number':1043,'multiline':False]['text':' C2.w[1] != 0 => nr. bits = 64 + nr_bits (C2.w[1])','line_number':1047,'multiline':False]['text':' exact conversion','line_number':1048,'multiline':False]['text':' z = f (non-zero finite)','line_number':1062,'multiline':False]['text':' q3 = nr. of decimal digits in z','line_number':1063,'multiline':False]['text':' determine first the nr. of bits in z','line_number':1064,'multiline':False]['text':' z >= 2^53','line_number':1066,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1067,'multiline':False]['text':' exact conversion','line_number':1068,'multiline':False]['text':' if z < 2^53','line_number':1071,'multiline':False]['text':' exact conversion','line_number':1072,'multiline':False]['text':' C3.w[1] != 0 => nr. bits = 64 + nr_bits (C3.w[1])','line_number':1076,'multiline':False]['text':' exact conversion','line_number':1077,'multiline':False]['text':' x = 0 or y = 0','line_number':1093,'multiline':False]['text':' z = f, necessarily; for 0 + z return z, with the preferred exponent','line_number':1094,'multiline':False]['text':' the result is z, but need to get the preferred exponent','line_number':1095,'multiline':False]['text':' the preferred exponent is z_exp','line_number':1096,'multiline':False]['text':' if (p_exp < z_exp) the preferred exponent is p_exp','line_number':1099,'multiline':False]['text':' return (C3 * 10^scale) * 10^(z_exp - scale)','line_number':1100,'multiline':False]['text':' where scale = min (p34-q3, (z_exp-p_exp) >> 49)','line_number':1101,'multiline':False]['text':' & MASK_COEFF, which is redundant','line_number':1107,'multiline':False]['text':' z fits in 64 bits ','line_number':1109,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1110,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale]','line_number':1111,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1113,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':1114,'multiline':False]['text':' z fits in 128 bits, but 10^scale must fit in 64 bits ','line_number':1117,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':1118,'multiline':False]['text':' subtract scale from the exponent','line_number':1121,'multiline':False]['text':' continue with x = f, y = f, z = 0 or x = f, y = f, z = f','line_number':1132,'multiline':False]['text':' unbiased exponent of x ','line_number':1135,'multiline':False]['text':' unbiased exponent of y ','line_number':1136,'multiline':False]['text':' unbiased exponent of z','line_number':1137,'multiline':False]['text':' unbiased exponent of the exact x * y','line_number':1138,'multiline':False]['text':' calculate C1 * C2 and its number of decimal digits, q4','line_number':1140,'multiline':False]['text':' the exact product has either q1 + q2 - 1 or q1 + q2 decimal digits','line_number':1142,'multiline':False]['text':' where 2 <= q1 + q2 <= 68','line_number':1143,'multiline':False]['text':' calculate C4 = C1 * C2 and determine q','line_number':1144,'multiline':False]['text':' if 2 <= q1 + q2 <= 19, C4 = C1 * C2 fits in 64 bits','line_number':1146,'multiline':False]['text':' if C4 < 10^(q1+q2-1) then q4 = q1 + q2 - 1 else q4 = q1 + q2','line_number':1148,'multiline':False]['text':' q4 in [1, 18]','line_number':1150,'multiline':False]['text':' q4 in [2, 19]','line_number':1152,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;','line_number':1153,'multiline':False]['text':' C4 = C1 * C2 fits in 64 or 128 bits','line_number':1154,'multiline':False]['text':' q1 <= 19 and q2 <= 19 so both C1 and C2 fit in 64 bits','line_number':1155,'multiline':False]['text':' if C4 < 10^(q1+q2-1) = 10^19 then q4 = q1+q2-1 = 19 else q4 = q1+q2 = 20','line_number':1157,'multiline':False]['text':' 19 = q1+q2-1','line_number':1158,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;','line_number':1159,'multiline':False]['text':' 19 = q1 + q2 - 1','line_number':1160,'multiline':False]['text':' if (C4.w[1] == 0)','line_number':1162,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;','line_number':1163,'multiline':False]['text':' else','line_number':1164,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1165,'multiline':False]['text':' 20 = q1 + q2','line_number':1166,'multiline':False]['text':' 21 <= q1 + q2 <= 38','line_number':1168,'multiline':False]['text':' C4 = C1 * C2 fits in 64 or 128 bits','line_number':1169,'multiline':False]['text':' (64 bits possibly, but only when q1 + q2 = 21 and C4 has 20 digits)','line_number':1170,'multiline':False]['text':' at least one of C1, C2 has at most 19 decimal digits & fits in 64 bits','line_number':1171,'multiline':False]['text':' q2 <= 19','line_number':1174,'multiline':False]['text':' if C4 < 10^(q1+q2-1) then q4 = q1 + q2 - 1 else q4 = q1 + q2','line_number':1177,'multiline':False]['text':' if (C4.w[1] == 0) // q4 = 20, necessarily','line_number':1181,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;','line_number':1182,'multiline':False]['text':' else','line_number':1183,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1184,'multiline':False]['text':' q4 in [20, 37]','line_number':1185,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1187,'multiline':False]['text':' q4 in [21, 38]','line_number':1188,'multiline':False]['text':' C4 = C1 * C2 fits in 128 or 192 bits','line_number':1190,'multiline':False]['text':' both C1 and C2 fit in 128 bits (actually in 113 bits)','line_number':1191,'multiline':False]['text':' may replace this by 128x128_to192','line_number':1192,'multiline':False]['text':' C4.w[3] is 0','line_number':1193,'multiline':False]['text':' if C4 < 10^(q1+q2-1) = 10^38 then q4 = q1+q2-1 = 38 else q4 = q1+q2 = 39','line_number':1194,'multiline':False]['text':' 18 = 38 - 20 = q1+q2-1 - 20','line_number':1198,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1199,'multiline':False]['text':' 38 = q1 + q2 - 1','line_number':1200,'multiline':False]['text':' if (C4.w[2] == 0)','line_number':1202,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1203,'multiline':False]['text':' else','line_number':1204,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1205,'multiline':False]['text':' 39 = q1 + q2','line_number':1206,'multiline':False]['text':' 40 <= q1 + q2 <= 57','line_number':1208,'multiline':False]['text':' C4 = C1 * C2 fits in 128 or 192 bits','line_number':1209,'multiline':False]['text':' (128 bits possibly, but only when q1 + q2 = 40 and C4 has 39 digits)','line_number':1210,'multiline':False]['text':' both C1 and C2 fit in 128 bits (actually in 113 bits); at most one','line_number':1211,'multiline':False]['text':' may fit in 64 bits','line_number':1212,'multiline':False]['text':' C1 fits in 64 bits','line_number':1213,'multiline':False]['text':' __mul_64x128_full (REShi64, RESlo128, A64, B128)','line_number':1214,'multiline':False]['text':' C2 fits in 64 bits','line_number':1216,'multiline':False]['text':' __mul_64x128_full (REShi64, RESlo128, A64, B128)','line_number':1217,'multiline':False]['text':' both C1 and C2 require 128 bits','line_number':1219,'multiline':False]['text':' may use __mul_128x128_to_192 (C4.w[2], C4.w[0], C2.w[0], C1);','line_number':1220,'multiline':False]['text':' C4.w[3] = 0','line_number':1221,'multiline':False]['text':' if C4 < 10^(q1+q2-1) then q4 = q1 + q2 - 1 else q4 = q1 + q2','line_number':1223,'multiline':False]['text':' if (C4.w[2] == 0) // q4 = 39, necessarily','line_number':1229,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;','line_number':1230,'multiline':False]['text':' else','line_number':1231,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1232,'multiline':False]['text':' q4 in [39, 56]','line_number':1233,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1235,'multiline':False]['text':' q4 in [40, 57]','line_number':1236,'multiline':False]['text':' C4 = C1 * C2 fits in 192 or 256 bits;','line_number':1238,'multiline':False]['text':' both C1 and C2 fit in 128 bits (actually in 113 bits); none can','line_number':1239,'multiline':False]['text':' fit in 64 bits, because each number must have at least 24 decimal','line_number':1240,'multiline':False]['text':' digits for the sum to have 58 (as the max. nr. of digits is 34) =>','line_number':1241,'multiline':False]['text':' C1.w[1] != 0 and C2.w[1] != 0','line_number':1242,'multiline':False]['text':' if C4 < 10^(q1+q2-1) = 10^57 then q4 = q1+q2-1 = 57 else q4 = q1+q2 = 58','line_number':1244,'multiline':False]['text':' 18 = 57 - 39 = q1+q2-1 - 39','line_number':1250,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1251,'multiline':False]['text':' 57 = q1 + q2 - 1','line_number':1252,'multiline':False]['text':' if (C4.w[3] == 0)','line_number':1254,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1255,'multiline':False]['text':' else','line_number':1256,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;','line_number':1257,'multiline':False]['text':' 58 = q1 + q2','line_number':1258,'multiline':False]['text':' if 59 <= q1 + q2 <= 68','line_number':1260,'multiline':False]['text':' C4 = C1 * C2 fits in 192 or 256 bits','line_number':1261,'multiline':False]['text':' (192 bits possibly, but only when q1 + q2 = 59 and C4 has 58 digits)','line_number':1262,'multiline':False]['text':' both C1 and C2 fit in 128 bits (actually in 113 bits); none fits in','line_number':1263,'multiline':False]['text':' 64 bits','line_number':1264,'multiline':False]['text':' may use __mul_128x128_to_192 (C4.w[2], C4.w[0], C2.w[0], C1);','line_number':1265,'multiline':False]['text':' C4.w[3] = 0','line_number':1266,'multiline':False]['text':' if C4 < 10^(q1+q2-1) then q4 = q1 + q2 - 1 else q4 = q1 + q2','line_number':1267,'multiline':False]['text':' if (C4.w[3] == 0) // q4 = 58, necessarily','line_number':1275,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;','line_number':1276,'multiline':False]['text':' else','line_number':1277,'multiline':False]['text':'   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;','line_number':1278,'multiline':False]['text':' q4 in [58, 67]','line_number':1279,'multiline':False]['text':' length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;','line_number':1281,'multiline':False]['text':' q4 in [59, 68]','line_number':1282,'multiline':False]['text':' x = f, y = f, z = 0','line_number':1286,'multiline':False]['text':' sticky bits - caller value must be preserved','line_number':1287,'multiline':False]['text':' truncate C4 to p34 digits into res','line_number':1292,'multiline':False]['text':' x = q4-p34, 1 <= x <= 34 because 35 <= q4 <= 68','line_number':1293,'multiline':False]['text':' 35 <= q4 <= 57','line_number':1302,'multiline':False]['text':' if (q4 <= 68)','line_number':1312,'multiline':False]['text':' res is now the coefficient of the result rounded to the destination ','line_number':1328,'multiline':False]['text':' precision, with unbounded exponent; the exponent is e4; q4=digits(res)','line_number':1329,'multiline':False]['text':' if (q4 <= p34)','line_number':1330,'multiline':False]['text':' C4 * 10^e4 is the result rounded to the destination precision, with  ','line_number':1331,'multiline':False]['text':' unbounded exponent (which is exact)','line_number':1332,'multiline':False]['text':' e4 is too large, but can be brought within range by scaling up C4','line_number':1335,'multiline':False]['text':' 1 <= scale < P-q4 <= P-1 => 1 <= scale <= P-2','line_number':1336,'multiline':False]['text':' res = (C4 * 10^scale) * 10^expmax','line_number':1337,'multiline':False]['text':' C4 fits in 64 bits','line_number':1338,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1339,'multiline':False]['text':' 64 x 64 C4.w[0] * bid_ten2k64[scale]','line_number':1340,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1342,'multiline':False]['text':' 64 x 128 C4.w[0] * bid_ten2k128[scale - 20]','line_number':1343,'multiline':False]['text':' C4 fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1346,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * CC43','line_number':1347,'multiline':False]['text':' expmax','line_number':1350,'multiline':False]['text':' res is the coefficient of the result rounded to the destination ','line_number':1356,'multiline':False]['text':' precision, with unbounded exponent (it has q4 digits); the exponent ','line_number':1357,'multiline':False]['text':' is e4 (exact result)','line_number':1358,'multiline':False]['text':' check for overflow','line_number':1361,'multiline':False]['text':' +/-inf','line_number':1364,'multiline':False]['text':' check for underflow','line_number':1383,'multiline':False]['text':' the result is tiny ','line_number':1385,'multiline':False]['text':' (good also for most cases if 'before rounding')','line_number':1386,'multiline':False]['text':' if e4 < expmin, we must truncate more of res','line_number':1388,'multiline':False]['text':' x0 >= 1','line_number':1389,'multiline':False]['text':' the number of decimal digits in res is q4','line_number':1398,'multiline':False]['text':' 1 <= x0 <= q4-1 => round res to q4 - x0 digits','line_number':1399,'multiline':False]['text':' 2 <= q4 <= 18, 1 <= x0 <= 17','line_number':1400,'multiline':False]['text':' R64 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 1, 1 <= q4 - x0 <= 17','line_number':1406,'multiline':False]['text':' res.w[1] = 0; (from above)','line_number':1409,'multiline':False]['text':' if (q4 <= 34)','line_number':1411,'multiline':False]['text':' 19 <= q4 <= 38','line_number':1412,'multiline':False]['text':' increase coefficient by a factor of 10; this will be <= 10^33','line_number':1420,'multiline':False]['text':' R128 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 1, 1 <= q4 - x0 <= 37','line_number':1421,'multiline':False]['text':' 1 <= q4 - x0 <= 19','line_number':1422,'multiline':False]['text':' res.w[1] = 0;','line_number':1423,'multiline':False]['text':' 20 <= q4 - x0 <= 37','line_number':1425,'multiline':False]['text':' expmin ','line_number':1431,'multiline':False]['text':' the second rounding is for 0.d(0)d(1)...d(q4-1) * 10^emin','line_number':1433,'multiline':False]['text':' determine relationship with 1/2 ulp','line_number':1434,'multiline':False]['text':' < 1/2 ulp','line_number':1436,'multiline':False]['text':' = 1/2 ulp','line_number':1439,'multiline':False]['text':' > 1/2 ulp','line_number':1442,'multiline':False]['text':' gt_half_ulp = 1;','line_number':1443,'multiline':False]['text':' if (q4 <= 34)','line_number':1446,'multiline':False]['text':' < 1/2 ulp','line_number':1449,'multiline':False]['text':' = 1/2 ulp','line_number':1453,'multiline':False]['text':' > 1/2 ulp','line_number':1456,'multiline':False]['text':' gt_half_ulp = 1;','line_number':1457,'multiline':False]['text':' res = +0.0 * 10^expmin','line_number':1462,'multiline':False]['text':' if (gt_half_ulp)','line_number':1465,'multiline':False]['text':' res = +1 * 10^expmin','line_number':1466,'multiline':False]['text':' if (x0 > q4)','line_number':1471,'multiline':False]['text':' the second rounding is for 0.0...d(0)d(1)...d(q4-1) * 10^emin','line_number':1472,'multiline':False]['text':' avoid a double rounding error','line_number':1478,'multiline':False]['text':' double rounding error upward','line_number':1480,'multiline':False]['text':' res = res - 1','line_number':1481,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':1485,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':1486,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':1487,'multiline':False]['text':' not possible for f * f + 0','line_number':1488,'multiline':False]['text':' double rounding error downward','line_number':1492,'multiline':False]['text':' res = res + 1','line_number':1493,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':1501,'multiline':False]['text':' inexact because of the first rounding','line_number':1502,'multiline':False]['text':' pulled up to a midpoint','line_number':1511,'multiline':False]['text':' pulled down to a midpoint','line_number':1518,'multiline':False]['text':' if e4 >= emin then q4 < P and the result is tiny and exact','line_number':1526,'multiline':False]['text':' if (e3 < e4) the preferred exponent is e3','line_number':1528,'multiline':False]['text':' return (C4 * 10^scale) * 10^(e4 - scale)','line_number':1529,'multiline':False]['text':' where scale = min (p34-q4, (e4 - e3))','line_number':1530,'multiline':False]['text':' res and e4 are unchanged','line_number':1536,'multiline':False]['text':' C4 fits in 64 bits','line_number':1537,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1538,'multiline':False]['text':' 64 x 64 res.w[0] * bid_ten2k64[scale]','line_number':1539,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1541,'multiline':False]['text':' 64 x 128 res.w[0] * bid_ten2k128[scale - 20]','line_number':1542,'multiline':False]['text':' res fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1545,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':1546,'multiline':False]['text':' subtract scale from the exponent','line_number':1549,'multiline':False]['text':' check for inexact result','line_number':1554,'multiline':False]['text':' set the inexact flag and the underflow flag','line_number':1557,'multiline':False]['text':' no overflow, and no underflow for rounding to nearest','line_number':1577,'multiline':False]['text':' (although if tininess is detected 'before rounding', we may','line_number':1578,'multiline':False]['text':' get here if incr_exp = 1 and then q4 + e4 == expmin + p34)','line_number':1579,'multiline':False]['text':' if e4 = expmin && significand < 10^33 => result is tiny (for RD, RZ)','line_number':1588,'multiline':False]['text':' set the inexact flag','line_number':1600,'multiline':False]['text':' x * y is exact','line_number':1606,'multiline':False]['text':' need to ensure that the result has the preferred exponent','line_number':1607,'multiline':False]['text':' the preferred exponent is z_exp','line_number':1609,'multiline':False]['text':' signficand of res in C3','line_number':1610,'multiline':False]['text':' the number of decimal digits of x * y is q4 <= 34','line_number':1613,'multiline':False]['text':' Note: the coefficient fits in 128 bits','line_number':1614,'multiline':False]['text':' return (C3 * 10^scale) * 10^(p_exp - scale)','line_number':1616,'multiline':False]['text':' where scale = min (p34-q4, (p_exp-z_exp) >> 49)','line_number':1617,'multiline':False]['text':' subtract scale from the exponent','line_number':1622,'multiline':False]['text':' leave res unchanged','line_number':1625,'multiline':False]['text':' x * y fits in 64 bits','line_number':1626,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1627,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale] ','line_number':1628,'multiline':False]['text':' 10^scale fits in 128 bits ','line_number':1630,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':1631,'multiline':False]['text':' x * y fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1635,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3 ','line_number':1636,'multiline':False]['text':' else leave the result as it is, because p_exp <= z_exp','line_number':1640,'multiline':False]['text':' else we have f * f + f','line_number':1649,'multiline':False]['text':' continue with x = f, y = f, z = f','line_number':1651,'multiline':False]['text':' Case (1')','line_number':1657,'multiline':False]['text':' Case (1''A)','line_number':1658,'multiline':False]['text':' check for overflow, which can occur only in Case (1')','line_number':1659,'multiline':False]['text':' e3 > expmax implies p34 <= delta-1 and e3 > expmax is a necessary','line_number':1661,'multiline':False]['text':' condition for (q3 + e3) > (p34 + expmax)','line_number':1662,'multiline':False]['text':' +/-inf','line_number':1664,'multiline':False]['text':' q3 <= p34; if (q3 < p34) scale C3 up by 10^(p34-q3)','line_number':1673,'multiline':False]['text':' C3 fits in 64 bits','line_number':1679,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1680,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale]','line_number':1681,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1683,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':1684,'multiline':False]['text':' C3 fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1688,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':1689,'multiline':False]['text':' the coefficient in res has q3 + scale = p34 digits','line_number':1692,'multiline':False]['text':' res = z','line_number':1709,'multiline':False]['text':' the preferred exponent is z_exp - (p34 - q3)','line_number':1710,'multiline':False]['text':' return (C3 * 10^scale) * 10^(z_exp - scale)','line_number':1711,'multiline':False]['text':' where scale = min (p34-q3, z_exp-EMIN)','line_number':1712,'multiline':False]['text':' z fits in 64 bits','line_number':1720,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1721,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale]','line_number':1722,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1724,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':1725,'multiline':False]['text':' z fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1728,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':1729,'multiline':False]['text':' the coefficient in res has q3 + scale digits','line_number':1732,'multiline':False]['text':' subtract scale from the exponent','line_number':1733,'multiline':False]['text':' OK for tininess detection ','line_number':1738,'multiline':False]['text':' before or after rounding, because the exponent of the ','line_number':1739,'multiline':False]['text':' rounded result with unbounded exponent does not change ','line_number':1740,'multiline':False]['text':' due to rounding overflow','line_number':1741,'multiline':False]['text':' if q3 = p34','line_number':1742,'multiline':False]['text':' use the following to avoid double rounding errors when operating on','line_number':1748,'multiline':False]['text':' mixed formats in rounding to nearest, and for correcting the result','line_number':1749,'multiline':False]['text':' if not rounding to nearest','line_number':1750,'multiline':False]['text':' there is a gap of exactly one digit between the scaled C3 and C4','line_number':1752,'multiline':False]['text':' C3 * 10^ scale = 10^(q3+scale-1) <=> C3 = 10^(q3-1) is a special case','line_number':1753,'multiline':False]['text':' C3 * 10^ scale != 10^(q3-1)','line_number':1758,'multiline':False]['text':' if ((res.w[1] & MASK_COEFF) != 0x0000314dc6448d93ull ||','line_number':1759,'multiline':False]['text':' res.w[0] != 0x38c15b0a00000000ull) { // C3 * 10^scale != 10^33','line_number':1760,'multiline':False]['text':' if (z_sign), set as if for abs. value','line_number':1761,'multiline':False]['text':' if C3 * 10^scale = 10^(q3+scale-1)','line_number':1762,'multiline':False]['text':' ok from above e3 = (z_exp >> 49) - 6176;','line_number':1763,'multiline':False]['text':' the result is always inexact','line_number':1764,'multiline':False]['text':' if q4 > 1 then truncate C4 from q4 digits to 1 digit; ','line_number':1768,'multiline':False]['text':' x = q4-1, 1 <= x <= 67 and check if this operation is exact','line_number':1769,'multiline':False]['text':' 2 <= q4 <= 18','line_number':1770,'multiline':False]['text':' one decimal digit','line_number':1783,'multiline':False]['text':' one decimal digit','line_number':1793,'multiline':False]['text':' if (q4 <= 68)','line_number':1794,'multiline':False]['text':' one decimal digit','line_number':1800,'multiline':False]['text':' result does not change','line_number':1814,'multiline':False]['text':' result decremented is 10^(q3+scale) - 1','line_number':1824,'multiline':False]['text':' if ((q3 + scale + 1) <= 35)','line_number':1828,'multiline':False]['text':' borrow never occurs','line_number':1832,'multiline':False]['text':' result not tiny (in round-to-nearest mode)','line_number':1840,'multiline':False]['text':' rounds to 10^33 * 10^emin','line_number':1841,'multiline':False]['text':' tiny if detected before rounding','line_number':1846,'multiline':False]['text':' end 10^(q3+scale-1)','line_number':1849,'multiline':False]['text':' set the inexact flag','line_number':1850,'multiline':False]['text':' if (z_sign), set as if for absolute value','line_number':1854,'multiline':False]['text':' if (p_sign != z_sign)','line_number':1856,'multiline':False]['text':' if (z_sign), set as if for absolute value','line_number':1857,'multiline':False]['text':' the result is always inexact => set the inexact flag','line_number':1862,'multiline':False]['text':' Determine tininess:','line_number':1863,'multiline':False]['text':'    if (exp > expmin)','line_number':1864,'multiline':False]['text':'      the result is not tiny','line_number':1865,'multiline':False]['text':'    else // if exp = emin','line_number':1866,'multiline':False]['text':'      if (q3 + scale < p34)','line_number':1867,'multiline':False]['text':'        the result is tiny','line_number':1868,'multiline':False]['text':'      else // if (q3 + scale = p34)','line_number':1869,'multiline':False]['text':'        if (C3 * 10^scale > 10^33)','line_number':1870,'multiline':False]['text':'          the result is not tiny','line_number':1871,'multiline':False]['text':'        else // if C3 * 10^scale = 10^33','line_number':1872,'multiline':False]['text':'          if (xy * z > 0)','line_number':1873,'multiline':False]['text':'            the result is not tiny','line_number':1874,'multiline':False]['text':'          else // if (xy * z < 0)','line_number':1875,'multiline':False]['text':'            if (rnd_mode = RN || rnd_mode = RA) and (delta = P+1) and','line_number':1876,'multiline':False]['text':'                C4 > 5 * 10^(q4-1)','line_number':1877,'multiline':False]['text':'              the result is tiny','line_number':1878,'multiline':False]['text':'            else','line_number':1879,'multiline':False]['text':'              the result is not tiny','line_number':1880,'multiline':False]['text':'          endif','line_number':1881,'multiline':False]['text':'        endif','line_number':1882,'multiline':False]['text':'      endif','line_number':1883,'multiline':False]['text':'    endif ','line_number':1884,'multiline':False]['text':' determine if C4 > 5 * 10^(q4-1)','line_number':1887,'multiline':False]['text':' if (q4 <= 68)','line_number':1904,'multiline':False]['text':' 10^33_high','line_number':1920,'multiline':False]['text':' 10^33_low','line_number':1921,'multiline':False]['text':' 10^33_high','line_number':1930,'multiline':False]['text':' 10^33_low','line_number':1931,'multiline':False]['text':' for all rounding modes','line_number':1933,'multiline':False]['text':' Case (1''B)','line_number':1950,'multiline':False]['text':' because Case (1''A) was treated above, e3 + 6176 >= p34 - q3','line_number':1952,'multiline':False]['text':' and C3 can be scaled up to p34 digits if needed','line_number':1953,'multiline':False]['text':' scale C3 to p34 digits if needed','line_number':1955,'multiline':False]['text':' 0 <= scale <= p34 - 1','line_number':1956,'multiline':False]['text':' z fits in 64 bits','line_number':1960,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1961,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale]','line_number':1962,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':1964,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':1965,'multiline':False]['text':' z fits in 128 bits, but 10^scale must fit in 64 bits','line_number':1968,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':1969,'multiline':False]['text':' subtract scale from the exponent','line_number':1972,'multiline':False]['text':' now z_sign, z_exp, and res correspond to a z scaled to p34 = 34 digits','line_number':1975,'multiline':False]['text':' determine whether x * y is less than, equal to, or greater than ','line_number':1977,'multiline':False]['text':' 1/2 ulp (z)','line_number':1978,'multiline':False]['text':' < 1/2 ulp','line_number':1980,'multiline':False]['text':' = 1/2 ulp','line_number':1982,'multiline':False]['text':' > 1/2 ulp','line_number':1984,'multiline':False]['text':' < 1/2 ulp','line_number':1990,'multiline':False]['text':' = 1/2 ulp','line_number':1993,'multiline':False]['text':' > 1/2 ulp','line_number':1995,'multiline':False]['text':' < 1/2 ulp','line_number':2004,'multiline':False]['text':' = 1/2 ulp','line_number':2008,'multiline':False]['text':' > 1/2 ulp','line_number':2010,'multiline':False]['text':' < 1/2 ulp','line_number':2023,'multiline':False]['text':' = 1/2 ulp','line_number':2028,'multiline':False]['text':' > 1/2 ulp','line_number':2030,'multiline':False]['text':' use the following to avoid double rounding errors when operating on','line_number':2038,'multiline':False]['text':' mixed formats in rounding to nearest','line_number':2039,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2040,'multiline':False]['text':' add 1 ulp to the significand','line_number':2042,'multiline':False]['text':' check for rounding overflow, when coeff == 10^34','line_number':2046,'multiline':False]['text':' coefficient = 10^34','line_number':2048,'multiline':False]['text':' coeff = 10^33','line_number':2050,'multiline':False]['text':' end add 1 ulp','line_number':2055,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2058,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2060,'multiline':False]['text':' if (eq_half_ulp && !(res.w[0] & 0x01))','line_number':2062,'multiline':False]['text':' leave unchanged ','line_number':2063,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2065,'multiline':False]['text':' the result is always inexact, and never tiny','line_number':2067,'multiline':False]['text':' set the inexact flag','line_number':2068,'multiline':False]['text':' check for overflow','line_number':2070,'multiline':False]['text':' +/-inf','line_number':2072,'multiline':False]['text':' if (p_sign != z_sign)','line_number':2090,'multiline':False]['text':' consider two cases, because C3 * 10^scale = 10^33 is a special case','line_number':2091,'multiline':False]['text':' C3 * 10^scale != 10^33','line_number':2093,'multiline':False]['text':' use the following to avoid double rounding errors when operating','line_number':2096,'multiline':False]['text':' on mixed formats in rounding to nearest','line_number':2097,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2098,'multiline':False]['text':' subtract 1 ulp from the significand','line_number':2100,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2106,'multiline':False]['text':'if(z_sign), as if for absolute value','line_number':2108,'multiline':False]['text':' if (eq_half_ulp && !(res.w[0] & 0x01))','line_number':2110,'multiline':False]['text':' leave unchanged','line_number':2111,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2113,'multiline':False]['text':' the result is always inexact, and never tiny','line_number':2115,'multiline':False]['text':' check for overflow for RN','line_number':2116,'multiline':False]['text':' +/-inf','line_number':2119,'multiline':False]['text':' set the inexact flag','line_number':2137,'multiline':False]['text':' if C3 * 10^scale = 10^33','line_number':2147,'multiline':False]['text':' the result is exact if exp > expmin and C4 = d*10^(q4-1), ','line_number':2150,'multiline':False]['text':' where d = 1, 2, 3, ..., 9; it could be tiny too, but exact','line_number':2151,'multiline':False]['text':' if q4 = 1 the result is exact','line_number':2153,'multiline':False]['text':' result coefficient = 10^34 - C4','line_number':2154,'multiline':False]['text':' if q4 > 1 then truncate C4 from q4 digits to 1 digit; ','line_number':2161,'multiline':False]['text':' x = q4-1, 1 <= x <= 67 and check if this operation is exact','line_number':2162,'multiline':False]['text':' 2 <= q4 <= 18','line_number':2163,'multiline':False]['text':' one decimal digit','line_number':2177,'multiline':False]['text':' one decimal digit','line_number':2187,'multiline':False]['text':' if (q4 <= 68)','line_number':2188,'multiline':False]['text':' one decimal digit','line_number':2194,'multiline':False]['text':' the result is exact: 10^34 - R64','line_number':2198,'multiline':False]['text':' incr_exp = 0 with certainty','line_number':2199,'multiline':False]['text':' We want R64 to be the top digit of C4, but we actually ','line_number':2206,'multiline':False]['text':' obtained (C4 * 10^(-q4+1))RN; a correction may be needed,','line_number':2207,'multiline':False]['text':' because the top digit is (C4 * 10^(-q4+1))RZ','line_number':2208,'multiline':False]['text':' however, if incr_exp = 1 then R64 = 10 with certainty','line_number':2209,'multiline':False]['text':' the result is inexact as C4 has more than 1 significant digit','line_number':2213,'multiline':False]['text':' and C3 * 10^scale = 10^33','line_number':2214,'multiline':False]['text':' example of case that is treated here:','line_number':2215,'multiline':False]['text':' 100...0 * 10^e3 - 0.41 * 10^e3 =','line_number':2216,'multiline':False]['text':' 0999...9.59 * 10^e3 -> rounds to 99...96*10^(e3-1)','line_number':2217,'multiline':False]['text':' note that (e3 > expmin}','line_number':2218,'multiline':False]['text':' in order to round, subtract R64 from 10^34 and then compare','line_number':2219,'multiline':False]['text':' C4 - R64 * 10^(q4-1) with 1/2 ulp','line_number':2220,'multiline':False]['text':' calculate 10^34 - R64','line_number':2221,'multiline':False]['text':' will be OR-ed with sign & significand','line_number':2224,'multiline':False]['text':' calculate C4 - R64 * 10^(q4-1); this is a rare case and','line_number':2225,'multiline':False]['text':' R64 is small, 1 <= R64 <= 9','line_number':2226,'multiline':False]['text':' the result is always inexact, and never tiny','line_number':2243,'multiline':False]['text':' check for overflow for RN','line_number':2244,'multiline':False]['text':' +/-inf','line_number':2247,'multiline':False]['text':' set the inexact flag','line_number':2265,'multiline':False]['text':' end result is inexact','line_number':2278,'multiline':False]['text':' end q4 > 1','line_number':2279,'multiline':False]['text':' if (e3 = emin)','line_number':2280,'multiline':False]['text':' if e3 = expmin the result is also tiny (the condition for','line_number':2281,'multiline':False]['text':' tininess is C4 > 050...0 [q4 digits] which is met because','line_number':2282,'multiline':False]['text':' the msd of C4 is not zero)','line_number':2283,'multiline':False]['text':' the result is tiny and inexact in all rounding modes;','line_number':2284,'multiline':False]['text':' it is either 100...0 or 0999...9 (use lt_half_ulp, eq_half_ulp, ','line_number':2285,'multiline':False]['text':' gt_half_ulp to calculate)','line_number':2286,'multiline':False]['text':' if (lt_half_ulp || eq_half_ulp) res = 10^33 stays unchanged','line_number':2287,'multiline':False]['text':' p_sign != z_sign so swap gt_half_ulp and lt_half_ulp','line_number':2289,'multiline':False]['text':' res = 10^33 - 1','line_number':2290,'multiline':False]['text':' inexact is set later','line_number':2298,'multiline':False]['text':' if (z_sign), as if for absolute value','line_number':2301,'multiline':False]['text':'if(z_sign), as if for absolute value','line_number':2303,'multiline':False]['text':' if (gt_half_ulp)','line_number':2304,'multiline':False]['text':'if(z_sign), as if for absolute value','line_number':2305,'multiline':False]['text':' end e3 = emin','line_number':2317,'multiline':False]['text':' set the inexact flag (if the result was not exact)','line_number':2318,'multiline':False]['text':' end 10^33','line_number':2322,'multiline':False]['text':' end if (p_sign != z_sign)','line_number':2323,'multiline':False]['text':' Case (2)','line_number':2332,'multiline':False]['text':' Case (3)','line_number':2333,'multiline':False]['text':' Case (4)','line_number':2334,'multiline':False]['text':' Case (5)','line_number':2335,'multiline':False]['text':' Case (6)','line_number':2336,'multiline':False]['text':' Case (2), (3), (4), (5) or (6)','line_number':2337,'multiline':False]['text':' the result has the sign of z','line_number':2339,'multiline':False]['text':' Case (2)','line_number':2341,'multiline':False]['text':' Case (4)','line_number':2342,'multiline':False]['text':' round first the sum x * y + z with unbounded exponent','line_number':2343,'multiline':False]['text':' scale C3 up by scale = p34 - q3, 1 <= scale <= p34-1, ','line_number':2344,'multiline':False]['text':' 1 <= scale <= 33','line_number':2345,'multiline':False]['text':' calculate res = C3 * 10^scale','line_number':2346,'multiline':False]['text':' Case (6)','line_number':2349,'multiline':False]['text':' make Case (6) look like Case (3) or Case (5) with scale = 0','line_number':2350,'multiline':False]['text':' by scaling up C4 by 10^(q3 - delta - q4) ','line_number':2351,'multiline':False]['text':' 1 <= scale <= 33','line_number':2352,'multiline':False]['text':' 1 <= scale <= 19; C4 fits in 64 bits','line_number':2353,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':2354,'multiline':False]['text':' 64 x 64 C4.w[0] * bid_ten2k64[scale]','line_number':2355,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':2357,'multiline':False]['text':' 64 x 128 C4.w[0] * bid_ten2k128[scale - 20]','line_number':2358,'multiline':False]['text':' C4 fits in 128 bits, but 10^scale must fit in 64 bits','line_number':2361,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C4','line_number':2362,'multiline':False]['text':' e4 does not need adjustment, as it is not used from this point on','line_number':2367,'multiline':False]['text':' now Case (6) looks like Case (3) or Case (5) with scale = 0 ','line_number':2370,'multiline':False]['text':' if Case (3) or Case (5)','line_number':2371,'multiline':False]['text':' Note: Case (3) is similar to Case (2), but scale differs and the','line_number':2372,'multiline':False]['text':' result is exact, unless it is tiny (so x0 = 0 when calculating the','line_number':2373,'multiline':False]['text':' result with unbounded exponent)','line_number':2374,'multiline':False]['text':' calculate first the sum x * y + z with unbounded exponent (exact)','line_number':2376,'multiline':False]['text':' scale C3 up by scale = delta + q4 - q3, 1 <= scale <= p34-1,','line_number':2377,'multiline':False]['text':' 1 <= scale <= 33','line_number':2378,'multiline':False]['text':' calculate res = C3 * 10^scale','line_number':2379,'multiline':False]['text':' Note: the comments which follow refer [mainly] to Case (2)]','line_number':2382,'multiline':False]['text':' this could happen e.g. if we return to case2_repeat','line_number':2386,'multiline':False]['text':' or in Case (4)','line_number':2387,'multiline':False]['text':' 1 <= scale <= 19; z fits in 64 bits','line_number':2390,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':2391,'multiline':False]['text':' 64 x 64 C3.w[0] * bid_ten2k64[scale]','line_number':2392,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':2394,'multiline':False]['text':' 64 x 128 C3.w[0] * bid_ten2k128[scale - 20]','line_number':2395,'multiline':False]['text':' z fits in 128 bits, but 10^scale must fit in 64 bits','line_number':2398,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C3','line_number':2399,'multiline':False]['text':' e3 is already calculated','line_number':2402,'multiline':False]['text':' now res = C3 * 10^scale and e3 = e3 - scale','line_number':2404,'multiline':False]['text':' Note: C3 * 10^scale could be 10^34 if we returned to case2_repeat','line_number':2405,'multiline':False]['text':' because the result was too small','line_number':2406,'multiline':False]['text':' round C4 to nearest to q4 - x0 digits, where x0 = delta + q4 - p34,','line_number':2408,'multiline':False]['text':' 1 <= x0 <= min (q4 - 1, 2 * p34 - 1) <=> 1 <= x0 <= min (q4 - 1, 67)','line_number':2409,'multiline':False]['text':' Also: 1 <= q4 - x0 <= p34 -1 => 1 <= q4 - x0 <= 33 (so the result of','line_number':2410,'multiline':False]['text':' the rounding fits in 128 bits!)','line_number':2411,'multiline':False]['text':' x0 = delta + q4 - p34 (calculated before reaching case2_repeat)','line_number':2412,'multiline':False]['text':' because q3 + q4 - x0 <= P => x0 >= q3 + q4 - p34','line_number':2413,'multiline':False]['text':' this could happen only if we return to case2_repeat, or','line_number':2414,'multiline':False]['text':' for Case (3) or Case (6)','line_number':2415,'multiline':False]['text':' 2 <= q4 <= 18, max(1, q3+q4-p34) <= x0 <= q4 - 1, 1 <= x0 <= 17','line_number':2419,'multiline':False]['text':' R64 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 1, 1 <= q4 - x0 <= 17','line_number':2424,'multiline':False]['text':' 19 <= q4 <= 38, max(1, q3+q4-p34) <= x0 <= q4 - 1, 1 <= x0 <= 37','line_number':2430,'multiline':False]['text':' R128 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 1, 1 <= q4 - x0 <= 37','line_number':2438,'multiline':False]['text':' 1 <= q4 - x0 <= 19','line_number':2439,'multiline':False]['text':' R128.w[1] stays 0','line_number':2441,'multiline':False]['text':' 20 <= q4 - x0 <= 37','line_number':2442,'multiline':False]['text':' 38 <= q4 <= 57, max(1, q3+q4-p34) <= x0 <= q4 - 1, 5 <= x0 <= 56','line_number':2448,'multiline':False]['text':' R192.w[2] is always 0','line_number':2456,'multiline':False]['text':' R192 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 5, 1 <= q4 - x0 <= 52','line_number':2458,'multiline':False]['text':' 1 <= q4 - x0 <= 19','line_number':2459,'multiline':False]['text':' R192.w[1] stays 0','line_number':2461,'multiline':False]['text':' R192.w[2] stays 0','line_number':2462,'multiline':False]['text':' 20 <= q4 - x0 <= 33','line_number':2463,'multiline':False]['text':' R192.w[2] stays 0','line_number':2466,'multiline':False]['text':' 58 <= q4 <= 68, max(1, q3+q4-p34) <= x0 <= q4 - 1, 25 <= x0 <= 67','line_number':2472,'multiline':False]['text':' R256.w[3] and R256.w[2] are always 0','line_number':2477,'multiline':False]['text':' R256 = 10^(q4-x0), 1 <= q4 - x0 <= q4 - 25, 1 <= q4 - x0 <= 43','line_number':2479,'multiline':False]['text':' 1 <= q4 - x0 <= 19  ','line_number':2480,'multiline':False]['text':' R256.w[1] stays 0','line_number':2482,'multiline':False]['text':' R256.w[2] stays 0','line_number':2483,'multiline':False]['text':' R256.w[3] stays 0','line_number':2484,'multiline':False]['text':' 20 <= q4 - x0 <= 33 ','line_number':2485,'multiline':False]['text':' R256.w[2] stays 0','line_number':2488,'multiline':False]['text':' R256.w[3] stays 0','line_number':2489,'multiline':False]['text':' now add C3 * 10^scale in res and the signed top (q4-x0) digits of C4,','line_number':2495,'multiline':False]['text':' rounded to nearest, which were copied into R128','line_number':2496,'multiline':False]['text':' lsb of C3 * 10^scale','line_number':2498,'multiline':False]['text':' the sum can result in [up to] p34 or p34 + 1 digits','line_number':2499,'multiline':False]['text':' carry','line_number':2503,'multiline':False]['text':' if res > 10^34 - 1 need to increase x0 and decrease scale by 1','line_number':2504,'multiline':False]['text':' avoid double rounding error','line_number':2508,'multiline':False]['text':' incr_exp is 0 with certainty in this case','line_number':2523,'multiline':False]['text':' avoid a double rounding error','line_number':2524,'multiline':False]['text':' double rounding error upward','line_number':2526,'multiline':False]['text':' res = res - 1','line_number':2527,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':2531,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':2532,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':2533,'multiline':False]['text':' not possible in Cases (2)-(6) or (15)-(17) which may get here','line_number':2534,'multiline':False]['text':' double rounding error downward','line_number':2538,'multiline':False]['text':' res = res + 1','line_number':2539,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':2548,'multiline':False]['text':' inexact because of the first rounding','line_number':2549,'multiline':False]['text':' pulled up to a midpoint','line_number':2559,'multiline':False]['text':' pulled down to a midpoint','line_number':2567,'multiline':False]['text':' adjust exponent','line_number':2575,'multiline':False]['text':' this is the result rounded with unbounded exponent, unless a','line_number':2585,'multiline':False]['text':' correction is needed','line_number':2586,'multiline':False]['text':' res = res + 1','line_number':2590,'multiline':False]['text':' check for rounding overflow','line_number':2596,'multiline':False]['text':' res = 10^34 => rounding overflow','line_number':2599,'multiline':False]['text':' 10^33','line_number':2601,'multiline':False]['text':' res = res - 1','line_number':2605,'multiline':False]['text':' if the result is pure zero, the sign depends on the rounding ','line_number':2611,'multiline':False]['text':' mode (x*y and z had opposite signs)','line_number':2612,'multiline':False]['text':' the exponent is max (e3, expmin)','line_number':2618,'multiline':False]['text':' if (z_sign != p_sign)','line_number':2633,'multiline':False]['text':' lsb of C3 * 10^scale; R128 contains rounded C4','line_number':2634,'multiline':False]['text':' used to swap rounding indicators if p_sign != z_sign','line_number':2635,'multiline':False]['text':' the sum can result in [up to] p34 or p34 - 1 digits','line_number':2636,'multiline':False]['text':' borrow','line_number':2641,'multiline':False]['text':' if res < 10^33 and exp > expmin need to decrease x0 and ','line_number':2642,'multiline':False]['text':' increase scale by 1','line_number':2643,'multiline':False]['text':' first restore e3, otherwise it will be too small','line_number':2652,'multiline':False]['text':' else this is the result rounded with unbounded exponent;','line_number':2662,'multiline':False]['text':' because the result has opposite sign to that of C4 which was ','line_number':2663,'multiline':False]['text':' rounded, need to change the rounding indicators','line_number':2664,'multiline':False]['text':' res = res + 1','line_number':2683,'multiline':False]['text':' check for rounding overflow','line_number':2687,'multiline':False]['text':' res = 10^34 => rounding overflow','line_number':2690,'multiline':False]['text':' 10^33','line_number':2692,'multiline':False]['text':' res = res - 1','line_number':2696,'multiline':False]['text':' if the result is pure zero, the sign depends on the rounding ','line_number':2700,'multiline':False]['text':' mode (x*y and z had opposite signs)','line_number':2701,'multiline':False]['text':' the exponent is max (e3, expmin)','line_number':2707,'multiline':False]['text':' check for underflow','line_number':2724,'multiline':False]['text':' and if significand < 10^33 => result is tiny','line_number':2725,'multiline':False]['text':' 10^33*10^-6176','line_number':2733,'multiline':False]['text':' the result is tiny, so we must truncate more of res','line_number':2737,'multiline':False]['text':' determine the number of decimal digits in res','line_number':2748,'multiline':False]['text':' between 1 and 19 digits','line_number':2750,'multiline':False]['text':' ind digits','line_number':2756,'multiline':False]['text':' 20 digits','line_number':2760,'multiline':False]['text':' between 21 and 38 digits','line_number':2762,'multiline':False]['text':' ind + 20 digits','line_number':2770,'multiline':False]['text':' at this point ind >= x0; because delta >= 2 on this path, the case','line_number':2774,'multiline':False]['text':' ind = x0 can occur only in Case (2) or case (3), when C3 has one','line_number':2775,'multiline':False]['text':' digit (q3 = 1) equal to 1 (C3 = 1), e3 is expmin (e3 = expmin), ','line_number':2776,'multiline':False]['text':' the signs of x * y and z are opposite, and through cancellation ','line_number':2777,'multiline':False]['text':' the most significant decimal digit in res has the weight','line_number':2778,'multiline':False]['text':' 10^(emin-1); however, it is clear that in this case the most','line_number':2779,'multiline':False]['text':' significant digit is 9, so the result before rounding is','line_number':2780,'multiline':False]['text':' 0.9... * 10^emin','line_number':2781,'multiline':False]['text':' Otherwise, ind > x0 because there are non-zero decimal digits in the','line_number':2782,'multiline':False]['text':' result with weight of at least 10^emin, and correction for underflow','line_number':2783,'multiline':False]['text':'  can be carried out using the round*_*_2_* () routines','line_number':2784,'multiline':False]['text':' the result before rounding is 0.9... * 10^emin','line_number':2785,'multiline':False]['text':' check that 2 <= ind','line_number':2789,'multiline':False]['text':' 2 <= ind <= 18, 1 <= x0 <= 17','line_number':2790,'multiline':False]['text':' R64 = 10^(ind-x0), 1 <= ind - x0 <= ind - 1, 1 <= ind - x0 <= 17','line_number':2796,'multiline':False]['text':' 19 <= ind <= 38','line_number':2802,'multiline':False]['text':' R128 = 10^(ind-x0), 1 <= ind - x0 <= ind - 1, 1 <= ind - x0 <= 37','line_number':2810,'multiline':False]['text':' 1 <= ind - x0 <= 19','line_number':2811,'multiline':False]['text':' res.w[1] stays 0','line_number':2813,'multiline':False]['text':' 20 <= ind - x0 <= 37','line_number':2814,'multiline':False]['text':' avoid a double rounding error','line_number':2820,'multiline':False]['text':' double rounding error upward','line_number':2822,'multiline':False]['text':' res = res - 1','line_number':2823,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':2827,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':2828,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':2829,'multiline':False]['text':' not possible in Cases (2)-(6) which may get here','line_number':2830,'multiline':False]['text':' double rounding error downward','line_number':2834,'multiline':False]['text':' res = res + 1','line_number':2835,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':2843,'multiline':False]['text':' inexact because of the first rounding','line_number':2844,'multiline':False]['text':' pulled up to a midpoint','line_number':2853,'multiline':False]['text':' pulled down to a midpoint','line_number':2860,'multiline':False]['text':' adjust exponent','line_number':2868,'multiline':False]['text':' not underflow','line_number':2878,'multiline':False]['text':' check for inexact result','line_number':2880,'multiline':False]['text':' set the inexact flag','line_number':2883,'multiline':False]['text':' now check for significand = 10^34 (may have resulted from going','line_number':2888,'multiline':False]['text':' back to case2_repeat)','line_number':2889,'multiline':False]['text':' if  res = 10^34','line_number':2891,'multiline':False]['text':' res = 10^33','line_number':2892,'multiline':False]['text':' check for overflow','line_number':2897,'multiline':False]['text':' +/-inf','line_number':2899,'multiline':False]['text':' we get here only if delta <= 1 in Cases (2), (3), (4), (5), or (6) and','line_number':2919,'multiline':False]['text':' the signs of x*y and z are opposite; in these cases massive','line_number':2920,'multiline':False]['text':' cancellation can occur, so it is better to scale either C3 or C4 and ','line_number':2921,'multiline':False]['text':' to perform the subtraction before rounding; rounding is performed ','line_number':2922,'multiline':False]['text':' next, depending on the number of decimal digits in the result and on ','line_number':2923,'multiline':False]['text':' the exponent value','line_number':2924,'multiline':False]['text':' Note: overlow is not possible in this case','line_number':2925,'multiline':False]['text':' this is similar to Cases (15), (16), and (17)','line_number':2926,'multiline':False]['text':' from Case (6) ','line_number':2928,'multiline':False]['text':' Case (6) with 0<= delta <= 1 is similar to Cases (15), (16), and ','line_number':2929,'multiline':False]['text':' (17) if we swap (C3, C4), (q3, q4), (e3, e4), (z_sign, p_sign)','line_number':2930,'multiline':False]['text':' and call bid_add_and_round; delta stays positive','line_number':2931,'multiline':False]['text':' C4.w[3] = 0 and C4.w[2] = 0, so swap just the low part of C4 with C3','line_number':2932,'multiline':False]['text':' from Cases (2), (3), (4), (5)','line_number':2948,'multiline':False]['text':' In Cases (2), (3), (4), (5) with 0 <= delta <= 1 C3 has to be ','line_number':2949,'multiline':False]['text':' scaled up by q4 + delta - q3; this is the same as in Cases (15), ','line_number':2950,'multiline':False]['text':' (16), and (17) if we just change the sign of delta','line_number':2951,'multiline':False]['text':' if delta < 0','line_number':2967,'multiline':False]['text':' Case (7)','line_number':2971,'multiline':False]['text':' truncate C4 to p34 digits into res','line_number':2973,'multiline':False]['text':' x = q4-p34, 1 <= x <= 34 because 35 <= q4 <= 68','line_number':2974,'multiline':False]['text':' 35 <= q4 <= 57','line_number':2983,'multiline':False]['text':' if (q4 <= 68)','line_number':2993,'multiline':False]['text':' if C4 rounded to p34 digits is exact then the result is inexact,','line_number':3007,'multiline':False]['text':' in a way that depends on the signs of x * y and z','line_number':3008,'multiline':False]['text':' if (p_sign != z_sign)','line_number':3011,'multiline':False]['text':' res != 10^33','line_number':3013,'multiline':False]['text':' res = 10^33 and exact is a special case','line_number':3015,'multiline':False]['text':' if C3 < 1/2 ulp then res = 10^33 and is_inexact_gt_midpoint = 1','line_number':3016,'multiline':False]['text':' if C3 = 1/2 ulp then res = 10^33 and is_midpoint_lt_even = 1','line_number':3017,'multiline':False]['text':' if C3 > 1/2 ulp then res = 10^34-1 and is_inexact_lt_midpoint = 1','line_number':3018,'multiline':False]['text':' Note: ulp is really ulp/10 (after borrow which propagates to msd)','line_number':3019,'multiline':False]['text':' C3 < 1/2','line_number':3020,'multiline':False]['text':' res = 10^33, unchanged','line_number':3021,'multiline':False]['text':' if (delta == p34 + 1)','line_number':3023,'multiline':False]['text':' C3 < 1/2 ulp','line_number':3025,'multiline':False]['text':' res = 10^33, unchanged','line_number':3026,'multiline':False]['text':' C3 = 1/2 ulp','line_number':3028,'multiline':False]['text':' res = 10^33, unchanged','line_number':3029,'multiline':False]['text':' if (C3.w[0] > bid_midpoint64[q3-1]), C3 > 1/2 ulp','line_number':3031,'multiline':False]['text':' 10^34 - 1','line_number':3032,'multiline':False]['text':' if (20 <= q3 <=34)','line_number':3037,'multiline':False]['text':' C3 < 1/2 ulp','line_number':3040,'multiline':False]['text':' res = 10^33, unchanged','line_number':3041,'multiline':False]['text':' C3 = 1/2 ulp','line_number':3044,'multiline':False]['text':' res = 10^33, unchanged','line_number':3045,'multiline':False]['text':' if (C3 > bid_midpoint128[q3-20]), C3 > 1/2 ulp','line_number':3047,'multiline':False]['text':' 10^34 - 1','line_number':3048,'multiline':False]['text':' needs correction: res = res - 1','line_number':3059,'multiline':False]['text':' if it is (10^33-1)*10^e4 then the corect result is ','line_number':3063,'multiline':False]['text':' (10^34-1)*10(e4-1)','line_number':3064,'multiline':False]['text':' 10^34 - 1','line_number':3067,'multiline':False]['text':' if (z_sign == p_sign)','line_number':3073,'multiline':False]['text':' needs correction: res = res + 1 (cannot cross in the next binade)','line_number':3079,'multiline':False]['text':' if (z_sign != p_sign)','line_number':3085,'multiline':False]['text':' the rounded result is already correct','line_number':3090,'multiline':False]['text':' check for overflow','line_number':3092,'multiline':False]['text':' no overflow or not RN','line_number':3097,'multiline':False]['text':' set the inexact flag','line_number':3110,'multiline':False]['text':' Case (8)','line_number':3120,'multiline':False]['text':' Case (9)','line_number':3121,'multiline':False]['text':' Case (10)','line_number':3122,'multiline':False]['text':' Case (13)','line_number':3123,'multiline':False]['text':' Case (14)','line_number':3124,'multiline':False]['text':' Case (18)','line_number':3125,'multiline':False]['text':' Case (8) is similar to Case (1), with C3 and C4 swapped','line_number':3127,'multiline':False]['text':' Case (9) is similar to Case (2), with C3 and C4 swapped','line_number':3128,'multiline':False]['text':' Case (10) is similar to Case (3), with C3 and C4 swapped','line_number':3129,'multiline':False]['text':' Case (13) is similar to Case (4), with C3 and C4 swapped','line_number':3130,'multiline':False]['text':' Case (14) is similar to Case (5), with C3 and C4 swapped','line_number':3131,'multiline':False]['text':' Case (18) is similar to Case (6), with C3 and C4 swapped','line_number':3132,'multiline':False]['text':' swap (C3, C4), (q3, q4), (e3, 34), (z_sign, p_sign), (z_exp, p_exp)','line_number':3134,'multiline':False]['text':' and go back to delta_ge_zero','line_number':3135,'multiline':False]['text':' C4.w[3] = 0 and C4.w[2] = 0, so swap just the low part of C4 with C3','line_number':3136,'multiline':False]['text':' Case (11)','line_number':3157,'multiline':False]['text':' Case (12)','line_number':3158,'multiline':False]['text':' round C3 to nearest to q3 - x0 digits, where x0 = e4 - e3,','line_number':3160,'multiline':False]['text':' 1 <= x0 <= q3 - 1 <= p34 - 1 ','line_number':3161,'multiline':False]['text':' or x0 = delta + q3 - q4','line_number':3162,'multiline':False]['text':' 2 <= q3 <= 18','line_number':3163,'multiline':False]['text':' C3.w[1] = 0;','line_number':3167,'multiline':False]['text':' the rounded result has q3 - x0 digits','line_number':3177,'multiline':False]['text':' we want the exponent to be e4, so if incr_exp = 1 then','line_number':3178,'multiline':False]['text':' multiply the rounded result by 10 - it will still fit in 113 bits','line_number':3179,'multiline':False]['text':' 64 x 128 -> 128','line_number':3181,'multiline':False]['text':' this is e4','line_number':3186,'multiline':False]['text':' now add/subtract the 256-bit C4 and the new (and shorter) 128-bit C3; ','line_number':3187,'multiline':False]['text':' the result will have the sign of x * y; the exponent is e4','line_number':3188,'multiline':False]['text':' R256 = C4 + R256','line_number':3193,'multiline':False]['text':' if (p_sign != z_sign) { // R256 = C4 - R256','line_number':3195,'multiline':False]['text':' the result cannot be pure zero','line_number':3196,'multiline':False]['text':' because the result has opposite sign to that of R256 which was ','line_number':3197,'multiline':False]['text':' rounded, need to change the rounding indicators','line_number':3198,'multiline':False]['text':' res = res + 1','line_number':3218,'multiline':False]['text':' no check for rounding overflow - R256 was a difference','line_number':3229,'multiline':False]['text':' res = res - 1','line_number':3231,'multiline':False]['text':' determine the number of decimal digits in R256','line_number':3249,'multiline':False]['text':' ind >= p34','line_number':3250,'multiline':False]['text':' if R256 is sum, then ind > p34; if R256 is a difference, then ','line_number':3251,'multiline':False]['text':' ind >= p34; this means that we can calculate the result rounded to','line_number':3252,'multiline':False]['text':' the destination precision, with unbounded exponent, starting from R256','line_number':3253,'multiline':False]['text':' and using the indicators from the rounding of C3 to avoid a double','line_number':3254,'multiline':False]['text':' rounding error ','line_number':3255,'multiline':False]['text':' the result rounded to the destination precision with ','line_number':3260,'multiline':False]['text':' unbounded exponent','line_number':3261,'multiline':False]['text':' is (-1)^p_sign * R256 * 10^e4','line_number':3262,'multiline':False]['text':' if (ind > p34)','line_number':3265,'multiline':False]['text':' if more than P digits, round to nearest to P digits','line_number':3266,'multiline':False]['text':' round R256 to p34 digits','line_number':3267,'multiline':False]['text':' 1 <= x0 <= 34 as 35 <= ind <= 68','line_number':3268,'multiline':False]['text':' save C3 rounding indicators to help avoid double rounding error','line_number':3269,'multiline':False]['text':' initialize rounding indicators','line_number':3274,'multiline':False]['text':' round to p34 digits; the result fits in 113 bits','line_number':3279,'multiline':False]['text':' if (ind <= 68)','line_number':3297,'multiline':False]['text':' the rounded result has p34 = 34 digits','line_number':3305,'multiline':False]['text':' avoid a double rounding error','line_number':3311,'multiline':False]['text':' double rounding error upward','line_number':3313,'multiline':False]['text':' res = res - 1','line_number':3314,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':3320,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':3321,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':3322,'multiline':False]['text':' not possible in Cases (2)-(6) or (15)-(17) which may get here','line_number':3323,'multiline':False]['text':' if this is 10^33 - 1 make it 10^34 - 1 and decrement exponent','line_number':3324,'multiline':False]['text':' 10^33 - 1','line_number':3326,'multiline':False]['text':' 10^34 - 1','line_number':3327,'multiline':False]['text':' double rounding error downward','line_number':3332,'multiline':False]['text':' res = res + 1 ','line_number':3333,'multiline':False]['text':' if this second rounding was exact the result may still be','line_number':3341,'multiline':False]['text':' inexact because of the first rounding','line_number':3342,'multiline':False]['text':' pulled up to a midpoint','line_number':3351,'multiline':False]['text':' pulled down to a midpoint','line_number':3358,'multiline':False]['text':' determine tininess','line_number':3368,'multiline':False]['text':' for other rounding modes apply correction','line_number':3371,'multiline':False]['text':' for RM, RP, RZ, RA apply correction in order to determine tininess','line_number':3374,'multiline':False]['text':' but do not save the result; apply the correction to ','line_number':3375,'multiline':False]['text':' (-1)^p_sign * res * 10^0','line_number':3376,'multiline':False]['text':' -1, 0, or +1','line_number':3384,'multiline':False]['text':' the number of digits in the significand is p34 = 34','line_number':3385,'multiline':False]['text':' the result rounded to the destination precision with unbounded exponent','line_number':3391,'multiline':False]['text':' is (-1)^p_sign * res * 10^e4','line_number':3392,'multiline':False]['text':' RN','line_number':3393,'multiline':False]['text':' res.w[0] unchanged;','line_number':3394,'multiline':False]['text':' Note: res is correct only if expmin <= e4 <= expmax','line_number':3395,'multiline':False]['text':' the number of decimal digits in the signifcand of res','line_number':3396,'multiline':False]['text':' at this point we have the result rounded with unbounded exponent in','line_number':3398,'multiline':False]['text':' res and we know its tininess:','line_number':3399,'multiline':False]['text':' res = (-1)^p_sign * significand * 10^e4, ','line_number':3400,'multiline':False]['text':' where q (significand) = ind = p34','line_number':3401,'multiline':False]['text':' Note: res is correct only if expmin <= e4 <= expmax','line_number':3402,'multiline':False]['text':' check for overflow if RN','line_number':3404,'multiline':False]['text':' else not overflow or not RN, so continue','line_number':3416,'multiline':False]['text':' from this point on this is similar to the last part of the computation','line_number':3418,'multiline':False]['text':' for Cases (15), (16), (17)','line_number':3419,'multiline':False]['text':' if (e4 >= expmin) we have the result rounded with bounded exponent','line_number':3421,'multiline':False]['text':' x0 >= 1; the number of digits to chop off of res','line_number':3423,'multiline':False]['text':' where the result rounded [at most] once is','line_number':3424,'multiline':False]['text':'   (-1)^p_sign * significand_res * 10^e4','line_number':3425,'multiline':False]['text':' avoid double rounding error','line_number':3427,'multiline':False]['text':' nothing is left of res when moving the decimal point left x0 digits','line_number':3438,'multiline':False]['text':' 1 <= x0 = ind <= p34 = 34','line_number':3443,'multiline':False]['text':' this is <, =, or > 1/2 ulp','line_number':3444,'multiline':False]['text':' compare the ind-digit value in the significand of res with','line_number':3445,'multiline':False]['text':' 1/2 ulp = 5*10^(ind-1), i.e. determine whether it is ','line_number':3446,'multiline':False]['text':' less than, equal to, or greater than 1/2 ulp (significand of res)','line_number':3447,'multiline':False]['text':' < 1/2 ulp','line_number':3451,'multiline':False]['text':' = 1/2 ulp','line_number':3454,'multiline':False]['text':' > 1/2 ulp','line_number':3457,'multiline':False]['text':' if (ind <= 38)','line_number':3461,'multiline':False]['text':' < 1/2 ulp','line_number':3464,'multiline':False]['text':' = 1/2 ulp','line_number':3468,'multiline':False]['text':' > 1/2 ulp','line_number':3471,'multiline':False]['text':' res = +0.0 * 10^expmin','line_number':3477,'multiline':False]['text':' if (gt_half_ulp)','line_number':3480,'multiline':False]['text':' res = +1 * 10^expmin','line_number':3481,'multiline':False]['text':' if (1 <= x0 <= ind - 1 <= 33)','line_number':3487,'multiline':False]['text':' round the ind-digit result to ind - x0 digits','line_number':3488,'multiline':False]['text':' 2 <= ind <= 18','line_number':3490,'multiline':False]['text':' expmin','line_number':3505,'multiline':False]['text':' we want the exponent to be expmin, so if incr_exp = 1 then','line_number':3506,'multiline':False]['text':' multiply the rounded result by 10 - it will still fit in 113 bits','line_number':3507,'multiline':False]['text':' 64 x 128 -> 128','line_number':3509,'multiline':False]['text':' avoid a double rounding error','line_number':3517,'multiline':False]['text':' double rounding error upward','line_number':3519,'multiline':False]['text':' res = res - 1','line_number':3520,'multiline':False]['text':' Note: a double rounding error upward is not possible; for this','line_number':3524,'multiline':False]['text':' the result after the first rounding would have to be 99...95','line_number':3525,'multiline':False]['text':' (35 digits in all), possibly followed by a number of zeros; this','line_number':3526,'multiline':False]['text':' not possible in this underflow case','line_number':3527,'multiline':False]['text':' double rounding error downward','line_number':3531,'multiline':False]['text':' res = res + 1','line_number':3532,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':3541,'multiline':False]['text':' inexact because of the first rounding','line_number':3542,'multiline':False]['text':' pulled up to a midpoint','line_number':3552,'multiline':False]['text':' pulled down to a midpoint','line_number':3560,'multiline':False]['text':' res contains the correct result','line_number':3570,'multiline':False]['text':' apply correction if not rounding to nearest','line_number':3571,'multiline':False]['text':' correction needed for tininess detection before rounding','line_number':3580,'multiline':False]['text':' 10^33*10^-6176_high','line_number':3582,'multiline':False]['text':' 10^33*10^-6176_low','line_number':3583,'multiline':False]['text':' set the inexact flag','line_number':3596,'multiline':False]['text':' Case (15)','line_number':3608,'multiline':False]['text':'Case (16)','line_number':3609,'multiline':False]['text':' Case (17)','line_number':3610,'multiline':False]['text':' calculate first the result rounded to the destination precision, with','line_number':3612,'multiline':False]['text':' unbounded exponent','line_number':3613,'multiline':False]['text':' end if delta < 0','line_number':3630,'multiline':False]['text':' Note: bid128qqq_fma is represented by bid128_fma','line_number':3962,'multiline':False]['text':' Note: bid64ddd_fma is represented by bid64_fma','line_number':3964,'multiline':False]['text':' needed because of the call to bid128_ext_fma','line_number':4193,'multiline':False]['text':' Note: for rounding modes other than RN or RA, the result can be obtained','line_number':4204,'multiline':False]['text':' by rounding first to BID128 and then to BID64','line_number':4205,'multiline':False]['text':' sticky bits - caller value must be preserved','line_number':4207,'multiline':False]['text':' no double rounding error is possible','line_number':4225,'multiline':False]['text':'res=QNaN (cannot be SNaN)','line_number':4226,'multiline':False]['text':' result is infinity  ','line_number':4227,'multiline':False]['text':' determine the unbiased exponent of the result','line_number':4233,'multiline':False]['text':' res1 not NaN','line_number':4236,'multiline':False]['text':' if subnormal, res1  must have exp = -398','line_number':4237,'multiline':False]['text':' if tiny and inexact set underflow and inexact status flags','line_number':4238,'multiline':False]['text':' set the inexact flag and the underflow flag','line_number':4243,'multiline':False]['text':' set the inexact flag and the underflow flag','line_number':4247,'multiline':False]['text':' correction needed for tininess detection before rounding','line_number':4251,'multiline':False]['text':' 10^15*10^-398','line_number':4253,'multiline':False]['text':' else the result is NaN','line_number':4264,'multiline':False]['text':' else continue, and use rounding to nearest to round to 16 digits','line_number':4268,'multiline':False]['text':' at this point the result is rounded to nearest (even or away) to 34 digits','line_number':4270,'multiline':False]['text':' (or less if exact), and it is zero or finite non-zero canonical [sub]normal','line_number':4271,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':4272,'multiline':False]['text':' biased and shifted left 49 bits','line_number':4273,'multiline':False]['text':' result is zero','line_number':4278,'multiline':False]['text':' clear under/overflow','line_number':4280,'multiline':False]['text':' else continue','line_number':4288,'multiline':False]['text':' -398 - 34 <= unbexp <= 369 + 15','line_number':4290,'multiline':False]['text':' apply correction, if needed, to make the result rounded to nearest-even','line_number':4292,'multiline':False]['text':' res = res - 1','line_number':4294,'multiline':False]['text':' res1 is now even','line_number':4295,'multiline':False]['text':' else the result is already correctly rounded to nearest-even','line_number':4296,'multiline':False]['text':' at this point the result is finite, non-zero canonical normal or subnormal,','line_number':4298,'multiline':False]['text':' and in most cases overflow or underflow will not occur','line_number':4299,'multiline':False]['text':' determine the number of digits q in the result','line_number':4301,'multiline':False]['text':' q = nr. of decimal digits in x','line_number':4302,'multiline':False]['text':' determine first the nr. of bits in x','line_number':4303,'multiline':False]['text':' x >= 2^53','line_number':4305,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':4306,'multiline':False]['text':' exact conversion','line_number':4307,'multiline':False]['text':' if x < 2^53','line_number':4310,'multiline':False]['text':' exact conversion','line_number':4311,'multiline':False]['text':' C.w[1] != 0 => nr. bits = 64 + nr_bits (C.w[1])','line_number':4315,'multiline':False]['text':' exact conversion','line_number':4316,'multiline':False]['text':' if q > 16, round to nearest even to 16 digits (but for underflow it may ','line_number':4328,'multiline':False]['text':' have to be truncated even more)','line_number':4329,'multiline':False]['text':' 19 <= q <= 34','line_number':4336,'multiline':False]['text':' the result fits in 64 bits','line_number':4340,'multiline':False]['text':' need to set in case denormalization is necessary','line_number':4345,'multiline':False]['text':' the result does not require a second rounding (and it must have ','line_number':4347,'multiline':False]['text':' been exact in the first rounding, since q <= 16)','line_number':4348,'multiline':False]['text':' avoid a double rounding error','line_number':4352,'multiline':False]['text':' double rounding error upward','line_number':4354,'multiline':False]['text':' res = res - 1 ','line_number':4355,'multiline':False]['text':' res1 becomes odd ','line_number':4356,'multiline':False]['text':' 10^15 - 1','line_number':4359,'multiline':False]['text':' 10^16 - 1 ','line_number':4360,'multiline':False]['text':' double rounding error downward','line_number':4364,'multiline':False]['text':' res = res + 1','line_number':4365,'multiline':False]['text':' res1 becomes odd (so it cannot be 10^16)','line_number':4366,'multiline':False]['text':' if this second rounding was exact the result may still be ','line_number':4371,'multiline':False]['text':' inexact because of the first rounding','line_number':4372,'multiline':False]['text':' pulled up to a midpoint ','line_number':4381,'multiline':False]['text':' pulled down to a midpoint ','line_number':4388,'multiline':False]['text':' this is the result rounded correctly to nearest even, with unbounded exp. ','line_number':4396,'multiline':False]['text':' check for overflow','line_number':4398,'multiline':False]['text':' q + unbexp <= P16 + expmax16','line_number':4404,'multiline':False]['text':' not overflow; the result must be exact, and we can multiply res1 by','line_number':4405,'multiline':False]['text':' 10^(unbexp - expmax16) and the product will fit in 16 decimal digits','line_number':4406,'multiline':False]['text':' res1 * 10^scale','line_number':4408,'multiline':False]['text':' unbexp - scale ','line_number':4409,'multiline':False]['text':' continue','line_number':4411,'multiline':False]['text':' check for underflow','line_number':4414,'multiline':False]['text':' we must truncate more of res','line_number':4417,'multiline':False]['text':' x0 >= 1','line_number':4418,'multiline':False]['text':' the number of decimal digits in res1 is q','line_number':4427,'multiline':False]['text':' 1 <= x0 <= q-1 => round res to q - x0 digits','line_number':4428,'multiline':False]['text':' 2 <= q <= 16, 1 <= x0 <= 15','line_number':4429,'multiline':False]['text':' res1 = 10^(q-x0), 1 <= q - x0 <= q - 1, 1 <= q - x0 <= 15','line_number':4434,'multiline':False]['text':' expmin16','line_number':4437,'multiline':False]['text':' the second rounding is for 0.d(0)d(1)...d(q-1) * 10^emin','line_number':4439,'multiline':False]['text':' determine relationship with 1/2 ulp','line_number':4440,'multiline':False]['text':' q <= 16','line_number':4441,'multiline':False]['text':' < 1/2 ulp','line_number':4442,'multiline':False]['text':' = 1/2 ulp','line_number':4445,'multiline':False]['text':' > 1/2 ulp','line_number':4448,'multiline':False]['text':' gt_half_ulp = 1;','line_number':4449,'multiline':False]['text':' res = +0.0 * 10^expmin16','line_number':4453,'multiline':False]['text':' if (gt_half_ulp)','line_number':4455,'multiline':False]['text':' res = +1 * 10^expmin16','line_number':4456,'multiline':False]['text':' if (x0 > q)','line_number':4460,'multiline':False]['text':' the second rounding is for 0.0...d(0)d(1)...d(q-1) * 10^emin','line_number':4461,'multiline':False]['text':' avoid a double rounding error','line_number':4466,'multiline':False]['text':' double rounding error upward','line_number':4468,'multiline':False]['text':' res = res - 1','line_number':4469,'multiline':False]['text':' res1 becomes odd','line_number':4470,'multiline':False]['text':' double rounding error downward','line_number':4474,'multiline':False]['text':' res = res + 1','line_number':4475,'multiline':False]['text':' res1 becomes odd','line_number':4476,'multiline':False]['text':' if this rounding was exact the result may still be ','line_number':4481,'multiline':False]['text':' inexact because of the previous roundings','line_number':4482,'multiline':False]['text':' pulled up to a midpoint','line_number':4491,'multiline':False]['text':' pulled down to a midpoint','line_number':4498,'multiline':False]['text':' else if unbexp >= emin then q < P (because q + unbexp < P16 + expmin16)','line_number':4507,'multiline':False]['text':' and the result is tiny and exact','line_number':4508,'multiline':False]['text':' check for inexact result','line_number':4510,'multiline':False]['text':' set the inexact flag and the underflow flag','line_number':4515,'multiline':False]['text':' this is the result rounded correctly to nearest, with bounded exponent','line_number':4522,'multiline':False]['text':' correction','line_number':4524,'multiline':False]['text':' res = res + 1','line_number':4525,'multiline':False]['text':' res1 is now odd','line_number':4526,'multiline':False]['text':' else the result is already correct','line_number':4527,'multiline':False]['text':' assemble the result','line_number':4529,'multiline':False]['text':' res < 2^53','line_number':4530,'multiline':False]['text':' res1 >= 2^53','line_number':4532,'multiline':False]['text':' correction needed for tininess detection before rounding','line_number':4537,'multiline':False]['text':' 10^15*10^-398','line_number':4539,'multiline':False]