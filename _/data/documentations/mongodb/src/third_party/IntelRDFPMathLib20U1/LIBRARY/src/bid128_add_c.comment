['text':'*****************************************************************************
  Copyright (c) 2007-2011, Intel Corp.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors 
      may be used to endorse or promote products derived from this software 
      without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************','line_number':1,'multiline':True]['text':' bid128_add stands for bid128qq_add','line_number':237,'multiline':False]['text':'****************************************************************************
 *  BID64/BID128 sub
 ***************************************************************************','line_number':240,'multiline':True]['text':' y is not NAN','line_number':332,'multiline':False]['text':' change its sign','line_number':333,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':334,'multiline':False]['text':' e1 = x_exp, e2 = y_exp','line_number':475,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent C1_hi, C1_lo (all BID_UINT64)','line_number':478,'multiline':False]['text':' Note: C2.w[1], C2.w[0] represent C2_hi, C2_lo (all BID_UINT64)','line_number':479,'multiline':False]['text':' top 128 bits in f2*; low 128 bits in R256[1], R256[0]','line_number':488,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':496,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':497,'multiline':False]['text':' check for NaN or Infinity','line_number':499,'multiline':False]['text':' x is special or y is special','line_number':502,'multiline':False]['text':' x is NAN','line_number':503,'multiline':False]['text':' check first for non-canonical NaN payload','line_number':504,'multiline':False]['text':' x is SNAN','line_number':511,'multiline':False]['text':' set invalid flag','line_number':512,'multiline':False]['text':' return quiet (x)','line_number':514,'multiline':False]['text':' clear out also G[6]-G[16]','line_number':516,'multiline':False]['text':' x is QNaN','line_number':518,'multiline':False]['text':' return x','line_number':519,'multiline':False]['text':' clear out G[6]-G[16]','line_number':521,'multiline':False]['text':' if y = SNaN signal invalid exception','line_number':523,'multiline':False]['text':' set invalid flag','line_number':525,'multiline':False]['text':' y is NAN','line_number':531,'multiline':False]['text':' check first for non-canonical NaN payload','line_number':532,'multiline':False]['text':' y is SNAN','line_number':539,'multiline':False]['text':' set invalid flag','line_number':540,'multiline':False]['text':' return quiet (y)','line_number':542,'multiline':False]['text':' clear out also G[6]-G[16]','line_number':544,'multiline':False]['text':' y is QNaN','line_number':546,'multiline':False]['text':' return y','line_number':547,'multiline':False]['text':' clear out G[6]-G[16]','line_number':549,'multiline':False]['text':' neither x not y is NaN; at least one is infinity','line_number':554,'multiline':False]['text':' x is infinity','line_number':555,'multiline':False]['text':' y is infinity','line_number':556,'multiline':False]['text':' if same sign, return either of them','line_number':557,'multiline':False]['text':' x and y are infinities of opposite signs','line_number':561,'multiline':False]['text':' set invalid flag','line_number':562,'multiline':False]['text':' return QNaN Indefinite','line_number':564,'multiline':False]['text':' y is 0 or finite','line_number':568,'multiline':False]['text':' return x','line_number':569,'multiline':False]['text':' x is not NaN or infinity, so y must be infinity','line_number':573,'multiline':False]['text':' unpack the arguments','line_number':581,'multiline':False]['text':' unpack x ','line_number':583,'multiline':False]['text':' test for non-canonical values:','line_number':586,'multiline':False]['text':' - values whose encoding begins with x00, x01, or x10 and whose ','line_number':587,'multiline':False]['text':'   coefficient is larger than 10^34 -1, or','line_number':588,'multiline':False]['text':' - values whose encoding begins with x1100, x1101, x1110 (if NaNs ','line_number':589,'multiline':False]['text':'   and infinitis were eliminated already this test is reduced to ','line_number':590,'multiline':False]['text':'   checking for x10x) ','line_number':591,'multiline':False]['text':' x is not infinity; check for non-canonical values - treated as zero','line_number':593,'multiline':False]['text':' G0_G1=11; non-canonical','line_number':595,'multiline':False]['text':' biased and shifted left 49 bits','line_number':596,'multiline':False]['text':' significand high','line_number':597,'multiline':False]['text':' significand low','line_number':598,'multiline':False]['text':' G0_G1 != 11','line_number':599,'multiline':False]['text':' biased and shifted left 49 bits','line_number':600,'multiline':False]['text':' x is non-canonical if coefficient is larger than 10^34 -1','line_number':604,'multiline':False]['text':' canonical','line_number':607,'multiline':False]['text':' unpack y  ','line_number':612,'multiline':False]['text':' y is not infinity; check for non-canonical values - treated as zero ','line_number':615,'multiline':False]['text':' G0_G1=11; non-canonical ','line_number':617,'multiline':False]['text':' biased and shifted left 49 bits','line_number':618,'multiline':False]['text':' significand high','line_number':619,'multiline':False]['text':' significand low ','line_number':620,'multiline':False]['text':' G0_G1 != 11 ','line_number':621,'multiline':False]['text':' biased and shifted left 49 bits','line_number':622,'multiline':False]['text':' y is non-canonical if coefficient is larger than 10^34 -1 ','line_number':626,'multiline':False]['text':' canonical','line_number':629,'multiline':False]['text':' x is 0 and y is not special','line_number':635,'multiline':False]['text':' if y is 0 return 0 with the smaller exponent','line_number':636,'multiline':False]['text':' both negative','line_number':643,'multiline':False]['text':' -0','line_number':645,'multiline':False]['text':' else; // res = +0','line_number':646,'multiline':False]['text':' for 0 + y return y, with the preferred exponent','line_number':649,'multiline':False]['text':' if y_exp > x_exp','line_number':653,'multiline':False]['text':' return (C2 * 10^scale) * 10^(y_exp - scale)','line_number':654,'multiline':False]['text':' where scale = min (P34-q2, y_exp-x_exp)','line_number':655,'multiline':False]['text':' determine q2 = nr. of decimal digits in y','line_number':656,'multiline':False]['text':'  determine first the nr. of bits in y (y_nr_bits)','line_number':657,'multiline':False]['text':' y_bits is the nr. of bits in C2_lo','line_number':659,'multiline':False]['text':' y >= 2^53','line_number':660,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid ','line_number':661,'multiline':False]['text':' rounding errors','line_number':662,'multiline':False]['text':' exact conversion','line_number':663,'multiline':False]['text':' if y < 2^53','line_number':666,'multiline':False]['text':' exact conversion','line_number':667,'multiline':False]['text':' C2_hi != 0 => nr. bits = 64 + nr_bits (C2_hi)','line_number':671,'multiline':False]['text':' exact conversion','line_number':672,'multiline':False]['text':' return (C2 * 10^scale) * 10^(y_exp - scale)','line_number':684,'multiline':False]['text':' where scale = min (P34-q2, y_exp-x_exp)','line_number':685,'multiline':False]['text':' y fits in 64 bits ','line_number':693,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':694,'multiline':False]['text':' 64 x 64 C2_lo * bid_ten2k64[scale]','line_number':695,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':697,'multiline':False]['text':' 64 x 128 C2_lo * bid_ten2k128[scale - 20]','line_number':698,'multiline':False]['text':' y fits in 128 bits, but 10^scale must fit in 64 bits ','line_number':701,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C2','line_number':702,'multiline':False]['text':' subtract scale from the exponent','line_number':707,'multiline':False]['text':' y is 0 and x is not special, and not zero','line_number':715,'multiline':False]['text':' for x + 0 return x, with the preferred exponent','line_number':716,'multiline':False]['text':' if x_exp > y_exp','line_number':720,'multiline':False]['text':' return (C1 * 10^scale) * 10^(x_exp - scale)','line_number':721,'multiline':False]['text':' where scale = min (P34-q1, x_exp-y_exp)','line_number':722,'multiline':False]['text':' determine q1 = nr. of decimal digits in x','line_number':723,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':724,'multiline':False]['text':' x_bits is the nr. of bits in C1_lo','line_number':725,'multiline':False]['text':' x >= 2^53','line_number':726,'multiline':False]['text':' split the 64-bit value in two 32-bit halves to avoid ','line_number':727,'multiline':False]['text':' rounding errors','line_number':728,'multiline':False]['text':' exact conversion','line_number':729,'multiline':False]['text':' if x < 2^53','line_number':733,'multiline':False]['text':' exact conversion','line_number':734,'multiline':False]['text':' C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)','line_number':738,'multiline':False]['text':' exact conversion','line_number':739,'multiline':False]['text':' return (C1 * 10^scale) * 10^(x_exp - scale)','line_number':751,'multiline':False]['text':' where scale = min (P34-q1, x_exp-y_exp)  ','line_number':752,'multiline':False]['text':' x fits in 64 bits  ','line_number':760,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':761,'multiline':False]['text':' 64 x 64 C1_lo * bid_ten2k64[scale] ','line_number':762,'multiline':False]['text':' 10^scale fits in 128 bits','line_number':764,'multiline':False]['text':' 64 x 128 C1_lo * bid_ten2k128[scale - 20]','line_number':765,'multiline':False]['text':' x fits in 128 bits, but 10^scale must fit in 64 bits','line_number':768,'multiline':False]['text':' 64 x 128 bid_ten2k64[scale] * C1','line_number':769,'multiline':False]['text':' subtract scale from the exponent','line_number':774,'multiline':False]['text':' x and y are not canonical, not special, and are not zero','line_number':780,'multiline':False]['text':' note that the result may still be zero, and then it has to have the','line_number':781,'multiline':False]['text':' preferred exponent','line_number':782,'multiline':False]['text':' if exp_x < exp_y then swap x and y ','line_number':783,'multiline':False]['text':' q1 = nr. of decimal digits in x','line_number':797,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':798,'multiline':False]['text':' x_bits is the nr. of bits in C1_lo','line_number':799,'multiline':False]['text':' x >= 2^53','line_number':800,'multiline':False]['text':'split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':801,'multiline':False]['text':' exact conversion','line_number':802,'multiline':False]['text':' if x < 2^53','line_number':805,'multiline':False]['text':' exact conversion','line_number':806,'multiline':False]['text':' C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)','line_number':810,'multiline':False]['text':' exact conversion','line_number':811,'multiline':False]['text':' q2 = nr. of decimal digits in y','line_number':824,'multiline':False]['text':'  determine first the nr. of bits in y (y_nr_bits)','line_number':825,'multiline':False]['text':' y_bits is the nr. of bits in C2_lo','line_number':826,'multiline':False]['text':' y >= 2^53','line_number':827,'multiline':False]['text':'split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':828,'multiline':False]['text':' exact conversion','line_number':829,'multiline':False]['text':' if y < 2^53','line_number':832,'multiline':False]['text':' exact conversion','line_number':833,'multiline':False]['text':' C2_hi != 0 => nr. bits = 64 + nr_bits (C2_hi)','line_number':837,'multiline':False]['text':' exact conversion','line_number':838,'multiline':False]['text':' round the result directly because 0 < C2 < ulp (C1 * 10^(x_exp-e2))','line_number':855,'multiline':False]['text':' n = C1 * 10^e1 or n = C1 +/- 10^(q1-P34)) * 10^e1','line_number':856,'multiline':False]['text':' the result is inexact; the preferred exponent is the least possible','line_number':857,'multiline':False]['text':' for RN the result is the operand with the larger magnitude,','line_number':860,'multiline':False]['text':' possibly scaled up by 10^(P34-q1)','line_number':861,'multiline':False]['text':' an overflow cannot occur in this case (rounding to nearest)','line_number':862,'multiline':False]['text':' scale C1 up by 10^(P34-q1)','line_number':863,'multiline':False]['text':' Note: because delta >= P34+1 it is certain that ','line_number':864,'multiline':False]['text':'     x_exp - ((BID_UINT64)scale << 49) will stay above e_min','line_number':865,'multiline':False]['text':' C1 fits in 64 bits','line_number':867,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':868,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':869,'multiline':False]['text':' if 20 <= scale <= 33','line_number':871,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':872,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits','line_number':873,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':877,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits','line_number':878,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1','line_number':881,'multiline':False]['text':' some special cases arise: if delta = P34 + 1 and C1 = 10^(P34-1) ','line_number':888,'multiline':False]['text':' (after scaling) and x_sign != y_sign and C2 > 5*10^(q2-1) => ','line_number':889,'multiline':False]['text':' subtract 1 ulp','line_number':890,'multiline':False]['text':' Note: do this only for rounding to nearest; for other rounding ','line_number':891,'multiline':False]['text':' modes the correction will be applied next','line_number':892,'multiline':False]['text':' C1 = 10^34 - 1 and decrement x_exp by 1 (no underflow possible)','line_number':900,'multiline':False]['text':' add 1 ulp and then check for overflow','line_number':908,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':910,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':915,'multiline':False]['text':' 10^33','line_number':917,'multiline':False]['text':' overflow','line_number':919,'multiline':False]['text':' +inf','line_number':920,'multiline':False]['text':' x_sign is preserved','line_number':922,'multiline':False]['text':' set overflow flag (the inexact flag was set too)','line_number':923,'multiline':False]['text':' subtract 1 ulp from C1','line_number':931,'multiline':False]['text':' Note: because delta >= P34 + 1 the result cannot be zero','line_number':932,'multiline':False]['text':' if the coefficient is 10^33 - 1 then make it 10^34 - 1 and ','line_number':936,'multiline':False]['text':' decrease the exponent by 1 (because delta >= P34 + 1 the','line_number':937,'multiline':False]['text':' exponent will not become less than e_min)','line_number':938,'multiline':False]['text':' 10^33 - 1 = 0x0000314dc6448d9338c15b09ffffffff','line_number':939,'multiline':False]['text':' 10^34 - 1 = 0x0001ed09bead87c0378d8e63ffffffff','line_number':940,'multiline':False]['text':' make C1 = 10^34  - 1','line_number':943,'multiline':False]['text':' the result is already correct','line_number':949,'multiline':False]['text':' set the inexact flag','line_number':952,'multiline':False]['text':' assemble the result','line_number':954,'multiline':False]['text':' delta = P34 ','line_number':957,'multiline':False]['text':' in most cases, the smaller operand may be < or = or > 1/2 ulp of the','line_number':958,'multiline':False]['text':' larger operand','line_number':959,'multiline':False]['text':' however, the case C1 = 10^(q1-1) and x_sign != y_sign is special due','line_number':960,'multiline':False]['text':' to accuracy loss after subtraction, and will be treated separately','line_number':961,'multiline':False]['text':' if x_sign == y_sign or C1 != 10^(q1-1)','line_number':967,'multiline':False]['text':' compare C2 with 1/2 ulp = 5 * 10^(q2-1), the latter read from table','line_number':968,'multiline':False]['text':' Note: cases q1<=19 and q1>=20 can be coalesced at some latency cost','line_number':969,'multiline':False]['text':' C2 and 5*10^(q2-1) both fit in 64 bits','line_number':970,'multiline':False]['text':' 5 * 10^(q2-1)','line_number':971,'multiline':False]['text':' n2 < 1/2 ulp (n1)','line_number':972,'multiline':False]['text':' for RN the result is the operand with the larger magnitude, ','line_number':973,'multiline':False]['text':' possibly scaled up by 10^(P34-q1)','line_number':974,'multiline':False]['text':' an overflow cannot occur in this case (rounding to nearest)','line_number':975,'multiline':False]['text':' scale C1 up by 10^(P34-q1)','line_number':976,'multiline':False]['text':' Note: because delta = P34 it is certain that','line_number':977,'multiline':False]['text':'     x_exp - ((BID_UINT64)scale << 49) will stay above e_min','line_number':978,'multiline':False]['text':' C1 fits in 64 bits','line_number':980,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':981,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':982,'multiline':False]['text':' if 20 <= scale <= 33','line_number':984,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':985,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits','line_number':986,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':990,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits','line_number':991,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1','line_number':994,'multiline':False]['text':' add 1 ulp and then check for overflow','line_number':1004,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1006,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1011,'multiline':False]['text':' 10^33','line_number':1013,'multiline':False]['text':' overflow','line_number':1015,'multiline':False]['text':' +inf','line_number':1016,'multiline':False]['text':' x_sign is preserved','line_number':1018,'multiline':False]['text':' set overflow flag (the inexact flag was set too)','line_number':1019,'multiline':False]['text':' subtract 1 ulp from C1','line_number':1028,'multiline':False]['text':' Note: because delta >= P34 + 1 the result cannot be zero','line_number':1029,'multiline':False]['text':' if the coefficient is 10^33-1 then make it 10^34-1 and ','line_number':1033,'multiline':False]['text':' decrease the exponent by 1 (because delta >= P34 + 1 the','line_number':1034,'multiline':False]['text':' exponent will not become less than e_min)','line_number':1035,'multiline':False]['text':' 10^33 - 1 = 0x0000314dc6448d9338c15b09ffffffff','line_number':1036,'multiline':False]['text':' 10^34 - 1 = 0x0001ed09bead87c0378d8e63ffffffff','line_number':1037,'multiline':False]['text':' make C1 = 10^34  - 1','line_number':1040,'multiline':False]['text':' the result is already correct','line_number':1046,'multiline':False]['text':' set the inexact flag','line_number':1049,'multiline':False]['text':' assemble the result','line_number':1051,'multiline':False]['text':' n2 = 1/2 ulp (n1) and q1 < P34 or C1 is even','line_number':1056,'multiline':False]['text':' the result is the operand with the larger magnitude,','line_number':1057,'multiline':False]['text':' possibly scaled up by 10^(P34-q1)','line_number':1058,'multiline':False]['text':' an overflow cannot occur in this case (rounding to nearest)','line_number':1059,'multiline':False]['text':' scale C1 up by 10^(P34-q1)','line_number':1060,'multiline':False]['text':' Note: because delta = P34 it is certain that','line_number':1061,'multiline':False]['text':'     x_exp - ((BID_UINT64)scale << 49) will stay above e_min','line_number':1062,'multiline':False]['text':' C1 fits in 64 bits','line_number':1064,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':1065,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1066,'multiline':False]['text':' if 20 <= scale <= 33 ','line_number':1068,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':1069,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits  ','line_number':1070,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':1074,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits ','line_number':1075,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1 ','line_number':1078,'multiline':False]['text':' add 1 ulp and then check for overflow','line_number':1090,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1092,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1097,'multiline':False]['text':' 10^33','line_number':1099,'multiline':False]['text':' overflow','line_number':1101,'multiline':False]['text':' +inf','line_number':1102,'multiline':False]['text':' x_sign is preserved','line_number':1104,'multiline':False]['text':' set overflow flag (the inexact flag was set too)','line_number':1105,'multiline':False]['text':' subtract 1 ulp from C1','line_number':1115,'multiline':False]['text':' Note: because delta >= P34 + 1 the result cannot be zero','line_number':1116,'multiline':False]['text':' if the coefficient is 10^33 - 1 then make it 10^34 - 1','line_number':1120,'multiline':False]['text':' and decrease the exponent by 1 (because delta >= P34 + 1','line_number':1121,'multiline':False]['text':' the exponent will not become less than e_min)','line_number':1122,'multiline':False]['text':' 10^33 - 1 = 0x0000314dc6448d9338c15b09ffffffff','line_number':1123,'multiline':False]['text':' 10^34 - 1 = 0x0001ed09bead87c0378d8e63ffffffff','line_number':1124,'multiline':False]['text':' make C1 = 10^34  - 1','line_number':1127,'multiline':False]['text':' the result is already correct','line_number':1133,'multiline':False]['text':' set the inexact flag','line_number':1135,'multiline':False]['text':' assemble the result ','line_number':1137,'multiline':False]['text':' if C2_lo > halfulp64 || ','line_number':1140,'multiline':False]['text':' (C2_lo == halfulp64 && q1 == P34 && ((C1_lo & 0x1) == 1)), i.e.','line_number':1141,'multiline':False]['text':' 1/2 ulp(n1) < n2 < 1 ulp(n1) or n2 = 1/2 ulp(n1) and C1 odd','line_number':1142,'multiline':False]['text':' res = x+1 ulp if n1*n2 > 0 and res = x-1 ulp if n1*n2 < 0','line_number':1143,'multiline':False]['text':' then 1 ulp = 10^(e1+q1-P34) < 10^e1','line_number':1144,'multiline':False]['text':' Note: if (q1 == P34) then 1 ulp = 10^(e1+q1-P34) = 10^e1','line_number':1145,'multiline':False]['text':' because q1 < P34 we must first replace C1 by ','line_number':1146,'multiline':False]['text':' C1 * 10^(P34-q1), and must decrease the exponent by ','line_number':1147,'multiline':False]['text':' (P34-q1) (it will still be at least e_min)','line_number':1148,'multiline':False]['text':' C1 fits in 64 bits','line_number':1150,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':1151,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1152,'multiline':False]['text':' if 20 <= scale <= 33','line_number':1154,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':1155,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits','line_number':1156,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':1160,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits','line_number':1161,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1','line_number':1164,'multiline':False]['text':' check for rounding overflow','line_number':1170,'multiline':False]['text':' C1 = 10^34 => rounding overflow ','line_number':1173,'multiline':False]['text':' 10^33','line_number':1175,'multiline':False]['text':' the result is x - 1','line_number':1186,'multiline':False]['text':' for RN n1 * n2 < 0; underflow not possible','line_number':1187,'multiline':False]['text':' check if we crossed into the lower decade','line_number':1191,'multiline':False]['text':' 10^33 - 1','line_number':1192,'multiline':False]['text':' 10^34 - 1','line_number':1193,'multiline':False]['text':' no underflow, because n1 >> n2','line_number':1195,'multiline':False]['text':' the result is x + 1','line_number':1205,'multiline':False]['text':' for RN x_sign = y_sign, i.e. n1*n2 > 0','line_number':1206,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1208,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1213,'multiline':False]['text':' 10^33','line_number':1215,'multiline':False]['text':' overflow','line_number':1217,'multiline':False]['text':' +inf','line_number':1218,'multiline':False]['text':' x_sign is preserved','line_number':1220,'multiline':False]['text':' set the overflow flag','line_number':1221,'multiline':False]['text':' the result is x','line_number':1226,'multiline':False]['text':' set the inexact flag','line_number':1228,'multiline':False]['text':' assemble the result','line_number':1230,'multiline':False]['text':' if q2 >= 20 then 5*10^(q2-1) and C2 (the latter in ','line_number':1234,'multiline':False]['text':' most cases) fit only in more than 64 bits','line_number':1235,'multiline':False]['text':' 5 * 10^(q2-1)','line_number':1236,'multiline':False]['text':' n2 < 1/2 ulp (n1)','line_number':1240,'multiline':False]['text':' the result is the operand with the larger magnitude,','line_number':1241,'multiline':False]['text':' possibly scaled up by 10^(P34-q1)','line_number':1242,'multiline':False]['text':' an overflow cannot occur in this case (rounding to nearest)','line_number':1243,'multiline':False]['text':' scale C1 up by 10^(P34-q1)','line_number':1244,'multiline':False]['text':' Note: because delta = P34 it is certain that','line_number':1245,'multiline':False]['text':'     x_exp - ((BID_UINT64)scale << 49) will stay above e_min','line_number':1246,'multiline':False]['text':' C1 fits in 64 bits','line_number':1248,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':1249,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1250,'multiline':False]['text':' if 20 <= scale <= 33 ','line_number':1252,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':1253,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits  ','line_number':1254,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':1258,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits ','line_number':1259,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1 ','line_number':1262,'multiline':False]['text':' add 1 ulp and then check for overflow','line_number':1272,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1274,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1279,'multiline':False]['text':' 10^33','line_number':1281,'multiline':False]['text':' overflow','line_number':1283,'multiline':False]['text':' +inf','line_number':1284,'multiline':False]['text':' x_sign is preserved','line_number':1286,'multiline':False]['text':' set overflow flag (the inexact flag was set too)','line_number':1287,'multiline':False]['text':' subtract 1 ulp from C1','line_number':1296,'multiline':False]['text':' Note: because delta >= P34 + 1 the result cannot be zero','line_number':1297,'multiline':False]['text':' if the coefficient is 10^33-1 then make it 10^34-1 and','line_number':1301,'multiline':False]['text':' decrease the exponent by 1 (because delta >= P34 + 1 the','line_number':1302,'multiline':False]['text':' exponent will not become less than e_min)','line_number':1303,'multiline':False]['text':' 10^33 - 1 = 0x0000314dc6448d9338c15b09ffffffff','line_number':1304,'multiline':False]['text':' 10^34 - 1 = 0x0001ed09bead87c0378d8e63ffffffff','line_number':1305,'multiline':False]['text':' make C1 = 10^34  - 1','line_number':1308,'multiline':False]['text':' the result is already correct','line_number':1314,'multiline':False]['text':' set the inexact flag ','line_number':1317,'multiline':False]['text':' assemble the result ','line_number':1319,'multiline':False]['text':' set the inexact flag ','line_number':1325,'multiline':False]['text':' midpoint & lsb in C1 is 0','line_number':1326,'multiline':False]['text':' n2 = 1/2 ulp (n1) and C1 is even','line_number':1327,'multiline':False]['text':' the result is the operand with the larger magnitude,','line_number':1328,'multiline':False]['text':' possibly scaled up by 10^(P34-q1)','line_number':1329,'multiline':False]['text':' an overflow cannot occur in this case (rounding to nearest)','line_number':1330,'multiline':False]['text':' scale C1 up by 10^(P34-q1)','line_number':1331,'multiline':False]['text':' Note: because delta = P34 it is certain that','line_number':1332,'multiline':False]['text':'     x_exp - ((BID_UINT64)scale << 49) will stay above e_min','line_number':1333,'multiline':False]['text':' C1 fits in 64 bits','line_number':1335,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':1336,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1337,'multiline':False]['text':' if 20 <= scale <= 33','line_number':1339,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':1340,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits','line_number':1341,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':1345,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits','line_number':1346,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1','line_number':1349,'multiline':False]['text':' add 1 ulp and then check for overflow','line_number':1360,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1362,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1367,'multiline':False]['text':' 10^33','line_number':1369,'multiline':False]['text':' overflow','line_number':1371,'multiline':False]['text':' +inf','line_number':1372,'multiline':False]['text':' x_sign is preserved','line_number':1374,'multiline':False]['text':' set overflow flag (the inexact flag was set too)','line_number':1375,'multiline':False]['text':' subtract 1 ulp from C1','line_number':1382,'multiline':False]['text':' Note: because delta >= P34 + 1 the result cannot be zero','line_number':1383,'multiline':False]['text':' if the coefficient is 10^33 - 1 then make it 10^34 - 1','line_number':1387,'multiline':False]['text':' and decrease the exponent by 1 (because delta >= P34 + 1','line_number':1388,'multiline':False]['text':' the exponent will not become less than e_min)','line_number':1389,'multiline':False]['text':' 10^33 - 1 = 0x0000314dc6448d9338c15b09ffffffff','line_number':1390,'multiline':False]['text':' 10^34 - 1 = 0x0001ed09bead87c0378d8e63ffffffff','line_number':1391,'multiline':False]['text':' make C1 = 10^34  - 1','line_number':1394,'multiline':False]['text':' the result is already correct','line_number':1400,'multiline':False]['text':' set the inexact flag','line_number':1403,'multiline':False]['text':' assemble the result','line_number':1405,'multiline':False]['text':' if C2 > halfulp128 ||','line_number':1408,'multiline':False]['text':' (C2 == halfulp128 && q1 == P34 && ((C1 & 0x1) == 1)), i.e.','line_number':1409,'multiline':False]['text':' 1/2 ulp(n1) < n2 < 1 ulp(n1) or n2 = 1/2 ulp(n1) and C1 odd','line_number':1410,'multiline':False]['text':' res = x+1 ulp if n1*n2 > 0 and res = x-1 ulp if n1*n2 < 0','line_number':1411,'multiline':False]['text':' then 1 ulp = 10^(e1+q1-P34) < 10^e1','line_number':1412,'multiline':False]['text':' Note: if (q1 == P34) then 1 ulp = 10^(e1+q1-P34) = 10^e1','line_number':1413,'multiline':False]['text':' because q1 < P34 we must first replace C1 by C1*10^(P34-q1),','line_number':1414,'multiline':False]['text':' and must decrease the exponent by (P34-q1) (it will still be','line_number':1415,'multiline':False]['text':' at least e_min)','line_number':1416,'multiline':False]['text':' C1 fits in 64 bits','line_number':1418,'multiline':False]['text':' 1 <= q1 <= 19 => 15 <= scale <= 33','line_number':1419,'multiline':False]['text':' 10^scale fits in 64 bits','line_number':1420,'multiline':False]['text':' if 20 <= scale <= 33','line_number':1422,'multiline':False]['text':' C1 * 10^scale = (C1 * 10^(scale-19)) * 10^19 where','line_number':1423,'multiline':False]['text':' (C1 * 10^(scale-19)) fits in 64 bits','line_number':1424,'multiline':False]['text':'if 20 <= q1 <= 33=P34-1 then C1 fits only in 128 bits','line_number':1428,'multiline':False]['text':' => 1 <= P34 - q1 <= 14 so 10^(P34-q1) fits in 64 bits','line_number':1429,'multiline':False]['text':' C1 = bid_ten2k64[P34 - q1] * C1','line_number':1432,'multiline':False]['text':' the result is x - 1','line_number':1447,'multiline':False]['text':' for RN n1 * n2 < 0; underflow not possible','line_number':1448,'multiline':False]['text':' check if we crossed into the lower decade','line_number':1452,'multiline':False]['text':' 10^33 - 1','line_number':1453,'multiline':False]['text':' 10^34 - 1','line_number':1454,'multiline':False]['text':' no underflow, because n1 >> n2','line_number':1456,'multiline':False]['text':' the result is x + 1','line_number':1465,'multiline':False]['text':' for RN x_sign = y_sign, i.e. n1*n2 > 0','line_number':1466,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1468,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1473,'multiline':False]['text':' 10^33','line_number':1475,'multiline':False]['text':' overflow','line_number':1477,'multiline':False]['text':' +inf','line_number':1478,'multiline':False]['text':' x_sign is preserved','line_number':1480,'multiline':False]['text':' set the overflow flag','line_number':1481,'multiline':False]['text':' the result is x','line_number':1486,'multiline':False]['text':' set the inexact flag','line_number':1488,'multiline':False]['text':' assemble the result','line_number':1490,'multiline':False]['text':' end q1 >= 20','line_number':1494,'multiline':False]['text':' end case where C1 != 10^(q1-1)','line_number':1495,'multiline':False]['text':' C1 = 10^(q1-1) and x_sign != y_sign','line_number':1496,'multiline':False]['text':' instead of C' = (C1 * 10^(e1-e2) + C2)rnd,P34','line_number':1497,'multiline':False]['text':' calculate C' = C1 * 10^(e1-e2-x1) + (C2 * 10^(-x1))rnd,P34 ','line_number':1498,'multiline':False]['text':' where x1 = q2 - 1, 0 <= x1 <= P34 - 1','line_number':1499,'multiline':False]['text':' Because C1 = 10^(q1-1) and x_sign != y_sign, C' will have P34 ','line_number':1500,'multiline':False]['text':' digits and n = C' * 10^(e2+x1)','line_number':1501,'multiline':False]['text':' If the result has P34+1 digits, redo the steps above with x1+1','line_number':1502,'multiline':False]['text':' If the result has P34-1 digits or less, redo the steps above with ','line_number':1503,'multiline':False]['text':' x1-1 but only if initially x1 >= 1','line_number':1504,'multiline':False]['text':' NOTE: these two steps can be improved, e.g we could guess if','line_number':1505,'multiline':False]['text':' P34+1 or P34-1 digits will be obtained by adding/subtracting ','line_number':1506,'multiline':False]['text':' just the top 64 bits of the two operands','line_number':1507,'multiline':False]['text':' The result cannot be zero, and it cannot overflow','line_number':1508,'multiline':False]['text':' 0 <= x1 <= P34-1','line_number':1509,'multiline':False]['text':' Calculate C1 * 10^(e1-e2-x1) where 1 <= e1-e2-x1 <= P34','line_number':1510,'multiline':False]['text':' scale = (int)(e1 >> 49) - (int)(e2 >> 49) - x1; 0 <= scale <= P34-1','line_number':1511,'multiline':False]['text':' scale=e1-e2-x1 = P34+1-q1; 1<=scale<=P34','line_number':1512,'multiline':False]['text':' either C1 or 10^(e1-e2-x1) may not fit is 64 bits,','line_number':1513,'multiline':False]['text':' but their product fits with certainty in 128 bits','line_number':1514,'multiline':False]['text':'10^(e1-e2-x1) doesn't fit in 64 bits, but C1 does','line_number':1515,'multiline':False]['text':' if (scale >= 1','line_number':1517,'multiline':False]['text':' if 1 <= scale <= 19 then 10^(e1-e2-x1) fits in 64 bits','line_number':1518,'multiline':False]['text':' C1 fits in 64 bits','line_number':1519,'multiline':False]['text':' q1 >= 20','line_number':1521,'multiline':False]['text':' C1.w[1], C1.w[0] contains C1 * 10^(e1-e2-x1)','line_number':1527,'multiline':False]['text':' now round C2 to q2-x1 = 1 decimal digit','line_number':1529,'multiline':False]['text':' C2' = C2 + 1/2 * 10^x1 = C2 + 5 * 10^(x1-1)','line_number':1530,'multiline':False]['text':' -1 <= ind <= P34 - 2','line_number':1531,'multiline':False]['text':' if (x1 >= 1)','line_number':1532,'multiline':False]['text':' 19 <= ind <= 32','line_number':1539,'multiline':False]['text':' the approximation of 10^(-x1) was rounded up to 118 bits','line_number':1545,'multiline':False]['text':' R256 = C2*, f2*','line_number':1546,'multiline':False]['text':' calculate C2* and f2*','line_number':1547,'multiline':False]['text':' C2* is actually floor(C2*) in this case','line_number':1548,'multiline':False]['text':' C2* and f2* need shifting and masking, as shown by','line_number':1549,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':1550,'multiline':False]['text':' the top Ex bits of 10^(-x1) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':1551,'multiline':False]['text':' if x1=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':1552,'multiline':False]['text':' if (0 < f2* < 10^(-x1)) then','line_number':1553,'multiline':False]['text':'   if floor(C1+C2*) is even then C2* = floor(C2*) - logical right','line_number':1554,'multiline':False]['text':'       shift; C2* has p decimal digits, correct by Prop. 1)','line_number':1555,'multiline':False]['text':'   else if floor(C1+C2*) is odd C2* = floor(C2*)-1 (logical right','line_number':1556,'multiline':False]['text':'       shift; C2* has p decimal digits, correct by Pr. 1)','line_number':1557,'multiline':False]['text':' else','line_number':1558,'multiline':False]['text':'   C2* = floor(C2*) (logical right shift; C has p decimal digits,','line_number':1559,'multiline':False]['text':'       correct by Property 1)','line_number':1560,'multiline':False]['text':' n = C2* * 10^(e2+x1)','line_number':1561,'multiline':False]['text':' low f2* ok','line_number':1565,'multiline':False]['text':' low f2* ok','line_number':1568,'multiline':False]['text':' low f2* is ok','line_number':1571,'multiline':False]['text':' shift right C2* by Ex-128 = bid_shiftright128[ind]','line_number':1573,'multiline':False]['text':' 3 <= shift <= 63','line_number':1576,'multiline':False]['text':' 66 <= shift <= 102','line_number':1580,'multiline':False]['text':' redundant','line_number':1585,'multiline':False]['text':' determine inexactness of the rounding of C2*','line_number':1590,'multiline':False]['text':' (cannot be followed by a second rounding)','line_number':1591,'multiline':False]['text':' if (0 < f2* - 1/2 < 10^(-x1)) then','line_number':1592,'multiline':False]['text':'   the result is exact','line_number':1593,'multiline':False]['text':' else (if f2* - 1/2 > T* then)','line_number':1594,'multiline':False]['text':'   the result of is inexact','line_number':1595,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':1600,'multiline':False]['text':' f* - 1/2','line_number':1601,'multiline':False]['text':' set the inexact flag','line_number':1605,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1607,'multiline':False]['text':' x_sign != y_sign','line_number':1608,'multiline':False]['text':' else the result is exact','line_number':1610,'multiline':False]['text':' rounding down, unless a midpoint in [ODD, EVEN]','line_number':1611,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':1612,'multiline':False]['text':' set the inexact flag','line_number':1613,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1615,'multiline':False]['text':' x_sign != y_sign','line_number':1616,'multiline':False]['text':' if 3 <= ind <= 21','line_number':1619,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':1626,'multiline':False]['text':' Calculate f2* - 1/2','line_number':1627,'multiline':False]['text':' set the inexact flag','line_number':1636,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1638,'multiline':False]['text':' x_sign != y_sign','line_number':1639,'multiline':False]['text':' else the result is exact','line_number':1641,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':1642,'multiline':False]['text':' set the inexact flag','line_number':1643,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1645,'multiline':False]['text':' x_sign != y_sign','line_number':1646,'multiline':False]['text':' if 22 <= ind <= 33','line_number':1649,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':1654,'multiline':False]['text':' Calculate f2* - 1/2','line_number':1655,'multiline':False]['text':' tmp64A = highf2star.w[0];','line_number':1656,'multiline':False]['text':' set the inexact flag','line_number':1662,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1664,'multiline':False]['text':' x_sign != y_sign','line_number':1665,'multiline':False]['text':' else the result is exact','line_number':1667,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':1668,'multiline':False]['text':' set the inexact flag','line_number':1669,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1671,'multiline':False]['text':' x_sign != y_sign','line_number':1672,'multiline':False]['text':' check for midpoints after determining inexactness','line_number':1676,'multiline':False]['text':' the result is a midpoint','line_number':1682,'multiline':False]['text':' MP in [EVEN, ODD]','line_number':1683,'multiline':False]['text':' if floor(C2*) is odd C = floor(C2*) - 1; the result may be 0','line_number':1684,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1688,'multiline':False]['text':' x_sign != y_sign','line_number':1689,'multiline':False]['text':' else MP in [ODD, EVEN]','line_number':1694,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':1695,'multiline':False]['text':' x_sign != y_sign','line_number':1696,'multiline':False]['text':' if (ind == -1) only when x1 = 0','line_number':1702,'multiline':False]['text':' and now subtract C1 * 10^(e1-e2-x1) - (C2 * 10^(-x1))rnd,P34','line_number':1710,'multiline':False]['text':' because x_sign != y_sign this last operation is exact','line_number':1711,'multiline':False]['text':' borrow','line_number':1715,'multiline':False]['text':' negative coefficient!','line_number':1716,'multiline':False]['text':' the result will have the sign of y','line_number':1722,'multiline':False]['text':' the difference has exactly P34 digits','line_number':1726,'multiline':False]['text':' general correction from RN to RA, RM, RP, RZ; result uses y_exp','line_number':1732,'multiline':False]['text':' C1 = C1 + 1','line_number':1753,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':1755,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':1760,'multiline':False]['text':' 10^33','line_number':1762,'multiline':False]['text':' C1 = C1 - 1','line_number':1773,'multiline':False]['text':' check if we crossed into the lower decade','line_number':1777,'multiline':False]['text':' 10^33 - 1','line_number':1778,'multiline':False]['text':' 10^34 - 1','line_number':1779,'multiline':False]['text':' no underflow, because delta + q2 >= P34 + 1','line_number':1782,'multiline':False]['text':' exact, the result is already correct','line_number':1785,'multiline':False]['text':' assemble the result','line_number':1788,'multiline':False]['text':' end delta = P34','line_number':1792,'multiline':False]['text':' if (|delta| <= P34 - 1)','line_number':1793,'multiline':False]['text':' if (0 <= delta <= P34 - 1)','line_number':1794,'multiline':False]['text':' calculate C' directly; the result is exact','line_number':1796,'multiline':False]['text':' in this case 1<=q1<=P34-1, 1<=q2<=P34-1 and 0 <= e1-e2 <= P34-2','line_number':1797,'multiline':False]['text':' The coefficient of the result is C1 * 10^(e1-e2) + C2 and the','line_number':1798,'multiline':False]['text':' exponent is e2; either C1 or 10^(e1-e2) may not fit is 64 bits,','line_number':1799,'multiline':False]['text':' but their product fits with certainty in 128 bits (actually in 113)','line_number':1800,'multiline':False]['text':' scale = (int)(e1 >> 49) - (int)(e2 >> 49) ','line_number':1801,'multiline':False]['text':' 10^(e1-e2) does not fit in 64 bits, but C1 does','line_number':1803,'multiline':False]['text':' if 1 <= scale <= 19 then 10^(e1-e2) fits in 64 bits ','line_number':1808,'multiline':False]['text':' C1 fits in 64 bits','line_number':1809,'multiline':False]['text':' q1 >= 20','line_number':1811,'multiline':False]['text':' if (scale == 0) C1 is unchanged','line_number':1818,'multiline':False]['text':' C1.w[1] = C1_hi; ','line_number':1819,'multiline':False]['text':' now add C2','line_number':1821,'multiline':False]['text':' the result cannot overflow','line_number':1823,'multiline':False]['text':' if x_sign != y_sign','line_number':1828,'multiline':False]['text':' the result can be zero, but it cannot overflow','line_number':1833,'multiline':False]['text':' assemble the result','line_number':1835,'multiline':False]['text':' negative coefficient!','line_number':1847,'multiline':False]['text':' the result will have the sign of y','line_number':1853,'multiline':False]['text':' assemble the result','line_number':1856,'multiline':False]['text':' calculate C' directly; the result may be inexact if it requires ','line_number':1860,'multiline':False]['text':' P34+1 decimal digits; in this case the 'cutoff' point for addition','line_number':1861,'multiline':False]['text':' is at the position of the lsb of C2, so 0 <= e1-e2 <= P34-1','line_number':1862,'multiline':False]['text':' The coefficient of the result is C1 * 10^(e1-e2) + C2 and the','line_number':1863,'multiline':False]['text':' exponent is e2; either C1 or 10^(e1-e2) may not fit is 64 bits,','line_number':1864,'multiline':False]['text':' but their product fits with certainty in 128 bits (actually in 113)','line_number':1865,'multiline':False]['text':' scale = (int)(e1 >> 49) - (int)(e2 >> 49)','line_number':1866,'multiline':False]['text':' 10^(e1-e2) does not fit in 64 bits, but C1 does','line_number':1867,'multiline':False]['text':' if 1 <= scale <= 19 then 10^(e1-e2) fits in 64 bits','line_number':1870,'multiline':False]['text':' C1 fits in 64 bits','line_number':1871,'multiline':False]['text':' q1 >= 20','line_number':1873,'multiline':False]['text':' if (scale == 0) C1 is unchanged','line_number':1878,'multiline':False]['text':' only the low part is necessary','line_number':1880,'multiline':False]['text':' now add C2','line_number':1884,'multiline':False]['text':' the result can overflow!','line_number':1886,'multiline':False]['text':' test for overflow, possible only when C1 >= 10^34','line_number':1891,'multiline':False]['text':' C1 >= 10^34','line_number':1892,'multiline':False]['text':' in this case q = P34 + 1 and x = q - P34 = 1, so multiply ','line_number':1893,'multiline':False]['text':' C'' = C'+ 5 = C1 + 5 by k1 ~ 10^(-1) calculated for P34 + 1 ','line_number':1894,'multiline':False]['text':' decimal digits','line_number':1895,'multiline':False]['text':' Calculate C'' = C' + 1/2 * 10^x','line_number':1896,'multiline':False]['text':' low half add has carry','line_number':1897,'multiline':False]['text':' the approximation of 10^(-1) was rounded up to 118 bits','line_number':1903,'multiline':False]['text':' 10^(-1) =~ 33333333333333333333333333333400 * 2^-129','line_number':1904,'multiline':False]['text':' 10^(-1) =~ 19999999999999999999999999999a00 * 2^-128','line_number':1905,'multiline':False]['text':' C''','line_number':1907,'multiline':False]['text':' P256 = C*, f*','line_number':1910,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':1911,'multiline':False]['text':' the top Ex = 128 bits of 10^(-1) are ','line_number':1912,'multiline':False]['text':' T* = 0x00199999999999999999999999999999','line_number':1913,'multiline':False]['text':' if (0 < f* < 10^(-x)) then','line_number':1914,'multiline':False]['text':'   if floor(C*) is even then C = floor(C*) - logical right ','line_number':1915,'multiline':False]['text':'       shift; C has p decimal digits, correct by Prop. 1)','line_number':1916,'multiline':False]['text':'   else if floor(C*) is odd C = floor(C*) - 1 (logical right','line_number':1917,'multiline':False]['text':'       shift; C has p decimal digits, correct by Pr. 1)','line_number':1918,'multiline':False]['text':' else','line_number':1919,'multiline':False]['text':'   C = floor(C*) (logical right shift; C has p decimal digits,','line_number':1920,'multiline':False]['text':'       correct by Property 1)','line_number':1921,'multiline':False]['text':' n = C * 10^(e2+x)','line_number':1922,'multiline':False]['text':' the result is a midpoint','line_number':1927,'multiline':False]['text':' if floor(C*) is odd C = floor(C*) - 1; the result is not 0','line_number':1930,'multiline':False]['text':' n = Cstar * 10^(e2+1)','line_number':1938,'multiline':False]['text':' C* != 10^P because C* has P34 digits','line_number':1940,'multiline':False]['text':' check for overflow','line_number':1941,'multiline':False]['text':' overflow for RN','line_number':1945,'multiline':False]['text':' +/-inf','line_number':1946,'multiline':False]['text':' set the inexact flag','line_number':1948,'multiline':False]['text':' set the overflow flag','line_number':1950,'multiline':False]['text':' if (0 < f* - 1/2 < 10^(-x)) then ','line_number':1955,'multiline':False]['text':'   the result of the addition is exact ','line_number':1956,'multiline':False]['text':' else ','line_number':1957,'multiline':False]['text':'   the result of the addition is inexact','line_number':1958,'multiline':False]['text':' the result may be exact','line_number':1959,'multiline':False]['text':' f* - 1/2','line_number':1960,'multiline':False]['text':' set the inexact flag','line_number':1964,'multiline':False]['text':' else the result is exact','line_number':1967,'multiline':False]['text':' the result is inexact','line_number':1968,'multiline':False]['text':' set the inexact flag','line_number':1969,'multiline':False]['text':' general correction from RN to RA, RM, RP, RZ; ','line_number':1981,'multiline':False]['text':' result uses y_exp','line_number':1982,'multiline':False]['text':' C1 = C1 + 1','line_number':2005,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':2007,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':2012,'multiline':False]['text':' 10^33','line_number':2014,'multiline':False]['text':' C1 = C1 - 1','line_number':2026,'multiline':False]['text':' check if we crossed into the lower decade','line_number':2030,'multiline':False]['text':' 10^33 - 1','line_number':2031,'multiline':False]['text':' 10^34 - 1','line_number':2032,'multiline':False]['text':' no underflow, because delta + q2 >= P34 + 1','line_number':2035,'multiline':False]['text':' exact, the result is already correct','line_number':2038,'multiline':False]['text':' in all cases check for overflow (RN and RA solved already)','line_number':2040,'multiline':False]['text':' overflow','line_number':2041,'multiline':False]['text':' RM and res < 0','line_number':2042,'multiline':False]['text':' RP and res > 0','line_number':2043,'multiline':False]['text':' +inf','line_number':2044,'multiline':False]['text':' RM and res > 0, RP and res < 0, or RZ','line_number':2046,'multiline':False]['text':' x_sign is preserved','line_number':2050,'multiline':False]['text':' set the inexact flag (in case the exact addition was exact)','line_number':2051,'multiline':False]['text':' set the overflow flag','line_number':2053,'multiline':False]['text':' else if (C1 < 10^34) then C1 is the coeff.; the result is exact','line_number':2057,'multiline':False]['text':' if x_sign != y_sign the result is exact','line_number':2058,'multiline':False]['text':' the result can be zero, but it cannot overflow','line_number':2063,'multiline':False]['text':' assemble the result','line_number':2065,'multiline':False]['text':' negative coefficient!','line_number':2077,'multiline':False]['text':' the result will have the sign of y','line_number':2083,'multiline':False]['text':' assemble the result','line_number':2086,'multiline':False]['text':' if (delta >= P34 + 1 - q2)','line_number':2089,'multiline':False]['text':' instead of C' = (C1 * 10^(e1-e2) + C2)rnd,P34','line_number':2090,'multiline':False]['text':' calculate C' = C1 * 10^(e1-e2-x1) + (C2 * 10^(-x1))rnd,P34 ','line_number':2091,'multiline':False]['text':' where x1 = q1 + e1 - e2 - P34, 1 <= x1 <= P34 - 1','line_number':2092,'multiline':False]['text':' In most cases C' will have P34 digits, and n = C' * 10^(e2+x1)','line_number':2093,'multiline':False]['text':' If the result has P34+1 digits, redo the steps above with x1+1','line_number':2094,'multiline':False]['text':' If the result has P34-1 digits or less, redo the steps above with ','line_number':2095,'multiline':False]['text':' x1-1 but only if initially x1 >= 1','line_number':2096,'multiline':False]['text':' NOTE: these two steps can be improved, e.g we could guess if','line_number':2097,'multiline':False]['text':' P34+1 or P34-1 digits will be obtained by adding/subtracting just','line_number':2098,'multiline':False]['text':' the top 64 bits of the two operands','line_number':2099,'multiline':False]['text':' The result cannot be zero, but it can overflow','line_number':2100,'multiline':False]['text':' 1 <= x1 <= P34-1','line_number':2101,'multiline':False]['text':' Calculate C1 * 10^(e1-e2-x1) where 0 <= e1-e2-x1 <= P34 - 1','line_number':2103,'multiline':False]['text':' scale = (int)(e1 >> 49) - (int)(e2 >> 49) - x1; 0 <= scale <= P34-1','line_number':2104,'multiline':False]['text':' scale = e1 - e2 - x1 = P34 - q1','line_number':2105,'multiline':False]['text':' either C1 or 10^(e1-e2-x1) may not fit is 64 bits,','line_number':2106,'multiline':False]['text':' but their product fits with certainty in 128 bits (actually in 113)','line_number':2107,'multiline':False]['text':'10^(e1-e2-x1) doesn't fit in 64 bits, but C1 does','line_number':2108,'multiline':False]['text':' if 1 <= scale <= 19 then 10^(e1-e2-x1) fits in 64 bits','line_number':2111,'multiline':False]['text':' C1 fits in 64 bits','line_number':2112,'multiline':False]['text':' q1 >= 20','line_number':2114,'multiline':False]['text':' if (scale == 0) C1 is unchanged','line_number':2119,'multiline':False]['text':' C1.w[1], C1.w[0] contains C1 * 10^(e1-e2-x1)','line_number':2123,'multiline':False]['text':' now round C2 to q2-x1 decimal digits, where 1<=x1<=q2-1<=P34-1','line_number':2125,'multiline':False]['text':' (but if we got here a second time after x1 = x1 - 1, then ','line_number':2126,'multiline':False]['text':' x1 >= 0; note that for x1 = 0 C2 is unchanged)','line_number':2127,'multiline':False]['text':' C2' = C2 + 1/2 * 10^x1 = C2 + 5 * 10^(x1-1)','line_number':2128,'multiline':False]['text':' 0 <= ind <= q2-2<=P34-2=32; but note that if x1 = 0','line_number':2129,'multiline':False]['text':' during a second pass, then ind = -1','line_number':2130,'multiline':False]['text':' if (x1 >= 1)','line_number':2131,'multiline':False]['text':' 19 <= ind <= 32','line_number':2138,'multiline':False]['text':' the approximation of 10^(-x1) was rounded up to 118 bits','line_number':2144,'multiline':False]['text':' R256 = C2*, f2*','line_number':2145,'multiline':False]['text':' calculate C2* and f2*','line_number':2146,'multiline':False]['text':' C2* is actually floor(C2*) in this case','line_number':2147,'multiline':False]['text':' C2* and f2* need shifting and masking, as shown by','line_number':2148,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':2149,'multiline':False]['text':' the top Ex bits of 10^(-x1) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':2150,'multiline':False]['text':' if x1=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2151,'multiline':False]['text':' if (0 < f2* < 10^(-x1)) then','line_number':2152,'multiline':False]['text':'   if floor(C1+C2*) is even then C2* = floor(C2*) - logical right','line_number':2153,'multiline':False]['text':'       shift; C2* has p decimal digits, correct by Prop. 1)','line_number':2154,'multiline':False]['text':'   else if floor(C1+C2*) is odd C2* = floor(C2*)-1 (logical right','line_number':2155,'multiline':False]['text':'       shift; C2* has p decimal digits, correct by Pr. 1)','line_number':2156,'multiline':False]['text':' else','line_number':2157,'multiline':False]['text':'   C2* = floor(C2*) (logical right shift; C has p decimal digits,','line_number':2158,'multiline':False]['text':'       correct by Property 1)','line_number':2159,'multiline':False]['text':' n = C2* * 10^(e2+x1)','line_number':2160,'multiline':False]['text':' low f2* ok','line_number':2164,'multiline':False]['text':' low f2* ok','line_number':2167,'multiline':False]['text':' low f2* is ok','line_number':2170,'multiline':False]['text':' shift right C2* by Ex-128 = bid_shiftright128[ind]','line_number':2172,'multiline':False]['text':' 3 <= shift <= 63','line_number':2175,'multiline':False]['text':' 66 <= shift <= 102','line_number':2179,'multiline':False]['text':' determine inexactness of the rounding of C2* (this may be ','line_number':2190,'multiline':False]['text':' followed by a second rounding only if we get P34+1 ','line_number':2191,'multiline':False]['text':' decimal digits)','line_number':2192,'multiline':False]['text':' if (0 < f2* - 1/2 < 10^(-x1)) then','line_number':2193,'multiline':False]['text':'   the result is exact','line_number':2194,'multiline':False]['text':' else (if f2* - 1/2 > T* then)','line_number':2195,'multiline':False]['text':'   the result of is inexact','line_number':2196,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':2201,'multiline':False]['text':' f* - 1/2','line_number':2202,'multiline':False]['text':' set the inexact flag','line_number':2206,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2207,'multiline':False]['text':' may be set again during a second pass','line_number':2208,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2209,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2212,'multiline':False]['text':' else the result is exact','line_number':2214,'multiline':False]['text':' rounding down, unless a midpoint in [ODD, EVEN]','line_number':2215,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':2216,'multiline':False]['text':' set the inexact flag','line_number':2217,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2218,'multiline':False]['text':' just in case we will round a second time','line_number':2219,'multiline':False]['text':' rounding up, unless a midpoint in [EVEN, ODD]','line_number':2220,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2221,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2224,'multiline':False]['text':' if 3 <= ind <= 21','line_number':2227,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':2234,'multiline':False]['text':' Calculate f2* - 1/2','line_number':2235,'multiline':False]['text':' set the inexact flag','line_number':2244,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2245,'multiline':False]['text':' may be set again during a second pass','line_number':2246,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2247,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2250,'multiline':False]['text':' else the result is exact','line_number':2252,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':2253,'multiline':False]['text':' set the inexact flag','line_number':2254,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2255,'multiline':False]['text':' may be set again during a second pass','line_number':2256,'multiline':False]['text':' rounding up, unless a midpoint in [EVEN, ODD]','line_number':2257,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2258,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2261,'multiline':False]['text':' if 22 <= ind <= 33','line_number':2264,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':2269,'multiline':False]['text':' Calculate f2* - 1/2','line_number':2270,'multiline':False]['text':' tmp64A = highf2star.w[0];','line_number':2271,'multiline':False]['text':' set the inexact flag','line_number':2277,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2278,'multiline':False]['text':' may be set again during a second pass','line_number':2279,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2280,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2283,'multiline':False]['text':' else the result is exact','line_number':2285,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':2286,'multiline':False]['text':' set the inexact flag','line_number':2287,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2288,'multiline':False]['text':' may be set again during a second pass','line_number':2289,'multiline':False]['text':' rounding up, unless a midpoint in [EVEN, ODD]','line_number':2290,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2291,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2294,'multiline':False]['text':' check for midpoints','line_number':2298,'multiline':False]['text':' the result is a midpoint','line_number':2304,'multiline':False]['text':' MP in [EVEN, ODD]','line_number':2305,'multiline':False]['text':' if floor(C2*) is odd C = floor(C2*) - 1; the result may be 0','line_number':2306,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2310,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2313,'multiline':False]['text':' else MP in [ODD, EVEN]','line_number':2318,'multiline':False]['text':' this rounding is applied to C2 only!','line_number':2319,'multiline':False]['text':' if (x_sign != y_sign)','line_number':2322,'multiline':False]['text':' end if (ind >= 0)','line_number':2328,'multiline':False]['text':' if (ind == -1); only during a 2nd pass, and when x1 = 0','line_number':2329,'multiline':False]['text':' to correct a possible setting to 1 from 1st pass','line_number':2333,'multiline':False]['text':' and now add/subtract C1 * 10^(e1-e2-x1) +/- (C2 * 10^(-x1))rnd,P34','line_number':2341,'multiline':False]['text':' addition; could overflow','line_number':2342,'multiline':False]['text':' no second pass is possible this way (only for x_sign != y_sign)','line_number':2343,'multiline':False]['text':' carry','line_number':2347,'multiline':False]['text':' if the sum has P34+1 digits, i.e. C1>=10^34 redo the calculation','line_number':2348,'multiline':False]['text':' with x1=x1+1 ','line_number':2349,'multiline':False]['text':' C1 >= 10^34','line_number':2350,'multiline':False]['text':' chop off one more digit from the sum, but make sure there is','line_number':2351,'multiline':False]['text':' no double-rounding error (see table - double rounding logic)','line_number':2352,'multiline':False]['text':' now round C1 from P34+1 to P34 decimal digits','line_number':2353,'multiline':False]['text':' C1' = C1 + 1/2 * 10 = C1 + 5','line_number':2354,'multiline':False]['text':' low half add has carry','line_number':2355,'multiline':False]['text':' the approximation of 10^(-1) was rounded up to 118 bits','line_number':2361,'multiline':False]['text':' Q256 = C1*, f1*','line_number':2362,'multiline':False]['text':' C1* is actually floor(C1*) in this case','line_number':2363,'multiline':False]['text':' the top 128 bits of 10^(-1) are','line_number':2364,'multiline':False]['text':' T* = bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2365,'multiline':False]['text':' if (0 < f1* < 10^(-1)) then','line_number':2366,'multiline':False]['text':'   if floor(C1*) is even then C1* = floor(C1*) - logical right','line_number':2367,'multiline':False]['text':'       shift; C1* has p decimal digits, correct by Prop. 1)','line_number':2368,'multiline':False]['text':'   else if floor(C1*) is odd C1* = floor(C1*) - 1 (logical right','line_number':2369,'multiline':False]['text':'       shift; C1* has p decimal digits, correct by Pr. 1)','line_number':2370,'multiline':False]['text':' else','line_number':2371,'multiline':False]['text':'   C1* = floor(C1*) (logical right shift; C has p decimal digits','line_number':2372,'multiline':False]['text':'       correct by Property 1)','line_number':2373,'multiline':False]['text':' n = C1* * 10^(e2+x1+1)','line_number':2374,'multiline':False]['text':' the result is a midpoint','line_number':2379,'multiline':False]['text':' for the 1st rounding','line_number':2380,'multiline':False]['text':' for the 1st rounding','line_number':2385,'multiline':False]['text':' for the 1st rounding','line_number':2393,'multiline':False]['text':' Note: cannot have is_midpoint_lt_even','line_number':2394,'multiline':False]['text':' the first rounding must have been exact','line_number':2399,'multiline':False]['text':' MP in [EVEN, ODD]','line_number':2400,'multiline':False]['text':' the truncated result is correct','line_number':2401,'multiline':False]['text':' MP in [ODD, EVEN]','line_number':2409,'multiline':False]['text':' in all cases','line_number':2416,'multiline':False]['text':' the result is not a midpoint ','line_number':2417,'multiline':False]['text':' determine inexactness of the rounding of C1 (the sum C1+C2*)','line_number':2418,'multiline':False]['text':' if (0 < f1* - 1/2 < 10^(-1)) then','line_number':2419,'multiline':False]['text':'   the result is exact','line_number':2420,'multiline':False]['text':' else (if f1* - 1/2 > T* then)','line_number':2421,'multiline':False]['text':'   the result of is inexact','line_number':2422,'multiline':False]['text':' ind = 0','line_number':2423,'multiline':False]['text':' f1* > 1/2 and the result may be exact','line_number':2427,'multiline':False]['text':' f1* - 1/2','line_number':2428,'multiline':False]['text':' set the inexact flag','line_number':2436,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2438,'multiline':False]['text':' else the result is exact for the 2nd rounding','line_number':2439,'multiline':False]['text':' if the previous rounding was inexact','line_number':2440,'multiline':False]['text':' no change','line_number':2448,'multiline':False]['text':' rounding down, unless a midpoint in [ODD, EVEN]','line_number':2452,'multiline':False]['text':' the result is inexact; f1* <= 1/2','line_number':2453,'multiline':False]['text':' set the inexact flag','line_number':2458,'multiline':False]['text':' *pfpsf |= BID_INEXACT_EXCEPTION;','line_number':2460,'multiline':False]['text':' end 'the result is not a midpoint'','line_number':2462,'multiline':False]['text':' n = C1 * 10^(e2+x1)','line_number':2463,'multiline':False]['text':' C1 < 10^34','line_number':2467,'multiline':False]['text':' C1.w[1] and C1.w[0] already set','line_number':2468,'multiline':False]['text':' n = C1 * 10^(e2+x1)','line_number':2469,'multiline':False]['text':' check for overflow','line_number':2472,'multiline':False]['text':' +/-inf','line_number':2476,'multiline':False]['text':' set the inexact flag','line_number':2478,'multiline':False]['text':' set the overflow flag','line_number':2480,'multiline':False]['text':' else no overflow','line_number':2484,'multiline':False]['text':' if x_sign != y_sign the result of this subtract. is exact','line_number':2485,'multiline':False]['text':' borrow','line_number':2489,'multiline':False]['text':' negative coefficient!','line_number':2490,'multiline':False]['text':' the result will have the sign of y if last rnd','line_number':2497,'multiline':False]['text':' if the difference has P34-1 digits or less, i.e. C1 < 10^33 then','line_number':2501,'multiline':False]['text':'   redo the calculation with x1=x1-1;','line_number':2502,'multiline':False]['text':' redo the calculation also if C1 = 10^33 and ','line_number':2503,'multiline':False]['text':'   (is_inexact_gt_midpoint or is_midpoint_lt_even);','line_number':2504,'multiline':False]['text':'   (the last part should have really been ','line_number':2505,'multiline':False]['text':'   (is_inexact_lt_midpoint or is_midpoint_gt_even) from','line_number':2506,'multiline':False]['text':'    the rounding of C2, but the position flags have been reversed)','line_number':2507,'multiline':False]['text':' 10^33 = 0x0000314dc6448d93 0x38c15b0a00000000','line_number':2508,'multiline':False]['text':' C1=10^33','line_number':2509,'multiline':False]['text':' x1 >= 0','line_number':2510,'multiline':False]['text':' clear position flags and tmp_inexact','line_number':2512,'multiline':False]['text':' else result has less than P34 digits','line_number':2519,'multiline':False]['text':' if the coefficient of the result is 10^34 it means that this','line_number':2522,'multiline':False]['text':' must be the second pass, and we are done ','line_number':2523,'multiline':False]['text':' if  C1 = 10^34','line_number':2524,'multiline':False]['text':' C1 = 10^33','line_number':2525,'multiline':False]['text':' x1 = -1 is possible at the end of a second pass when the ','line_number':2532,'multiline':False]['text':' first pass started with x1 = 1 ','line_number':2533,'multiline':False]['text':' general correction from RN to RA, RM, RP, RZ; result uses y_exp','line_number':2537,'multiline':False]['text':' C1 = C1 + 1','line_number':2558,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':2560,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':2565,'multiline':False]['text':' 10^33','line_number':2567,'multiline':False]['text':' C1 = C1 - 1','line_number':2578,'multiline':False]['text':' check if we crossed into the lower decade','line_number':2582,'multiline':False]['text':' 10^33 - 1','line_number':2583,'multiline':False]['text':' 10^34 - 1','line_number':2584,'multiline':False]['text':' no underflow, because delta + q2 >= P34 + 1','line_number':2587,'multiline':False]['text':' exact, the result is already correct','line_number':2590,'multiline':False]['text':' in all cases check for overflow (RN and RA solved already)','line_number':2592,'multiline':False]['text':' overflow','line_number':2593,'multiline':False]['text':' RM and res < 0','line_number':2594,'multiline':False]['text':' RP and res > 0','line_number':2595,'multiline':False]['text':' +inf','line_number':2596,'multiline':False]['text':' RM and res > 0, RP and res < 0, or RZ','line_number':2598,'multiline':False]['text':' x_sign is preserved','line_number':2602,'multiline':False]['text':' set the inexact flag (in case the exact addition was exact)','line_number':2603,'multiline':False]['text':' set the overflow flag','line_number':2605,'multiline':False]['text':' assemble the result','line_number':2609,'multiline':False]['text':' if (-P34 + 1 <= delta <= -1) <=> 1 <= -delta <= P34 - 1','line_number':2615,'multiline':False]['text':' NOTE: the following, up to "} else { // if x_sign != y_sign ','line_number':2616,'multiline':False]['text':' the result is exact" is identical to "else if (delta == P34 - q2) {"','line_number':2617,'multiline':False]['text':' from above; also, the code is not symmetric: a+b and b+a may take','line_number':2618,'multiline':False]['text':' different paths (need to unify eventually!) ','line_number':2619,'multiline':False]['text':' calculate C' = C2 + C1 * 10^(e1-e2) directly; the result may be ','line_number':2620,'multiline':False]['text':' inexact if it requires P34 + 1 decimal digits; in either case the ','line_number':2621,'multiline':False]['text':' 'cutoff' point for addition is at the position of the lsb of C2','line_number':2622,'multiline':False]['text':' The coefficient of the result is C1 * 10^(e1-e2) + C2 and the','line_number':2623,'multiline':False]['text':' exponent is e2; either C1 or 10^(e1-e2) may not fit is 64 bits,','line_number':2624,'multiline':False]['text':' but their product fits with certainty in 128 bits (actually in 113)','line_number':2625,'multiline':False]['text':' Note that 0 <= e1 - e2 <= P34 - 2','line_number':2626,'multiline':False]['text':'   -P34 + 1 <= delta <= -1 <=> -P34 + 1 <= delta <= -1 <=>','line_number':2627,'multiline':False]['text':'   -P34 + 1 <= q1 + e1 - q2 - e2 <= -1 <=>','line_number':2628,'multiline':False]['text':'   q2 - q1 - P34 + 1 <= e1 - e2 <= q2 - q1 - 1 <=>','line_number':2629,'multiline':False]['text':'   1 - P34 - P34 + 1 <= e1-e2 <= P34 - 1 - 1 => 0 <= e1-e2 <= P34 - 2','line_number':2630,'multiline':False]['text':' scale = (int)(e1 >> 49) - (int)(e2 >> 49)','line_number':2631,'multiline':False]['text':' 10^(e1-e2) does not fit in 64 bits, but C1 does','line_number':2632,'multiline':False]['text':' if 1 <= scale <= 19 then 10^(e1-e2) fits in 64 bits','line_number':2635,'multiline':False]['text':' C1 fits in 64 bits','line_number':2636,'multiline':False]['text':' q1 >= 20','line_number':2638,'multiline':False]['text':' if (scale == 0) C1 is unchanged','line_number':2643,'multiline':False]['text':' only the low part is necessary','line_number':2645,'multiline':False]['text':' now add C2','line_number':2649,'multiline':False]['text':' the result can overflow!','line_number':2651,'multiline':False]['text':' test for overflow, possible only when C1 >= 10^34','line_number':2656,'multiline':False]['text':' C1 >= 10^34','line_number':2657,'multiline':False]['text':' in this case q = P34 + 1 and x = q - P34 = 1, so multiply ','line_number':2658,'multiline':False]['text':' C'' = C'+ 5 = C1 + 5 by k1 ~ 10^(-1) calculated for P34 + 1 ','line_number':2659,'multiline':False]['text':' decimal digits','line_number':2660,'multiline':False]['text':' Calculate C'' = C' + 1/2 * 10^x','line_number':2661,'multiline':False]['text':' low half add has carry','line_number':2662,'multiline':False]['text':' the approximation of 10^(-1) was rounded up to 118 bits','line_number':2668,'multiline':False]['text':' 10^(-1) =~ 33333333333333333333333333333400 * 2^-129','line_number':2669,'multiline':False]['text':' 10^(-1) =~ 19999999999999999999999999999a00 * 2^-128','line_number':2670,'multiline':False]['text':' C''','line_number':2672,'multiline':False]['text':' P256 = C*, f*','line_number':2675,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':2676,'multiline':False]['text':' the top Ex = 128 bits of 10^(-1) are ','line_number':2677,'multiline':False]['text':' T* = 0x00199999999999999999999999999999','line_number':2678,'multiline':False]['text':' if (0 < f* < 10^(-x)) then','line_number':2679,'multiline':False]['text':'   if floor(C*) is even then C = floor(C*) - logical right ','line_number':2680,'multiline':False]['text':'       shift; C has p decimal digits, correct by Prop. 1)','line_number':2681,'multiline':False]['text':'   else if floor(C*) is odd C = floor(C*) - 1 (logical right','line_number':2682,'multiline':False]['text':'       shift; C has p decimal digits, correct by Pr. 1)','line_number':2683,'multiline':False]['text':' else','line_number':2684,'multiline':False]['text':'   C = floor(C*) (logical right shift; C has p decimal digits,','line_number':2685,'multiline':False]['text':'       correct by Property 1)','line_number':2686,'multiline':False]['text':' n = C * 10^(e2+x)','line_number':2687,'multiline':False]['text':' the result is a midpoint','line_number':2692,'multiline':False]['text':' if floor(C*) is odd C = floor(C*) - 1; the result is not 0','line_number':2695,'multiline':False]['text':' n = Cstar * 10^(e2+1)','line_number':2703,'multiline':False]['text':' C* != 10^P34 because C* has P34 digits','line_number':2705,'multiline':False]['text':' check for overflow','line_number':2706,'multiline':False]['text':' overflow for RN','line_number':2710,'multiline':False]['text':' +/-inf','line_number':2711,'multiline':False]['text':' set the inexact flag','line_number':2713,'multiline':False]['text':' set the overflow flag','line_number':2715,'multiline':False]['text':' if (0 < f* - 1/2 < 10^(-x)) then ','line_number':2720,'multiline':False]['text':'   the result of the addition is exact ','line_number':2721,'multiline':False]['text':' else ','line_number':2722,'multiline':False]['text':'   the result of the addition is inexact','line_number':2723,'multiline':False]['text':' the result may be exact','line_number':2724,'multiline':False]['text':' f* - 1/2','line_number':2725,'multiline':False]['text':' set the inexact flag','line_number':2729,'multiline':False]['text':' else the result is exact','line_number':2732,'multiline':False]['text':' the result is inexact','line_number':2733,'multiline':False]['text':' set the inexact flag','line_number':2734,'multiline':False]['text':' general correction from RN to RA, RM, RP, RZ; result uses y_exp','line_number':2746,'multiline':False]['text':' C1 = C1 + 1','line_number':2768,'multiline':False]['text':' rounding overflow in the low 64 bits','line_number':2770,'multiline':False]['text':' C1 = 10^34 => rounding overflow','line_number':2775,'multiline':False]['text':' 10^33','line_number':2777,'multiline':False]['text':' C1 = C1 - 1','line_number':2786,'multiline':False]['text':' check if we crossed into the lower decade','line_number':2790,'multiline':False]['text':' 10^33 - 1','line_number':2791,'multiline':False]['text':' 10^34 - 1','line_number':2792,'multiline':False]['text':' no underflow, because delta + q2 >= P34 + 1','line_number':2795,'multiline':False]['text':' exact, the result is already correct','line_number':2798,'multiline':False]['text':' in all cases check for overflow (RN and RA solved already)','line_number':2800,'multiline':False]['text':' overflow','line_number':2801,'multiline':False]['text':' RM and res < 0','line_number':2802,'multiline':False]['text':' RP and res > 0','line_number':2803,'multiline':False]['text':' +inf','line_number':2804,'multiline':False]['text':' RM and res > 0, RP and res < 0, or RZ','line_number':2806,'multiline':False]['text':' x_sign is preserved','line_number':2810,'multiline':False]['text':' set the inexact flag (in case the exact addition was exact)','line_number':2811,'multiline':False]['text':' set the overflow flag','line_number':2813,'multiline':False]['text':' else if (C1 < 10^34) then C1 is the coeff.; the result is exact','line_number':2817,'multiline':False]['text':' assemble the result','line_number':2818,'multiline':False]['text':' if x_sign != y_sign the result is exact','line_number':2821,'multiline':False]['text':' negative coefficient!','line_number':2826,'multiline':False]['text':' the result will have the sign of y','line_number':2832,'multiline':False]['text':' the result can be zero, but it cannot overflow','line_number':2834,'multiline':False]['text':' assemble the result','line_number':2836,'multiline':False]['text':' assemble the result','line_number':2848,'multiline':False]['text':' bid128_sub stands for bid128qq_sub','line_number':2861,'multiline':False]['text':'****************************************************************************
 *  BID128 sub
 ***************************************************************************','line_number':2863,'multiline':True]['text':' y is not NAN','line_number':2887,'multiline':False]['text':' change its sign','line_number':2888,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':2889,'multiline':False]