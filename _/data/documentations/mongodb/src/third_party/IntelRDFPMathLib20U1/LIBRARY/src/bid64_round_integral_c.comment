['text':'*****************************************************************************
  Copyright (c) 2007-2011, Intel Corp.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors 
      may be used to endorse or promote products derived from this software 
      without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************','line_number':1,'multiline':True]['text':'****************************************************************************
 *  BID64_round_integral_exact
 ***************************************************************************','line_number':32,'multiline':True]['text':' unbiased exponent','line_number':40,'multiline':False]['text':' Note: C1 represents the significand (BID_UINT64)','line_number':41,'multiline':False]['text':' BID_UINT64 res is C* at first - represents up to 16 decimal digits <= 54 bits','line_number':46,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':50,'multiline':False]['text':' check for NaNs and infinities','line_number':52,'multiline':False]['text':' check for NaN','line_number':53,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':55,'multiline':False]['text':' clear G6-G12','line_number':57,'multiline':False]['text':' SNaN','line_number':58,'multiline':False]['text':' set invalid flag','line_number':59,'multiline':False]['text':' return quiet (SNaN)','line_number':61,'multiline':False]['text':' QNaN','line_number':63,'multiline':False]['text':' check for Infinity','line_number':67,'multiline':False]['text':' unpack x','line_number':71,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then ','line_number':73,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':74,'multiline':False]['text':' non-canonical','line_number':77,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':80,'multiline':False]['text':' if x is 0 or non-canonical return 0 preserving the sign bit and ','line_number':85,'multiline':False]['text':' the preferred exponent of MAX(Q(x), 0)','line_number':86,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':93,'multiline':False]['text':' return 0 if (exp <= -(p+1))','line_number':98,'multiline':False]['text':' return 0 if (exp <= -p)','line_number':106,'multiline':False]['text':' return 0 if (exp <= -p)','line_number':118,'multiline':False]['text':' return 0 if (exp <= -p) ','line_number':130,'multiline':False]['text':' end switch ()','line_number':137,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':139,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':140,'multiline':False]['text':' x >= 2^53','line_number':141,'multiline':False]['text':' if x < 2^53','line_number':143,'multiline':False]['text':' exact conversion','line_number':144,'multiline':False]['text':' -exp <= 0','line_number':155,'multiline':False]['text':' the argument is an integer already','line_number':156,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':163,'multiline':False]['text':' need to shift right -exp digits from the coefficient; exp will be 0','line_number':164,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':165,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':166,'multiline':False]['text':' C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits','line_number':167,'multiline':False]['text':' FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate','line_number':168,'multiline':False]['text':' calculate C* and f*','line_number':170,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':171,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':172,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':173,'multiline':False]['text':' 1 <= x <= 16','line_number':174,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':175,'multiline':False]['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':176,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':177,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':180,'multiline':False]['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':181,'multiline':False]['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':182,'multiline':False]['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':183,'multiline':False]['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':184,'multiline':False]['text':' else  ','line_number':185,'multiline':False]['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':186,'multiline':False]['text':'       correct by Property 1)','line_number':187,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':188,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':190,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':194,'multiline':False]['text':' 3 <= shift <= 63','line_number':195,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':200,'multiline':False]['text':' since round_to_even, subtract 1 if current result is odd','line_number':201,'multiline':False]['text':' determine inexactness of the rounding of C*','line_number':206,'multiline':False]['text':' if (0 < f* - 1/2 < 10^(-x)) then','line_number':207,'multiline':False]['text':'   the result is exact','line_number':208,'multiline':False]['text':' else // if (f* - 1/2 > T*) then','line_number':209,'multiline':False]['text':'   the result is inexact','line_number':210,'multiline':False]['text':' f* > 1/2 and the result may be exact','line_number':213,'multiline':False]['text':' fstar.w[0] - 0x8000000000000000ull is f* - 1/2','line_number':214,'multiline':False]['text':' set the inexact flag','line_number':216,'multiline':False]['text':' else the result is exact','line_number':218,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':219,'multiline':False]['text':' set the inexact flag','line_number':220,'multiline':False]['text':' if 3 <= ind - 1 <= 21','line_number':223,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':226,'multiline':False]['text':' Calculate f2* - 1/2','line_number':227,'multiline':False]['text':' set the inexact flag','line_number':230,'multiline':False]['text':' else the result is exact','line_number':232,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':233,'multiline':False]['text':' set the inexact flag','line_number':234,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':238,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':241,'multiline':False]['text':' the result is +0 or -0','line_number':242,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':249,'multiline':False]['text':' need to shift right -exp digits from the coefficient; exp will be 0','line_number':250,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':251,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':252,'multiline':False]['text':' C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits','line_number':253,'multiline':False]['text':' FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate','line_number':254,'multiline':False]['text':' calculate C* and f*','line_number':256,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':257,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':258,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':259,'multiline':False]['text':' 1 <= x <= 16','line_number':260,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':261,'multiline':False]['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':262,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':263,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':266,'multiline':False]['text':'   C* = floor(C*) - logical right shift; C* has p decimal digits, ','line_number':267,'multiline':False]['text':'       correct by Prop. 1)','line_number':268,'multiline':False]['text':' else','line_number':269,'multiline':False]['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':270,'multiline':False]['text':'       correct by Property 1)','line_number':271,'multiline':False]['text':' n = C* * 10^(e+x)','line_number':272,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':274,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':278,'multiline':False]['text':' 3 <= shift <= 63','line_number':279,'multiline':False]['text':' midpoints are already rounded correctly','line_number':284,'multiline':False]['text':' determine inexactness of the rounding of C*','line_number':285,'multiline':False]['text':' if (0 < f* - 1/2 < 10^(-x)) then','line_number':286,'multiline':False]['text':'   the result is exact','line_number':287,'multiline':False]['text':' else // if (f* - 1/2 > T*) then','line_number':288,'multiline':False]['text':'   the result is inexact','line_number':289,'multiline':False]['text':' f* > 1/2 and the result may be exact ','line_number':292,'multiline':False]['text':' fstar.w[0] - 0x8000000000000000ull is f* - 1/2','line_number':293,'multiline':False]['text':' set the inexact flag','line_number':295,'multiline':False]['text':' else the result is exact','line_number':297,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':298,'multiline':False]['text':' set the inexact flag','line_number':299,'multiline':False]['text':' if 3 <= ind - 1 <= 21','line_number':302,'multiline':False]['text':' f2* > 1/2 and the result may be exact','line_number':305,'multiline':False]['text':' Calculate f2* - 1/2','line_number':306,'multiline':False]['text':' set the inexact flag','line_number':309,'multiline':False]['text':' else the result is exact','line_number':311,'multiline':False]['text':' the result is inexact; f2* <= 1/2','line_number':312,'multiline':False]['text':' set the inexact flag','line_number':313,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':317,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':320,'multiline':False]['text':' the result is +0 or -0','line_number':321,'multiline':False]['text':' exp < 0 and 1 <= -exp < q','line_number':328,'multiline':False]['text':' need to shift right -exp digits from the coefficient; exp will be 0','line_number':329,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':330,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':331,'multiline':False]['text':' C1 fits in 64 bits','line_number':332,'multiline':False]['text':' calculate C* and f*','line_number':333,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':334,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':335,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':336,'multiline':False]['text':' 1 <= x <= 16','line_number':337,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':338,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':339,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':340,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':343,'multiline':False]['text':'       correct by Property 1)','line_number':344,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':345,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':346,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':348,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':352,'multiline':False]['text':' 3 <= shift <= 63','line_number':353,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':358,'multiline':False]['text':' if negative and not exact, increment magnitude','line_number':361,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':366,'multiline':False]['text':' if exp < 0 and q + exp <= 0','line_number':369,'multiline':False]['text':' the result is +0 or -1','line_number':370,'multiline':False]['text':' exp < 0 and 1 <= -exp < q','line_number':381,'multiline':False]['text':' need to shift right -exp digits from the coefficient; exp will be 0','line_number':382,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':383,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':384,'multiline':False]['text':' C1 fits in 64 bits','line_number':385,'multiline':False]['text':' calculate C* and f*','line_number':386,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':387,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':388,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':389,'multiline':False]['text':' 1 <= x <= 16','line_number':390,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':391,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':392,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':393,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':396,'multiline':False]['text':'       correct by Property 1)','line_number':397,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':398,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':399,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':401,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':405,'multiline':False]['text':' 3 <= shift <= 63','line_number':406,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':411,'multiline':False]['text':' if positive and not exact, increment magnitude','line_number':414,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':419,'multiline':False]['text':' if exp < 0 and q + exp <= 0','line_number':422,'multiline':False]['text':' the result is -0 or +1','line_number':423,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':434,'multiline':False]['text':' need to shift right -exp digits from the coefficient; exp will be 0','line_number':435,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':436,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':437,'multiline':False]['text':' C1 fits in 127 bits','line_number':438,'multiline':False]['text':' calculate C* and f*','line_number':439,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':440,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':441,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':442,'multiline':False]['text':' 1 <= x <= 16','line_number':443,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':444,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':445,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':446,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':449,'multiline':False]['text':'       correct by Property 1)','line_number':450,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':451,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':452,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':454,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':458,'multiline':False]['text':' 3 <= shift <= 63','line_number':459,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':464,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':468,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':471,'multiline':False]['text':' the result is +0 or -0','line_number':472,'multiline':False]['text':' end switch ()','line_number':478,'multiline':False]['text':'****************************************************************************
 *  BID64_round_integral_nearest_even
 ***************************************************************************','line_number':482,'multiline':True]['text':' unbiased exponent','line_number':490,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':491,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':499,'multiline':False]['text':' check for NaNs and infinities','line_number':501,'multiline':False]['text':' check for NaN','line_number':502,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':504,'multiline':False]['text':' clear G6-G12 ','line_number':506,'multiline':False]['text':' SNaN ','line_number':507,'multiline':False]['text':' set invalid flag ','line_number':508,'multiline':False]['text':' return quiet (SNaN) ','line_number':510,'multiline':False]['text':' QNaN','line_number':512,'multiline':False]['text':' check for Infinity','line_number':516,'multiline':False]['text':' unpack x','line_number':520,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then','line_number':522,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':523,'multiline':False]['text':' non-canonical','line_number':526,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':529,'multiline':False]['text':' if x is 0 or non-canonical','line_number':534,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':541,'multiline':False]['text':' return 0 if (exp <= -(p+1))','line_number':543,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':548,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':549,'multiline':False]['text':' x >= 2^53','line_number':550,'multiline':False]['text':' if x < 2^53','line_number':552,'multiline':False]['text':' exact conversion','line_number':553,'multiline':False]['text':' -exp <= 0','line_number':564,'multiline':False]['text':' the argument is an integer already','line_number':565,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':568,'multiline':False]['text':' need to shift right -exp digits from the coefficient; the exp will be 0','line_number':569,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':570,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':571,'multiline':False]['text':' C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits','line_number':572,'multiline':False]['text':' FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate','line_number':573,'multiline':False]['text':' calculate C* and f*','line_number':575,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':576,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':577,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':578,'multiline':False]['text':' 1 <= x <= 16','line_number':579,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':580,'multiline':False]['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':581,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':582,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':585,'multiline':False]['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':586,'multiline':False]['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':587,'multiline':False]['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':588,'multiline':False]['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':589,'multiline':False]['text':' else  ','line_number':590,'multiline':False]['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':591,'multiline':False]['text':'       correct by Property 1)','line_number':592,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':593,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':595,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':599,'multiline':False]['text':' 3 <= shift <= 63','line_number':600,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':605,'multiline':False]['text':' since round_to_even, subtract 1 if current result is odd','line_number':606,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':611,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':614,'multiline':False]['text':' the result is +0 or -0','line_number':615,'multiline':False]['text':'****************************************************************************
 *  BID64_round_integral_negative
 ****************************************************************************','line_number':621,'multiline':True]['text':' unbiased exponent','line_number':629,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':630,'multiline':False]['text':' BID_UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits','line_number':635,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':639,'multiline':False]['text':' check for NaNs and infinities','line_number':641,'multiline':False]['text':' check for NaN','line_number':642,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':644,'multiline':False]['text':' clear G6-G12 ','line_number':646,'multiline':False]['text':' SNaN ','line_number':647,'multiline':False]['text':' set invalid flag ','line_number':648,'multiline':False]['text':' return quiet (SNaN) ','line_number':650,'multiline':False]['text':' QNaN','line_number':652,'multiline':False]['text':' check for Infinity','line_number':656,'multiline':False]['text':' unpack x','line_number':660,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then','line_number':662,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':663,'multiline':False]['text':' non-canonical','line_number':666,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':669,'multiline':False]['text':' if x is 0 or non-canonical','line_number':674,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':681,'multiline':False]['text':' return 0 if (exp <= -p)','line_number':683,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':692,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':693,'multiline':False]['text':' x >= 2^53','line_number':694,'multiline':False]['text':' if x < 2^53','line_number':696,'multiline':False]['text':' exact conversion','line_number':697,'multiline':False]['text':' -exp <= 0','line_number':708,'multiline':False]['text':' the argument is an integer already','line_number':709,'multiline':False]['text':' exp < 0 and 1 <= -exp < q','line_number':712,'multiline':False]['text':' need to shift right -exp digits from the coefficient; the exp will be 0','line_number':713,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':714,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':715,'multiline':False]['text':' C1 fits in 64 bits','line_number':716,'multiline':False]['text':' calculate C* and f*','line_number':717,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':718,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':719,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':720,'multiline':False]['text':' 1 <= x <= 16','line_number':721,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':722,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':723,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':724,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':727,'multiline':False]['text':'       correct by Property 1)','line_number':728,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':729,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':730,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':732,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':736,'multiline':False]['text':' 3 <= shift <= 63','line_number':737,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':742,'multiline':False]['text':' if negative and not exact, increment magnitude','line_number':745,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':748,'multiline':False]['text':' if exp < 0 and q + exp <= 0','line_number':751,'multiline':False]['text':' the result is +0 or -1','line_number':752,'multiline':False]['text':'****************************************************************************
 *  BID64_round_integral_positive
 ***************************************************************************','line_number':762,'multiline':True]['text':' unbiased exponent','line_number':770,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':771,'multiline':False]['text':' BID_UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits','line_number':776,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':780,'multiline':False]['text':' check for NaNs and infinities','line_number':782,'multiline':False]['text':' check for NaN','line_number':783,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':785,'multiline':False]['text':' clear G6-G12 ','line_number':787,'multiline':False]['text':' SNaN ','line_number':788,'multiline':False]['text':' set invalid flag ','line_number':789,'multiline':False]['text':' return quiet (SNaN) ','line_number':791,'multiline':False]['text':' QNaN','line_number':793,'multiline':False]['text':' check for Infinity','line_number':797,'multiline':False]['text':' unpack x','line_number':801,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then','line_number':803,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':804,'multiline':False]['text':' non-canonical','line_number':807,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':810,'multiline':False]['text':' if x is 0 or non-canonical','line_number':815,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':822,'multiline':False]['text':' return 0 if (exp <= -p)','line_number':824,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':833,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':834,'multiline':False]['text':' x >= 2^53','line_number':835,'multiline':False]['text':' if x < 2^53','line_number':837,'multiline':False]['text':' exact conversion','line_number':838,'multiline':False]['text':' -exp <= 0','line_number':849,'multiline':False]['text':' the argument is an integer already','line_number':850,'multiline':False]['text':' exp < 0 and 1 <= -exp < q','line_number':853,'multiline':False]['text':' need to shift right -exp digits from the coefficient; the exp will be 0','line_number':854,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':855,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':856,'multiline':False]['text':' C1 fits in 64 bits','line_number':857,'multiline':False]['text':' calculate C* and f*','line_number':858,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':859,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':860,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':861,'multiline':False]['text':' 1 <= x <= 16','line_number':862,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':863,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':864,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':865,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':868,'multiline':False]['text':'       correct by Property 1)','line_number':869,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':870,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':871,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':873,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':877,'multiline':False]['text':' 3 <= shift <= 63','line_number':878,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':883,'multiline':False]['text':' if positive and not exact, increment magnitude','line_number':886,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':889,'multiline':False]['text':' if exp < 0 and q + exp <= 0','line_number':892,'multiline':False]['text':' the result is -0 or +1','line_number':893,'multiline':False]['text':'****************************************************************************
 *  BID64_round_integral_zero
 ***************************************************************************','line_number':903,'multiline':True]['text':' unbiased exponent','line_number':911,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':912,'multiline':False]['text':' BID_UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits','line_number':917,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':920,'multiline':False]['text':' check for NaNs and infinities','line_number':922,'multiline':False]['text':' check for NaN','line_number':923,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':925,'multiline':False]['text':' clear G6-G12 ','line_number':927,'multiline':False]['text':' SNaN ','line_number':928,'multiline':False]['text':' set invalid flag ','line_number':929,'multiline':False]['text':' return quiet (SNaN) ','line_number':931,'multiline':False]['text':' QNaN','line_number':933,'multiline':False]['text':' check for Infinity','line_number':937,'multiline':False]['text':' unpack x','line_number':941,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then','line_number':943,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':944,'multiline':False]['text':' non-canonical','line_number':947,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':950,'multiline':False]['text':' if x is 0 or non-canonical','line_number':955,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':962,'multiline':False]['text':' return 0 if (exp <= -p)','line_number':964,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':969,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':970,'multiline':False]['text':' x >= 2^53','line_number':971,'multiline':False]['text':' if x < 2^53','line_number':973,'multiline':False]['text':' exact conversion','line_number':974,'multiline':False]['text':' -exp <= 0','line_number':985,'multiline':False]['text':' the argument is an integer already','line_number':986,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':989,'multiline':False]['text':' need to shift right -exp digits from the coefficient; the exp will be 0','line_number':990,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':991,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':992,'multiline':False]['text':' C1 fits in 127 bits','line_number':993,'multiline':False]['text':' calculate C* and f*','line_number':994,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':995,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':996,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':997,'multiline':False]['text':' 1 <= x <= 16','line_number':998,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':999,'multiline':False]['text':' C* = C1 * 10^(-x)','line_number':1000,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':1001,'multiline':False]['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':1004,'multiline':False]['text':'       correct by Property 1)','line_number':1005,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is exact','line_number':1006,'multiline':False]['text':' n = C* * 10^(e+x)  ','line_number':1007,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':1009,'multiline':False]['text':' redundant fstar.w[1] = 0;','line_number':1011,'multiline':False]['text':' redundant fstar.w[0] = P128.w[0];','line_number':1012,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':1013,'multiline':False]['text':' 3 <= shift <= 63','line_number':1014,'multiline':False]['text':' redundant fstar.w[1] = P128.w[1] & bid_maskhigh128[ind - 1];','line_number':1016,'multiline':False]['text':' redundant fstar.w[0] = P128.w[0];','line_number':1017,'multiline':False]['text':' if (f* > 10^(-x)) then the result is inexact','line_number':1019,'multiline':False]['text':' if ((fstar.w[1] != 0) || (fstar.w[0] >= bid_ten2mk64[ind-1])){','line_number':1020,'multiline':False]['text':'   // redundant','line_number':1021,'multiline':False]['text':' }','line_number':1022,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':1023,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':1026,'multiline':False]['text':' the result is +0 or -0','line_number':1027,'multiline':False]['text':'****************************************************************************
 *  BID64_round_integral_nearest_away
 ***************************************************************************','line_number':1033,'multiline':True]['text':' unbiased exponent','line_number':1041,'multiline':False]['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':1042,'multiline':False]['text':' 0 for positive, MASK_SIGN for negative','line_number':1049,'multiline':False]['text':' check for NaNs and infinities','line_number':1051,'multiline':False]['text':' check for NaN','line_number':1052,'multiline':False]['text':' clear G6-G12 and the payload bits','line_number':1054,'multiline':False]['text':' clear G6-G12 ','line_number':1056,'multiline':False]['text':' SNaN ','line_number':1057,'multiline':False]['text':' set invalid flag ','line_number':1058,'multiline':False]['text':' return quiet (SNaN) ','line_number':1060,'multiline':False]['text':' QNaN','line_number':1062,'multiline':False]['text':' check for Infinity','line_number':1066,'multiline':False]['text':' unpack x','line_number':1070,'multiline':False]['text':' if the steering bits are 11 (condition will be 0), then','line_number':1072,'multiline':False]['text':' the exponent is G[0:w+1]','line_number':1073,'multiline':False]['text':' non-canonical','line_number':1076,'multiline':False]['text':' if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)','line_number':1079,'multiline':False]['text':' if x is 0 or non-canonical','line_number':1084,'multiline':False]['text':' x is a finite non-zero number (not 0, non-canonical, or special)','line_number':1091,'multiline':False]['text':' return 0 if (exp <= -(p+1))','line_number':1093,'multiline':False]['text':' q = nr. of decimal digits in x (1 <= q <= 54)','line_number':1098,'multiline':False]['text':'  determine first the nr. of bits in x','line_number':1099,'multiline':False]['text':' x >= 2^53','line_number':1100,'multiline':False]['text':' if x < 2^53','line_number':1102,'multiline':False]['text':' exact conversion','line_number':1103,'multiline':False]['text':' -exp <= 0','line_number':1114,'multiline':False]['text':' the argument is an integer already','line_number':1115,'multiline':False]['text':' exp < 0 and 1 <= -exp <= q','line_number':1118,'multiline':False]['text':' need to shift right -exp digits from the coefficient; the exp will be 0','line_number':1119,'multiline':False]['text':' 1 <= ind <= 16; ind is a synonym for 'x'','line_number':1120,'multiline':False]['text':' chop off ind digits from the lower part of C1 ','line_number':1121,'multiline':False]['text':' C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits','line_number':1122,'multiline':False]['text':' FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate','line_number':1123,'multiline':False]['text':' calculate C* and f*','line_number':1125,'multiline':False]['text':' C* is actually floor(C*) in this case','line_number':1126,'multiline':False]['text':' C* and f* need shifting and masking, as shown by','line_number':1127,'multiline':False]['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':1128,'multiline':False]['text':' 1 <= x <= 16','line_number':1129,'multiline':False]['text':' kx = 10^(-x) = bid_ten2mk64[ind - 1]','line_number':1130,'multiline':False]['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':1131,'multiline':False]['text':' the approximation of 10^(-x) was rounded up to 64 bits','line_number':1132,'multiline':False]['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':1135,'multiline':False]['text':'   C* = floor(C*) - logical right shift; C* has p decimal digits, ','line_number':1136,'multiline':False]['text':'       correct by Prop. 1)','line_number':1137,'multiline':False]['text':' else','line_number':1138,'multiline':False]['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':1139,'multiline':False]['text':'       correct by Property 1)','line_number':1140,'multiline':False]['text':' n = C* * 10^(e+x)','line_number':1141,'multiline':False]['text':' 0 <= ind - 1 <= 2 => shift = 0','line_number':1143,'multiline':False]['text':' 3 <= ind - 1 <= 21 => 3 <= shift <= 63','line_number':1145,'multiline':False]['text':' 3 <= shift <= 63','line_number':1146,'multiline':False]['text':' midpoints are already rounded correctly','line_number':1149,'multiline':False]['text':' set exponent to zero as it was negative before.','line_number':1150,'multiline':False]['text':' if exp < 0 and q + exp < 0','line_number':1153,'multiline':False]['text':' the result is +0 or -0','line_number':1154,'multiline':False]