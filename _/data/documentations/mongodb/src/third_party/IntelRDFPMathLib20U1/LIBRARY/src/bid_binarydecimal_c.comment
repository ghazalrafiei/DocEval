['text':'*****************************************************************************
  Copyright (c) 2007-2011, Intel Corp.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************','line_number':1,'multiline':True]['text':' Counting leading zeros in an unsigned 32-bit word','line_number':34,'multiline':False]['text':' The "_nz" version will return the wrong answer (31) for zero inputs','line_number':35,'multiline':False]['text':' Counting trailing zeros in an unsigned 32-bit word','line_number':52,'multiline':False]['text':' The ctz32_1bit version is for a single bit','line_number':53,'multiline':False]['text':' Counting leading zeros in an unsigned 64-bit word','line_number':64,'multiline':False]['text':' The "_nz" version will return the wrong answer (63) for zero inputs','line_number':65,'multiline':False]['text':' Counting trailing zeros in an unsigned 64-bit word','line_number':84,'multiline':False]['text':' The ctz64_1bit version is for a single bit','line_number':85,'multiline':False]['text':' Counting leading zeros in an unsigned 2-part 128-bit word','line_number':97,'multiline':False]['text':' Counting trailing zeros in a 2-part 128-bit word','line_number':103,'multiline':False]['text':' Shift 2-part 2^64 * hi + lo left by "c" bits','line_number':107,'multiline':False]['text':' The "short" form requires a shift 0 < c < 64 and will be faster','line_number':108,'multiline':False]['text':' Note that shifts of 64 can't be relied on as ANSI','line_number':109,'multiline':False]['text':' Shift 2-part 2^64 * hi + lo right by "c" bits','line_number':120,'multiline':False]['text':' The "short" form requires a shift 0 < c < 64 and will be faster','line_number':121,'multiline':False]['text':' Note that shifts of 64 can't be relied on as ANSI','line_number':122,'multiline':False]['text':' Shift 4-part 2^196 * x3 + 2^128 * x2 + 2^64 * x1 + x0','line_number':133,'multiline':False]['text':' right by "c" bits (must have c < 64)','line_number':134,'multiline':False]['text':' Similarly for 6-part result','line_number':143,'multiline':False]['text':' Compare "<" two 2-part unsigned integers','line_number':154,'multiline':False]['text':' Likewise "<="','line_number':159,'multiline':False]['text':' 128x256->384 bit multiplication (missing from existing macros)','line_number':164,'multiline':False]['text':' I derived this by propagating (A).w[2] = 0 in __mul_192x256_to_448','line_number':165,'multiline':False]['text':' Multiply a 64-bit number by 10, getting "carry" and "sum"','line_number':181,'multiline':False]['text':' Multiply a 256-bit number by 10, assuming no overflow','line_number':191,'multiline':False]['text':' Likewise a 384-bit number','line_number':201,'multiline':False]['text':' Set up indices for low and high parts, depending on the endian-ness.','line_number':213,'multiline':False]['text':' Note that this only affects 128-bit input and output operands, not any','line_number':214,'multiline':False]['text':' of the internal workings, where w[0] is always the low-order part.','line_number':215,'multiline':False]['text':' Pack and return binary floating-point numbers from raw fields','line_number':247,'multiline':False]['text':' Special cases of returning zero, infinity, NaN as binary FP','line_number':337,'multiline':False]['text':' Take parameters for the sign, and for NaN the significand','line_number':338,'multiline':False]['text':' Return finite values of maximal magnitude in the various formats','line_number':360,'multiline':False]['text':' Handle overflow by either infinity or maximal value as appropriate','line_number':373,'multiline':False]['text':' Unpack binary floating-point number x into','line_number':424,'multiline':False]['text':'','line_number':425,'multiline':False]['text':' int    s (sign in the LSB)','line_number':426,'multiline':False]['text':' int    e (true "integer" exponent)','line_number':427,'multiline':False]['text':'        c (normalized coefficient with explicit 1 bit)','line_number':428,'multiline':False]['text':'        t (trailing zero count, valid in normalized case only)','line_number':429,'multiline':False]['text':'        [c_hi,c_lo in the case of quad]','line_number':430,'multiline':False]['text':'','line_number':431,'multiline':False]['text':' Call the given zero, infinity or nan macros if appropriate','line_number':432,'multiline':False]['text':' Pack and return decimal number from raw fields','line_number':549,'multiline':False]['text':' Special cases of returning zero, infinity, NaN as decimal FP','line_number':607,'multiline':False]['text':' Take parameters for the sign, and for NaN the significand','line_number':608,'multiline':False]['text':' Unpack decimal floating-point number x into sign,exponent,coefficient','line_number':630,'multiline':False]['text':' In special cases, call the macros provided','line_number':631,'multiline':False]['text':' Coefficient is normalized in the binary sense with postcorrection k,','line_number':632,'multiline':False]['text':' so that x = 10^e * c / 2^k and the range of c is:','line_number':633,'multiline':False]['text':'','line_number':634,'multiline':False]['text':' 2^23 <= c < 2^24   (decimal32)','line_number':635,'multiline':False]['text':' 2^53 <= c < 2^54   (decimal64)','line_number':636,'multiline':False]['text':' 2^112 <= c < 2^113 (decimal128)','line_number':637,'multiline':False]['text':' Rounding boundaries table, indexed by','line_number':714,'multiline':False]['text':' 4 * rounding_mode + 2 * sign + lsb of truncation','line_number':715,'multiline':False]['text':' We round up if the round/sticky data is strictly > this boundary','line_number':716,'multiline':False]['text':'','line_number':717,'multiline':False]['text':' NB: This depends on the particular values of the rounding mode','line_number':718,'multiline':False]['text':' numbers, which are supposed to be defined as here:','line_number':719,'multiline':False]['text':'','line_number':720,'multiline':False]['text':' #define BID_ROUNDING_TO_NEAREST     0x00000','line_number':721,'multiline':False]['text':' #define BID_ROUNDING_DOWN           0x00001','line_number':722,'multiline':False]['text':' #define BID_ROUNDING_UP             0x00002','line_number':723,'multiline':False]['text':' #define BID_ROUNDING_TO_ZERO        0x00003','line_number':724,'multiline':False]['text':' #define BID_ROUNDING_TIES_AWAY      0x00004','line_number':725,'multiline':False]['text':'','line_number':726,'multiline':False]['text':' Some of the shortcuts below in "underflow after rounding" also use','line_number':727,'multiline':False]['text':' the concrete values.','line_number':728,'multiline':False]['text':'','line_number':729,'multiline':False]['text':' So we add a directive here to double-check that this is the case','line_number':730,'multiline':False]['text':' BID_ROUNDING_TO_NEAREST | positive | even','line_number':739,'multiline':False]['text':' BID_ROUNDING_TO_NEAREST | positive | odd','line_number':740,'multiline':False]['text':' BID_ROUNDING_TO_NEAREST | negative | even','line_number':741,'multiline':False]['text':' BID_ROUNDING_TO_NEAREST | negative | odd','line_number':742,'multiline':False]['text':' BID_ROUNDING_DOWN       | positive | even','line_number':744,'multiline':False]['text':' BID_ROUNDING_DOWN       | positive | odd','line_number':745,'multiline':False]['text':' BID_ROUNDING_DOWN       | negative | even','line_number':746,'multiline':False]['text':' BID_ROUNDING_DOWN       | negative | odd','line_number':747,'multiline':False]['text':' BID_ROUNDING_UP         | positive | even','line_number':749,'multiline':False]['text':' BID_ROUNDING_UP         | positive | odd','line_number':750,'multiline':False]['text':' BID_ROUNDING_UP         | negative | even','line_number':751,'multiline':False]['text':' BID_ROUNDING_UP         | negative | odd','line_number':752,'multiline':False]['text':' BID_ROUNDING_TO_ZERO    | positive | even','line_number':754,'multiline':False]['text':' BID_ROUNDING_TO_ZERO    | positive | odd','line_number':755,'multiline':False]['text':' BID_ROUNDING_TO_ZERO    | negative | even','line_number':756,'multiline':False]['text':' BID_ROUNDING_TO_ZERO    | negative | odd','line_number':757,'multiline':False]['text':' BID_ROUNDING_TIES_AWAY  | positive | even','line_number':759,'multiline':False]['text':' BID_ROUNDING_TIES_AWAY  | positive | odd','line_number':760,'multiline':False]['text':' BID_ROUNDING_TIES_AWAY  | negative | even','line_number':761,'multiline':False]['text':' BID_ROUNDING_TIES_AWAY  | negative | odd','line_number':762,'multiline':False]['text':' Table of powers of 5','line_number':765,'multiline':False]['text':' Tables of values for the various conversions:','line_number':819,'multiline':False]['text':'','line_number':820,'multiline':False]['text':' exponents: table of output exponents','line_number':821,'multiline':False]['text':' breakpoints: test values to decide between two possible exponents','line_number':822,'multiline':False]['text':' multipliers1/multipliers2: corresponding reciprocal multipliers','line_number':823,'multiline':False]['text':' coefflimits: used in exactness checks','line_number':824,'multiline':False]['text':'','line_number':825,'multiline':False]['text':' **********************************************************************','line_number':1478,'multiline':False]['text':' **********************************************************************','line_number':5389,'multiline':False]['text':' matches #if __ENABLE_BINARY80__','line_number':64808,'multiline':False]['text':' **********************************************************************','line_number':64810,'multiline':False]['text':' **********************************************************************','line_number':124317,'multiline':False]['text':' **********************************************************************','line_number':128028,'multiline':False]['text':' **********************************************************************','line_number':143304,'multiline':False]['text':' These are the different, bipartite, tables for conversion to bid128','line_number':143358,'multiline':False]['text':' Using the same approach, the tables become extremely large','line_number':143359,'multiline':False]['text':' And things are more amenable here since there's never overflow/underflow','line_number':143360,'multiline':False]['text':' **********************************************************************','line_number':143939,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-24=89','line_number':143973,'multiline':False]['text':' Thus a shift of 25 given that we've already upacked in c.w[1]','line_number':143974,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':143980,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':143981,'multiline':False]['text':'','line_number':143982,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':143983,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':143984,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':143985,'multiline':False]['text':'','line_number':143986,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':143987,'multiline':False]['text':' which in this case is e >= ceil(128 * log_10(2)) = 39','line_number':143988,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':143994,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':143995,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':143996,'multiline':False]['text':'','line_number':143997,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':143998,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':143999,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144004,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144009,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144018,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144023,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144024,'multiline':False]['text':' Round using round-sticky words','line_number':144035,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144036,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':144037,'multiline':False]['text':' Check for overflow','line_number':144050,'multiline':False]['text':' Modify exponent for a tiny result, otherwise lop the implicit bit','line_number':144056,'multiline':False]['text':' Set the inexact and underflow flag as appropriate (tiny after rounding)','line_number':144063,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144070,'multiline':False]['text':' **********************************************************************','line_number':144075,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-54=59','line_number':144108,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144113,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144114,'multiline':False]['text':'','line_number':144115,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144116,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144117,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144118,'multiline':False]['text':'','line_number':144119,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144120,'multiline':False]['text':' which in this case is e >= ceil(128 * log_10(2)) = 39','line_number':144121,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':144127,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':144128,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':144129,'multiline':False]['text':'','line_number':144130,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':144131,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':144132,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144137,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144142,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144151,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144154,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144155,'multiline':False]['text':' Round using round-sticky words','line_number':144166,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144167,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':144168,'multiline':False]['text':' Check for overflow','line_number':144188,'multiline':False]['text':' Modify exponent for a tiny result, otherwise lop the implicit bit','line_number':144194,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144201,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144208,'multiline':False]['text':' **********************************************************************','line_number':144213,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144245,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144246,'multiline':False]['text':'','line_number':144247,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144248,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144249,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144250,'multiline':False]['text':'','line_number':144251,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144252,'multiline':False]['text':' which in this case is e >= ceil(128 * log_10(2)) = 39','line_number':144253,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':144259,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':144260,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':144261,'multiline':False]['text':'','line_number':144262,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':144263,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':144264,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144269,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144274,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144283,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144286,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144287,'multiline':False]['text':' Round using round-sticky words','line_number':144298,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144299,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':144300,'multiline':False]['text':' Check for overflow','line_number':144320,'multiline':False]['text':' Modify exponent for a tiny result, otherwise lop the implicit bit','line_number':144326,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144333,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144340,'multiline':False]['text':' **********************************************************************','line_number':144345,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-24=89','line_number':144374,'multiline':False]['text':' In fact shift a further 6 places ready for reciprocal multiplication','line_number':144375,'multiline':False]['text':' Thus (113-24)+6=95, a shift of 31 given that we've already upacked in c.w[1]','line_number':144376,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144382,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144383,'multiline':False]['text':'','line_number':144384,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144385,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144386,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144387,'multiline':False]['text':'','line_number':144388,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144389,'multiline':False]['text':' which in this case is e >= ceil(1024 * log_10(2)) = ceil(308.25) = 309','line_number':144390,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144392,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144397,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144406,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144411,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144412,'multiline':False]['text':' Round using round-sticky words','line_number':144416,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144417,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144428,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144433,'multiline':False]['text':' **********************************************************************','line_number':144438,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-54=59','line_number':144467,'multiline':False]['text':' In fact shift a further 6 places ready for reciprocal multiplication','line_number':144468,'multiline':False]['text':' Thus (113-54)+6=65, a shift of 1 given that we've already upacked in c.w[1]','line_number':144469,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144475,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144476,'multiline':False]['text':'','line_number':144477,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144478,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144479,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144480,'multiline':False]['text':'','line_number':144481,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144482,'multiline':False]['text':' which in this case is 2 >= ceil(1024 * log_10(2)) = ceil(308.25) = 309','line_number':144483,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':144489,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':144490,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':144491,'multiline':False]['text':'','line_number':144492,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':144493,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':144494,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144499,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144504,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144513,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144518,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144519,'multiline':False]['text':' Round using round-sticky words','line_number':144530,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144531,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':144532,'multiline':False]['text':' Check for overflow','line_number':144552,'multiline':False]['text':' Modify exponent for a tiny result, otherwise lop the implicit bit','line_number':144558,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144565,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144572,'multiline':False]['text':' **********************************************************************','line_number':144577,'multiline':False]['text':' Shift 6 more places left ready for reciprocal multiplication','line_number':144606,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144610,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144611,'multiline':False]['text':'','line_number':144612,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144613,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144614,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144615,'multiline':False]['text':'','line_number':144616,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144617,'multiline':False]['text':' which in this case is 2 >= ceil(1024 * log_10(2)) = ceil(308.25) = 309','line_number':144618,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':144624,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':144625,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':144626,'multiline':False]['text':'','line_number':144627,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':144628,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':144629,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144634,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144639,'multiline':False]['text':' Do the reciprocal multiplication','line_number':144648,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144651,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144652,'multiline':False]['text':' Round using round-sticky words','line_number':144663,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144664,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':144665,'multiline':False]['text':' Check for overflow','line_number':144685,'multiline':False]['text':' Modify exponent for a tiny result, otherwise lop the implicit bit','line_number':144691,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144698,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144705,'multiline':False]['text':' **********************************************************************','line_number':144710,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-24=89','line_number':144743,'multiline':False]['text':' Given that we've unpacked in the high part (<<64), that's just <<25','line_number':144744,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144750,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144751,'multiline':False]['text':'','line_number':144752,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144753,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144754,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144755,'multiline':False]['text':'','line_number':144756,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144757,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':144758,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144760,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144765,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 303 bits','line_number':144775,'multiline':False]['text':' by shifting 47 places right and taking the result from word 4','line_number':144776,'multiline':False]['text':' Round using round-sticky words','line_number':144785,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144786,'multiline':False]['text':' Check for overflow','line_number':144795,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144797,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144802,'multiline':False]['text':' **********************************************************************','line_number':144807,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-54=59','line_number':144840,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144845,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144846,'multiline':False]['text':'','line_number':144847,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144848,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144849,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144850,'multiline':False]['text':'','line_number':144851,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144852,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':144853,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144855,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144860,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 303 bits','line_number':144870,'multiline':False]['text':' by shifting 47 places right and taking the result from word 4','line_number':144871,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144876,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144877,'multiline':False]['text':' Round using round-sticky words','line_number':144881,'multiline':False]['text':' If we spill into the next binade, correct','line_number':144882,'multiline':False]['text':' Check for overflow','line_number':144892,'multiline':False]['text':' Modify exponent for a tiny result','line_number':144894,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':144896,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':144901,'multiline':False]['text':' **********************************************************************','line_number':144906,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':144938,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':144939,'multiline':False]['text':'','line_number':144940,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':144941,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':144942,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':144943,'multiline':False]['text':'','line_number':144944,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':144945,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':144946,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':144952,'multiline':False]['text':' so test e <= floor((emin - 115) * log_10(2))','line_number':144953,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':144954,'multiline':False]['text':'','line_number':144955,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':144956,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':144957,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':144962,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':144967,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 303 bits','line_number':144977,'multiline':False]['text':' by shifting 47 places right and taking the result from word 4','line_number':144978,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':144983,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':144984,'multiline':False]['text':' Round using round-sticky words','line_number':145000,'multiline':False]['text':' If we spill into the next binade, correct','line_number':145001,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':145002,'multiline':False]['text':' Check for overflow','line_number':145022,'multiline':False]['text':' Modify exponent for a tiny result','line_number':145028,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':145033,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':145040,'multiline':False]['text':' matches #if __ENABLE_BINARY80__','line_number':145045,'multiline':False]['text':' **********************************************************************','line_number':145047,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-24=89','line_number':145079,'multiline':False]['text':' But also make an additional shift of 2 places to get a whole-word lop:','line_number':145080,'multiline':False]['text':' (c * r) >> 254 = ((c << 2) * r) >> 256. Given that we unpack in the high','line_number':145081,'multiline':False]['text':' end, our shift is (89+2)-64 = 27','line_number':145082,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':145088,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':145089,'multiline':False]['text':'','line_number':145090,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':145091,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':145092,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':145093,'multiline':False]['text':'','line_number':145094,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':145095,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':145096,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':145098,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':145103,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 254 bits','line_number':145112,'multiline':False]['text':' (given that we already shifted left 2 places) by lopping from word 4','line_number':145113,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':145118,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':145119,'multiline':False]['text':' Round using round-sticky words','line_number':145124,'multiline':False]['text':' If we spill into the next binade, correct','line_number':145125,'multiline':False]['text':' codecov:','line_number':145133,'multiline':False]['text':' The following "if" block seems to be redundant (hard to prove...).','line_number':145134,'multiline':False]['text':' Here we process any bid32 points x such that x is close to some binary128','line_number':145135,'multiline':False]['text':' value b with zero low part, so that x<b and x rounds to b:','line_number':145136,'multiline':False]['text':' Check for overflow','line_number':145141,'multiline':False]['text':' Modify exponent for a tiny result; otherwise lop off the implicit bit','line_number':145143,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':145147,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':145152,'multiline':False]['text':' **********************************************************************','line_number':145157,'multiline':False]['text':' Correct to 2^112 <= c < 2^113 with corresponding exponent adding 113-54=59','line_number':145190,'multiline':False]['text':' But also make an additional shift of 2 places to get a whole-word lop:','line_number':145191,'multiline':False]['text':' (c * r) >> 254 = ((c << 2) * r) >> 256','line_number':145192,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':145197,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':145198,'multiline':False]['text':'','line_number':145199,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':145200,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':145201,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':145202,'multiline':False]['text':'','line_number':145203,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':145204,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':145205,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':145207,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':145212,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 254 bits','line_number':145221,'multiline':False]['text':' (given that we already shifted left 2 places) by lopping from word 4','line_number':145222,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':145225,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':145226,'multiline':False]['text':' Round using round-sticky words','line_number':145231,'multiline':False]['text':' If we spill into the next binade, correct','line_number':145232,'multiline':False]['text':' codecov:','line_number':145240,'multiline':False]['text':' The following "if" block seems to be redundant (hard to prove...).','line_number':145241,'multiline':False]['text':' Here we process any bid64 points x such that x is close to some binary128','line_number':145242,'multiline':False]['text':' value b with zero low part, so that x<b and x rounds to b:','line_number':145243,'multiline':False]['text':' Check for overflow','line_number':145248,'multiline':False]['text':' Modify exponent for a tiny result; otherwise lop off the implicit bit','line_number':145250,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':145254,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':145259,'multiline':False]['text':' **********************************************************************','line_number':145264,'multiline':False]['text':' Unpack the input and shift two further places for reciprocal multiplication','line_number':145293,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':145299,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':145300,'multiline':False]['text':'','line_number':145301,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':145302,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':145303,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':145304,'multiline':False]['text':'','line_number':145305,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':145306,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':145307,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':145313,'multiline':False]['text':' so test e <= floor((emin - 114) * log_10(2))','line_number':145314,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':145315,'multiline':False]['text':'','line_number':145316,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':145317,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':145318,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':145323,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':145328,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 254 bits','line_number':145337,'multiline':False]['text':' (given that we already shifted left 2 places) by lopping from word 4','line_number':145338,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':145341,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':145342,'multiline':False]['text':' Round using round-sticky words','line_number':145358,'multiline':False]['text':' If we spill into the next binade, correct','line_number':145359,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':145360,'multiline':False]['text':' Check for overflow','line_number':145382,'multiline':False]['text':' Modify exponent for a tiny result; otherwise lop off the implicit bit','line_number':145388,'multiline':False]['text':' Set the inexact and underflow flag as appropriate','line_number':145395,'multiline':False]['text':' Package up the result as a binary floating-point number','line_number':145402,'multiline':False]['text':' **********************************************************************','line_number':145407,'multiline':False]['text':' Unpack the input','line_number':145436,'multiline':False]['text':' Now -172<=e<=104 (104 for max normal, -149 for min normal, -172 for min denormal)','line_number':145440,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-24} * c * r) >> 320,','line_number':145442,'multiline':False]['text':' where 320 is the truncation value for the reciprocal multiples, exactly','line_number':145443,'multiline':False]['text':' five 64-bit words. So we shift 113-24=89 places. Since we unpacked in','line_number':145444,'multiline':False]['text':' the high end, shift a further 89-64=25 places','line_number':145445,'multiline':False]['text':'','line_number':145446,'multiline':False]['text':' Remember to compensate for the fact that exponents are integer for quad','line_number':145447,'multiline':False]['text':' Now e belongs [-238..15]','line_number':145452,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':145454,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':145455,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':145456,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':145458,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':145459,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':145460,'multiline':False]['text':'','line_number':145461,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':145462,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':145463,'multiline':False]['text':' We write a = -(e + t)','line_number':145464,'multiline':False]['text':'','line_number':145465,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':145466,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':145467,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':145468,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':145469,'multiline':False]['text':'','line_number':145470,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':145471,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':145472,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':145473,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':145474,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':145475,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':145498,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':145499,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':145500,'multiline':False]['text':'','line_number':145501,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':145502,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':145503,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':145505,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':145510,'multiline':False]['text':' Do the reciprocal multiplication','line_number':145519,'multiline':False]['text':' Round using round-sticky words','line_number':145524,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':145525,'multiline':False]['text':' Check for overflow','line_number':145538,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':145540,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':145541,'multiline':False]['text':' Package up the result','line_number':145546,'multiline':False]['text':' **********************************************************************','line_number':145551,'multiline':False]['text':' Unpack the input','line_number':145580,'multiline':False]['text':' Now -1126<=e<=971 (971 for max normal, -1074 for min normal, -1126 for min denormal)','line_number':145584,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-53} * c * r) >> 320,','line_number':145586,'multiline':False]['text':' where 320 is the truncation value for the reciprocal multiples, exactly','line_number':145587,'multiline':False]['text':' five 64-bit words. So we shift 113-53=60 places','line_number':145588,'multiline':False]['text':'','line_number':145589,'multiline':False]['text':' Remember to compensate for the fact that exponents are integer for quad','line_number':145590,'multiline':False]['text':' Now e belongs [-1186;911].','line_number':145595,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':145597,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':145598,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':145599,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':145605,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':145606,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':145607,'multiline':False]['text':'','line_number':145608,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':145609,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':145610,'multiline':False]['text':' We write a = -(e + t)','line_number':145611,'multiline':False]['text':'','line_number':145612,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':145613,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':145614,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':145615,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':145616,'multiline':False]['text':'','line_number':145617,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':145618,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':145619,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':145620,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':145621,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':145622,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':145645,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':145646,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':145647,'multiline':False]['text':'','line_number':145648,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':145649,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':145650,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':145655,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':145660,'multiline':False]['text':' Do the reciprocal multiplication','line_number':145669,'multiline':False]['text':' Test inexactness and underflow (when testing tininess before rounding)','line_number':145674,'multiline':False]['text':' Round using round-sticky words','line_number':145684,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':145685,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':145686,'multiline':False]['text':' Check for overflow','line_number':145707,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':145714,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':145715,'multiline':False]['text':' Package up the result','line_number':145725,'multiline':False]['text':' **********************************************************************','line_number':145730,'multiline':False]['text':' Unpack the input','line_number':145762,'multiline':False]['text':' Now -16508<=e<=16320 (16320 for max normal, -16445 for min normal, -16508 for min denormal)','line_number':145766,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-64} * c * r) >> 320,','line_number':145768,'multiline':False]['text':' where 320 is the truncation value for the reciprocal multiples, exactly','line_number':145769,'multiline':False]['text':' five 64-bit words. So we shift 113-64=49 places','line_number':145770,'multiline':False]['text':'','line_number':145771,'multiline':False]['text':' Remember to compensate for the fact that exponents are integer for quad','line_number':145772,'multiline':False]['text':' Now e belongs [-16557;16271].','line_number':145777,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':145779,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':145780,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':145781,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':145787,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':145788,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':145789,'multiline':False]['text':'','line_number':145790,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':145791,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':145792,'multiline':False]['text':' We write a = -(e + t)','line_number':145793,'multiline':False]['text':'','line_number':145794,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':145795,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':145796,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':145797,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':145798,'multiline':False]['text':'','line_number':145799,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':145800,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':145801,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':145802,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':145803,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':145804,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':145827,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':145828,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':145829,'multiline':False]['text':'','line_number':145830,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':145831,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':145832,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':145837,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':145842,'multiline':False]['text':' Do the reciprocal multiplication','line_number':145851,'multiline':False]['text':' Test inexactness and underflow (when testing tininess before rounding)','line_number':145856,'multiline':False]['text':' Round using round-sticky words','line_number':145866,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':145867,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':145868,'multiline':False]['text':' Check for overflow','line_number':145890,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':145897,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':145898,'multiline':False]['text':' Package up the result','line_number':145908,'multiline':False]['text':' matches #if __ENABLE_BINARY80__','line_number':145913,'multiline':False]['text':' **********************************************************************','line_number':145915,'multiline':False]['text':' Unpack the input','line_number':145945,'multiline':False]['text':' Now -16606<=e<=16271 (16271 for max normal, -16494 for min normal, -16606 for min denormal)','line_number':145949,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':145951,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':145952,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':145953,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':145959,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':145960,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':145961,'multiline':False]['text':'','line_number':145962,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':145963,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':145964,'multiline':False]['text':' We write a = -(e + t)','line_number':145965,'multiline':False]['text':'','line_number':145966,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':145967,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':145968,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':145969,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':145970,'multiline':False]['text':'','line_number':145971,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':145972,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':145973,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':145974,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':145975,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':145976,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':145999,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':146000,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':146001,'multiline':False]['text':'','line_number':146002,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':146003,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':146004,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':146009,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':146014,'multiline':False]['text':' Do the reciprocal multiplication','line_number':146023,'multiline':False]['text':' Test inexactness and underflow (when testing tininess before rounding)','line_number':146028,'multiline':False]['text':' Round using round-sticky words','line_number':146038,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146039,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':146040,'multiline':False]['text':' This needs to be done in extra precision because of the precision disparity','line_number':146041,'multiline':False]['text':' and the fact that the breakpoint isn't an exact binary number.','line_number':146042,'multiline':False]['text':' Check for overflow','line_number':146067,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':146074,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':146075,'multiline':False]['text':' Package up the result','line_number':146085,'multiline':False]['text':' **********************************************************************','line_number':146090,'multiline':False]['text':' Unpack the input','line_number':146120,'multiline':False]['text':' Now -172<=e<=104 (104 for max normal, -149 for min normal, -172 for min denormal)','line_number':146124,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-24} * c * r) >> 312','line_number':146126,'multiline':False]['text':' (312 is the shift value for these tables) which can be written as','line_number':146127,'multiline':False]['text':' (2^97 c * r) >> 320, lopping off exactly 320 bits = 5 words. Thus we put','line_number':146128,'multiline':False]['text':' input coefficient as the high part of c (<<64) shifted by 33 bits (<<97)','line_number':146129,'multiline':False]['text':'','line_number':146130,'multiline':False]['text':' Remember to compensate for the fact that exponents are integer for quad','line_number':146131,'multiline':False]['text':' Now e belongs [-238..15]','line_number':146136,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':146138,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':146139,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':146140,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146142,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146143,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146144,'multiline':False]['text':'','line_number':146145,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146146,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146147,'multiline':False]['text':' We write a = -(e + t)','line_number':146148,'multiline':False]['text':'','line_number':146149,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146150,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146151,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146152,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146153,'multiline':False]['text':'','line_number':146154,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146155,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146156,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146157,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146158,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146159,'multiline':False]['text':'','line_number':146160,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146161,'multiline':False]['text':' c is already 8 places to the left in preparation for the reciprocal','line_number':146162,'multiline':False]['text':' multiplication; thus we add 8 to all the shift counts','line_number':146163,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':146186,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':146187,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':146188,'multiline':False]['text':'','line_number':146189,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':146190,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':146191,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':146193,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':146198,'multiline':False]['text':' Do the reciprocal multiplication','line_number':146207,'multiline':False]['text':' Round using round-sticky words','line_number':146212,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146213,'multiline':False]['text':' Check for overflow','line_number':146226,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':146228,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':146229,'multiline':False]['text':' Package up the result','line_number':146234,'multiline':False]['text':' **********************************************************************','line_number':146239,'multiline':False]['text':' Unpack the input','line_number':146269,'multiline':False]['text':' Now -1126<=e<=971 (971 for max normal, -1074 for min normal, -1126 for min denormal)','line_number':146273,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-53} * c * r) >> 312','line_number':146275,'multiline':False]['text':' (312 is the shift value for these tables) which can be written as','line_number':146276,'multiline':False]['text':' (2^68 c * r) >> 320, lopping off exactly 320 bits = 5 words. Thus we put','line_number':146277,'multiline':False]['text':' input coefficient as the high part of c (<<64) shifted by 4 bits (<<68)','line_number':146278,'multiline':False]['text':'','line_number':146279,'multiline':False]['text':' Remember to compensate for the fact that exponents are integer for quad','line_number':146280,'multiline':False]['text':' Now e belongs [-1186;911].','line_number':146285,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':146287,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':146288,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':146289,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146291,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146292,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146293,'multiline':False]['text':'','line_number':146294,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146295,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146296,'multiline':False]['text':' We write a = -(e + t)','line_number':146297,'multiline':False]['text':'','line_number':146298,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146299,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146300,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146301,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146302,'multiline':False]['text':'','line_number':146303,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146304,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146305,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146306,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146307,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146308,'multiline':False]['text':'','line_number':146309,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146310,'multiline':False]['text':' c is already 8 places to the left in preparation for the reciprocal','line_number':146311,'multiline':False]['text':' multiplication; thus we add 8 to all the shift counts','line_number':146312,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':146335,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':146336,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':146337,'multiline':False]['text':'','line_number':146338,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':146339,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':146340,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':146342,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':146347,'multiline':False]['text':' Do the reciprocal multiplication','line_number':146356,'multiline':False]['text':' Round using round-sticky words','line_number':146361,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146362,'multiline':False]['text':' Check for overflow','line_number':146375,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':146377,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':146378,'multiline':False]['text':' Package up the result','line_number':146383,'multiline':False]['text':' **********************************************************************','line_number':146388,'multiline':False]['text':' Unpack the input','line_number':146420,'multiline':False]['text':' Now -16508<=e<=16320 (16320 for max normal, -16445 for min normal, -16508 for min denormal)','line_number':146424,'multiline':False]['text':' Treat like a quad input for uniformity, so (2^{113-64} * c * r) >> 312','line_number':146426,'multiline':False]['text':' (312 is the shift value for these tables) which can be written as','line_number':146427,'multiline':False]['text':' (2^57 c * r) >> 320, lopping off exactly 320 bits = 5 words. Thus we put the','line_number':146428,'multiline':False]['text':' input in the high part then shift right 7 places','line_number':146429,'multiline':False]['text':' Now e belongs [-16557;16271].','line_number':146434,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':146436,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':146437,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':146438,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146444,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146445,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146446,'multiline':False]['text':'','line_number':146447,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146448,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146449,'multiline':False]['text':' We write a = -(e + t)','line_number':146450,'multiline':False]['text':'','line_number':146451,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146452,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146453,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146454,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146455,'multiline':False]['text':'','line_number':146456,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146457,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146458,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146459,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146460,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146461,'multiline':False]['text':'','line_number':146462,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146463,'multiline':False]['text':' c is already 8 places to the left in preparation for the reciprocal','line_number':146464,'multiline':False]['text':' multiplication; thus we add 8 to all the shift counts','line_number':146465,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':146488,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':146489,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':146490,'multiline':False]['text':'','line_number':146491,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':146492,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':146493,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':146498,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':146503,'multiline':False]['text':' Do the reciprocal multiplication','line_number':146512,'multiline':False]['text':' Test inexactness and underflow (when testing tininess before rounding)','line_number':146517,'multiline':False]['text':' Round using round-sticky words','line_number':146527,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146528,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':146529,'multiline':False]['text':' Check for overflow','line_number':146550,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':146556,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':146557,'multiline':False]['text':' Package up the result','line_number':146567,'multiline':False]['text':' matches #if __ENABLE_BINARY80__','line_number':146572,'multiline':False]['text':' **********************************************************************','line_number':146574,'multiline':False]['text':' Unpack the input','line_number':146604,'multiline':False]['text':' Now -16606<=e<=16271 (16271 for max normal, -16494 for min normal, -16606 for min denormal)','line_number':146608,'multiline':False]['text':' Shift left 8 spaces so (c * r) >> 312 = ((c<<8) * r) >> 320 and we','line_number':146610,'multiline':False]['text':' can lop off exactly 5 words','line_number':146611,'multiline':False]['text':' Check for "trivial" overflow, when 2^e * 2^112 > 10^emax * 10^d.','line_number':146615,'multiline':False]['text':' We actually check if e >= ceil((emax + d) * log_2(10) - 112)','line_number':146616,'multiline':False]['text':' This could be intercepted later, but it's convenient to keep tables smaller','line_number':146617,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146623,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146624,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146625,'multiline':False]['text':'','line_number':146626,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146627,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146628,'multiline':False]['text':' We write a = -(e + t)','line_number':146629,'multiline':False]['text':'','line_number':146630,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146631,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146632,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146633,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146634,'multiline':False]['text':'','line_number':146635,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146636,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146637,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146638,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146639,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146640,'multiline':False]['text':'','line_number':146641,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146642,'multiline':False]['text':' c is already 8 places to the left in preparation for the reciprocal','line_number':146643,'multiline':False]['text':' multiplication; thus we add 8 to all the shift counts','line_number':146644,'multiline':False]['text':' Check for "trivial" underflow, when 2^e * 2^113 <= 10^emin * 1/4,','line_number':146667,'multiline':False]['text':' so test e <= floor(emin * log_2(10) - 115)','line_number':146668,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':146669,'multiline':False]['text':'','line_number':146670,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':146671,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':146672,'multiline':False]['text':' Now look up our exponent e, and the breakpoint between e and e+1','line_number':146677,'multiline':False]['text':' Choose exponent and reciprocal multiplier based on breakpoint','line_number':146682,'multiline':False]['text':' Do the reciprocal multiplication','line_number':146691,'multiline':False]['text':' Test inexactness and underflow (when testing tininess before rounding)','line_number':146696,'multiline':False]['text':' Round using round-sticky words','line_number':146706,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146707,'multiline':False]['text':' Flag underflow where it may be needed even for |result| = SNN','line_number':146708,'multiline':False]['text':' Check for overflow','line_number':146729,'multiline':False]['text':' Set the inexact flag as appropriate and check underflow','line_number':146736,'multiline':False]['text':' It's no doubt superfluous to check inexactness, but anyway...','line_number':146737,'multiline':False]['text':' Package up the result','line_number':146747,'multiline':False]['text':' **********************************************************************','line_number':146752,'multiline':False]['text':' Unpack the input','line_number':146781,'multiline':False]['text':' Now -172<=e<=104 (104 for max normal, -149 for min normal, -172 for min denormal)','line_number':146785,'multiline':False]['text':' Shift up to the top: like a pure quad coefficient with a shift of 15.','line_number':146787,'multiline':False]['text':' In our case, this is 2^{113-24+15} times the core, so unpack at the','line_number':146788,'multiline':False]['text':' high end shifted by 40.','line_number':146789,'multiline':False]['text':' Now e belongs [-238..15]','line_number':146795,'multiline':False]['text':' (We never need to check for overflow: this format is the biggest of all!)','line_number':146797,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146799,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146800,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146801,'multiline':False]['text':'','line_number':146802,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146803,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146804,'multiline':False]['text':' We write a = -(e + t)','line_number':146805,'multiline':False]['text':'','line_number':146806,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146807,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146808,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146809,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146810,'multiline':False]['text':'','line_number':146811,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146812,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146813,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146814,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146815,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146816,'multiline':False]['text':'','line_number':146817,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146818,'multiline':False]['text':' c is already 15 places to the left in preparation for the reciprocal','line_number':146819,'multiline':False]['text':' multiplication; thus we add 15 to all the shift counts','line_number':146820,'multiline':False]['text':' Input exponent can stretch between the maximal and minimal','line_number':146844,'multiline':False]['text':' exponents (remembering we force normalization): -16607 <= e <= 16271','line_number':146845,'multiline':False]['text':' Compute the estimated decimal exponent e_out; the provisional exponent','line_number':146847,'multiline':False]['text':' will be either "e_out" or "e_out-1" depending on later significand check','line_number':146848,'multiline':False]['text':' NB: this is the *biased* exponent','line_number':146849,'multiline':False]['text':' Set up pointers into the bipartite table','line_number':146854,'multiline':False]['text':' Look up the inner entry first','line_number':146860,'multiline':False]['text':' If we need the other entry, multiply significands and add exponents','line_number':146864,'multiline':False]['text':' Make adjustive shift, ignoring the lower 128 bits','line_number':146877,'multiline':False]['text':' Now test against 10^33 and so decide on adjustment','line_number':146882,'multiline':False]['text':' I feel there ought to be a smarter way of doing the multiplication','line_number':146883,'multiline':False]['text':' Set up provisional results','line_number':146890,'multiline':False]['text':' Round using round-sticky words','line_number':146895,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':146896,'multiline':False]['text':' Don't need to check overflow or underflow; however set inexact flag','line_number':146913,'multiline':False]['text':' Package up the result','line_number':146918,'multiline':False]['text':' **********************************************************************','line_number':146923,'multiline':False]['text':' Unpack the input','line_number':146952,'multiline':False]['text':' Now -1126<=e<=971 (971 for max normal, -1074 for min normal, -1126 for min denormal)','line_number':146956,'multiline':False]['text':' Shift up to the top: like a pure quad coefficient with a shift of 15.','line_number':146958,'multiline':False]['text':' In our case, this is 2^{113-53+15} times the core, so unpack at the','line_number':146959,'multiline':False]['text':' high end shifted by 11.','line_number':146960,'multiline':False]['text':' Now e belongs [-1186;911].','line_number':146966,'multiline':False]['text':' (We never need to check for overflow: this format is the biggest of all!)','line_number':146968,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':146970,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':146971,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':146972,'multiline':False]['text':'','line_number':146973,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':146974,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':146975,'multiline':False]['text':' We write a = -(e + t)','line_number':146976,'multiline':False]['text':'','line_number':146977,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':146978,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':146979,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':146980,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':146981,'multiline':False]['text':'','line_number':146982,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':146983,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':146984,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':146985,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':146986,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':146987,'multiline':False]['text':'','line_number':146988,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':146989,'multiline':False]['text':' c is already 15 places to the left in preparation for the reciprocal','line_number':146990,'multiline':False]['text':' multiplication; thus we add 15 to all the shift counts','line_number':146991,'multiline':False]['text':' Input exponent can stretch between the maximal and minimal','line_number':147015,'multiline':False]['text':' exponents (remembering we force normalization): -16607 <= e <= 16271','line_number':147016,'multiline':False]['text':' Compute the estimated decimal exponent e_out; the provisional exponent','line_number':147018,'multiline':False]['text':' will be either "e_out" or "e_out-1" depending on later significand check','line_number':147019,'multiline':False]['text':' NB: this is the *biased* exponent','line_number':147020,'multiline':False]['text':' Set up pointers into the bipartite table','line_number':147025,'multiline':False]['text':' Look up the inner entry first','line_number':147031,'multiline':False]['text':' If we need the other entry, multiply significands and add exponents','line_number':147035,'multiline':False]['text':' Make adjustive shift, ignoring the lower 128 bits','line_number':147048,'multiline':False]['text':' Now test against 10^33 and so decide on adjustment','line_number':147053,'multiline':False]['text':' I feel there ought to be a smarter way of doing the multiplication','line_number':147054,'multiline':False]['text':' Set up provisional results','line_number':147061,'multiline':False]['text':' Round using round-sticky words','line_number':147066,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':147067,'multiline':False]['text':' Don't need to check overflow or underflow; however set inexact flag','line_number':147084,'multiline':False]['text':' Package up the result','line_number':147089,'multiline':False]['text':' **********************************************************************','line_number':147094,'multiline':False]['text':' Unpack the input','line_number':147125,'multiline':False]['text':' Now -16508<=e<=16320 (16320 for max normal, -16445 for min normal, -16508 for min denormal)','line_number':147128,'multiline':False]['text':' Treat like a pure quad coefficient with a shift of 15. We get this','line_number':147130,'multiline':False]['text':' just by unpacking at the high end','line_number':147131,'multiline':False]['text':' Now e belongs [-16557;16271].','line_number':147136,'multiline':False]['text':' (We never need to check for overflow: this format is the biggest of all!)','line_number':147138,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':147140,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':147141,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':147142,'multiline':False]['text':'','line_number':147143,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':147144,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':147145,'multiline':False]['text':' We write a = -(e + t)','line_number':147146,'multiline':False]['text':'','line_number':147147,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':147148,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':147149,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':147150,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':147151,'multiline':False]['text':'','line_number':147152,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':147153,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':147154,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':147155,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':147156,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':147157,'multiline':False]['text':'','line_number':147158,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':147159,'multiline':False]['text':' c is already 15 places to the left in preparation for the reciprocal','line_number':147160,'multiline':False]['text':' multiplication; thus we add 15 to all the shift counts','line_number':147161,'multiline':False]['text':' Input exponent can stretch between the maximal and minimal','line_number':147185,'multiline':False]['text':' exponents (remembering we force normalization): -16607 <= e <= 16271','line_number':147186,'multiline':False]['text':' Compute the estimated decimal exponent e_out; the provisional exponent','line_number':147188,'multiline':False]['text':' will be either "e_out" or "e_out-1" depending on later significand check','line_number':147189,'multiline':False]['text':' NB: this is the *biased* exponent','line_number':147190,'multiline':False]['text':' Set up pointers into the bipartite table','line_number':147195,'multiline':False]['text':' Look up the inner entry first','line_number':147201,'multiline':False]['text':' If we need the other entry, multiply significands and add exponents','line_number':147205,'multiline':False]['text':' Make adjustive shift, ignoring the lower 128 bits','line_number':147218,'multiline':False]['text':' Now test against 10^33 and so decide on adjustment','line_number':147223,'multiline':False]['text':' I feel there ought to be a smarter way of doing the multiplication','line_number':147224,'multiline':False]['text':' Set up provisional results','line_number':147231,'multiline':False]['text':' Round using round-sticky words','line_number':147236,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':147237,'multiline':False]['text':' Don't need to check overflow or underflow; however set inexact flag','line_number':147254,'multiline':False]['text':' Package up the result','line_number':147259,'multiline':False]['text':' matches #if __ENABLE_BINARY80__','line_number':147264,'multiline':False]['text':' **********************************************************************','line_number':147266,'multiline':False]['text':' Unpack the input','line_number':147295,'multiline':False]['text':' Now -16606<=e<=16271 (16271 for max normal, -16494 for min normal, -16606 for min denormal)','line_number':147299,'multiline':False]['text':' Shift up 15 places to move to the top','line_number':147301,'multiline':False]['text':' (We never need to check for overflow: this format is the biggest of all!)','line_number':147305,'multiline':False]['text':' Now filter out all the exact cases where we need to specially force','line_number':147307,'multiline':False]['text':' the exponent to 0. We can let through inexact cases and those where the','line_number':147308,'multiline':False]['text':' main path will do the right thing anyway, e.g. integers outside coeff range.','line_number':147309,'multiline':False]['text':'','line_number':147310,'multiline':False]['text':' First check that e <= 0, because if e > 0, the input must be >= 2^113,','line_number':147311,'multiline':False]['text':' which is too large for the coefficient of any target decimal format.','line_number':147312,'multiline':False]['text':' We write a = -(e + t)','line_number':147313,'multiline':False]['text':'','line_number':147314,'multiline':False]['text':' (1) If e + t >= 0 <=> a <= 0 the input is an integer; treat it specially','line_number':147315,'multiline':False]['text':'     iff it fits in the coefficient range. Shift c' = c >> -e, and','line_number':147316,'multiline':False]['text':'     compare with the coefficient range; if it's in range then c' is','line_number':147317,'multiline':False]['text':'     our coefficient, exponent is 0. Otherwise we pass through.','line_number':147318,'multiline':False]['text':'','line_number':147319,'multiline':False]['text':' (2) If a > 0 then we have a non-integer input. The special case would','line_number':147320,'multiline':False]['text':'     arise as c' / 2^a where c' = c >> t, i.e. 10^-a * (5^a c'). Now','line_number':147321,'multiline':False]['text':'     if a > 48 we can immediately forget this, since 5^49 > 10^34.','line_number':147322,'multiline':False]['text':'     Otherwise we determine whether we're in range by a table based on','line_number':147323,'multiline':False]['text':'     a, and if so get the multiplier also from a table based on a.','line_number':147324,'multiline':False]['text':'','line_number':147325,'multiline':False]['text':' Note that when we shift, we need to take into account the fact that','line_number':147326,'multiline':False]['text':' c is already 15 places to the left in preparation for the reciprocal','line_number':147327,'multiline':False]['text':' multiplication; thus we add 15 to all the shift counts','line_number':147328,'multiline':False]['text':' Input exponent can stretch between the maximal and minimal','line_number':147352,'multiline':False]['text':' exponents (remembering we force normalization): -16607 <= e <= 16271','line_number':147353,'multiline':False]['text':' Compute the estimated decimal exponent e_out; the provisional exponent','line_number':147355,'multiline':False]['text':' will be either "e_out" or "e_out-1" depending on later significand check','line_number':147356,'multiline':False]['text':' NB: this is the *biased* exponent','line_number':147357,'multiline':False]['text':' Set up pointers into the bipartite table','line_number':147362,'multiline':False]['text':' Look up the inner entry first','line_number':147368,'multiline':False]['text':' If we need the other entry, multiply significands and add exponents','line_number':147372,'multiline':False]['text':' *** NB I should run an exhaustive check this +1 doesn't overflow','line_number':147379,'multiline':False]['text':' Make adjustive shift, ignoring the lower 128 bits','line_number':147386,'multiline':False]['text':' Now test against 10^33 and so decide on adjustment','line_number':147391,'multiline':False]['text':' I feel there ought to be a smarter way of doing the multiplication','line_number':147392,'multiline':False]['text':' Set up provisional results','line_number':147399,'multiline':False]['text':' Round using round-sticky words','line_number':147404,'multiline':False]['text':' If we spill over into the next decade, correct','line_number':147405,'multiline':False]['text':' Don't need to check overflow or underflow; however set inexact flag','line_number':147422,'multiline':False]['text':' Package up the result','line_number':147427,'multiline':False]['text':' **********************************************************************','line_number':147432,'multiline':False]['text':' Special conversion returning 2-part result, for use in transcendentals','line_number':147433,'multiline':False]['text':' **********************************************************************','line_number':147434,'multiline':False]['text':' Unpack the input and shift two further places for reciprocal multiplication','line_number':147498,'multiline':False]['text':' Check for "trivial" overflow, when 10^e * 1 > 2^{sci_emax+1}, just to','line_number':147506,'multiline':False]['text':' keep tables smaller (it would be intercepted later otherwise).','line_number':147507,'multiline':False]['text':'','line_number':147508,'multiline':False]['text':' (Note that we may have normalized the coefficient, but we have a','line_number':147509,'multiline':False]['text':'  corresponding exponent postcorrection to account for; this can','line_number':147510,'multiline':False]['text':'  afford to be conservative anyway.)','line_number':147511,'multiline':False]['text':'','line_number':147512,'multiline':False]['text':' We actually check if e >= ceil((sci_emax + 1) * log_10(2))','line_number':147513,'multiline':False]['text':' which in this case is 2 >= ceil(16384 * log_10(2)) = ceil(4932.07544) = 4933','line_number':147514,'multiline':False]['text':' Also check for "trivial" underflow, when 10^e * 2^113 <= 2^emin * 1/4,','line_number':147518,'multiline':False]['text':' so test e <= floor((emin - 114) * log_10(2))','line_number':147519,'multiline':False]['text':' In this case just fix ourselves at that value for uniformity.','line_number':147520,'multiline':False]['text':'','line_number':147521,'multiline':False]['text':' This is important not only to keep the tables small but to maintain the','line_number':147522,'multiline':False]['text':' testing of the round/sticky words as a correct rounding method','line_number':147523,'multiline':False]['text':' Look up the breakpoint and approximate exponent','line_number':147527,'multiline':False]['text':' Choose provisional exponent and reciprocal multiplier based on breakpoint','line_number':147532,'multiline':False]['text':' Do the reciprocal multiplication; make an effective shift of 254 bits','line_number':147542,'multiline':False]['text':' (given that we already shifted left 2 places) by lopping from word 4','line_number':147543,'multiline':False]['text':' Check for exponent underflow and compensate by shifting the product','line_number':147547,'multiline':False]['text':' Cut off the process at precision+2, since we can't really shift further','line_number':147548,'multiline':False]['text':' Check for overflow','line_number':147564,'multiline':False]['text':' Modify exponent for a tiny result; otherwise lop off the implicit bit','line_number':147568,'multiline':False]['text':' Package up high part as binary floating-point number','line_number':147573,'multiline':False]['text':' Convert low part also to a binary floating-point number','line_number':147577,'multiline':False]