['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]['text':'
 * A note on error handling: main split functions first allocate/initialize new structures; failures
 * during that period are handled by discarding the memory and returning an error code, the caller
 * knows the split didn't happen and proceeds accordingly. Second, split functions update the tree,
 * and a failure in that period is catastrophic, any partial update to the tree requires a panic, we
 * can't recover. Third, once the split is complete and the tree has been fully updated, we have to
 * ignore most errors, the split is complete and correct, callers have to proceed accordingly.
 ','line_number':18,'multiline':True]['text':' Ignore minor errors ','line_number':27,'multiline':True]['text':' Panic on all errors ','line_number':28,'multiline':True]['text':' Clean up and return error ','line_number':29,'multiline':True]['text':'
 * __split_safe_free --
 *     Free a buffer if we can be sure no thread is accessing it, or schedule it to be freed
 *     otherwise.
 ','line_number':32,'multiline':True]['text':'
     * We have swapped something in a page: it's only safe to free it if we have exclusive access.
     ','line_number':40,'multiline':True]['text':'
 * __split_verify_intl_key_order --
 *     Verify the key order on an internal page after a split.
 ','line_number':51,'multiline':True]['text':' Less than any valid record number. ','line_number':70,'multiline':True]['text':'
             * Don't compare the first slot with any other slot, it's ignored on row-store internal
             * pages.
             ','line_number':91,'multiline':True]['text':'
 * __split_verify_root --
 *     Verify a root page involved in a split.
 ','line_number':111,'multiline':True]['text':'
     * Ignore pages not in-memory (deleted, on-disk, being read), there's no in-memory structure to
     * check.
     ','line_number':122,'multiline':True]['text':' The split is complete and live, verify all of the pages involved. ','line_number':128,'multiline':True]['text':'
         * The page might be in transition, being read or evicted or something else. Acquire a
         * hazard pointer for the page so we know its state.
         ','line_number':132,'multiline':True]['text':' Something really bad just happened. ','line_number':149,'multiline':True]['text':'
 * __split_ovfl_key_cleanup --
 *     Handle cleanup for on-page row-store overflow keys.
 ','line_number':153,'multiline':True]['text':' There's a per-page flag if there are any overflow keys at all. ','line_number':165,'multiline':True]['text':'
     * A key being discarded (page split) or moved to a different page (page deepening) may be an
     * on-page overflow key. Clear any reference to an underlying disk image, and, if the key hasn't
     * been deleted, delete it along with any backing blocks.
     ','line_number':169,'multiline':True]['text':' Leak blocks rather than try this twice. ','line_number':179,'multiline':True]['text':'
 * __split_ref_move --
 *     Move a WT_REF from one page to another, including updating accounting information.
 ','line_number':190,'multiline':True]['text':'
     * The from-home argument is the page into which the "from" WT_REF may point, for example, if
     * there's an on-page key the "from" WT_REF references, it will be on the page "from-home".
     *
     * Instantiate row-store keys, and column- and row-store addresses in the WT_REF structures
     * referenced by a page that's being split. The WT_REF structures aren't moving, but the index
     * references are moving from the page we're splitting to a set of new pages, and so we can no
     * longer reference the block image that remains with the page being split.
     *
     * No locking is required to update the WT_REF structure because we're the only thread splitting
     * the page, and there's no way for readers to race with our updates of single pointers. The
     * changes have to be written before the page goes away, of course, our caller owns that
     * problem.
     ','line_number':209,'multiline':True]['text':'
         * Row-store keys: if it's not yet instantiated, instantiate it. If already instantiated,
         * check for overflow cleanup (overflow keys are always instantiated).
         ','line_number':224,'multiline':True]['text':'
     * If there's no address at all (the page has never been written), or the address has already
     * been instantiated, there's no work to do. Otherwise, the address still references a split
     * page on-page cell, instantiate it. We can race with reconciliation and/or eviction of the
     * child pages, be cautious: read the address and verify it, and only update it if the value is
     * unchanged from the original. In the case of a race, the address must no longer reference the
     * split page, we're done.
     ','line_number':239,'multiline':True]['text':' Could only have been fast-truncated if there were no overflow items. ','line_number':256,'multiline':True]['text':' If the compare-and-swap is successful, clear addr to skip the free at the end. ','line_number':271,'multiline':True]['text':' And finally, copy the WT_REF pointer itself. ','line_number':276,'multiline':True]['text':'
 * __split_ref_final --
 *     Finalize the WT_REF move.
 ','line_number':288,'multiline':True]['text':' The parent page's page index has been updated. ','line_number':298,'multiline':True]['text':'
     * The moved child pages are locked to prevent them from splitting before the parent move
     * completes, unlock them as the final step.
     *
     * Once the split is live, newly created internal pages might be evicted and their WT_REF
     * structures freed. If that happens before all threads exit the index of the page that
     * previously "owned" the WT_REF, a thread might see a freed WT_REF. To ensure that doesn't
     * happen, the created pages are set to the current split generation and so can't be evicted
     * until all readers have left the old generation.
     ','line_number':305,'multiline':True]['text':'
 * __split_ref_prepare --
 *     Prepare a set of WT_REFs for a move.
 ','line_number':323,'multiline':True]['text':'
     * Update the moved WT_REFs so threads moving through them start looking at the created
     * children's page index information. Because we've not yet updated the page index of the parent
     * page into which we are going to split this subtree, a cursor moving through these WT_REFs
     * will ascend into the created children, but eventually fail as that parent page won't yet know
     * about the created children pages. That's OK, we spin there until the parent's page index is
     * updated.
     *
     * Lock the newly created page to ensure none of its children can split. First, to ensure all of
     * the child pages are updated before any pages can split. Second, to ensure the original split
     * completes before any of the children can split. The latter involves split generations: the
     * original split page has references to these children. If they split immediately, they could
     * free WT_REF structures based on split generations earlier than the split generation we'll
     * eventually choose to protect the original split page's previous page index.
     ','line_number':341,'multiline':True]['text':' Track the locked pages for cleanup. ','line_number':361,'multiline':True]['text':' Switch the WT_REF's to their new page. ','line_number':367,'multiline':True]['text':'
 * __split_root --
 *     Split the root page in-memory, deepening the tree.
 ','line_number':386,'multiline':True]['text':' Mark the root page dirty. ','line_number':411,'multiline':True]['text':'
     * Our caller is holding the root page locked to single-thread splits, which means we can safely
     * look at the page's index without setting a split generation.
     ','line_number':415,'multiline':True]['text':'
     * Decide how many child pages to create, then calculate the standard chunk and whatever
     * remains. Sanity check the number of children: the decision to split matched to the
     * deepen-per-child configuration might get it wrong.
     ','line_number':421,'multiline':True]['text':'
     * Allocate a new WT_PAGE_INDEX and set of WT_REF objects to be inserted into the root page,
     * replacing the root's page-index.
     ','line_number':439,'multiline':True]['text':' Allocate child pages, and connect them into the new page index. ','line_number':453,'multiline':True]['text':'
         * Initialize the page's child reference; we need a copy of the page's key.
         ','line_number':459,'multiline':True]['text':'
         * Initialize the child page. Block eviction in newly created pages and mark them dirty.
         ','line_number':475,'multiline':True]['text':'
         * The newly allocated child's page index references the same structures as the root. (We
         * cannot move WT_REF structures, threads may be underneath us right now changing the
         * structure state.) However, if the WT_REF structures reference on-page information, we
         * have to fix that, because the disk image for the page that has a page index entry for the
         * WT_REF is about to change.
         ','line_number':482,'multiline':True]['text':'
     * Flush our writes and start making real changes to the tree, errors are fatal.
     ','line_number':499,'multiline':True]['text':' Prepare the WT_REFs for the move. ','line_number':504,'multiline':True]['text':' Encourage a race ','line_number':507,'multiline':True]['text':'
     * Confirm the root page's index hasn't moved, then update it, which makes the split visible to
     * threads descending the tree.
     ','line_number':510,'multiline':True]['text':' Encourage a race ','line_number':518,'multiline':True]['text':'
     * Mark the root page with the split generation.
     *
     * Note: as the root page cannot currently be evicted, the root split generation isn't ever
     * used. That said, it future proofs eviction and isn't expensive enough to special-case.
     ','line_number':521,'multiline':True]['text':' Finalize the WT_REF move. ','line_number':531,'multiline':True]['text':' The split is complete and verified, ignore benign errors. ','line_number':539,'multiline':True]['text':'
     * We can't free the previous root's index, there may be threads using it. Add to the session's
     * discard list, to be freed once we know no threads can still be using it.
     *
     * This change requires care with error handling: we have already updated the page with a new
     * index. Even if stashing the old value fails, we don't roll back that change, because threads
     * may already be using the new index.
     ','line_number':542,'multiline':True]['text':' Adjust the root's memory footprint. ','line_number':555,'multiline':True]['text':' FALLTHROUGH ','line_number':578,'multiline':True]['text':'
 * __split_parent_discard_ref --
 *     Worker routine to discard WT_REFs for the split-parent function.
 ','line_number':586,'multiline':True]['text':'
     * Row-store trees where the old version of the page is being discarded: the previous parent
     * page's key for this child page may have been an on-page overflow key. In that case, if the
     * key hasn't been deleted, delete it now, including its backing blocks. We are exchanging the
     * WT_REF that referenced it for the split page WT_REFs and their keys, and there's no longer
     * any reference to it. Done after completing the split (if we failed, we'd leak the underlying
     * blocks, but the parent page would be unaffected).
     ','line_number':598,'multiline':True]['text':' Free any backing fast-truncate memory. ','line_number':616,'multiline':True]['text':' Free the backing block and address. ','line_number':619,'multiline':True]['text':'
     * Set the WT_REF state. It may be possible to immediately free the WT_REF, so this is our last
     * chance.
     ','line_number':622,'multiline':True]['text':'
 * __split_parent --
 *     Resolve a multi-page split, inserting new information into the parent.
 ','line_number':634,'multiline':True]['text':' Mark the page dirty. ','line_number':665,'multiline':True]['text':'
     * We've locked the parent, which means it cannot split (which is the only reason to worry about
     * split generation values).
     ','line_number':669,'multiline':True]['text':'
     * Remove any refs to deleted pages while we are splitting, we have the internal page locked
     * down and are copying the refs into a new page-index array anyway.
     *
     * We can't do this if there is a sync running in the tree in another session: removing the refs
     * frees the blocks for the deleted pages, which can corrupt the free list calculated by the
     * sync.
     ','line_number':676,'multiline':True]['text':'
             * Protect against including the replaced WT_REF in the list of deleted items. Also, in
             * VLCS, avoid dropping the leftmost page even if it's deleted, because the namespace
             * gap that produces causes search to fail. (For other gaps, search just takes the next
             * page to the left; but for the leftmost page in an internal page that doesn't work
             * unless we update the internal page's start recno on the fly and restart the search,
             * which seems like asking for trouble.)
             ','line_number':690,'multiline':True]['text':'
     * The final entry count is the original count, where one entry will be replaced by some number
     * of new entries, and some number will be deleted.
     ','line_number':710,'multiline':True]['text':'
     * If there are no remaining entries on the parent, give up, we can't leave an empty internal
     * page. Mark it to be evicted soon and clean up any references that have changed state.
     ','line_number':716,'multiline':True]['text':'
     * Allocate and initialize a new page index array for the parent, then copy references from the
     * original index array, plus references from the newly created split array, into place.
     *
     * Update the WT_REF's page-index hint as we go. This can race with a thread setting the hint
     * based on an older page-index, and the change isn't backed out in the case of an error, so
     * there ways for the hint to be wrong; OK because it's just a hint.
     ','line_number':727,'multiline':True]['text':' Skip refs we have marked for deletion. ','line_number':751,'multiline':True]['text':' Check we filled in the expected number of entries. ','line_number':764,'multiline':True]['text':' Start making real changes to the tree, errors are fatal. ','line_number':767,'multiline':True]['text':' Encourage a race ','line_number':770,'multiline':True]['text':'
     * Confirm the parent page's index hasn't moved then update it, which makes the split visible to
     * threads descending the tree.
     ','line_number':773,'multiline':True]['text':' Encourage a race ','line_number':781,'multiline':True]['text':'
     * Get a generation for this split, mark the page. This must be after the new index is swapped
     * into place in order to know that no readers with the new generation will look at the old
     * index.
     ','line_number':784,'multiline':True]['text':' The split is complete and verified, ignore benign errors. ','line_number':796,'multiline':True]['text':'
     * The new page index is in place. Threads cursoring in the tree are blocked because the WT_REF
     * being discarded (if any), and deleted WT_REFs (if any) are in a locked state. Changing the
     * locked state to split unblocks those threads and causes them to re-calculate their position
     * based on the just-updated parent page's index. The split state doesn't lock the WT_REF.addr
     * information which is read by cursor threads in some tree-walk cases: free the WT_REF we were
     * splitting and any deleted WT_REFs we found, modulo the usual safe free semantics, then reset
     * the WT_REF state.
     ','line_number':799,'multiline':True]['text':'
     * !!!
     * The original WT_REF has now been freed, we can no longer look at it.
     ','line_number':820,'multiline':True]['text':'
     * Don't cache the change: not required for correctness, but stops threads spinning on incorrect
     * page references.
     ','line_number':825,'multiline':True]['text':'
     * We can't free the previous page index, there may be threads using it. Add it to the session
     * discard list, to be freed when it's safe.
     ','line_number':831,'multiline':True]['text':' Adjust the parent's memory footprint. ','line_number':840,'multiline':True]['text':'
     * We've discarded the WT_REFs and swapping in a new page index released the page for eviction;
     * we can no longer look inside the WT_REF or the page, be careful logging the results.
     ','line_number':844,'multiline':True]['text':'
     * A note on error handling: if we completed the split, return success, nothing really bad can
     * have happened, and our caller has to proceed with the split.
     ','line_number':854,'multiline':True]['text':' Unlock WT_REFs locked because they were in a deleted state. ','line_number':860,'multiline':True]['text':'
         * The split couldn't proceed because the parent would be empty, return EBUSY so our caller
         * knows to unlock the WT_REF that's being deleted, but don't be noisy, there's nothing
         * wrong.
         ','line_number':868,'multiline':True]['text':' FALLTHROUGH ','line_number':883,'multiline':True]['text':'
 * __split_internal --
 *     Split an internal page into its parent.
 ','line_number':892,'multiline':True]['text':' Mark the page dirty. ','line_number':911,'multiline':True]['text':'
     * Our caller is holding the page locked to single-thread splits, which means we can safely look
     * at the page's index without setting a split generation.
     ','line_number':922,'multiline':True]['text':'
     * Decide how many child pages to create, then calculate the standard chunk and whatever
     * remains. Sanity check the number of children: the decision to split matched to the
     * deepen-per-child configuration might get it wrong.
     ','line_number':928,'multiline':True]['text':'
     * Ideally, we'd discard the original page, but that's hard since other threads of control are
     * using it (for example, if eviction is walking the tree and looking at the page.) Instead,
     * perform a right-split, moving all except the first chunk of the page's WT_REF objects to new
     * pages.
     *
     * Create and initialize a replacement WT_PAGE_INDEX for the original page.
     ','line_number':946,'multiline':True]['text':'
     * Allocate a new WT_PAGE_INDEX and set of WT_REF objects to be inserted into the page's parent,
     * replacing the page's page-index.
     *
     * The first slot of the new WT_PAGE_INDEX is the original page WT_REF. The remainder of the
     * slots are allocated WT_REFs.
     ','line_number':962,'multiline':True]['text':' Allocate child pages, and connect them into the new page index. ','line_number':980,'multiline':True]['text':'
         * Initialize the page's child reference; we need a copy of the page's key.
         ','line_number':987,'multiline':True]['text':'
         * Initialize the child page. Block eviction in newly created pages and mark them dirty.
         ','line_number':1003,'multiline':True]['text':'
         * The newly allocated child's page index references the same structures as the parent. (We
         * cannot move WT_REF structures, threads may be underneath us right now changing the
         * structure state.) However, if the WT_REF structures reference on-page information, we
         * have to fix that, because the disk image for the page that has a page index entry for the
         * WT_REF is about to be discarded.
         ','line_number':1010,'multiline':True]['text':'
     * Flush our writes and start making real changes to the tree, errors are fatal.
     ','line_number':1027,'multiline':True]['text':' Prepare the WT_REFs for the move. ','line_number':1032,'multiline':True]['text':' Encourage a race ','line_number':1035,'multiline':True]['text':' Split into the parent. ','line_number':1038,'multiline':True]['text':'
     * Confirm the page's index hasn't moved, then update it, which makes the split visible to
     * threads descending the tree.
     ','line_number':1042,'multiline':True]['text':' Encourage a race ','line_number':1049,'multiline':True]['text':'
     * Get a generation for this split, mark the parent page. This must be after the new index is
     * swapped into place in order to know that no readers with the new generation will look at the
     * old index.
     ','line_number':1052,'multiline':True]['text':' Finalize the WT_REF move. ','line_number':1061,'multiline':True]['text':' The split is complete and verified, ignore benign errors. ','line_number':1069,'multiline':True]['text':'
     * We don't care about the page-index we allocated, all we needed was the array of WT_REF
     * structures, which has now been split into the parent page.
     ','line_number':1072,'multiline':True]['text':'
     * We can't free the previous page's index, there may be threads using it. Add to the session's
     * discard list, to be freed once we know no threads can still be using it.
     *
     * This change requires care with error handling, we've already updated the parent page. Even if
     * stashing the old value fails, we don't roll back that change, because threads may already be
     * using the new parent page.
     ','line_number':1078,'multiline':True]['text':' Adjust the page's memory footprint. ','line_number':1091,'multiline':True]['text':'
         * The replace-index variable is the internal page being split's new page index, referencing
         * the first chunk of WT_REFs that aren't being moved to other pages. Those WT_REFs survive
         * the failure, they're referenced from the page's current index. Simply free that memory,
         * but nothing it references.
         ','line_number':1103,'multiline':True]['text':'
         * The alloc-index variable is the array of new WT_REF entries intended to be inserted into
         * the page being split's parent.
         *
         * Except for the first slot (the original page's WT_REF), it's an array of newly allocated
         * combined WT_PAGE_INDEX and WT_REF structures, each of which references a newly allocated
         * (and modified) child page, each of which references an index of WT_REFs from the page
         * being split. Free everything except for slot 1 and the WT_REFs in the child page indexes.
         *
         * First, skip slot 1. Second, we want to free all of the child pages referenced from the
         * alloc-index array, but we can't just call the usual discard function because the WT_REFs
         * referenced by the child pages remain referenced by the original page, after error. For
         * each entry, free the child page's page index (so the underlying page-free function will
         * ignore it), then call the general-purpose discard function.
         ','line_number':1111,'multiline':True]['text':' FALLTHROUGH ','line_number':1149,'multiline':True]['text':'
 * __split_internal_lock --
 *     Lock an internal page.
 ','line_number':1157,'multiline':True]['text':'
     * A checkpoint reconciling this parent page can deadlock with our split. We have an exclusive
     * page lock on the child before we acquire the page's reconciliation lock, and reconciliation
     * acquires the page's reconciliation lock before it encounters the child's exclusive lock
     * (which causes reconciliation to loop until the exclusive lock is resolved). If we want to
     * split the parent, give up to avoid that deadlock.
     ','line_number':1168,'multiline':True]['text':'
     * Get a page-level lock on the parent to single-thread splits into the page because we need to
     * single-thread sizing/growing the page index. It's OK to queue up multiple splits as the child
     * pages split, but the actual split into the parent has to be serialized. Note we allocate
     * memory inside of the lock and may want to invest effort in making the locked period shorter.
     *
     * We use the reconciliation lock here because not only do we have to single-thread the split,
     * we have to lock out reconciliation of the parent because reconciliation of the parent can't
     * deal with finding a split child during internal page traversal. Basically, there's no reason
     * to use a different lock if we have to block reconciliation anyway.
     ','line_number':1178,'multiline':True]['text':' Encourage races. ','line_number':1192,'multiline':True]['text':' Page locks live in the modify structure. ','line_number':1195,'multiline':True]['text':'
     * This child has exclusive access to split its parent and the child's existence prevents the
     * parent from being evicted. However, once we update the parent's index, it may no longer refer
     * to the child, and could conceivably be evicted. If the parent page is dirty, our page lock
     * prevents eviction because reconciliation is blocked. However, if the page were clean, it
     * could be evicted without encountering our page lock. That isn't possible because you cannot
     * move a child page and still leave the parent page clean.
     ','line_number':1207,'multiline':True]['text':'
 * __split_internal_unlock --
 *     Unlock the parent page.
 ','line_number':1220,'multiline':True]['text':'
 * __split_internal_should_split --
 *     Return if we should split an internal page.
 ','line_number':1230,'multiline':True]['text':'
     * Our caller is holding the parent page locked to single-thread splits, which means we can
     * safely look at the page's index without setting a split generation.
     ','line_number':1244,'multiline':True]['text':' Sanity check for a reasonable number of on-page keys. ','line_number':1250,'multiline':True]['text':'
     * Deepen the tree if the page's memory footprint is larger than the maximum size for a page in
     * memory (presumably putting eviction pressure on the cache).
     ','line_number':1254,'multiline':True]['text':'
     * Check if the page has enough keys to make it worth splitting. If the number of keys is
     * allowed to grow too large, the cost of splitting into parent pages can become large enough to
     * result in slow operations.
     ','line_number':1261,'multiline':True]['text':'
 * __split_parent_climb --
 *     Check if we should split up the tree.
 ','line_number':1272,'multiline':True]['text':'
     * Disallow internal splits during the final pass of a checkpoint. Most splits are already
     * disallowed during checkpoints, but an important exception is insert splits. The danger is an
     * insert split creates a new chunk of the namespace, and then the internal split will move it
     * to a different part of the tree where it will be written; in other words, in one part of the
     * tree we'll skip the newly created insert split chunk, but we'll write it upon finding it in a
     * different part of the tree.
     *
     * Historically we allowed checkpoint itself to trigger an internal split here. That wasn't
     * correct, since if that split climbs the tree above the immediate parent the checkpoint walk
     * will potentially miss some internal pages. This is wrong as checkpoint needs to reconcile the
     * entire internal tree structure. Non checkpoint cursor traversal doesn't care the internal
     * tree structure as they just want to get the next leaf page correctly. Therefore, it is OK to
     * split concurrently to cursor operations.
     ','line_number':1283,'multiline':True]['text':'
     * Page splits trickle up the tree, that is, as leaf pages grow large enough and are evicted,
     * they'll split into their parent. And, as that parent page grows large enough and is evicted,
     * it splits into its parent and so on. When the page split wave reaches the root, the tree will
     * permanently deepen as multiple root pages are written.
     *
     * However, this only helps if internal pages are evicted (and we resist evicting internal pages
     * for obvious reasons), or if the tree were to be closed and re-opened from a disk image, which
     * may be a rare event.
     *
     * To avoid internal pages becoming too large absent eviction, check parent pages each time
     * pages are split into them. If the page is big enough, either split the page into its parent
     * or, in the case of the root, deepen the tree.
     *
     * Split up the tree.
     ','line_number':1303,'multiline':True]['text':' If we don't need to split the page, we're done. ','line_number':1323,'multiline':True]['text':'
         * If we've reached the root page, there are no subsequent pages to review, deepen the tree
         * and quit.
         ','line_number':1327,'multiline':True]['text':'
         * Lock the parent and split into it, then swap the parent/page locks, lock-coupling up the
         * tree.
         ','line_number':1336,'multiline':True]['text':' A page may have been busy, in which case return without error. ','line_number':1354,'multiline':True]['text':'
 * __split_multi_inmem --
 *     Instantiate a page from a disk image.
 ','line_number':1370,'multiline':True]['text':'
     * This code re-creates an in-memory page from a disk image, and adds references to any
     * unresolved update chains to the new page. We get here either because an update could not be
     * written when evicting a page, or eviction chose to keep a page in memory.
     *
     * Reconciliation won't create a disk image with entries the running database no longer cares
     * about (at least, not based on the current tests we're performing), ignore the validity
     * window.
     *
     * Steal the disk image and link the page into the passed-in WT_REF to simplify error handling:
     * our caller will not discard the disk image when discarding the original page, and our caller
     * will discard the allocated page on error, when discarding the allocated WT_REF.
     ','line_number':1388,'multiline':True]['text':'
     * In-memory databases restore non-obsolete updates directly in this function, don't call the
     * underlying page functions to do it.
     ','line_number':1404,'multiline':True]['text':'
     * Put the re-instantiated page in the same LRU queue location as the original page, unless this
     * was a forced eviction, in which case we leave the new page with the read generation unset.
     * Eviction will set the read generation next time it visits this page.
     ','line_number':1411,'multiline':True]['text':'
     * If there are no updates to apply to the page, we're done. Otherwise, there are updates we
     * need to restore.
     ','line_number':1419,'multiline':True]['text':' Re-create each modification we couldn't write. ','line_number':1433,'multiline':True]['text':' Ignore update chains that don't need to be restored. ','line_number':1435,'multiline':True]['text':' Note: supd->ins is never null for column-store. ','line_number':1440,'multiline':True]['text':' We shouldn't restore an empty update chain. ','line_number':1446,'multiline':True]['text':'
         * Truncate the onpage value and the older versions moved to the history store. We can't
         * truncate the updates for an in memory database as it doesn't support the history store.
         * We can't free the truncated updates here as we may still fail. If we fail, we will append
         * them back to their original update chains. Truncate before we restore them to ensure the
         * size of the page is correct.
         ','line_number':1449,'multiline':True]['text':'
             * If there is an on-page tombstone we need to remove it as well while performing update
             * restore eviction.
             ','line_number':1457,'multiline':True]['text':'
             * We have decided to restore this update chain so it must have newer updates than the
             * onpage value on it.
             ','line_number':1463,'multiline':True]['text':'
             * Move the pointer to the position before the onpage value and truncate all the updates
             * starting from the onpage value.
             ','line_number':1470,'multiline':True]['text':'
             * During update restore eviction we remove anything older than the on-page update,
             * including the on-page update. However it is possible a tombstone is also written as
             * the stop time of the on-page value. To handle this we also need to remove the
             * tombstone from the update chain.
             *
             * This assertion checks that there aren't any unexpected updates between that tombstone
             * and the subsequent value which both make up the on-page value.
             ','line_number':1479,'multiline':True]['text':' Build a key. ','line_number':1497,'multiline':True]['text':' Search the page. ','line_number':1500,'multiline':True]['text':' Apply the modification. ','line_number':1503,'multiline':True]['text':' Build a key. ','line_number':1507,'multiline':True]['text':' Search the page. ','line_number':1515,'multiline':True]['text':' Apply the modification. ','line_number':1518,'multiline':True]['text':'
     * When modifying the page we set the first dirty transaction to the last transaction currently
     * running. However, the updates we made might be older than that. Set the first dirty
     * transaction to an impossibly old value so this page is never skipped in a checkpoint.
     ','line_number':1526,'multiline':True]['text':'
     * Restore the previous page's modify state to avoid repeatedly attempting eviction on the same
     * page.
     ','line_number':1534,'multiline':True]['text':' Add the update/restore flag to any previous state. ','line_number':1544,'multiline':True]['text':' Free any resources that may have been cached in the cursor. ','line_number':1549,'multiline':True]['text':'
 * __split_multi_inmem_final --
 *     Discard moved update lists from the original page and free the updates written to the data
 *     store and the history store.
 ','line_number':1556,'multiline':True]['text':' If we have saved updates, we must have decided to restore them to the new page. ','line_number':1568,'multiline':True]['text':'
     * We successfully created new in-memory pages. For error-handling reasons, we've left the
     * update chains referenced by both the original and new pages. We're ready to discard the
     * original page, terminate the original page's reference to any update list we moved and free
     * the updates written to the data store and the history store.
     ','line_number':1571,'multiline':True]['text':' We have finished restoration. Discard the update chains that aren't restored. ','line_number':1578,'multiline':True]['text':' Note: supd->ins is never null for column-store. ','line_number':1583,'multiline':True]['text':'
         * Free the updates written to the data store and the history store when there exists an
         * onpage value. It is possible that there can be an onpage tombstone without an onpage
         * value when the tombstone is globally visible. Do not free them here as it is possible
         * that the globally visible tombstone is already freed as part of update obsolete check.
         ','line_number':1589,'multiline':True]['text':'
 * __split_multi_inmem_fail --
 *     Discard allocated pages after failure and append the onpage values back to the original
 *     update chains.
 ','line_number':1603,'multiline':True]['text':' Append the onpage values back to the original update chains. ','line_number':1616,'multiline':True]['text':'
             * We don't need to do anything for update chains that are not restored, or restored
             * without an onpage value.
             ','line_number':1618,'multiline':True]['text':' Note: supd->ins is never null for column-store. ','line_number':1626,'multiline':True]['text':'
     * We failed creating new in-memory pages. For error-handling reasons, we've left the update
     * chains referenced by both the original and new pages. Discard the newly allocated WT_REF
     * structures and their pages (setting a flag so the discard code doesn't discard the updates on
     * the page).
     *
     * Our callers allocate WT_REF arrays, then individual WT_REFs, check for uninitialized
     * information.
     ','line_number':1640,'multiline':True]['text':'
 * __wt_multi_to_ref --
 *     Move a multi-block entry into a WT_REF structure.
 ','line_number':1656,'multiline':True]['text':' There can be an address or a disk image or both. ','line_number':1668,'multiline':True]['text':' If closing the file, there better be an address. ','line_number':1671,'multiline':True]['text':' If closing the file, there better not be any saved updates. ','line_number':1674,'multiline':True]['text':' If we don't have a disk image, we can't restore the saved updates. ','line_number':1677,'multiline':True]['text':' Verify any disk image we have. ','line_number':1681,'multiline':True]['text':' Allocate an underlying WT_REF. ','line_number':1688,'multiline':True]['text':'
     * Set the WT_REF key before (optionally) building the page, underlying column-store functions
     * need the page's key space to search it.
     ','line_number':1694,'multiline':True]['text':'
     * If there's an address, the page was written, set it.
     *
     * Copy the address: we could simply take the buffer, but that would complicate error handling,
     * freeing the reference array would have to avoid freeing the memory, and it's not worth the
     * confusion.
     ','line_number':1721,'multiline':True]['text':'
     * If we have a disk image and we're not closing the file, re-instantiate the page.
     *
     * Discard any page image we don't use.
     ','line_number':1739,'multiline':True]['text':'
 * __split_insert --
 *     Split a page's last insert list entries into a separate page.
 ','line_number':1753,'multiline':True]['text':'
     * Assert splitting makes sense; specifically assert the page is dirty, we depend on that,
     * otherwise the page might be evicted based on its last reconciliation which no longer matches
     * reality after the split.
     ','line_number':1775,'multiline':True]['text':' Only split in-memory once. ','line_number':1784,'multiline':True]['text':' Find the last item on the page. ','line_number':1786,'multiline':True]['text':'
     * The first page in the split is almost identical to the current page, but we have to create a
     * replacement WT_REF, the original WT_REF will be set to split status and eventually freed.
     ','line_number':1794,'multiline':True]['text':' Visible as soon as the split completes. ','line_number':1805,'multiline':True]['text':'
     * The address has moved to the replacement WT_REF. Make sure it isn't freed when the original
     * ref is discarded.
     ','line_number':1814,'multiline':True]['text':' The second page in the split is a new WT_REF/page pair. ','line_number':1820,'multiline':True]['text':'
     * The new page is dirty by definition, plus column-store splits update the page-modify
     * structure, so create it now.
     ','line_number':1823,'multiline':True]['text':' Visible as soon as the split completes. ','line_number':1845,'multiline':True]['text':'
     * Allocation operations completed, we're going to split.
     *
     * Record the fixed-length column-store split page record, used in reconciliation.
     ','line_number':1853,'multiline':True]['text':'
     * Calculate how much memory we're moving: figure out how deep the skip list stack is for the
     * element we are moving, and the memory used by the item's list of updates.
     ','line_number':1863,'multiline':True]['text':'
     * Move the last insert list item from the original page to the new page.
     *
     * First, update the item to the new child page. (Just append the entry for simplicity, the
     * previous skip list pointers originally allocated can be ignored.)
     ','line_number':1874,'multiline':True]['text':'
     * Remove the entry from the orig page (i.e truncate the skip list).
     * Following is an example skip list that might help.
     *
     *               __
     *              |c3|
     *               |
     *   __		 __    __
     *  |a2|--------|c2|--|d2|
     *   |		 |	|
     *   __		 __    __	   __
     *  |a1|--------|c1|--|d1|--------|f1|
     *   |		 |	|	   |
     *   __    __    __    __    __    __
     *  |a0|--|b0|--|c0|--|d0|--|e0|--|f0|
     *
     *   From the above picture.
     *   The head array will be: a0, a1, a2, c3, NULL
     *   The tail array will be: f0, f1, d2, c3, NULL
     *   We are looking for: e1, d2, NULL
     *   If there were no f1, we'd be looking for: e0, NULL
     *   If there were an f2, we'd be looking for: e0, d1, d2, NULL
     *
     *   The algorithm does:
     *   1) Start at the top of the head list.
     *   2) Step down until we find a level that contains more than one
     *      element.
     *   3) Step across until we reach the tail of the level.
     *   4) If the tail is the item being moved, remove it.
     *   5) Drop down a level, and go to step 3 until at level 0.
     ','line_number':1884,'multiline':True]['text':' -Wconditional-uninitialized ','line_number':1915,'multiline':True]['text':' Level empty, or a single element. ','line_number':1917,'multiline':True]['text':' Remove if it is the element being moved. ','line_number':1919,'multiline':True]['text':'
         * Update the stack head so that we step down as far to the right as possible. We know that
         * prev_ins is valid since levels must contain at least two items to be here.
         ','line_number':1928,'multiline':True]['text':' Remove the item being moved. ','line_number':1934,'multiline':True]['text':'
     * Verify the moved insert item appears nowhere on the skip list.
     ','line_number':1943,'multiline':True]['text':'
     * We perform insert splits concurrently with checkpoints, where the requirement is a checkpoint
     * must include either the original page or both new pages. The page we're splitting is dirty,
     * but that's insufficient: set the first dirty transaction to an impossibly old value so this
     * page is not skipped by a checkpoint.
     ','line_number':1951,'multiline':True]['text':'
     * We modified the page above, which will have set the first dirty transaction to the last
     * transaction current running. However, the updates we installed may be older than that. Set
     * the first dirty transaction to an impossibly old value so this page is never skipped in a
     * checkpoint.
     ','line_number':1959,'multiline':True]['text':'
     * Update the page accounting.
     ','line_number':1967,'multiline':True]['text':'
     * The act of splitting into the parent releases the pages for eviction; ensure the page
     * contents are consistent.
     ','line_number':1973,'multiline':True]['text':'
     * Split into the parent.
     ','line_number':1979,'multiline':True]['text':'
     * Failure.
     *
     * Reset the fixed-length column-store split page record.
     ','line_number':1987,'multiline':True]['text':'
     * Clear the allocated page's reference to the moved insert list element so it's not freed when
     * we discard the page.
     *
     * Move the element back to the original page list. For simplicity, the previous skip list
     * pointers originally allocated can be ignored, just append the entry to the end of the level 0
     * list. As before, we depend on the list having multiple elements and ignore the edge cases
     * small lists have.
     ','line_number':1995,'multiline':True]['text':' Fix up accounting for the page size. ','line_number':2014,'multiline':True]['text':'
         * The address was moved to the replacement WT_REF, restore it.
         ','line_number':2019,'multiline':True]['text':'
         * We marked the new page dirty; we're going to discard it, but first mark it clean and fix
         * up the cache statistics.
         ','line_number':2034,'multiline':True]['text':'
 * __split_insert_lock --
 *     Split a page's last insert list entries into a separate page.
 ','line_number':2044,'multiline':True]['text':' Lock the parent page, then proceed with the insert split. ','line_number':2054,'multiline':True]['text':'
     * Split up through the tree as necessary; we're holding the original parent page locked, note
     * the functions we call are responsible for releasing that lock.
     ','line_number':2061,'multiline':True]['text':'
 * __wt_split_insert --
 *     Split a page's last insert list entries into a separate page.
 ','line_number':2068,'multiline':True]['text':'
     * Set the session split generation to ensure underlying code isn't surprised by internal page
     * eviction, then proceed with the insert split.
     ','line_number':2079,'multiline':True]['text':'
 * __split_multi --
 *     Split a page into multiple pages.
 ','line_number':2087,'multiline':True]['text':'
     * Convert the split page's multiblock reconciliation information into an array of page
     * reference structures.
     ','line_number':2107,'multiline':True]['text':'
     * Split into the parent; if we're closing the file, we hold it exclusively.
     ','line_number':2116,'multiline':True]['text':'
     * The split succeeded, we can no longer fail.
     *
     * Finalize the move, discarding moved update lists from the original page.
     ','line_number':2122,'multiline':True]['text':'
     * Page with changes not written in this reconciliation is not marked as clean, do it now, then
     * discard the page.
     ','line_number':2130,'multiline':True]['text':'
         * Mark the page dirty to ensure it is reconciled again as we free the split disk images if
         * we fail to instantiate any of them into memory.
         ','line_number':2141,'multiline':True]['text':'
 * __split_multi_lock --
 *     Split a page into multiple pages.
 ','line_number':2152,'multiline':True]['text':' Fail 1% of the time to simulate we fail to split the page. ','line_number':2162,'multiline':True]['text':' Lock the parent page, then proceed with the split. ','line_number':2166,'multiline':True]['text':'
     * Split up through the tree as necessary; we're holding the original parent page locked, note
     * the functions we call are responsible for releasing that lock.
     ','line_number':2173,'multiline':True]['text':'
 * __wt_split_multi --
 *     Split a page into multiple pages.
 ','line_number':2180,'multiline':True]['text':'
     * Set the session split generation to ensure underlying code isn't surprised by internal page
     * eviction, then proceed with the split.
     ','line_number':2191,'multiline':True]['text':'
 * __split_reverse --
 *     Reverse split (rewrite a parent page's index to reflect an empty page).
 ','line_number':2199,'multiline':True]['text':' Lock the parent page, then proceed with the reverse split. ','line_number':2209,'multiline':True]['text':'
 * __wt_split_reverse --
 *     Reverse split (rewrite a parent page's index to reflect an empty page).
 ','line_number':2216,'multiline':True]['text':'
     * Set the session split generation to ensure underlying code isn't surprised by internal page
     * eviction, then proceed with the reverse split.
     ','line_number':2227,'multiline':True]['text':'
 * __wt_split_rewrite --
 *     Rewrite an in-memory page with a new version.
 ','line_number':2235,'multiline':True]['text':'
     * This isn't a split: a reconciliation failed because we couldn't write something, and in the
     * case of forced eviction, we need to stop this page from being such a problem. We have
     * exclusive access, rewrite the page in memory. The code lives here because the split code
     * knows how to re-create a page in memory after it's been reconciled, and that's exactly what
     * we want to do.
     *
     * Build the new page.
     *
     * Allocate a WT_REF, the error path calls routines that free memory. The only field we need to
     * set is the record number, as it's used by the search routines.
     ','line_number':2250,'multiline':True]['text':'
     * The rewrite succeeded, we can no longer fail.
     *
     * Finalize the move, discarding moved update lists from the original page.
     ','line_number':2267,'multiline':True]['text':'
     * Discard the original page.
     *
     * Pages with unresolved changes are not marked clean during reconciliation, do it now.
     *
     * Don't count this as eviction making progress, we did a one-for-one rewrite of a page in
     * memory, typical in the case of cache pressure unless the cache is configured for scrub and
     * page doesn't have any skipped updates.
     ','line_number':2274,'multiline':True]['text':' Swap the new page into place. ','line_number':2288,'multiline':True]