['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]['text':' Illegal record number ','line_number':9,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':11,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 32 ','line_number':27,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':29,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 32 ','line_number':41,'multiline':True]['text':'
 * WT_PAGE_HEADER --
 *	Blocks have a common header, a WT_PAGE_HEADER structure followed by a
 * block-manager specific structure.
 ','line_number':43,'multiline':True]['text':'
     * The record number of the first record of the page is stored on disk so we can figure out
     * where the column-store leaf page fits into the key space during salvage.
     ','line_number':49,'multiline':True]['text':' 00-07: column-store starting recno ','line_number':53,'multiline':True]['text':'
     * We maintain page write-generations in the non-transactional case as that's how salvage can
     * determine the most recent page between pages overlapping the same key range.
     ','line_number':55,'multiline':True]['text':' 08-15: write generation ','line_number':59,'multiline':True]['text':'
     * The page's in-memory size isn't rounded or aligned, it's the actual number of bytes the
     * disk-image consumes when instantiated in memory.
     ','line_number':61,'multiline':True]['text':' 16-19: in-memory page size ','line_number':65,'multiline':True]['text':' 20-23: number of cells on page ','line_number':68,'multiline':True]['text':' 20-23: overflow data length ','line_number':69,'multiline':True]['text':' 24: page type ','line_number':72,'multiline':True]['text':'
 * No automatic generation: flag values cannot change, they're written to disk.
 ','line_number':74,'multiline':True]['text':' Page is compressed on disk ','line_number':77,'multiline':True]['text':' Page has all zero-length values ','line_number':78,'multiline':True]['text':' Page has no zero-length values ','line_number':79,'multiline':True]['text':' Page is encrypted on disk ','line_number':80,'multiline':True]['text':' Historic lookaside store page updates, no longer used ','line_number':81,'multiline':True]['text':' Page contains updated fast-truncate information ','line_number':82,'multiline':True]['text':' 25: flags ','line_number':83,'multiline':True]['text':' A byte of padding, positioned to be added to the flags. ','line_number':85,'multiline':True]['text':' 26: unused padding ','line_number':86,'multiline':True]['text':' Original version ','line_number':88,'multiline':True]['text':' Timestamps added ','line_number':89,'multiline':True]['text':' 27: version ','line_number':90,'multiline':True]['text':'
 * WT_PAGE_HEADER_SIZE is the number of bytes we allocate for the structure: if the compiler inserts
 * padding it will break the world.
 ','line_number':92,'multiline':True]['text':'
 * __wt_page_header_byteswap --
 *     Handle big- and little-endian transformation of a page header.
 ','line_number':98,'multiline':True]['text':'
 * The block-manager specific information immediately follows the WT_PAGE_HEADER structure.
 ','line_number':115,'multiline':True]['text':'
 * WT_PAGE_HEADER_BYTE --
 * WT_PAGE_HEADER_BYTE_SIZE --
 *	The first usable data byte on the block (past the combined headers).
 ','line_number':120,'multiline':True]['text':'
 * WT_ADDR --
 *	An in-memory structure to hold a block's location.
 ','line_number':129,'multiline':True]['text':' Block-manager's cookie ','line_number':136,'multiline':True]['text':' Block-manager's cookie length ','line_number':137,'multiline':True]['text':' Internal page ','line_number':139,'multiline':True]['text':' Leaf page ','line_number':140,'multiline':True]['text':' Leaf page, no overflow ','line_number':141,'multiline':True]['text':'
 * Overflow tracking for reuse: When a page is reconciled, we write new K/V overflow items. If pages
 * are reconciled multiple times, we need to know if we've already written a particular overflow
 * record (so we don't write it again), as well as if we've modified an overflow record previously
 * written (in which case we want to write a new record and discard blocks used by the previously
 * written record). Track overflow records written for the page, storing the values in a skiplist
 * with the record's value as the "key".
 ','line_number':145,'multiline':True]['text':' Overflow value offset ','line_number':154,'multiline':True]['text':' Overflow value size ','line_number':155,'multiline':True]['text':' Overflow addr offset ','line_number':156,'multiline':True]['text':' Overflow addr size ','line_number':157,'multiline':True]['text':'
 * On each page reconciliation, we clear the entry's in-use flag, and reset it as the overflow
 * record is re-used. After reconciliation completes, unused skiplist entries are discarded, along
 * with their underlying blocks.
 *
 * On each page reconciliation, set the just-added flag for each new skiplist entry; if
 * reconciliation fails for any reason, discard the newly added skiplist entries, along with their
 * underlying blocks.
 ','line_number':159,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':168,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 8 ','line_number':171,'multiline':True]['text':'
 * The untyped address immediately follows the WT_OVFL_REUSE structure, the untyped value
 * immediately follows the address.
 ','line_number':174,'multiline':True]['text':' Forward-linked skip list ','line_number':181,'multiline':True]['text':'
 * History store table support: when a page is being reconciled for eviction and has updates that
 * might be required by earlier readers in the system, the updates are written into the history
 * store table, and restored as necessary if the page is read.
 *
 * The first part of the key is comprised of a file ID, record key (byte-string for row-store,
 * record number for column-store) and timestamp. This allows us to search efficiently for a given
 * record key and read timestamp combination. The last part of the key is a monotonically increasing
 * counter to keep the key unique in the case where we have multiple transactions committing at the
 * same timestamp.
 * The value is the WT_UPDATE structure's:
 * 	- stop timestamp
 * 	- durable timestamp
 *	- update type
 *	- value.
 *
 * As the key for the history store table is different for row- and column-store, we store both key
 * types in a WT_ITEM, building/parsing them in the code, because otherwise we'd need two
 * history store files with different key formats. We could make the history store table's key
 * standard by moving the source key into the history store table value, but that doesn't make the
 * coding any simpler, and it makes the history store table's value more likely to overflow the page
 * size when the row-store key is relatively large.
 *
 * Note that we deliberately store the update type as larger than necessary (8 bytes vs 1 byte).
 * We've done this to leave room in case we need to store extra bit flags in this value at a later
 * point. If we need to store more information, we can potentially tack extra information at the end
 * of the "value" buffer and then use bit flags within the update type to determine how to interpret
 * it.
 *
 * We also configure a larger than default internal page size to accommodate for larger history
 * store keys. We do that to reduce the chances of having to create overflow keys on the page.
 ','line_number':184,'multiline':True]['text':'
 * WT_SAVE_UPD --
 *	Unresolved updates found during reconciliation.
 ','line_number':230,'multiline':True]['text':' Insert list reference ','line_number':235,'multiline':True]['text':' Original on-page reference ','line_number':236,'multiline':True]['text':' Whether to restore this saved update chain ','line_number':239,'multiline':True]['text':'
 * WT_MULTI --
 *	Replacement block information used during reconciliation.
 ','line_number':242,'multiline':True]['text':'
     * Block's key: either a column-store record number or a row-store variable length byte string.
     ','line_number':247,'multiline':True]['text':'
     * A disk image that may or may not have been written, used to re-instantiate the page in
     * memory.
     ','line_number':255,'multiline':True]['text':'
     * List of unresolved updates. Updates are either a row-store insert or update list, or
     * column-store insert list. When creating history store records, there is an additional value,
     * the committed item's transaction information.
     *
     * If there are unresolved updates, the block wasn't written and there will always be a disk
     * image.
     ','line_number':261,'multiline':True]['text':' Whether to restore saved update chains to this page ','line_number':271,'multiline':True]['text':' Disk image written address ','line_number':273,'multiline':True]['text':'
 * WT_OVFL_TRACK --
 *  Overflow record tracking for reconciliation. We assume overflow records are relatively rare,
 * so we don't allocate the structures to track them until we actually see them in the data.
 ','line_number':276,'multiline':True]['text':'
     * Overflow key/value address/byte-string pairs we potentially reuse each time we reconcile the
     * page.
     ','line_number':282,'multiline':True]['text':'
     * Overflow key/value addresses to be discarded from the block manager after reconciliation
     * completes successfully.
     ','line_number':288,'multiline':True]['text':'
 * WT_PAGE_MODIFY --
 *	When a page is modified, there's additional information to maintain.
 ','line_number':297,'multiline':True]['text':' The first unwritten transaction ID (approximate). ','line_number':302,'multiline':True]['text':' The transaction state last time eviction was attempted. ','line_number':305,'multiline':True]['text':' Check that transaction time moves forward. ','line_number':311,'multiline':True]['text':' Avoid checking for obsolete updates during checkpoints. ','line_number':315,'multiline':True]['text':' The largest transaction seen on the page by reconciliation. ','line_number':319,'multiline':True]['text':' The largest update transaction ID (approximate). ','line_number':323,'multiline':True]['text':' Dirty bytes added to the cache. ','line_number':326,'multiline':True]['text':'
     * When pages are reconciled, the result is one or more replacement blocks. A replacement block
     * can be in one of two states: it was written to disk, and so we have a block address, or it
     * contained unresolved modifications and we have a disk image for it with a list of those
     * unresolved modifications. The former is the common case: we only build lists of unresolved
     * modifications when we're evicting a page, and we only expect to see unresolved modifications
     * on a page being evicted in the case of a hot page that's too large to keep in memory as it
     * is. In other words, checkpoints will skip unresolved modifications, and will write the blocks
     * rather than build lists of unresolved modifications.
     *
     * Ugly union/struct layout to conserve memory, we never have both a replace address and
     * multiple replacement blocks.
     ','line_number':330,'multiline':True]['text':' Single, written replacement block ','line_number':344,'multiline':True]['text':'
             * A disk image that may or may not have been written, used to re-instantiate the page
             * in memory.
             ','line_number':347,'multiline':True]['text':' Multiple replacement blocks ','line_number':359,'multiline':True]['text':' Multiple blocks element count ','line_number':360,'multiline':True]['text':'
     * Internal pages need to be able to chain root-page splits and have a special transactional
     * eviction requirement. Column-store leaf pages need update and append lists.
     *
     * Ugly union/struct layout to conserve memory, a page is either a leaf page or an internal
     * page.
     ','line_number':368,'multiline':True]['text':'
             * When a root page splits, we create a new page and write it; the new page can also
             * split and so on, and we continue this process until we write a single replacement
             * root page. We use the root split field to track the list of created pages so they can
             * be discarded when no longer needed.
             ','line_number':377,'multiline':True]['text':' Linked list of root split pages ','line_number':383,'multiline':True]['text':'
             * Appended items to column-stores. Actual appends to the tree only happen on the last
             * page, but gaps created in the namespace by truncate operations can result in the
             * append lists of other pages becoming populated.
             ','line_number':388,'multiline':True]['text':'
             * Updated items in column-stores: variable-length RLE entries can expand to multiple
             * entries which requires some kind of list we can expand on demand. Updated items in
             * fixed-length files could be done based on an WT_UPDATE array as in row-stores, but
             * there can be a very large number of bits on a single page, and the cost of the
             * WT_UPDATE array would be huge.
             ','line_number':395,'multiline':True]['text':'
             * Split-saved last column-store page record. If a fixed-length column-store page is
             * split, we save the first record number moved so that during reconciliation we know
             * the page's last record and can write any implicitly created deleted records for the
             * page. No longer used by VLCS.
             ','line_number':404,'multiline':True]['text':' Inserted items for row-store. ','line_number':419,'multiline':True]['text':' Updated items for row-stores. ','line_number':422,'multiline':True]['text':' Overflow record tracking for reconciliation. ','line_number':431,'multiline':True]['text':'
     * Page-delete information for newly instantiated deleted pages. The instantiated flag remains
     * set until the page is reconciled successfully; this indicates that the page_del information
     * in the ref remains valid. The update list remains set (if set at all) until the transaction
     * that deleted the page is resolved. These transitions are independent; that is, the first
     * reconciliation can happen either before or after the delete transaction resolves.
     ','line_number':434,'multiline':True]['text':' True if this is a newly instantiated page. ','line_number':441,'multiline':True]['text':' Update list for instantiated page with unresolved truncate. ','line_number':442,'multiline':True]['text':' Page's spinlock ','line_number':447,'multiline':True]['text':'
 * The page state is incremented when a page is modified.
 *
 * WT_PAGE_CLEAN --
 *	The page is clean.
 * WT_PAGE_DIRTY_FIRST --
 *	The page is in this state after the first operation that marks a
 *	page dirty, or when reconciliation is checking to see if it has
 *	done enough work to be able to mark the page clean.
 * WT_PAGE_DIRTY --
 *	Two or more updates have been added to the page.
 ','line_number':449,'multiline':True]['text':' Reconciliation: no replacement ','line_number':466,'multiline':True]['text':' Reconciliation: multiple blocks ','line_number':467,'multiline':True]['text':' Reconciliation: single block ','line_number':468,'multiline':True]['text':' Reconciliation state ','line_number':469,'multiline':True]['text':' Created by restoring updates ','line_number':472,'multiline':True]['text':' Additional diagnostics fields to catch invalid updates to page_state, even in release builds. ','line_number':474,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':475,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 8 ','line_number':478,'multiline':True]['text':'
 * WT_COL_RLE --
 *	Variable-length column-store pages have an array of page entries with
 *	RLE counts greater than 1 when reading the page, so it's not necessary
 *	to walk the page counting records to find a specific entry. We can do a
 *	binary search in this array, then an offset calculation to find the
 *	cell.
 ','line_number':482,'multiline':True]['text':' Record number of first repeat. ','line_number':491,'multiline':True]['text':' Repeat count. ','line_number':492,'multiline':True]['text':' Slot of entry in col_var. ','line_number':493,'multiline':True]['text':'
 * WT_PAGE_INDEX --
 *	The page index held by each internal page.
 ','line_number':496,'multiline':True]['text':'
 * WT_COL_VAR_REPEAT --
 *  Variable-length column-store pages have an array of page entries with RLE counts
 * greater than 1 when reading the page, so it's not necessary to walk the page counting
 * records to find a specific entry. We can do a binary search in this array, then an
 * offset calculation to find the cell.
 *
 * It's a separate structure to keep the page structure as small as possible.
 ','line_number':506,'multiline':True]['text':' repeat slots ','line_number':516,'multiline':True]['text':' lookup RLE array ','line_number':517,'multiline':True]['text':'
 * WT_COL_FIX_TW_ENTRY --
 *     This is a single entry in the WT_COL_FIX_TW array. It stores the offset from the page's
 * starting recno and the offset into the page to find the value cell containing the time window.
 ','line_number':520,'multiline':True]['text':'
 * WT_COL_FIX_TW --
 *     Fixed-length column-store pages carry an array of page entries that have time windows. This
 * is built when reading the page to avoid the need to walk the page to find a specific entry. We
 * can do a binary search in this array instead.
 ','line_number':530,'multiline':True]['text':' number of time window slots ','line_number':537,'multiline':True]['text':' lookup array ','line_number':538,'multiline':True]['text':' WT_COL_FIX_TW_CELL gets the cell pointer from a WT_COL_FIX_TW_ENTRY. ','line_number':541,'multiline':True]['text':'
 * WT_SPLIT_HIST --
 *	State information of a split at a single point in time.
 ','line_number':545,'multiline':True]['text':'
 * WT_PAGE --
 *	The WT_PAGE structure describes the in-memory page information.
 ','line_number':559,'multiline':True]['text':' Per page-type information. ','line_number':564,'multiline':True]['text':'
         * Internal pages (both column- and row-store).
         *
         * In-memory internal pages have an array of pointers to child
         * structures, maintained in collated order.
         *
         * Multiple threads of control may be searching the in-memory
         * internal page and a child page of the internal page may
         * cause a split at any time.  When a page splits, a new array
         * is allocated and atomically swapped into place.  Threads in
         * the old array continue without interruption (the old array is
         * still valid), but have to avoid racing.  No barrier is needed
         * because the array reference is updated atomically, but code
         * reading the fields multiple times would be a very bad idea.
         * Specifically, do not do this:
         *	WT_REF **refp = page->u.intl__index->index;
         *	uint32_t entries = page->u.intl__index->entries;
         *
         * The field is declared volatile (so the compiler knows not to
         * read it multiple times), and we obscure the field name and
         * use a copy macro in all references to the field (so the code
         * doesn't read it multiple times).
         ','line_number':566,'multiline':True]['text':' Parent reference ','line_number':590,'multiline':True]['text':' Generation of last split ','line_number':591,'multiline':True]['text':' Collated children ','line_number':593,'multiline':True]['text':'
 * Macros to copy/set the index because the name is obscured to ensure the field isn't read multiple
 * times.
 *
 * There are two versions of WT_INTL_INDEX_GET because the session split generation is usually set,
 * but it's not always required: for example, if a page is locked for splitting, or being created or
 * destroyed.
 ','line_number':600,'multiline':True]['text':'
 * Macro to walk the list of references in an internal page.
 ','line_number':620,'multiline':True]['text':' Row-store leaf page. ','line_number':646,'multiline':True]['text':' Key/value pairs ','line_number':647,'multiline':True]['text':' Fixed-length column-store leaf page. ','line_number':651,'multiline':True]['text':' Values ','line_number':653,'multiline':True]['text':' Time window index ','line_number':654,'multiline':True]['text':' Variable-length column-store leaf page. ','line_number':664,'multiline':True]['text':' Values ','line_number':666,'multiline':True]['text':' Repeats array ','line_number':667,'multiline':True]['text':'
     * Page entry count, page-wide prefix information, type and flags are positioned at the end of
     * the WT_PAGE union to reduce cache misses when searching row-store pages.
     *
     * The entries field only applies to leaf pages, internal pages use the page-index entries
     * instead.
     ','line_number':678,'multiline':True]['text':' Leaf page entries ','line_number':685,'multiline':True]['text':' Best page prefix starting slot ','line_number':687,'multiline':True]['text':' Maximum slot to which the best page prefix applies ','line_number':688,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':690,'multiline':True]['text':' Keys have been built in memory ','line_number':691,'multiline':True]['text':' Writing the page for compaction ','line_number':692,'multiline':True]['text':' Disk image in allocated memory ','line_number':693,'multiline':True]['text':' Disk image in mapped memory ','line_number':694,'multiline':True]['text':' Page is on the LRU queue ','line_number':695,'multiline':True]['text':' Page is in the urgent queue ','line_number':696,'multiline':True]['text':' Eviction doesn't count as progress ','line_number':697,'multiline':True]['text':' Internal page has overflow keys (historic only) ','line_number':698,'multiline':True]['text':' The page is being pre-fetched ','line_number':699,'multiline':True]['text':' A leaf page was split for append ','line_number':700,'multiline':True]['text':' Ignore updates on page discard ','line_number':701,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 16 ','line_number':702,'multiline':True]['text':' Atomic flags, use F_*_ATOMIC_16 ','line_number':703,'multiline':True]['text':' Invalid page ','line_number':707,'multiline':True]['text':' Block-manager page ','line_number':708,'multiline':True]['text':' Col-store fixed-len leaf ','line_number':709,'multiline':True]['text':' Col-store internal page ','line_number':710,'multiline':True]['text':' Col-store var-length leaf page ','line_number':711,'multiline':True]['text':' Overflow page ','line_number':712,'multiline':True]['text':' Row-store internal page ','line_number':713,'multiline':True]['text':' Row-store leaf page ','line_number':714,'multiline':True]['text':' Page type ','line_number':715,'multiline':True]['text':' 1 byte hole expected. ','line_number':717,'multiline':True]['text':' Memory attached to the page ','line_number':719,'multiline':True]['text':' Page's on-disk representation: NULL for pages created in memory. ','line_number':721,'multiline':True]['text':' If/when the page is modified, we need lots more information. ','line_number':724,'multiline':True]['text':'
     * !!!
     * This is the 64 byte boundary, try to keep hot fields above here.
     ','line_number':727,'multiline':True]['text':'
 * The page's read generation acts as an LRU value for each page in the
 * tree; it is used by the eviction server thread to select pages to be
 * discarded from the in-memory tree.
 *
 * The read generation is a 64-bit value, if incremented frequently, a
 * 32-bit value could overflow.
 *
 * The read generation is a piece of shared memory potentially read
 * by many threads.  We don't want to update page read generations for
 * in-cache workloads and suffer the cache misses, so we don't simply
 * increment the read generation value on every access.  Instead, the
 * read generation is incremented by the eviction server each time it
 * becomes active.  To avoid incrementing a page's read generation too
 * frequently, it is set to a future point.
 *
 * Because low read generation values have special meaning, and there
 * are places where we manipulate the value, use an initial value well
 * outside of the special range.
 ','line_number':732,'multiline':True]['text':' Page create timestamp ','line_number':761,'multiline':True]['text':' Eviction pass generation ','line_number':762,'multiline':True]['text':'
 * WT_PAGE_DISK_OFFSET, WT_PAGE_REF_OFFSET --
 *	Return the offset/pointer of a pointer/offset in a page disk image.
 ','line_number':784,'multiline':True]['text':'
 * Prepare update states.
 *
 * Prepare update synchronization is based on the state field, which has the
 * following possible states:
 *
 * WT_PREPARE_INIT:
 *	The initial prepare state of either an update or a page_del structure,
 *	indicating a prepare phase has not started yet.
 *	This state has no impact on the visibility of the update's data.
 *
 * WT_PREPARE_INPROGRESS:
 *	Update is in prepared phase.
 *
 * WT_PREPARE_LOCKED:
 *	State is locked as state transition is in progress from INPROGRESS to
 *	RESOLVED. Any reader of the state needs to wait for state transition to
 *	complete.
 *
 * WT_PREPARE_RESOLVED:
 *	Represents the commit state of the prepared update.
 *
 * State Transition:
 * 	From uncommitted -> prepare -> commit:
 * 	INIT --> INPROGRESS --> LOCKED --> RESOLVED
 * 	LOCKED will be a momentary phase during timestamp update.
 *
 * 	From uncommitted -> prepare -> rollback:
 * 	INIT --> INPROGRESS
 * 	Prepare state will not be updated during rollback and will continue to
 * 	have the state as INPROGRESS.
 ','line_number':791,'multiline':True]['text':' Must be 0, as structures will be default initialized with 0. ','line_number':824,'multiline':True]['text':'
 * Page state.
 *
 * Synchronization is based on the WT_REF->state field, which has a number of
 * possible states:
 *
 * WT_REF_DISK:
 *	The initial setting before a page is brought into memory, and set as a
 *	result of page eviction; the page is on disk, and must be read into
 *	memory before use.  WT_REF_DISK has a value of 0 (the default state
 *	after allocating cleared memory).
 *
 * WT_REF_DELETED:
 *	The page is on disk, but has been deleted from the tree; we can delete
 *	row-store and VLCS leaf pages without reading them if they don't
 *	reference overflow items.
 *
 * WT_REF_LOCKED:
 *	Locked for exclusive access.  In eviction, this page or a parent has
 *	been selected for eviction; once hazard pointers are checked, the page
 *	will be evicted.  When reading a page that was previously deleted, it
 *	is locked until the page is in memory and the deletion has been
 *      instantiated with tombstone updates. The thread that set the page to
 *      WT_REF_LOCKED has exclusive access; no other thread may use the WT_REF
 *      until the state is changed.
 *
 * WT_REF_MEM:
 *	Set by a reading thread once the page has been read from disk; the page
 *	is in the cache and the page reference is OK.
 *
 * WT_REF_SPLIT:
 *	Set when the page is split; the WT_REF is dead and can no longer be
 *	used.
 *
 * The life cycle of a typical page goes like this: pages are read into memory
 * from disk and their state set to WT_REF_MEM.  When the page is selected for
 * eviction, the page state is set to WT_REF_LOCKED.  In all cases, evicting
 * threads reset the page's state when finished with the page: if eviction was
 * successful (a clean page was discarded, and a dirty page was written to disk
 * and then discarded), the page state is set to WT_REF_DISK; if eviction failed
 * because the page was busy, page state is reset to WT_REF_MEM.
 *
 * Readers check the state field and if it's WT_REF_MEM, they set a hazard
 * pointer to the page, flush memory and re-confirm the page state.  If the
 * page state is unchanged, the reader has a valid reference and can proceed.
 *
 * When an evicting thread wants to discard a page from the tree, it sets the
 * WT_REF_LOCKED state, flushes memory, then checks hazard pointers.  If a
 * hazard pointer is found, state is reset to WT_REF_MEM, restoring the page
 * to the readers.  If the evicting thread does not find a hazard pointer,
 * the page is evicted.
 ','line_number':830,'multiline':True]['text':'
 * WT_PAGE_DELETED --
 *	Information about how they got deleted for deleted pages. This structure records the
 *      transaction that deleted the page, plus the state the ref was in when the deletion happened.
 *      This structure is akin to an update but applies to a whole page.
 ','line_number':883,'multiline':True]['text':'
     * Transaction IDs are set when updates are created (before they become visible) and only change
     * when marked with WT_TXN_ABORTED. Transaction ID readers expect to copy a transaction ID into
     * a local variable and see a stable value. In case a compiler might re-read the transaction ID
     * from memory rather than using the local variable, mark the shared transaction IDs volatile to
     * prevent unexpected repeated/reordered reads.
     ','line_number':890,'multiline':True]['text':' Transaction ID ','line_number':897,'multiline':True]['text':' Timestamps ','line_number':899,'multiline':True]['text':'
     * The prepare state is used for transaction prepare to manage visibility and propagating the
     * prepare state to the updates generated at instantiation time.
     ','line_number':902,'multiline':True]['text':'
     * The previous state of the WT_REF; if the fast-truncate transaction is rolled back without the
     * page first being instantiated, this is the state to which the WT_REF returns.
     ','line_number':908,'multiline':True]['text':'
     * If the fast-truncate transaction has committed. If we're forced to instantiate the page, and
     * the committed flag isn't set, we have to create an update structure list for the transaction
     * to resolve in a subsequent commit. (This is tricky: if the transaction is rolled back, the
     * entire structure is discarded, that is, the flag is set only on commit and not on rollback.)
     ','line_number':914,'multiline':True]['text':' Flag to indicate fast-truncate is written to disk. ','line_number':922,'multiline':True]['text':'
 * WT_REF_HIST --
 *	State information of a ref at a single point in time.
 ','line_number':926,'multiline':True]['text':'
 * WT_PREFETCH_QUEUE_ENTRY --
 *	Queue entry for pages queued for pre-fetch.
 ','line_number':939,'multiline':True]['text':' List of pages queued for pre-fetch. ','line_number':947,'multiline':True]['text':'
 * WT_REF --
 *	A single in-memory page and state information.
 ','line_number':950,'multiline':True]['text':' Page ','line_number':955,'multiline':True]['text':'
     * When the tree deepens as a result of a split, the home page value changes. Don't cache it, we
     * need to see that change when looking up our slot in the page's index structure.
     ','line_number':957,'multiline':True]['text':' Reference page ','line_number':961,'multiline':True]['text':' Reference page index hint ','line_number':962,'multiline':True]['text':' Padding: before the flags field so flags can be easily expanded. ','line_number':964,'multiline':True]['text':'
 * Define both internal- and leaf-page flags for now: we only need one, but it provides an easy way
 * to assert a page-type flag is always set (we allocate WT_REFs in lots of places and it's easy to
 * miss one). If we run out of bits in the flags field, remove the internal flag and rewrite tests
 * depending on it to be "!leaf" instead.
 ','line_number':966,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':972,'multiline':True]['text':' Page is an internal page ','line_number':973,'multiline':True]['text':' Page is a leaf page ','line_number':974,'multiline':True]['text':' Page is on the pre-fetch queue ','line_number':975,'multiline':True]['text':' Page is being read in ','line_number':976,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 8 ','line_number':977,'multiline':True]['text':' Page is on disk ','line_number':980,'multiline':True]['text':' Page is on disk, but deleted ','line_number':981,'multiline':True]['text':' Page locked for exclusive access ','line_number':982,'multiline':True]['text':' Page is in cache and valid ','line_number':983,'multiline':True]['text':' Parent page split (WT_REF dead) ','line_number':984,'multiline':True]['text':' Page state ','line_number':985,'multiline':True]['text':'
     * Address: on-page cell if read from backing block, off-page WT_ADDR if instantiated in-memory,
     * or NULL if page created in-memory.
     ','line_number':987,'multiline':True]['text':'
     * The child page's key.  Do NOT change this union without reviewing
     * __wt_ref_key.
     ','line_number':993,'multiline':True]['text':' Column-store: starting recno ','line_number':998,'multiline':True]['text':' Row-store: key ','line_number':999,'multiline':True]['text':'
     * Page deletion information, written-to/read-from disk as necessary in the internal page's
     * address cell. (Deleted-address cells are also referred to as "proxy cells".) When a WT_REF
     * first becomes part of a fast-truncate operation, the page_del field is allocated and
     * initialized; it is similar to an update and holds information about the transaction that
     * performed the truncate. It can be discarded and set to NULL when that transaction reaches
     * global visibility.
     *
     * Operations other than truncate that produce deleted pages (checkpoint cleanup, reconciliation
     * as empty, etc.) leave the page_del field NULL as in these cases the deletion is already
     * globally visible.
     *
     * Once the deletion is globally visible, the original on-disk page is no longer needed and can
     * be discarded; this happens the next time the parent page is reconciled, either by eviction or
     * by a checkpoint. The ref remains, however, and still occupies the same key space in the table
     * that it always did.
     *
     * Deleted refs (and thus chunks of the tree namespace) are only discarded at two points: when
     * the parent page is discarded after being evicted, or in the course of internal page splits
     * and reverse splits. Until this happens, the "same" page can be brought back to life by
     * writing to its portion of the key space.
     *
     * A deleted page needs to be "instantiated" (read in from disk and converted to an in-memory
     * page where every item on the page has been individually deleted) if we need to position a
     * cursor on the page, or if we need to visit it for other reasons. Logic exists to avoid that
     * in various common cases (see: __wt_btcur_skip_page, __wt_delete_page_skip) but in many less
     * common situations we proceed with instantiation anyway to avoid multiplying the number of
     * special cases in the system.
     *
     * Common triggers for instantiation include: another thread reading from the page before a
     * truncate commits; an older reader visiting a page after a truncate commits; a thread reading
     * the page via a checkpoint cursor if the truncation wasn't yet globally visible at checkpoint
     * time; a thread reading the page after shutdown and restart under similar circumstances; RTS
     * needing to roll back a committed but unstable truncation (and possibly also updates that
     * occurred before the truncation); and a thread writing to the truncated portion of the table
     * space after the truncation but before the page is completely discarded.
     *
     * If the page must be instantiated for any reason: (1) for each entry on the page a WT_UPDATE
     * is created; (2) the transaction information from page_del is copied to those WT_UPDATE
     * structures (making them a match for the truncate operation), and (3) the WT_REF state
     * switches to WT_REF_MEM.
     *
     * If the fast-truncate operation has not yet committed, an array of references to the WT_UPDATE
     * structures is placed in modify->inst_updates. This is used to find the updates when the
     * operation subsequently resolves. (The page can split, so there needs to be some way to find
     * all of the update structures.)
     *
     * After instantiation, the page_del structure is kept until the instantiated page is next
     * reconciled. This is because in some cases reconciliation of the parent internal page may need
     * to write out a reference to the pre-instantiated on-disk page, at which point the page_del
     * information is needed to build the correct reference.
     *
     * If the ref is in WT_REF_DELETED state, all actions besides checking whether page_del is NULL
     * require that the WT_REF be locked. There are two reasons for this: first, the page might be
     * instantiated at any time, and it is important to not see a partly-completed instantiation;
     * and second, the page_del structure is discarded opportunistically if its transaction is found
     * to be globally visible, so accessing it without locking the ref is unsafe.
     *
     * If the ref is in WT_REF_MEM state because it has been instantiated, the safety requirements
     * are somewhat looser. Checking for an instantiated page by examining modify->instantiated does
     * not require locking. Checking if modify->inst_updates is non-NULL (which means that the
     * truncation isn't committed) also doesn't require locking. In general the page_del structure
     * should not be used after instantiation; exceptions are (a) it is still updated by transaction
     * prepare, commit, and rollback (so that it remains correct) and (b) it is used by internal
     * page reconciliation if that occurs before the instantiated child is itself reconciled. (The
     * latter can only happen if the child is evicted in a fairly narrow time window during a
     * checkpoint.) This still requires locking the ref.
     *
     * It is vital to consider all the possible cases when touching a deleted or instantiated page.
     *
     * There are two major groups of states:
     *
     * 1. The WT_REF state is WT_REF_DELETED. This means the page is deleted and not in memory.
     *    - If the page has no disk address, the ref is a placeholder in the key space and may in
     *      general be discarded at the next opportunity. (Some restrictions apply in VLCS.)
     *    - If the page has a disk address, page_del may be NULL. In this case, the deletion of the
     *      page is globally visible and the on-disk page can be discarded at the next opportunity.
     *    - If the page has a disk address and page_del is not NULL, page_del contains information
     *      about the transaction that deleted the page. It is necessary to lock the ref to read
     *      page_del; at that point (if the state hasn't changed while getting the lock)
     *      page_del->committed can be used to check if the transaction is committed or not.
     *
     * 2. The WT_REF state is WT_REF_MEM. The page is either an ordinary page or an instantiated
     * deleted page.
     *    - If ref->page->modify is NULL, the page is ordinary.
     *    - If ref->page->modify->instantiated is false and ref->page->modify->inst_updates is NULL,
     *      the page is ordinary.
     *    - If ref->page->modify->instantiated is true, the page is instantiated and has not yet
     *      been reconciled. ref->page_del is either NULL (meaning the deletion is globally visible)
     *      or contains information about the transaction that deleted the page. This information is
     *      only meaningful either (a) in relation to the existing on-disk page rather than the in-
     *      memory page (this can be needed to reconcile the parent internal page) or (b) if the
     *      page is clean.
     *    - If ref->page->modify->inst_updates is not NULL, the page is instantiated and the
     *      transaction that deleted it has not resolved yet. The update list is used during commit
     *      or rollback to find the updates created during instantiation.
     *
     * The last two points of group (2) are orthogonal; that is, after instantiation the
     * instantiated flag and page_del structure (on the one hand) and the update list (on the other)
     * are used and discarded independently. The former persists only until the page is first
     * successfully reconciled; the latter persists until the transaction resolves. These events may
     * occur in either order.
     *
     * As described above, in any state in group (1) an access to the page may require it be read
     * into memory, at which point it moves into group (2). Instantiation always sets the
     * instantiated flag to true; the updates list is only created if the transaction has not yet
     * resolved at the point instantiation happens. (The ref is locked in both transaction
     * resolution and instantiation to make sure these events happen in a well-defined order.)
     *
     * Because internal pages with uncommitted (including prepared) deletions are not written to
     * disk, a page instantiated after its parent was read from disk will always have inst_updates
     * set to NULL.
     ','line_number':1006,'multiline':True]['text':' Page-delete information for a deleted page. ','line_number':1119,'multiline':True]['text':'
 * In DIAGNOSTIC mode we overwrite the WT_REF on free to force failures, but we want to retain ref
 * state history. Don't overwrite these fields.
 ','line_number':1122,'multiline':True]['text':' Capture history of ref state changes. ','line_number':1128,'multiline':True]['text':'
 * WT_REF_SIZE is the expected structure size -- we verify the build to ensure the compiler hasn't
 * inserted padding which would break the world.
 ','line_number':1152,'multiline':True]['text':' A macro wrapper allowing us to remember the callers code location ','line_number':1162,'multiline':True]['text':'
 * WT_ROW --
 * Each in-memory page row-store leaf page has an array of WT_ROW structures:
 * this is created from on-page data when a page is read from the file.  It's
 * sorted by key, fixed in size, and starts with a reference to on-page data.
 *
 * Multiple threads of control may be searching the in-memory row-store pages,
 * and the key may be instantiated at any time.  Code must be able to handle
 * both when the key has not been instantiated (the key field points into the
 * page's disk image), and when the key has been instantiated (the key field
 * points outside the page's disk image).  We don't need barriers because the
 * key is updated atomically, but code that reads the key field multiple times
 * is a very, very bad idea.  Specifically, do not do this:
 *
 *	key = rip->key;
 *	if (key_is_on_page(key)) {
 *		cell = rip->key;
 *	}
 *
 * The field is declared volatile (so the compiler knows it shouldn't read it
 * multiple times), and we obscure the field name and use a copy macro in all
 * references to the field (so the code doesn't read it multiple times), all
 * to make sure we don't introduce this bug (again).
 ','line_number':1180,'multiline':True]['text':' On-page key, on-page cell, or off-page WT_IKEY ','line_number':1204,'multiline':True]['text':'
 * WT_ROW_FOREACH --
 *	Walk the entries of an in-memory row-store leaf page.
 ','line_number':1210,'multiline':True]['text':'
 * WT_ROW_SLOT --
 *	Return the 0-based array offset based on a WT_ROW reference.
 ','line_number':1220,'multiline':True]['text':'
 * WT_COL -- Each in-memory variable-length column-store leaf page has an array of WT_COL
 * structures: this is created from on-page data when a page is read from the file. It's fixed in
 * size, and references data on the page.
 ','line_number':1226,'multiline':True]['text':'
     * Variable-length column-store data references are page offsets, not pointers (we boldly
     * re-invent short pointers). The trade-off is 4B per K/V pair on a 64-bit machine vs. a single
     * cycle for the addition of a base pointer. The on-page data is a WT_CELL (same as row-store
     * pages).
     *
     * Obscure the field name, code shouldn't use WT_COL->__col_value, the public interface is
     * WT_COL_PTR and WT_COL_PTR_SET.
     ','line_number':1232,'multiline':True]['text':'
 * WT_COL_PTR, WT_COL_PTR_SET --
 *	Return/Set a pointer corresponding to the data offset. (If the item does
 * not exist on the page, return a NULL.)
 ','line_number':1244,'multiline':True]['text':'
 * WT_COL_FOREACH --
 *	Walk the entries of variable-length column-store leaf page.
 ','line_number':1252,'multiline':True]['text':'
 * WT_COL_SLOT --
 *	Return the 0-based array offset based on a WT_COL reference.
 ','line_number':1259,'multiline':True]['text':'
 * WT_IKEY --
 *  Instantiated key: row-store keys are usually prefix compressed or overflow objects.
 *  Normally, a row-store page in-memory key points to the on-page WT_CELL, but in some
 *  cases, we instantiate the key in memory, in which case the row-store page in-memory
 *  key points to a WT_IKEY structure.
 ','line_number':1265,'multiline':True]['text':' Key length ','line_number':1273,'multiline':True]['text':'
     * If we no longer point to the key's on-page WT_CELL, we can't find its
     * related value.  Save the offset of the key cell in the page.
     *
     * Row-store cell references are page offsets, not pointers (we boldly
     * re-invent short pointers).  The trade-off is 4B per K/V pair on a
     * 64-bit machine vs. a single cycle for the addition of a base pointer.
     ','line_number':1275,'multiline':True]['text':' The key bytes immediately follow the WT_IKEY structure. ','line_number':1285,'multiline':True]['text':'
 * WT_UPDATE --
 *
 * Entries on leaf pages can be updated, either modified or deleted. Updates to entries in the
 * WT_ROW and WT_COL arrays are stored in the page's WT_UPDATE array. When the first element on a
 * page is updated, the WT_UPDATE array is allocated, with one slot for every existing element in
 * the page. A slot points to a WT_UPDATE structure; if more than one update is done for an entry,
 * WT_UPDATE structures are formed into a forward-linked list.
 ','line_number':1289,'multiline':True]['text':'
     * Transaction IDs are set when updates are created (before they become visible) and only change
     * when marked with WT_TXN_ABORTED. Transaction ID readers expect to copy a transaction ID into
     * a local variable and see a stable value. In case a compiler might re-read the transaction ID
     * from memory rather than using the local variable, mark the shared transaction IDs volatile to
     * prevent unexpected repeated/reordered reads.
     ','line_number':1299,'multiline':True]['text':' transaction ID ','line_number':1306,'multiline':True]['text':' timestamps ','line_number':1308,'multiline':True]['text':'
     * The durable timestamp of the previous update in the update chain. This timestamp is used for
     * diagnostic checks only, and could be removed to reduce the size of the structure should that
     * be necessary.
     ','line_number':1311,'multiline':True]['text':' forward-linked list ','line_number':1318,'multiline':True]['text':' data length ','line_number':1320,'multiline':True]['text':' diagnostic check ','line_number':1322,'multiline':True]['text':' partial-update modify value ','line_number':1323,'multiline':True]['text':' reserved ','line_number':1324,'multiline':True]['text':' complete value ','line_number':1325,'multiline':True]['text':' deleted ','line_number':1326,'multiline':True]['text':' type (one byte to conserve memory); also read-only after initialization ','line_number':1327,'multiline':True]['text':' If the update includes a complete value. ','line_number':1329,'multiline':True]['text':'
     * The update state is used for transaction prepare to manage visibility and transitioning
     * update structure state safely.
     ','line_number':1333,'multiline':True]['text':' prepare state ','line_number':1337,'multiline':True]['text':' When introducing a new flag, consider adding it to WT_UPDATE_SELECT_FOR_DS. ','line_number':1339,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':1340,'multiline':True]['text':' Update has been written to the data store. ','line_number':1341,'multiline':True]['text':' Update has been written to history store. ','line_number':1342,'multiline':True]['text':' Prepared update restored from data store. ','line_number':1343,'multiline':True]['text':' Fast truncate instantiation ','line_number':1344,'multiline':True]['text':' Update restored from data store. ','line_number':1345,'multiline':True]['text':' Update restored from history store. ','line_number':1346,'multiline':True]['text':' Update needs to be deleted from history store ','line_number':1347,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 8 ','line_number':1348,'multiline':True]['text':' There are several cases we should select the update irrespective of visibility to write to the
 * disk image:
 *
 * 1. A previous reconciliation selected this update as writing anything that is older
 * undoes the previous work.
 *
 * 2. The update is restored from the disk image as writing anything that is older undoes
 * the previous work.
 *
 * 3. An earlier reconciliation performed an update-restore eviction and this update was
 * restored from disk.
 *
 * 4. We rolled back a prepared transaction and restored an update from the history store.
 *
 * 5. We rolled back a prepared transaction and aim to delete the following update from the
 * history store.
 *
 * These scenarios can happen if the current reconciliation has a limited visibility of
 * updates compared to one of the previous reconciliations. This is important as it is never
 * ok to undo the work of the previous reconciliations.
 ','line_number':1351,'multiline':True]['text':'
     * Zero or more bytes of value (the payload) immediately follows the WT_UPDATE structure. We use
     * a C99 flexible array member which has the semantics we want.
     ','line_number':1375,'multiline':True]['text':' start of the data ','line_number':1379,'multiline':True]['text':'
 * WT_UPDATE_SIZE is the expected structure size excluding the payload data -- we verify the build
 * to ensure the compiler hasn't inserted padding.
 ','line_number':1382,'multiline':True]['text':'
 * If there is no value, ensure that the memory allocation size matches that returned by sizeof().
 * Otherwise bit-exact tools like MSan may infer the structure is not completely initialized.
 ','line_number':1388,'multiline':True]['text':'
 * The memory size of an update: include some padding because this is such a common case that
 * overhead of tiny allocations can swamp our cache overhead calculation.
 ','line_number':1394,'multiline':True]['text':'
 * WT_UPDATE_VALUE --
 *
 * A generic representation of an update's value regardless of where it exists. This structure is
 * used to represent both in-memory updates and updates that don't exist in an update list such as
 * reconstructed modify updates, updates in the history store and onpage values.
 *
 * The skip buffer flag is an optimization for callers of various read functions to communicate that
 * they just want to check that an update exists and not read its underlying value. This means that
 * the read functions can avoid the performance penalty of reconstructing modifies.
 ','line_number':1400,'multiline':True]['text':'
 * WT_WITH_UPDATE_VALUE_SKIP_BUF --
 *
 * A helper macro to use for calling read functions when we're checking for the existence of a given
 * key. This means that read functions can avoid the performance penalty of reconstructing modifies.
 ','line_number':1418,'multiline':True]['text':'
 * WT_MODIFY_UPDATE_MIN/MAX, WT_MODIFY_VECTOR_STACK_SIZE
 *	Limit update chains value to avoid penalizing reads and permit truncation. Having a smaller
 * value will penalize the cases when history has to be maintained, resulting in multiplying cache
 * pressure.
 *
 * When threads race modifying a record, we can end up with more than the usual maximum number of
 * modifications in an update list. We use small vectors of modify updates in a couple of places to
 * avoid heap allocation, add a few additional slots to that array.
 ','line_number':1431,'multiline':True]['text':' Update count before we bother checking anything else ','line_number':1441,'multiline':True]['text':' Update count hard limit ','line_number':1442,'multiline':True]['text':'
 * WT_UPDATE_VECTOR --
 * 	A resizable array for storing updates. The allocation strategy is similar to that of
 *	llvm::SmallVector<T> where we keep space on the stack for the regular case but fall back to
 *	dynamic allocation as needed.
 ','line_number':1445,'multiline':True]['text':'
 * WT_MODIFY_MEM_FRACTION
 *	Limit update chains to a fraction of the base document size.
 ','line_number':1459,'multiline':True]['text':'
 * WT_INSERT --
 *
 * Row-store leaf pages support inserts of new K/V pairs. When the first K/V pair is inserted, the
 * WT_INSERT_HEAD array is allocated, with one slot for every existing element in the page, plus one
 * additional slot. A slot points to a WT_INSERT_HEAD structure for the items which sort after the
 * WT_ROW element that references it and before the subsequent WT_ROW element; the skiplist
 * structure has a randomly chosen depth of next pointers in each inserted node.
 *
 * The additional slot is because it's possible to insert items smaller than any existing key on the
 * page: for that reason, the first slot of the insert array holds keys smaller than any other key
 * on the page.
 *
 * In column-store variable-length run-length encoded pages, a single indx entry may reference a
 * large number of records, because there's a single on-page entry representing many identical
 * records. (We don't expand those entries when the page comes into memory, as that would require
 * resources as pages are moved to/from the cache, including read-only files.) Instead, a single
 * indx entry represents all of the identical records originally found on the page.
 *
 * Modifying (or deleting) run-length encoded column-store records is hard because the page's entry
 * no longer references a set of identical items. We handle this by "inserting" a new entry into the
 * insert array, with its own record number. (This is the only case where it's possible to insert
 * into a column-store: only appends are allowed, as insert requires re-numbering subsequent
 * records. Berkeley DB did support mutable records, but it won't scale and it isn't useful enough
 * to re-implement, IMNSHO.)
 ','line_number':1465,'multiline':True]['text':' value ','line_number':1492,'multiline':True]['text':' column-store record number ','line_number':1495,'multiline':True]['text':' row-store key data start ','line_number':1497,'multiline':True]['text':' row-store key data size ','line_number':1498,'multiline':True]['text':' forward-linked skip list ','line_number':1506,'multiline':True]['text':'
 * Skiplist helper macros.
 ','line_number':1509,'multiline':True]['text':'
 * Atomically allocate and swap a structure or array into place.
 ','line_number':1520,'multiline':True]['text':'
 * WT_INSERT_HEAD --
 * 	The head of a skiplist of WT_INSERT items.
 ','line_number':1534,'multiline':True]['text':' first item on skiplists ','line_number':1539,'multiline':True]['text':' last item on skiplists ','line_number':1540,'multiline':True]['text':'
 * The row-store leaf page insert lists are arrays of pointers to structures, and may not exist. The
 * following macros return an array entry if the array of pointers and the specific structure exist,
 * else NULL.
 ','line_number':1543,'multiline':True]['text':'
 * WT_ROW_INSERT_SMALLEST references an additional slot past the end of the "one per WT_ROW slot"
 * insert array. That's because the insert array requires an extra slot to hold keys that sort
 * before any key found on the original page.
 ','line_number':1557,'multiline':True]['text':'
 * The column-store leaf page update lists are arrays of pointers to structures, and may not exist.
 * The following macros return an array entry if the array of pointers and the specific structure
 * exist, else NULL.
 ','line_number':1567,'multiline':True]['text':'
 * WT_COL_UPDATE_SINGLE is a single WT_INSERT list, used for any fixed-length column-store updates
 * for a page.
 ','line_number':1578,'multiline':True]['text':'
 * WT_COL_APPEND is an WT_INSERT list, used for fixed- and variable-length appends.
 ','line_number':1584,'multiline':True]['text':' WT_COL_FIX_FOREACH_BITS walks fixed-length bit-fields on a disk page. ','line_number':1592,'multiline':True]['text':'
 * FLCS pages with time information have a small additional header after the main page data that
 * holds a version number and cell count, plus the byte offset to the start of the cell data. The
 * latter values are limited by the page size, so need only be 32 bits. One hopes we'll never need
 * 2^32 versions.
 *
 * This struct is the in-memory representation. The number of entries is the number of time windows
 * (there are twice as many cells) and the offsets is from the beginning of the page. The space
 * between the empty offset and the data offset is not used and is expected to be zeroed.
 *
 * This structure is only used when handling on-disk pages; once the page is read in, one should
 * instead use the time window index in the page structure, which is a different type found above.
 ','line_number':1603,'multiline':True]['text':'
 * The on-disk auxiliary header uses a 1-byte version (the header must always begin with a nonzero
 * byte) and packed integers for the entry count and offset. To make the size of the offset entry
 * predictable (rather than dependent on the total page size) and also as small as possible, we
 * store the distance from the auxiliary data. To avoid complications computing the offset, we
 * include the offset's own storage space in the offset, and to make things simpler all around, we
 * include the whole auxiliary header in the offset; that is, the position of the auxiliary data is
 * computed as the position of the start of the auxiliary header plus the decoded stored offset.
 *
 * Both the entry count and the offset are limited to 32 bits because pages may not exceed 4G, so
 * their maximum encoded lengths are 5 each, so the maximum size of the on-disk header is 11 bytes.
 * It can be as small as 3 bytes, though.
 *
 * We reserve 7 bytes for the header on a full page (not 11) because on a full page the encoded
 * offset is the reservation size, and 7 encodes in one byte. This is enough for all smaller pages:
 * obviously if there's at least 4 extra bytes in the bitmap space any header will fit (4 + 7 = 11)
 * and if there's less the encoded offset is less than 11, which still encodes to one byte.
 ','line_number':1623,'multiline':True]['text':' Values for ->version. Version 0 never appears in an on-disk header. ','line_number':1645,'multiline':True]['text':' Original page format with no timestamp data ','line_number':1646,'multiline':True]['text':' Upgraded format with cells carrying timestamp info ','line_number':1647,'multiline':True]['text':'
 * Manage split generation numbers. Splits walk the list of sessions to check when it is safe to
 * free structures that have been replaced. We also check that list periodically (e.g., when
 * wrapping up a transaction) to free any memory we can.
 *
 * Before a thread enters code that will examine page indexes (which are swapped out by splits), it
 * publishes a copy of the current split generation into its session. Don't assume that threads
 * never re-enter this code: if we already have a split generation, leave it alone. If our caller is
 * examining an index, we don't want the oldest split generation to move forward and potentially
 * free it.
 ','line_number':1649,'multiline':True]['text':'
 * Manage the given generation number with support for re-entry. Re-entry is allowed as the previous
 * generation as it must be as low as the current generation.
 ','line_number':1669,'multiline':True]['text':'
 * WT_VERIFY_INFO -- A structure to hold all the information related to a verify operation.
 ','line_number':1687,'multiline':True]['text':' Identifier included in error messages ','line_number':1693,'multiline':True]['text':' The disk header for the page being verified ','line_number':1694,'multiline':True]['text':' An item representing a page entry being verified ','line_number':1695,'multiline':True]['text':' The current cell offset being verified ','line_number':1697,'multiline':True]['text':' The current record number in a column store page ','line_number':1698,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':1700,'multiline':True]['text':' AUTOMATIC FLAG VALUE GENERATION STOP 32 ','line_number':1703,'multiline':True]