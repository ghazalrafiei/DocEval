['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]['text':'
 * __evict_lock_handle_list --
 *     Try to get the handle list lock, with yield and sleep back off. Keep timing statistics
 *     overall.
 ','line_number':25,'multiline':True]['text':'
     * Use a custom lock acquisition back off loop so the eviction server notices any interrupt
     * quickly.
     ','line_number':43,'multiline':True]['text':'
 * __evict_entry_priority --
 *     Get the adjusted read generation for an eviction entry.
 ','line_number':57,'multiline':True]['text':' Any page set to the oldest generation should be discarded. ','line_number':71,'multiline':True]['text':' Any page from a dead tree is a great choice. ','line_number':75,'multiline':True]['text':' Any empty page (leaf or internal), is a good choice. ','line_number':79,'multiline':True]['text':' Any large page in memory is likewise a good choice. ','line_number':83,'multiline':True]['text':'
     * The base read-generation is skewed by the eviction priority. Internal pages are also
     * adjusted, we prefer to evict leaf pages.
     ','line_number':87,'multiline':True]['text':'
 * __evict_lru_cmp_debug --
 *     Qsort function: sort the eviction array. Version for eviction debug mode.
 ','line_number':106,'multiline':True]['text':'
 * __evict_lru_cmp --
 *     Qsort function: sort the eviction array.
 ','line_number':124,'multiline':True]['text':'
 * __evict_list_clear --
 *     Clear an entry in the LRU eviction list.
 ','line_number':142,'multiline':True]['text':'
 * __evict_list_clear_page_locked --
 *     This function searches for the page in all the eviction queues (skipping the urgent queue if
 *     requested) and clears it if found. It does not take the eviction queue lock, so the caller
 *     should hold the appropriate locks before calling this function.
 ','line_number':157,'multiline':True]['text':'
 * __wt_evict_list_clear_page --
 *     Check whether a page is present in the LRU eviction list. If the page is found in the list,
 *     remove it. This is called from the page eviction code to make sure there is no attempt to
 *     evict a child page multiple times.
 ','line_number':191,'multiline':True]['text':' Fast path: if the page isn't in the queue, don't bother searching. ','line_number':204,'multiline':True]['text':' Remove the reference from the eviction queues. ','line_number':211,'multiline':True]['text':'
 * __evict_queue_empty --
 *     Is the queue empty? Note that the eviction server is pessimistic and treats a half full queue
 *     as empty.
 ','line_number':217,'multiline':True]['text':' The eviction server only considers half of the candidates. ','line_number':230,'multiline':True]['text':'
 * __evict_queue_full --
 *     Is the queue full (i.e., it has been populated with candidates and none of them have been
 *     evicted yet)?
 ','line_number':238,'multiline':True]['text':'
 * __wt_evict_server_wake --
 *     Wake the eviction server thread.
 ','line_number':249,'multiline':True]['text':'
 * __wt_evict_thread_chk --
 *     Check to decide if the eviction thread should continue running.
 ','line_number':276,'multiline':True]['text':'
 * __wt_evict_thread_run --
 *     Entry function for an eviction thread. This is called repeatedly from the thread group code
 *     so it does not need to loop itself.
 ','line_number':286,'multiline':True]['text':' Mark the session as an eviction thread session. ','line_number':302,'multiline':True]['text':'
     * Cache a history store cursor to avoid deadlock: if an eviction thread marks a file busy and
     * then opens a different file (in this case, the HS file), it can deadlock with a thread
     * waiting for the first file to drain from the eviction queue. See WT-5946 for details.
     ','line_number':305,'multiline':True]['text':'
         * Cannot use WT_WITH_PASS_LOCK because this is a try lock. Fix when that is supported. We
         * set the flag on both sessions because we may call clear_walk when we are walking with the
         * walk session, locked.
         ','line_number':312,'multiline':True]['text':'
         * If the eviction server was interrupted, wait until requests have been processed: the
         * system may otherwise be busy so don't go to sleep.
         ','line_number':326,'multiline':True]['text':' Don't rely on signals: check periodically. ','line_number':337,'multiline':True]['text':'
 * __wt_evict_thread_stop --
 *     Shutdown function for an eviction thread.
 ','line_number':351,'multiline':True]['text':'
     * The only time the first eviction thread is stopped is on shutdown: in case any trees are
     * still open, clear all walks now so that they can be closed.
     ','line_number':367,'multiline':True]['text':'
     * The only cases when the eviction server is expected to stop are when recovery is finished,
     * when the connection is closing or when an error has occurred and connection panic flag is
     * set.
     ','line_number':373,'multiline':True]['text':' Clear the eviction thread session flag. ','line_number':380,'multiline':True]['text':'
 * __evict_server --
 *     Thread to evict pages from the cache.
 ','line_number':392,'multiline':True]['text':' Assume there has been no progress. ','line_number':405,'multiline':True]['text':' Evict pages from the cache as needed. ','line_number':413,'multiline':True]['text':'
         * Try to get the handle list lock: if we give up, that indicates a session is waiting for
         * us to clear walks. Do that as part of a normal pass (without the handle list lock) to
         * avoid deadlock.
         ','line_number':420,'multiline':True]['text':'
         * Clear the walks so we don't pin pages while asleep, otherwise we can block applications
         * evicting large pages.
         ','line_number':429,'multiline':True]['text':' Make sure we'll notice next time we're stuck. ','line_number':438,'multiline':True]['text':' Track if work was done. ','line_number':443,'multiline':True]['text':' Eviction is stuck, check if we have made progress. ','line_number':447,'multiline':True]['text':' Need verbose check only if not in diagnostic build ','line_number':450,'multiline':True]['text':' Need verbose check only if not in diagnostic build ','line_number':458,'multiline':True]['text':'
     * If we're stuck for 5 minutes in diagnostic mode, or the verbose evict_stuck flag is
     * configured, log the cache and transaction state.
     *
     * If we're stuck for 5 minutes in diagnostic mode, give up.
     *
     * We don't do this check for in-memory workloads because application threads are not blocked by
     * the cache being full. If the cache becomes full of clean pages, we can be servicing reads
     * while the cache appears stuck to eviction.
     ','line_number':462,'multiline':True]['text':' The checks below should only be executed when a cache timeout has been set. ','line_number':477,'multiline':True]['text':' Enable extra logs 20ms before timing out. ','line_number':481,'multiline':True]['text':' Reset the timer. ','line_number':501,'multiline':True]['text':'
 * __wt_evict_create --
 *     Start the eviction server.
 ','line_number':510,'multiline':True]['text':'
     * In case recovery has allocated some transaction IDs, bump to the current state. This will
     * prevent eviction threads from pinning anything as they start up and read metadata in order to
     * open cursors.
     ','line_number':522,'multiline':True]['text':' Set first, the thread might run before we finish up. ','line_number':530,'multiline':True]['text':'
     * Create the eviction thread group. Set the group size to the maximum allowed sessions.
     ','line_number':533,'multiline':True]['text':'
 * Ensure the cache stuck timer is initialized when starting eviction.
 ','line_number':541,'multiline':True]['text':' Need verbose check only if not in diagnostic build ','line_number':545,'multiline':True]['text':'
     * Allow queues to be populated now that the eviction threads are running.
     ','line_number':550,'multiline':True]['text':'
 * __wt_evict_destroy --
 *     Destroy the eviction threads.
 ','line_number':558,'multiline':True]['text':' We are done if the eviction server didn't start successfully. ','line_number':569,'multiline':True]['text':' Wait for any eviction thread group changes to stabilize. ','line_number':573,'multiline':True]['text':'
     * Signal the threads to finish and stop populating the queue.
     ','line_number':576,'multiline':True]['text':'
     * We call the destroy function still holding the write lock. It assumes it is called locked.
     ','line_number':585,'multiline':True]['text':'
 * __evict_update_work --
 *     Configure eviction work state.
 ','line_number':593,'multiline':True]['text':' Build up the new state. ','line_number':617,'multiline':True]['text':'
     * TODO: We are caching the cache usage values associated with the history store because the
     * history store dhandle isn't always available to eviction. Keeping potentially out-of-date
     * values could lead to surprising bugs in the future.
     ','line_number':628,'multiline':True]['text':'
     * If we need space in the cache, try to find clean pages to evict.
     *
     * Avoid division by zero if the cache size has not yet been set in a shared cache.
     ','line_number':638,'multiline':True]['text':'
     * If application threads are blocked by the total volume of data in cache, try dirty pages as
     * well.
     ','line_number':662,'multiline':True]['text':'
     * Scrub dirty pages and keep them in cache if we are less than half way to the clean, dirty or
     * updates triggers.
     ','line_number':669,'multiline':True]['text':'
     * With an in-memory cache, we only do dirty eviction in order to scrub pages.
     ','line_number':685,'multiline':True]['text':' Update the global eviction state. ','line_number':696,'multiline':True]['text':'
 * __evict_pass --
 *     Evict pages from memory.
 ','line_number':702,'multiline':True]['text':' [-Wconditional-uninitialized] ','line_number':719,'multiline':True]['text':' Track whether pages are being evicted and progress is made. ','line_number':721,'multiline':True]['text':' Evict pages from the cache. ','line_number':725,'multiline':True]['text':'
         * Increment the shared read generation. Do this occasionally even if eviction is not
         * currently required, so that pages have some relative read generation when the eviction
         * server does need to do some work.
         ','line_number':732,'multiline':True]['text':'
         * Update the oldest ID: we use it to decide whether pages are candidates for eviction.
         * Without this, if all threads are blocked after a long-running transaction (such as a
         * checkpoint) completes, we may never start evicting again.
         *
         * Do this every time the eviction server wakes up, regardless of whether the cache is full,
         * to prevent the oldest ID falling too far behind. Don't wait to lock the table: with
         * highly threaded workloads, that creates a bottleneck.
         ','line_number':740,'multiline':True]['text':'
         * If the queue has been empty recently, keep queuing more pages to evict. If the rate of
         * queuing pages is high enough, this score will go to zero, in which case the eviction
         * server might as well help out with eviction.
         *
         * Also, if there is a single eviction server thread with no workers, it must service the
         * urgent queue in case all application threads are busy.
         ','line_number':761,'multiline':True]['text':'
         * If we're making progress, keep going; if we're not making any progress at all, mark the
         * cache "stuck" and go back to sleep, it's not something we can fix.
         *
         * We check for progress every 20ms, the idea being that the aggressive score will reach 10
         * after 200ms if we aren't making progress and eviction will start considering more pages.
         * If there is still no progress after 2s, we will treat the cache as stuck and start
         * rolling back transactions and writing updates to the history store table.
         ','line_number':777,'multiline':True]['text':'
             * Keep trying for long enough that we should be able to evict a page if the server
             * isn't interfering.
             ','line_number':798,'multiline':True]['text':'
                 * Back off if we aren't making progress: walks hold the handle list lock, blocking
                 * other operations that can free space in cache, such as LSM discarding handles.
                 *
                 * Allow this wait to be interrupted (e.g. if a checkpoint completes): make sure we
                 * wait for a non-zero number of microseconds).
                 ','line_number':803,'multiline':True]['text':'
 * __evict_clear_walk --
 *     Clear a single walk point.
 ','line_number':827,'multiline':True]['text':'
     * Clear evict_ref before releasing it in case that forces eviction (we assert that we never try
     * to evict the current eviction walk point).
     ','line_number':852,'multiline':True]['text':'
 * __evict_clear_all_walks --
 *     Clear the eviction walk points for all files a session is waiting on.
 ','line_number':863,'multiline':True]['text':'
 * __wt_evict_file_exclusive_on --
 *     Get exclusive eviction access to a file and discard any of the file's blocks queued for
 *     eviction.
 ','line_number':882,'multiline':True]['text':' Hold the walk lock to turn off eviction. ','line_number':899,'multiline':True]['text':'
     * Special operations don't enable eviction, however the underlying command (e.g. verify) may
     * choose to turn on eviction. This falls outside of the typical eviction flow, and here
     * eviction may forcibly remove pages from the cache. Consequently, we may end up evicting
     * internal pages which still have child pages present on the pre-fetch queue. Remove any refs
     * still present on the pre-fetch queue so that they are not accidentally accessed in an invalid
     * way later on.
     ','line_number':906,'multiline':True]['text':'
     * Ensure no new pages from the file will be queued for eviction after this point, then clear
     * any existing LRU eviction walk for the file.
     ','line_number':917,'multiline':True]['text':'
     * The eviction candidate list might reference pages from the file, clear it. Hold the evict
     * lock to remove queued pages from a file.
     ','line_number':926,'multiline':True]['text':'
     * We have disabled further eviction: wait for concurrent LRU eviction activity to drain.
     ','line_number':943,'multiline':True]['text':'
 * __wt_evict_file_exclusive_off --
 *     Release exclusive eviction access to a file.
 ','line_number':957,'multiline':True]['text':'
     * We have seen subtle bugs with multiple threads racing to turn eviction on/off. Make races
     * more likely in diagnostic builds.
     ','line_number':968,'multiline':True]['text':'
 * Atomically decrement the evict-disabled count, without acquiring the eviction walk-lock. We can't
 * acquire that lock here because there's a potential deadlock. When acquiring exclusive eviction
 * access, we acquire the eviction walk-lock and then the cache's pass-intr lock. The current
 * eviction implementation can hold the pass-intr lock and call into this function (see WT-3303 for
 * the details), which might deadlock with another thread trying to get exclusive eviction access.
 ','line_number':974,'multiline':True]['text':' Max workers to add each period ','line_number':994,'multiline':True]['text':'
                            * Data points needed before deciding if we should keep adding workers or
                            * settle on an earlier value.
                            ','line_number':995,'multiline':True]['text':' Tune period in milliseconds ','line_number':1000,'multiline':True]['text':'
 * We will do a fresh re-tune every that many milliseconds to adjust to significant phase changes.
 ','line_number':1002,'multiline':True]['text':'
 * __evict_tune_workers --
 *     Find the right number of eviction workers. Gradually ramp up the number of workers increasing
 *     the number in batches indicated by the setting above. Store the number of workers that gave
 *     us the best throughput so far and the number of data points we have tried. Every once in a
 *     while when we have the minimum number of data points we check whether the eviction throughput
 *     achieved with the current number of workers is the best we have seen so far. If so, we will
 *     keep increasing the number of workers. If not, we are past the infliction point on the
 *     eviction throughput curve. In that case, we will set the number of workers to the best
 *     observed so far and settle into a stable state.
 ','line_number':1007,'multiline':True]['text':'
     * If we have a fixed number of eviction threads, there is no value in calculating if we should
     * do any tuning.
     ','line_number':1031,'multiline':True]['text':'
     * If we have reached the stable state and have not run long enough to surpass the forced
     * re-tuning threshold, return.
     ','line_number':1041,'multiline':True]['text':'
         * Stable state was reached a long time ago. Let's re-tune. Reset all the state.
         ','line_number':1049,'multiline':True]['text':' Reduce the number of eviction workers by one ','line_number':1058,'multiline':True]['text':'
         * If we have not reached stable state, don't do anything unless enough time has passed
         * since the last time we have taken any action in this function.
         ','line_number':1068,'multiline':True]['text':'
     * Measure the evicted progress so far. Eviction rate correlates to performance, so this is our
     * metric of success.
     ','line_number':1074,'multiline':True]['text':'
     * If we have recorded the number of pages evicted at the end of the previous measurement
     * interval, we can compute the eviction rate in evicted pages per second achieved during the
     * current measurement interval. Otherwise, we just record the number of evicted pages and
     * return.
     ','line_number':1080,'multiline':True]['text':'
     * Keep track of the maximum eviction throughput seen and the number of workers corresponding to
     * that throughput.
     ','line_number':1094,'multiline':True]['text':'
     * Compare the current number of data points with the number needed variable. If they are equal,
     * we will check whether we are still going up on the performance curve, in which case we will
     * increase the number of needed data points, to provide opportunity for further increasing the
     * number of workers. Or we are past the inflection point on the curve, in which case we will go
     * back to the best observed number of workers and settle into a stable state.
     ','line_number':1103,'multiline':True]['text':'
             * Keep adding workers. We will check again at the next check point.
             ','line_number':1113,'multiline':True]['text':'
             * We are past the inflection point. Choose the best number of eviction workers observed
             * and settle into a stable state.
             ','line_number':1119,'multiline':True]['text':'
     * If we have not added any worker threads in the past, we set the number of data points needed
     * equal to the number of data points that we must accumulate before deciding if we should keep
     * adding workers or settle on a previously tried stable number of workers.
     ','line_number':1135,'multiline':True]['text':'
         * Start the new threads.
         ','line_number':1146,'multiline':True]['text':'
 * __evict_lru_pages --
 *     Get pages from the LRU queue to evict.
 ','line_number':1162,'multiline':True]['text':'
     * Reconcile and discard some pages: EBUSY is returned if a page fails eviction because it's
     * unavailable, continue in that case.
     ','line_number':1176,'multiline':True]['text':' If any resources are pinned, release them now. ','line_number':1184,'multiline':True]['text':' If a worker thread found the queue empty, pause. ','line_number':1187,'multiline':True]['text':'
 * __evict_lru_walk --
 *     Add pages to the LRU queue to be evicted from cache.
 ','line_number':1195,'multiline':True]['text':' Age out the score of how much the queue has been empty recently. ','line_number':1214,'multiline':True]['text':' Fill the next queue (that isn't the urgent queue). ','line_number':1218,'multiline':True]['text':' If this queue is full, try the other one. ','line_number':1223,'multiline':True]['text':'
     * If both queues are full and haven't been empty on recent refills, we're done.
     ','line_number':1227,'multiline':True]['text':'
     * If the queue we are filling is empty, pages are being requested faster than they are being
     * queued.
     ','line_number':1233,'multiline':True]['text':'
     * Get some more pages to consider for eviction.
     *
     * If the walk is interrupted, we still need to sort the queue: the next walk assumes there are
     * no entries beyond WT_EVICT_WALK_BASE.
     ','line_number':1245,'multiline':True]['text':' Sort the list into LRU order and restart. ','line_number':1255,'multiline':True]['text':'
     * We have locked the queue: in the (unusual) case where we are filling the current queue, mark
     * it empty so that subsequent requests switch to the other queue.
     ','line_number':1258,'multiline':True]['text':'
     * Style note: __wt_qsort is a macro that can leave a dangling else. Full curly braces are
     * needed here for the compiler.
     ','line_number':1266,'multiline':True]['text':' Trim empty entries from the end. ','line_number':1276,'multiline':True]['text':'
     * If we have more entries than the maximum tracked between walks, clear them. Do this before
     * figuring out how many of the entries are candidates so we never end up with more candidates
     * than entries.
     ','line_number':1280,'multiline':True]['text':'
         * If there are no entries, there cannot be any candidates. Make sure application threads
         * don't read past the end of the candidate list, or they may race with the next walk.
         ','line_number':1291,'multiline':True]['text':' Decide how many of the candidates we're going to try and evict. ','line_number':1301,'multiline':True]['text':'
         * Find the oldest read generation apart that we have in the queue, used to set the initial
         * value for pages read into the system. The queue is sorted, find the first "normal"
         * generation.
         ','line_number':1305,'multiline':True]['text':'
         * Take all candidates if we only gathered pages with an oldest
         * read generation set.
         *
         * We normally never take more than 50% of the entries but if
         * 50% of the entries were at the oldest read generation, take
         * all of them.
         ','line_number':1317,'multiline':True]['text':'
             * Take all of the urgent pages plus a third of ordinary candidates (which could be
             * expressed as WT_EVICT_WALK_INCR / WT_EVICT_WALK_BASE). In the steady state, we want
             * to get as many candidates as the eviction walk adds to the queue.
             *
             * That said, if there is only one entry, which is normal when populating an empty file,
             * don't exclude it.
             ','line_number':1330,'multiline':True]['text':'
     * Signal any application or helper threads that may be waiting to help with eviction.
     ','line_number':1347,'multiline':True]['text':'
 * __evict_walk_choose_dhandle --
 *     Randomly select a dhandle for the next eviction walk
 ','line_number':1357,'multiline':True]['text':'
     * If we don't have many dhandles, most hash buckets will be empty. Just pick a random dhandle
     * from the list in that case.
     ','line_number':1377,'multiline':True]['text':'
     * Keep picking up a random bucket until we find one that is not empty.
     ','line_number':1390,'multiline':True]['text':' We can't pick up an empty bucket with a non zero bucket count. ','line_number':1397,'multiline':True]['text':' Pick a random dhandle in the chosen bucket. ','line_number':1400,'multiline':True]['text':' Just step through dhandles. ','line_number':1406,'multiline':True]['text':'
 * __evict_walk --
 *     Fill in the array by walking the next set of pages.
 ','line_number':1421,'multiline':True]['text':'
     * Set the starting slot in the queue and the maximum pages added per walk.
     ','line_number':1447,'multiline':True]['text':'
     * Another pathological case: if there are only a tiny number of candidate pages in cache, don't
     * put all of them on one queue.
     ','line_number':1453,'multiline':True]['text':' We're done if shutting down or reconfiguring. ','line_number':1465,'multiline':True]['text':'
         * If another thread is waiting on the eviction server to clear the walk point in a tree,
         * give up.
         ','line_number':1469,'multiline':True]['text':'
         * Lock the dhandle list to find the next handle and bump its reference count to keep it
         * alive while we sweep.
         ','line_number':1476,'multiline':True]['text':'
             * On entry, continue from wherever we got to in the scan last time through. If we don't
             * have a saved handle, pick one randomly from the list.
             ','line_number':1486,'multiline':True]['text':' If we couldn't find any dhandle, we're done. ','line_number':1504,'multiline':True]['text':' Ignore non-btree handles, or handles that aren't open. ','line_number':1508,'multiline':True]['text':' Skip files that don't allow eviction. ','line_number':1512,'multiline':True]['text':'
         * Skip files that are checkpointing if we are only looking for dirty pages.
         ','line_number':1517,'multiline':True]['text':'
         * Skip files that are configured to stick in cache until we become aggressive.
         *
         * If the file is contributing heavily to our cache usage then ignore the "stickiness" of
         * its pages.
         ','line_number':1524,'multiline':True]['text':'
         * Skip files if we have too many active walks.
         *
         * This used to be limited by the configured maximum number of hazard pointers per session.
         * Even though that ceiling has been removed, we need to test eviction with huge numbers of
         * active trees before allowing larger numbers of hazard pointers in the walk session.
         ','line_number':1534,'multiline':True]['text':'
         * If we are filling the queue, skip files that haven't been useful in the past.
         ','line_number':1544,'multiline':True]['text':'
         * Re-check the "no eviction" flag, used to enforce exclusive access when a handle is being
         * closed.
         *
         * Only try to acquire the lock and simply continue if we fail; the lock is held while the
         * thread turning off eviction clears the tree's current eviction point, and part of the
         * process is waiting on this thread to acknowledge that action.
         *
         * If a handle is being discarded, it will still be marked open, but won't have a root page.
         ','line_number':1556,'multiline':True]['text':'
                 * Remember the file to visit first, next loop.
                 ','line_number':1568,'multiline':True]['text':'
             * If there is a checkpoint thread gathering handles, which means it is holding the
             * schema lock, then there is often contention on the evict walk lock with that thread.
             * If eviction is not in aggressive mode, sleep a bit to give the checkpoint thread a
             * chance to gather its handles.
             ','line_number':1579,'multiline':True]['text':'
     * Repeat the walks a few times if we don't find enough pages. Give up when we have some
     * candidates and we aren't finding more.
     ','line_number':1598,'multiline':True]['text':'
     * If we didn't find any entries on a walk when we weren't interrupted, let our caller know.
     ','line_number':1619,'multiline':True]['text':'
 * __evict_push_candidate --
 *     Initialize a WT_EVICT_ENTRY structure with a given page.
 ','line_number':1630,'multiline':True]['text':'
     * Threads can race to queue a page (e.g., an ordinary LRU walk can race with a page being
     * queued for urgent eviction).
     ','line_number':1641,'multiline':True]['text':' Keep track of the maximum slot we are using. ','line_number':1651,'multiline':True]['text':' Adjust for size when doing dirty eviction. ','line_number':1663,'multiline':True]['text':'
 * __evict_walk_target --
 *     Calculate how many pages to queue for a given tree.
 ','line_number':1671,'multiline':True]['text':'
 * The minimum number of pages we should consider per tree.
 ','line_number':1685,'multiline':True]['text':'
     * The target number of pages for this tree is proportional to the space it is taking up in
     * cache. Round to the nearest number of slots so we assign all of the slots to a tree filling
     * 99+% of the cache (and only have to walk it once).
     ','line_number':1690,'multiline':True]['text':'
     * Walk trees with a small fraction of the cache in case there are so many trees that none of
     * them use enough of the cache to be allocated slots. Only skip a tree if it has no bytes of
     * interest.
     ','line_number':1719,'multiline':True]['text':'
     * There is some cost associated with walking a tree. If we're going to visit this tree, always
     * look for a minimum number of pages.
     ','line_number':1733,'multiline':True]['text':' If the tree is dead, take a lot of pages. ','line_number':1740,'multiline':True]['text':'
 * __evict_walk_tree --
 *     Get a few page eviction candidates from a single underlying file.
 ','line_number':1747,'multiline':True]['text':'
     * Figure out how many slots to fill from this tree. Note that some care is taken in the
     * calculation to avoid overflow.
     ','line_number':1776,'multiline':True]['text':'
     * Reduce the number of pages to be selected from btrees other than the history store (HS) if
     * the cache pressure is high and HS content dominates the cache. Evicting unclean non-HS pages
     * can generate even more HS content and will not help with the cache pressure, and will
     * probably just amplify it further.
     ','line_number':1791,'multiline':True]['text':' If target pages are less than 10, keep it like that. ','line_number':1798,'multiline':True]['text':' If we don't want any pages from this tree, move on. ','line_number':1805,'multiline':True]['text':'
     * These statistics generate a histogram of the number of pages targeted for eviction each
     * round. The range of values here start at MIN_PAGES_PER_TREE as this is the smallest number of
     * pages we can target, unless there are fewer slots available. The aim is to cover the likely
     * ranges of target pages in as few statistics as possible to reduce the overall overhead.
     ','line_number':1809,'multiline':True]['text':'
     * Examine at least a reasonable number of pages before deciding whether to give up. When we are
     * only looking for dirty pages, search the tree for longer.
     ','line_number':1834,'multiline':True]['text':'
     * Choose a random point in the tree if looking for candidates in a tree with no starting point
     * set. This is mostly aimed at ensuring eviction fairly visits all pages in trees with a lot of
     * in-cache content.
     ','line_number':1859,'multiline':True]['text':' FALLTHROUGH ','line_number':1872,'multiline':True]['text':' Ensure internal pages indexes remain valid ','line_number':1878,'multiline':True]['text':'
     * Get some more eviction candidate pages, starting at the last saved point. Clear the saved
     * point immediately, we assert when discarding pages we're not discarding an eviction point, so
     * this clear must be complete before the page is released.
     ','line_number':1891,'multiline':True]['text':'
     * !!! Take care terminating this loop.
     *
     * Don't make an extra call to __wt_tree_walk after we hit the end of a
     * tree: that will leave a page pinned, which may prevent any work from
     * being done.
     *
     * Once we hit the page limit, do one more step through the walk in
     * case we are appending and only the last page in the file is live.
     ','line_number':1899,'multiline':True]['text':'
         * Check whether we're finding a good ratio of candidates vs pages seen. Some workloads
         * create "deserts" in trees where no good eviction candidates can be found. Abandon the
         * walk if we get into that situation.
         ','line_number':1914,'multiline':True]['text':'
             * Try a different walk start point next time if a walk gave up.
             ','line_number':1923,'multiline':True]['text':'
             * We differentiate the reasons we gave up on this walk and increment the stats
             * accordingly.
             ','line_number':1941,'multiline':True]['text':' Ignore root pages entirely. ','line_number':1970,'multiline':True]['text':' Count internal pages seen. ','line_number':1978,'multiline':True]['text':' Use the EVICT_LRU flag to avoid putting pages onto the list multiple times. ','line_number':1982,'multiline':True]['text':' Don't queue dirty pages in trees during checkpoints. ','line_number':1990,'multiline':True]['text':'
         * It's possible (but unlikely) to visit a page without a read generation, if we race with
         * the read instantiating the page. Set the page's read generation here to ensure a bug
         * doesn't somehow leave a page without a read generation.
         ','line_number':1996,'multiline':True]['text':' Pages being forcibly evicted go on the urgent queue. ','line_number':2004,'multiline':True]['text':'
         * If history store dirty content is dominating the cache, we want to prioritize evicting
         * history store pages over other btree pages. This helps in keeping cache contents below
         * the configured cache size during checkpoints where reconciling non-HS pages can generate
         * significant amount of HS dirty content very quickly.
         ','line_number':2013,'multiline':True]['text':' Pages that are empty or from dead trees are fast-tracked. ','line_number':2026,'multiline':True]['text':'
         * Do not evict a clean metadata page that contains historical data needed to satisfy a
         * reader. Since there is no history store for metadata, we won't be able to serve an older
         * reader if we evict this page.
         ','line_number':2030,'multiline':True]['text':' Skip pages we don't want. ','line_number':2041,'multiline':True]['text':'
         * Don't attempt eviction of internal pages with children in cache (indicated by seeing an
         * internal page that is the parent of the last page we saw).
         *
         * Also skip internal page unless we get aggressive, the tree is idle (indicated by the tree
         * being skipped for walks), or we are in eviction debug mode. The goal here is that if
         * trees become completely idle, we eventually push them out of cache completely.
         ','line_number':2048,'multiline':True]['text':' If eviction gets aggressive, anything else is fair game. ','line_number':2064,'multiline':True]['text':'
         * If the global transaction state hasn't changed since the last time we tried eviction,
         * it's unlikely we can make progress. This heuristic avoids repeated attempts to evict the
         * same page.
         ','line_number':2068,'multiline':True]['text':'
             * FIXME-WT-11805: The assumption that the eviction will fail if most recent update on
             * the page from the transaction that is greater than the last running transaction has
             * changed because now eviction also has it's own snapshot for visibility check.
             ','line_number':2077,'multiline':True]['text':' If the page can't be evicted, give up. ','line_number':2087,'multiline':True]['text':' Count internal pages queued. ','line_number':2098,'multiline':True]['text':'
     * If we couldn't find the number of pages we were looking for, skip the tree next time.
     ','line_number':2113,'multiline':True]['text':'
         * If there's a chance the Btree was fully evicted, update the evicted flag in the handle.
         ','line_number':2120,'multiline':True]['text':'
     * Give up the walk occasionally.
     *
     * If we happen to end up on the root page or a page requiring urgent eviction, clear it. We
     * have to track hazard pointers, and the root page complicates that calculation.
     *
     * Likewise if we found no new candidates during the walk: there is no point keeping a page
     * pinned, since it may be the only candidate in an idle tree.
     *
     * If we land on a page requiring forced eviction, or that isn't an ordinary in-memory page,
     * move until we find an ordinary page: we should not prevent exclusive access to the page until
     * the next walk.
     ','line_number':2128,'multiline':True]['text':'
 * __evict_get_ref --
 *     Get a page for eviction.
 ','line_number':2166,'multiline':True]['text':'
     * It is polite to initialize output variables, but it isn't safe for callers to use the
     * previous state if we don't return a locked ref.
     ','line_number':2182,'multiline':True]['text':' Application threads do eviction when cache is full of dirty data ','line_number':2192,'multiline':True]['text':' Avoid the LRU lock if no pages are available. ','line_number':2199,'multiline':True]['text':'
     * The server repopulates whenever the other queue is not full, as long as at least one page has
     * been evicted out of the current queue.
     *
     * Note that there are pathological cases where there are only enough eviction candidates in the
     * cache to fill one queue. In that case, we will continually evict one page and attempt to
     * refill the queues. Such cases are extremely rare in real applications.
     ','line_number':2207,'multiline':True]['text':' Check the urgent queue first. ','line_number':2224,'multiline':True]['text':'
         * Check if the current queue needs to change.
         *
         * The server will only evict half of the pages before looking for more, but should only
         * switch queues if there are no other eviction workers.
         ','line_number':2228,'multiline':True]['text':'
     * We got the queue lock, which should be fast, and chose a queue. Now we want to get the lock
     * on the individual queue.
     ','line_number':2245,'multiline':True]['text':' Verify there are still pages available. ','line_number':2250,'multiline':True]['text':'
     * Only evict half of the pages before looking for more. The remainder are left to eviction
     * workers (if configured), or application thread if necessary.
     ','line_number':2262,'multiline':True]['text':' Get the next page queued for eviction. ','line_number':2270,'multiline':True]['text':'
         * Evicting a dirty page in the server thread could stall during a write and prevent
         * eviction from finding new work.
         *
         * However, we can't skip entries in the urgent queue or they may never be found again.
         *
         * Don't force application threads to evict dirty pages if they aren't stalled by the amount
         * of dirty data in cache.
         ','line_number':2277,'multiline':True]['text':'
         * Lock the page while holding the eviction mutex to prevent multiple attempts to evict it.
         * For pages that are already being evicted, this operation will fail and we will move on.
         ','line_number':2293,'multiline':True]['text':'
         * Increment the busy count in the btree handle to prevent it from being closed under us.
         ','line_number':2303,'multiline':True]['text':'
         * Remove the entry so we never try to reconcile the same page on reconciliation error.
         ','line_number':2312,'multiline':True]['text':' Move to the next item. ','line_number':2319,'multiline':True]['text':' Clear the current pointer if there are no more candidates. ','line_number':2322,'multiline':True]['text':'
 * __evict_page --
 *     Called by both eviction and application threads to evict a page.
 ','line_number':2330,'multiline':True]['text':'
     * An internal session flags either the server itself or an eviction worker thread.
     ','line_number':2356,'multiline':True]['text':'
     * In case something goes wrong, don't pick the same set of pages every time.
     *
     * We used to bump the page's read generation only if eviction failed, but that isn't safe: at
     * that point, eviction has already unlocked the page and some other thread may have evicted it
     * by the time we look at it.
     ','line_number':2371,'multiline':True]['text':'
 * __wt_cache_eviction_worker --
 *     Worker function for __wt_cache_eviction_check: evict pages if the cache crosses its
 *     boundaries.
 ','line_number':2392,'multiline':True]['text':'
     * Before we enter the eviction generation, make sure this session has a cached history store
     * cursor, otherwise we can deadlock with a session wanting exclusive access to a handle: that
     * session will have a handle list write lock and will be waiting on eviction to drain, we'll be
     * inside eviction waiting on a handle list read lock to open a history store cursor.
     ','line_number':2423,'multiline':True]['text':'
     * It is not safe to proceed if the eviction server threads aren't setup yet.
     ','line_number':2431,'multiline':True]['text':' Wake the eviction server if we need to do work. ','line_number':2437,'multiline':True]['text':' Track how long application threads spend doing eviction. ','line_number':2440,'multiline':True]['text':'
     * Note that this for loop is designed to reset expected eviction error codes before exiting,
     * namely, the busy return and empty eviction queue. We do not need the calling functions to
     * have to deal with internal eviction return codes.
     ','line_number':2445,'multiline':True]['text':'
         * If eviction is stuck, check if this thread is likely causing problems and should be
         * rolled back. Ignore if in recovery, those transactions can't be rolled back.
         ','line_number':2451,'multiline':True]['text':'
         * Check if we've exceeded our operation timeout, this would also get called from the
         * previous txn is blocking call, however it won't pickup transactions that have been
         * committed or rolled back as their mod count is 0, and that txn needs to be the oldest.
         *
         * Additionally we don't return rollback which could confuse the caller.
         ','line_number':2466,'multiline':True]['text':' Check if we have exceeded the global or the session timeout for waiting on the cache. ','line_number':2476,'multiline':True]['text':'
         * Check if we have become busy.
         *
         * If we're busy (because of the transaction check we just did or because our caller is
         * waiting on a longer-than-usual event such as a page read), and the cache level drops
         * below 100%, limit the work to 5 evictions and return. If that's not the case, we can do
         * more.
         ','line_number':2483,'multiline':True]['text':' See if eviction is still needed. ','line_number':2496,'multiline':True]['text':' Evict a page. ','line_number':2501,'multiline':True]['text':' FALLTHROUGH ','line_number':2506,'multiline':True]['text':' Allow the queue to re-populate before retrying. ','line_number':2510,'multiline':True]['text':'
         * Check if a rollback is required only if there has not been an error. Returning an error
         * takes precedence over asking for a rollback. We can not do both.
         ','line_number':2526,'multiline':True]['text':'
 * __wt_page_evict_urgent --
 *     Set a page to be evicted as soon as possible.
 ','line_number':2544,'multiline':True]['text':' Root pages should never be evicted via LRU. ','line_number':2557,'multiline':True]['text':' Append to the urgent queue if we can. ','line_number':2568,'multiline':True]['text':' Check again, in case we raced with another thread. ','line_number':2574,'multiline':True]['text':'
     * If the page is already in the LRU eviction list, clear it from the list if eviction server is
     * not running.
     ','line_number':2578,'multiline':True]['text':'
 * __wt_evict_priority_set --
 *     Set a tree's eviction priority.
 ','line_number':2617,'multiline':True]['text':'
 * __wt_evict_priority_clear --
 *     Clear a tree's eviction priority.
 ','line_number':2627,'multiline':True]['text':'
 * __verbose_dump_cache_single --
 *     Output diagnostic information about a single file in the cache.
 ','line_number':2637,'multiline':True]['text':'
     * We cannot walk the tree of a dhandle held exclusively because the owning thread could be
     * manipulating it in a way that causes us to dump core. So print out that we visited and
     * skipped it.
     ','line_number':2669,'multiline':True]['text':'
 * __verbose_dump_cache_apply --
 *     Apply dumping cache for all the dhandles.
 ','line_number':2745,'multiline':True]['text':' Skip if the tree is marked discarded by another thread. ','line_number':2763,'multiline':True]['text':'
 * __wt_verbose_dump_cache --
 *     Output diagnostic information about the cache.
 ','line_number':2777,'multiline':True]['text':' [-Werror=uninitialized] ','line_number':2794,'multiline':True]['text':'
     * Apply the overhead percentage so our total bytes are comparable with the tracked value.
     ','line_number':2812,'multiline':True]