['text':'','line_number':1,'multiline':False]['text':' buffer.hpp','line_number':2,'multiline':False]['text':' ~~~~~~~~~~','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' Distributed under the Boost Software License, Version 1.0. (See accompanying','line_number':7,'multiline':False]['text':' file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]['text':'','line_number':9,'multiline':False]['text':' defined(_MSC_VER) && (_MSC_VER >= 1200)','line_number':16,'multiline':False]['text':' !defined(ASIO_DISABLE_BUFFER_DEBUGGING)','line_number':34,'multiline':False]['text':' defined(_HAS_ITERATOR_DEBUGGING)','line_number':35,'multiline':False]['text':' defined(ASIO_MSVC) && (ASIO_MSVC >= 1700)','line_number':36,'multiline':False]['text':' !defined(ASIO_DISABLE_BUFFER_DEBUGGING)','line_number':42,'multiline':False]['text':' defined(_GLIBCXX_DEBUG)','line_number':43,'multiline':False]['text':' defined(__GNUC__)','line_number':44,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':48,'multiline':False]['text':' BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582))','line_number':55,'multiline':False]['text':' || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))','line_number':56,'multiline':False]['text':' defined(ASIO_HAS_BOOST_WORKAROUND)','line_number':57,'multiline':False]['text':' defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':61,'multiline':False]['text':'/ Holds a buffer that can be modified.','line_number':70,'multiline':False]['text':'*
 * The mutable_buffer class provides a safe representation of a buffer that can
 * be modified. It does not own the underlying data, and so is cheap to copy or
 * assign.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code asio::mutable_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
 * @endcode
 *
 * The @c data() member function permits violations of type safety, so uses of
 * it in application code should be carefully considered.
 ','line_number':71,'multiline':True]['text':'/ Construct an empty buffer.','line_number':92,'multiline':False]['text':'/ Construct a buffer to represent a given memory range.','line_number':99,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':119,'multiline':False]['text':'/ Get a pointer to the beginning of the memory range.','line_number':121,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':127,'multiline':False]['text':'/ Get the size of the memory range.','line_number':131,'multiline':False]['text':'/ Move the start of the buffer by the specified number of bytes.','line_number':137,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':152,'multiline':False]['text':'/ (Deprecated: Use mutable_buffer.) Adapts a single modifiable buffer so that','line_number':157,'multiline':False]['text':'/ it meets the requirements of the MutableBufferSequence concept.','line_number':158,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':163,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':166,'multiline':False]['text':'/ Construct to represent a given memory range.','line_number':169,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':181,'multiline':False]['text':'/ Construct to represent a single modifiable buffer.','line_number':183,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':189,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':195,'multiline':False]['text':' !defined(ASIO_NO_DEPRECATED)','line_number':202,'multiline':False]['text':'/ Holds a buffer that cannot be modified.','line_number':204,'multiline':False]['text':'*
 * The const_buffer class provides a safe representation of a buffer that cannot
 * be modified. It does not own the underlying data, and so is cheap to copy or
 * assign.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code asio::const_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());
 * @endcode
 *
 * The @c data() member function permits violations of type safety, so uses of
 * it in application code should be carefully considered.
 ','line_number':205,'multiline':True]['text':'/ Construct an empty buffer.','line_number':226,'multiline':False]['text':'/ Construct a buffer to represent a given memory range.','line_number':233,'multiline':False]['text':'/ Construct a non-modifiable buffer from a modifiable one.','line_number':240,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':246,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':263,'multiline':False]['text':'/ Get a pointer to the beginning of the memory range.','line_number':265,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':271,'multiline':False]['text':'/ Get the size of the memory range.','line_number':275,'multiline':False]['text':'/ Move the start of the buffer by the specified number of bytes.','line_number':281,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':296,'multiline':False]['text':'/ (Deprecated: Use const_buffer.) Adapts a single non-modifiable buffer so','line_number':301,'multiline':False]['text':'/ that it meets the requirements of the ConstBufferSequence concept.','line_number':302,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':307,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':310,'multiline':False]['text':'/ Construct to represent a given memory range.','line_number':313,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':325,'multiline':False]['text':'/ Construct to represent a single non-modifiable buffer.','line_number':327,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':333,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':339,'multiline':False]['text':' !defined(ASIO_NO_DEPRECATED)','line_number':346,'multiline':False]['text':'/ (Deprecated: Use the socket/descriptor wait() and async_wait() member','line_number':348,'multiline':False]['text':'/ functions.) An implementation of both the ConstBufferSequence and','line_number':349,'multiline':False]['text':'/ MutableBufferSequence concepts to represent a null buffer sequence.','line_number':350,'multiline':False]['text':'/ The type for each element in the list of buffers.','line_number':354,'multiline':False]['text':'/ A random-access iterator type that may be used to read elements.','line_number':357,'multiline':False]['text':'/ Get a random-access iterator to the first element.','line_number':360,'multiline':False]['text':'/ Get a random-access iterator for one past the last element.','line_number':366,'multiline':False]['text':'* @defgroup buffer_sequence_begin asio::buffer_sequence_begin
 *
 * @brief The asio::buffer_sequence_begin function returns an iterator
 * pointing to the first element in a buffer sequence.
 ','line_number':376,'multiline':True]['text':'@{','line_number':381,'multiline':True]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':383,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':389,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':397,'multiline':False]['text':'/ Get an iterator to the first element in a buffer sequence.','line_number':404,'multiline':False]['text':' defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':411,'multiline':False]['text':' defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':425,'multiline':False]['text':'@}','line_number':427,'multiline':True]['text':'* @defgroup buffer_sequence_end asio::buffer_sequence_end
 *
 * @brief The asio::buffer_sequence_end function returns an iterator
 * pointing to one past the end element in a buffer sequence.
 ','line_number':429,'multiline':True]['text':'@{','line_number':434,'multiline':True]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':436,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':442,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':450,'multiline':False]['text':'/ Get an iterator to one past the end element in a buffer sequence.','line_number':457,'multiline':False]['text':' defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':464,'multiline':False]['text':' defined(ASIO_HAS_DECLTYPE) || defined(GENERATING_DOCUMENTATION)','line_number':478,'multiline':False]['text':'@}','line_number':480,'multiline':True]['text':' Tag types used to select appropriately optimised overloads.','line_number':484,'multiline':False]['text':' Helper trait to detect single buffers.','line_number':488,'multiline':False]['text':' !defined(ASIO_NO_DEPRECATED)','line_number':496,'multiline':False]['text':' namespace detail','line_number':523,'multiline':False]['text':'/ Get the total number of bytes in a buffer sequence.','line_number':525,'multiline':False]['text':'*
 * The @c buffer_size function determines the total size of all buffers in the
 * buffer sequence, as if computed as follows:
 *
 * @code size_t total_size = 0;
 * auto i = asio::buffer_sequence_begin(buffers);
 * auto end = asio::buffer_sequence_end(buffers);
 * for (; i != end; ++i)
 * {
 *   const_buffer b(*i);
 *   total_size += b.size();
 * }
 * return total_size; @endcode
 *
 * The @c BufferSequence template parameter may meet either of the @c
 * ConstBufferSequence or @c MutableBufferSequence type requirements.
 ','line_number':526,'multiline':True]['text':'* @defgroup buffer_cast asio::buffer_cast
 *
 * @brief (Deprecated: Use the @c data() member function.) The
 * asio::buffer_cast function is used to obtain a pointer to the
 * underlying memory region associated with a buffer.
 *
 * @par Examples:
 *
 * To access the memory of a non-modifiable buffer, use:
 * @code asio::const_buffer b1 = ...;
 * const unsigned char* p1 = asio::buffer_cast<const unsigned char*>(b1);
 * @endcode
 *
 * To access the memory of a modifiable buffer, use:
 * @code asio::mutable_buffer b2 = ...;
 * unsigned char* p2 = asio::buffer_cast<unsigned char*>(b2);
 * @endcode
 *
 * The asio::buffer_cast function permits violations of type safety, so
 * uses of it in application code should be carefully considered.
 ','line_number':554,'multiline':True]['text':'@{','line_number':575,'multiline':True]['text':'/ Cast a non-modifiable buffer to a specified pointer to POD type.','line_number':577,'multiline':False]['text':'/ Cast a non-modifiable buffer to a specified pointer to POD type.','line_number':584,'multiline':False]['text':'@}','line_number':591,'multiline':True]['text':' !defined(ASIO_NO_DEPRECATED)','line_number':593,'multiline':False]['text':'/ Create a new modifiable buffer that is offset from the start of another.','line_number':595,'multiline':False]['text':'*
 * @relates mutable_buffer
 ','line_number':596,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':608,'multiline':False]['text':'/ Create a new modifiable buffer that is offset from the start of another.','line_number':612,'multiline':False]['text':'*
 * @relates mutable_buffer
 ','line_number':613,'multiline':True]['text':'/ Create a new non-modifiable buffer that is offset from the start of another.','line_number':622,'multiline':False]['text':'*
 * @relates const_buffer
 ','line_number':623,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':635,'multiline':False]['text':'/ Create a new non-modifiable buffer that is offset from the start of another.','line_number':639,'multiline':False]['text':'*
 * @relates const_buffer
 ','line_number':640,'multiline':True]['text':' MSVC 8's string iterator checking may crash in a std::string::iterator','line_number':664,'multiline':False]['text':' object's destructor when the iterator points to an already-destroyed','line_number':665,'multiline':False]['text':' std::string object, unless the iterator is cleared first.','line_number':666,'multiline':False]['text':' defined(ASIO_MSVC) && (ASIO_MSVC == 1400)','line_number':668,'multiline':False]['text':' namespace detail','line_number':680,'multiline':False]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':681,'multiline':False]['text':'* @defgroup buffer asio::buffer
 *
 * @brief The asio::buffer function is used to create a buffer object to
 * represent raw memory, an array of POD elements, a vector of POD elements,
 * or a std::string.
 *
 * A buffer object represents a contiguous region of memory as a 2-tuple
 * consisting of a pointer and size in bytes. A tuple of the form <tt>{void*,
 * size_t}</tt> specifies a mutable (modifiable) region of memory. Similarly, a
 * tuple of the form <tt>{const void*, size_t}</tt> specifies a const
 * (non-modifiable) region of memory. These two forms correspond to the classes
 * mutable_buffer and const_buffer, respectively. To mirror C++'s conversion
 * rules, a mutable_buffer is implicitly convertible to a const_buffer, and the
 * opposite conversion is not permitted.
 *
 * The simplest use case involves reading or writing a single buffer of a
 * specified size:
 *
 * @code sock.send(asio::buffer(data, size)); @endcode
 *
 * In the above example, the return value of asio::buffer meets the
 * requirements of the ConstBufferSequence concept so that it may be directly
 * passed to the socket's write function. A buffer created for modifiable
 * memory also meets the requirements of the MutableBufferSequence concept.
 *
 * An individual buffer may be created from a builtin array, std::vector,
 * std::array or boost::array of POD elements. This helps prevent buffer
 * overruns by automatically determining the size of the buffer:
 *
 * @code char d1[128];
 * size_t bytes_transferred = sock.receive(asio::buffer(d1));
 *
 * std::vector<char> d2(128);
 * bytes_transferred = sock.receive(asio::buffer(d2));
 *
 * std::array<char, 128> d3;
 * bytes_transferred = sock.receive(asio::buffer(d3));
 *
 * boost::array<char, 128> d4;
 * bytes_transferred = sock.receive(asio::buffer(d4)); @endcode
 *
 * In all three cases above, the buffers created are exactly 128 bytes long.
 * Note that a vector is @e never automatically resized when creating or using
 * a buffer. The buffer size is determined using the vector's <tt>size()</tt>
 * member function, and not its capacity.
 *
 * @par Accessing Buffer Contents
 *
 * The contents of a buffer may be accessed using the @c data() and @c size()
 * member functions:
 *
 * @code asio::mutable_buffer b1 = ...;
 * std::size_t s1 = b1.size();
 * unsigned char* p1 = static_cast<unsigned char*>(b1.data());
 *
 * asio::const_buffer b2 = ...;
 * std::size_t s2 = b2.size();
 * const void* p2 = b2.data(); @endcode
 *
 * The @c data() member function permits violations of type safety, so
 * uses of it in application code should be carefully considered.
 *
 * For convenience, a @ref buffer_size function is provided that works with
 * both buffers and buffer sequences (that is, types meeting the
 * ConstBufferSequence or MutableBufferSequence type requirements). In this
 * case, the function returns the total size of all buffers in the sequence.
 *
 * @par Buffer Copying
 *
 * The @ref buffer_copy function may be used to copy raw bytes between
 * individual buffers and buffer sequences.
*
 * In particular, when used with the @ref buffer_size function, the @ref
 * buffer_copy function can be used to linearise a sequence of buffers. For
 * example:
 *
 * @code vector<const_buffer> buffers = ...;
 *
 * vector<unsigned char> data(asio::buffer_size(buffers));
 * asio::buffer_copy(asio::buffer(data), buffers); @endcode
 *
 * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
 * consequently it cannot be used to copy between overlapping memory regions.
 *
 * @par Buffer Invalidation
 *
 * A buffer object does not have any ownership of the memory it refers to. It
 * is the responsibility of the application to ensure the memory region remains
 * valid until it is no longer required for an I/O operation. When the memory
 * is no longer available, the buffer is said to have been invalidated.
 *
 * For the asio::buffer overloads that accept an argument of type
 * std::vector, the buffer objects returned are invalidated by any vector
 * operation that also invalidates all references, pointers and iterators
 * referring to the elements in the sequence (C++ Std, 23.2.4)
 *
 * For the asio::buffer overloads that accept an argument of type
 * std::basic_string, the buffer objects returned are invalidated according to
 * the rules defined for invalidation of references, pointers and iterators
 * referring to elements of the sequence (C++ Std, 21.3).
 *
 * @par Buffer Arithmetic
 *
 * Buffer objects may be manipulated using simple arithmetic in a safe way
 * which helps prevent buffer overruns. Consider an array initialised as
 * follows:
 *
 * @code boost::array<char, 6> a = { 'a', 'b', 'c', 'd', 'e' }; @endcode
 *
 * A buffer object @c b1 created using:
 *
 * @code b1 = asio::buffer(a); @endcode
 *
 * represents the entire array, <tt>{ 'a', 'b', 'c', 'd', 'e' }</tt>. An
 * optional second argument to the asio::buffer function may be used to
 * limit the size, in bytes, of the buffer:
 *
 * @code b2 = asio::buffer(a, 3); @endcode
 *
 * such that @c b2 represents the data <tt>{ 'a', 'b', 'c' }</tt>. Even if the
 * size argument exceeds the actual size of the array, the size of the buffer
 * object created will be limited to the array size.
 *
 * An offset may be applied to an existing buffer to create a new one:
 *
 * @code b3 = b1 + 2; @endcode
 *
 * where @c b3 will set to represent <tt>{ 'c', 'd', 'e' }</tt>. If the offset
 * exceeds the size of the existing buffer, the newly created buffer will be
 * empty.
 *
 * Both an offset and size may be specified to create a buffer that corresponds
 * to a specific range of bytes within an existing buffer:
 *
 * @code b4 = asio::buffer(b1 + 1, 3); @endcode
 *
 * so that @c b4 will refer to the bytes <tt>{ 'b', 'c', 'd' }</tt>.
 *
 * @par Buffers and Scatter-Gather I/O
 *
 * To read or write using multiple buffers (i.e. scatter-gather I/O), multiple
 * buffer objects may be assigned into a container that supports the
 * MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:
 *
 * @code
 * char d1[128];
 * std::vector<char> d2(128);
 * boost::array<char, 128> d3;
 *
 * boost::array<mutable_buffer, 3> bufs1 = {
 *   asio::buffer(d1),
 *   asio::buffer(d2),
 *   asio::buffer(d3) };
 * bytes_transferred = sock.receive(bufs1);
 *
 * std::vector<const_buffer> bufs2;
 * bufs2.push_back(asio::buffer(d1));
 * bufs2.push_back(asio::buffer(d2));
 * bufs2.push_back(asio::buffer(d3));
 * bytes_transferred = sock.send(bufs2); @endcode
 ','line_number':683,'multiline':True]['text':'@{','line_number':844,'multiline':True]['text':' defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)','line_number':849,'multiline':False]['text':' defined(ASIO_NO_DEPRECATED) || defined(GENERATING_DOCUMENTATION)','line_number':852,'multiline':False]['text':'/ Create a new modifiable buffer from an existing buffer.','line_number':854,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(b)</tt>.
 ','line_number':855,'multiline':True]['text':'/ Create a new modifiable buffer from an existing buffer.','line_number':864,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     b.data(),
 *     min(b.size(), max_size_in_bytes)); @endcode
 ','line_number':865,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':880,'multiline':False]['text':'/ Create a new non-modifiable buffer from an existing buffer.','line_number':884,'multiline':False]['text':'*
 * @returns <tt>const_buffer(b)</tt>.
 ','line_number':885,'multiline':True]['text':'/ Create a new non-modifiable buffer from an existing buffer.','line_number':894,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     b.data(),
 *     min(b.size(), max_size_in_bytes)); @endcode
 ','line_number':895,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':909,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given memory range.','line_number':913,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data, size_in_bytes)</tt>.
 ','line_number':914,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given memory range.','line_number':923,'multiline':False]['text':'*
 * @returns <tt>const_buffer(data, size_in_bytes)</tt>.
 ','line_number':924,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':933,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     static_cast<void*>(data),
 *     N * sizeof(PodType)); @endcode
 ','line_number':934,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':946,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     static_cast<void*>(data),
 *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':947,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':962,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     static_cast<const void*>(data),
 *     N * sizeof(PodType)); @endcode
 ','line_number':963,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':976,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     static_cast<const void*>(data),
 *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':977,'multiline':True]['text':' Borland C++ and Sun Studio think the overloads:','line_number':994,'multiline':False]['text':'','line_number':995,'multiline':False]['text':'   unspecified buffer(boost::array<PodType, N>& array ...);','line_number':996,'multiline':False]['text':'','line_number':997,'multiline':False]['text':' and','line_number':998,'multiline':False]['text':'','line_number':999,'multiline':False]['text':'   unspecified buffer(boost::array<const PodType, N>& array ...);','line_number':1000,'multiline':False]['text':'','line_number':1001,'multiline':False]['text':' are ambiguous. This will be worked around by using a buffer_types traits','line_number':1002,'multiline':False]['text':' class that contains typedefs for the appropriate buffer and container','line_number':1003,'multiline':False]['text':' classes, based on whether PodType is const or non-const.','line_number':1004,'multiline':False]['text':' namespace detail','line_number':1031,'multiline':False]['text':' defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':1060,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1062,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1063,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1077,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1078,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1093,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1094,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1107,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1108,'multiline':True]['text':' defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)','line_number':1123,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1125,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1126,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1139,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1140,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1157,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1158,'multiline':True]['text':'/ Create a new modifiable buffer that represents the given POD array.','line_number':1171,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1172,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1187,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1188,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1201,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1202,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1217,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     data.size() * sizeof(PodType)); @endcode
 ','line_number':1218,'multiline':True]['text':'/ Create a new non-modifiable buffer that represents the given POD array.','line_number':1231,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 ','line_number':1232,'multiline':True]['text':' defined(ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)','line_number':1247,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD vector.','line_number':1249,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     data.size() * sizeof(PodType)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1250,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1269,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given POD vector.','line_number':1273,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1274,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1294,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD vector.','line_number':1298,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.size() ? &data[0] : 0,
 *     data.size() * sizeof(PodType)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1299,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1318,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given POD vector.','line_number':1322,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any vector operation that would also
 * invalidate iterators.
 ','line_number':1323,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1344,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string.','line_number':1348,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
 * data.size() * sizeof(Elem))</tt>.
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1349,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1366,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string.','line_number':1370,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1371,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1392,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1396,'multiline':False]['text':'*
 * @returns <tt>const_buffer(data.data(), data.size() * sizeof(Elem))</tt>.
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1397,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1412,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1416,'multiline':False]['text':'*
 * @returns A const_buffer value equivalent to:
 * @code const_buffer(
 *     data.data(),
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 *
 * @note The buffer is invalidated by any non-const operation called on the
 * given string object.
 ','line_number':1417,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1438,'multiline':False]['text':'/ Create a new modifiable buffer that represents the given string_view.','line_number':1445,'multiline':False]['text':'*
 * @returns <tt>mutable_buffer(data.size() ? &data[0] : 0,
 * data.size() * sizeof(Elem))</tt>.
 ','line_number':1446,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1460,'multiline':False]['text':'/ Create a new non-modifiable buffer that represents the given string.','line_number':1464,'multiline':False]['text':'*
 * @returns A mutable_buffer value equivalent to:
 * @code mutable_buffer(
 *     data.size() ? &data[0] : 0,
 *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
 ','line_number':1465,'multiline':True]['text':' ASIO_ENABLE_BUFFER_DEBUGGING','line_number':1483,'multiline':False]['text':' defined(ASIO_HAS_STRING_VIEW)','line_number':1487,'multiline':False]['text':'  || defined(GENERATING_DOCUMENTATION)','line_number':1488,'multiline':False]['text':'@}','line_number':1490,'multiline':True]['text':'/ Adapt a basic_string to the DynamicBuffer requirements.','line_number':1492,'multiline':False]['text':'*
 * Requires that <tt>sizeof(Elem) == 1</tt>.
 ','line_number':1493,'multiline':True]['text':'/ The type used to represent the input sequence as a list of buffers.','line_number':1500,'multiline':False]['text':'/ The type used to represent the output sequence as a list of buffers.','line_number':1503,'multiline':False]['text':'/ Construct a dynamic buffer from a string.','line_number':1506,'multiline':False]['text':'*
   * @param s The string to be used as backing storage for the dynamic buffer.
   * Any existing data in the string is treated as the dynamic buffer's input
   * sequence. The object stores a reference to the string and the user is
   * responsible for ensuring that the string object remains valid until the
   * dynamic_string_buffer object is destroyed.
   *
   * @param maximum_size Specifies a maximum size for the buffer, in bytes.
   ','line_number':1507,'multiline':True]['text':'/ Move construct a dynamic buffer.','line_number':1526,'multiline':False]['text':' defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)','line_number':1533,'multiline':False]['text':'/ Get the size of the input sequence.','line_number':1535,'multiline':False]['text':'/ Get the maximum size of the dynamic buffer.','line_number':1541,'multiline':False]['text':'*
   * @returns The allowed maximum of the sum of the sizes of the input sequence
   * and output sequence.
   ','line_number':1542,'multiline':True]['text':'/ Get the current capacity of the dynamic buffer.','line_number':1551,'multiline':False]['text':'*
   * @returns The current total capacity of the buffer, i.e. for both the input
   * sequence and output sequence.
   ','line_number':1552,'multiline':True]['text':'/ Get a list of buffers that represents the input sequence.','line_number':1561,'multiline':False]['text':'*
   * @returns An object of type @c const_buffers_type that satisfies
   * ConstBufferSequence requirements, representing the basic_string memory in
   * input sequence.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that modifies the input sequence or
   * output sequence.
   ','line_number':1562,'multiline':True]['text':'/ Get a list of buffers that represents the output sequence, with the given','line_number':1576,'multiline':False]['text':'/ size.','line_number':1577,'multiline':False]['text':'*
   * Ensures that the output sequence can accommodate @c n bytes, resizing the
   * basic_string object as necessary.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing basic_string memory
   * at the start of the output sequence of size @c n.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   *
   * @note The returned object is invalidated by any @c dynamic_string_buffer
   * or @c basic_string member function that modifies the input sequence or
   * output sequence.
   ','line_number':1578,'multiline':True]['text':'/ Move bytes from the output sequence to the input sequence.','line_number':1605,'multiline':False]['text':'*
   * @param n The number of bytes to append from the start of the output
   * sequence to the end of the input sequence. The remainder of the output
   * sequence is discarded.
   *
   * Requires a preceding call <tt>prepare(x)</tt> where <tt>x >= n</tt>, and
   * no intervening operations that modify the input or output sequence.
   *
   * @note If @c n is greater than the size of the output sequence, the entire
   * output sequence is moved to the input sequence and no error is issued.
   ','line_number':1606,'multiline':True]['text':'/ Remove characters from the input sequence.','line_number':1623,'multiline':False]['text':'*
   * Removes @c n characters from the beginning of the input sequence.
   *
   * @note If @c n is greater than the size of the input sequence, the entire
   * input sequence is consumed and no error is issued.
   ','line_number':1624,'multiline':True]['text':'/ Adapt a vector to the DynamicBuffer requirements.','line_number':1643,'multiline':False]['text':'*
 * Requires that <tt>sizeof(Elem) == 1</tt>.
 ','line_number':1644,'multiline':True]['text':'/ The type used to represent the input sequence as a list of buffers.','line_number':1651,'multiline':False]['text':'/ The type used to represent the output sequence as a list of buffers.','line_number':1654,'multiline':False]['text':'/ Construct a dynamic buffer from a string.','line_number':1657,'multiline':False]['text':'*
   * @param v The vector to be used as backing storage for the dynamic buffer.
   * Any existing data in the vector is treated as the dynamic buffer's input
   * sequence. The object stores a reference to the vector and the user is
   * responsible for ensuring that the vector object remains valid until the
   * dynamic_vector_buffer object is destroyed.
   *
   * @param maximum_size Specifies a maximum size for the buffer, in bytes.
   ','line_number':1658,'multiline':True]['text':'/ Move construct a dynamic buffer.','line_number':1677,'multiline':False]['text':' defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)','line_number':1684,'multiline':False]['text':'/ Get the size of the input sequence.','line_number':1686,'multiline':False]['text':'/ Get the maximum size of the dynamic buffer.','line_number':1692,'multiline':False]['text':'*
   * @returns The allowed maximum of the sum of the sizes of the input sequence
   * and output sequence.
   ','line_number':1693,'multiline':True]['text':'/ Get the current capacity of the dynamic buffer.','line_number':1702,'multiline':False]['text':'*
   * @returns The current total capacity of the buffer, i.e. for both the input
   * sequence and output sequence.
   ','line_number':1703,'multiline':True]['text':'/ Get a list of buffers that represents the input sequence.','line_number':1712,'multiline':False]['text':'*
   * @returns An object of type @c const_buffers_type that satisfies
   * ConstBufferSequence requirements, representing the basic_string memory in
   * input sequence.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c basic_string member function that modifies the input sequence or
   * output sequence.
   ','line_number':1713,'multiline':True]['text':'/ Get a list of buffers that represents the output sequence, with the given','line_number':1727,'multiline':False]['text':'/ size.','line_number':1728,'multiline':False]['text':'*
   * Ensures that the output sequence can accommodate @c n bytes, resizing the
   * basic_string object as necessary.
   *
   * @returns An object of type @c mutable_buffers_type that satisfies
   * MutableBufferSequence requirements, representing basic_string memory
   * at the start of the output sequence of size @c n.
   *
   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
   *
   * @note The returned object is invalidated by any @c dynamic_vector_buffer
   * or @c basic_string member function that modifies the input sequence or
   * output sequence.
   ','line_number':1729,'multiline':True]['text':'/ Move bytes from the output sequence to the input sequence.','line_number':1756,'multiline':False]['text':'*
   * @param n The number of bytes to append from the start of the output
   * sequence to the end of the input sequence. The remainder of the output
   * sequence is discarded.
   *
   * Requires a preceding call <tt>prepare(x)</tt> where <tt>x >= n</tt>, and
   * no intervening operations that modify the input or output sequence.
   *
   * @note If @c n is greater than the size of the output sequence, the entire
   * output sequence is moved to the input sequence and no error is issued.
   ','line_number':1757,'multiline':True]['text':'/ Remove characters from the input sequence.','line_number':1774,'multiline':False]['text':'*
   * Removes @c n characters from the beginning of the input sequence.
   *
   * @note If @c n is greater than the size of the input sequence, the entire
   * input sequence is consumed and no error is issued.
   ','line_number':1775,'multiline':True]['text':'* @defgroup dynamic_buffer asio::dynamic_buffer
 *
 * @brief The asio::dynamic_buffer function is used to create a
 * dynamically resized buffer from a @c std::basic_string or @c std::vector.
 ','line_number':1794,'multiline':True]['text':'@{','line_number':1799,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given string.','line_number':1801,'multiline':False]['text':'*
 * @returns <tt>dynamic_string_buffer<Elem, Traits, Allocator>(data)</tt>.
 ','line_number':1802,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given string.','line_number':1812,'multiline':False]['text':'*
 * @returns <tt>dynamic_string_buffer<Elem, Traits, Allocator>(data,
 * max_size)</tt>.
 ','line_number':1813,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given vector.','line_number':1825,'multiline':False]['text':'*
 * @returns <tt>dynamic_vector_buffer<Elem, Allocator>(data)</tt>.
 ','line_number':1826,'multiline':True]['text':'/ Create a new dynamic buffer that represents the given vector.','line_number':1836,'multiline':False]['text':'*
 * @returns <tt>dynamic_vector_buffer<Elem, Allocator>(data, max_size)</tt>.
 ','line_number':1837,'multiline':True]['text':'@}','line_number':1848,'multiline':True]['text':'* @defgroup buffer_copy asio::buffer_copy
 *
 * @brief The asio::buffer_copy function is used to copy bytes from a
 * source buffer (or buffer sequence) to a target buffer (or buffer sequence).
 *
 * The @c buffer_copy function is available in two forms:
 *
 * @li A 2-argument form: @c buffer_copy(target, source)
 *
 * @li A 3-argument form: @c buffer_copy(target, source, max_bytes_to_copy)
 *
 * Both forms return the number of bytes actually copied. The number of bytes
 * copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * @li @c If specified, @c max_bytes_to_copy.
 *
 * This prevents buffer overflow, regardless of the buffer sizes used in the
 * copy operation.
 *
 * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
 * consequently it cannot be used to copy between overlapping memory regions.
 ','line_number':1850,'multiline':True]['text':'@{','line_number':1876,'multiline':True]['text':' For memcpy.','line_number':1883,'multiline':False]['text':' namespace detail','line_number':2048,'multiline':False]['text':'/ Copies bytes from a source buffer sequence to a target buffer sequence.','line_number':2050,'multiline':False]['text':'*
 * @param target A modifiable buffer sequence representing the memory regions to
 * which the bytes will be copied.
 *
 * @param source A non-modifiable buffer sequence representing the memory
 * regions from which the bytes will be copied.
 *
 * @returns The number of bytes copied.
 *
 * @note The number of bytes copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * This function is implemented in terms of @c memcpy, and consequently it
 * cannot be used to copy between overlapping memory regions.
 ','line_number':2051,'multiline':True]['text':'/ Copies a limited number of bytes from a source buffer sequence to a target','line_number':2082,'multiline':False]['text':'/ buffer sequence.','line_number':2083,'multiline':False]['text':'*
 * @param target A modifiable buffer sequence representing the memory regions to
 * which the bytes will be copied.
 *
 * @param source A non-modifiable buffer sequence representing the memory
 * regions from which the bytes will be copied.
 *
 * @param max_bytes_to_copy The maximum number of bytes to be copied.
 *
 * @returns The number of bytes copied.
 *
 * @note The number of bytes copied is the lesser of:
 *
 * @li @c buffer_size(target)
 *
 * @li @c buffer_size(source)
 *
 * @li @c max_bytes_to_copy
 *
 * This function is implemented in terms of @c memcpy, and consequently it
 * cannot be used to copy between overlapping memory regions.
 ','line_number':2084,'multiline':True]['text':'@}','line_number':2120,'multiline':True]['text':' namespace asio','line_number':2122,'multiline':False]['text':'/ Trait to determine whether a type satisfies the MutableBufferSequence','line_number':2130,'multiline':False]['text':'/ requirements.','line_number':2131,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2136,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2138,'multiline':False]['text':'/ Trait to determine whether a type satisfies the ConstBufferSequence','line_number':2142,'multiline':False]['text':'/ requirements.','line_number':2143,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2148,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2150,'multiline':False]['text':'/ Trait to determine whether a type satisfies the DynamicBuffer requirements.','line_number':2154,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2159,'multiline':False]['text':' defined(GENERATING_DOCUMENTATION)','line_number':2161,'multiline':False]['text':' namespace asio','line_number':2165,'multiline':False]['text':' ASIO_BUFFER_HPP','line_number':2169,'multiline':False]