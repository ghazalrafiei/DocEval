['text':'
   new_p = skip_utf8(p, c, lb, l, n); skips n characters forwards from p + c
   if n +ve, or n characters backwards from p + c - 1 if n -ve. new_p is the new
   position, or 0 on failure.

   -- used to implement hop and next in the utf8 case.
','line_number':27,'multiline':True]['text':' 1100 0000 ','line_number':41,'multiline':True]['text':' break unless b is 10------ ','line_number':45,'multiline':True]['text':' 1000 0000 ','line_number':54,'multiline':True]['text':' 1100 0000 ','line_number':57,'multiline':True]['text':' Code for character groupings: utf8 cases ','line_number':66,'multiline':True]['text':' 1100 0000 ','line_number':72,'multiline':True]['text':' 1110 0000 ','line_number':76,'multiline':True]['text':' 1000 0000 ','line_number':86,'multiline':True]['text':' 1100 0000 ','line_number':90,'multiline':True]['text':' Code for character groupings: non-utf8 cases ','line_number':144,'multiline':True]['text':' smaller ','line_number':230,'multiline':True]['text':' v->s has been inspected ','line_number':243,'multiline':True]['text':' only one item in v ','line_number':244,'multiline':True]['text':' - but now we need to go round once more to get
               v->s inspected. This looks messy, but is actually
               the optimal approach.  ','line_number':246,'multiline':True]['text':' find_among_b is for backwards processing. Same comments apply ','line_number':270,'multiline':True]['text':' Increase the size of the buffer pointed to by p to at least n symbols.
 * If insufficient memory, returns NULL and frees the old buffer.
 ','line_number':326,'multiline':True]['text':' to replace symbols between c_bra and c_ket in z->p by the
   s_size symbols at s.
   Returns 0 on success, -1 on error.
   Also, frees z->p (and sets it to NULL) on error.
','line_number':343,'multiline':True]['text':' this line could be removed ','line_number':386,'multiline':True]['text':'if (number >= 0) printf("%3d (line %4d): '", number, line_count);','line_number':462,'multiline':True]