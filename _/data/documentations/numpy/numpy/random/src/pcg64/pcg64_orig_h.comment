['text':'
 * PCG Random Number Generation for C.
 *
 * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For additional information about the PCG random number generation scheme,
 * including its license and other licensing options, visit
 *
 *     http://www.pcg-random.org
 ','line_number':1,'multiline':True]['text':'
 * This code is derived from the canonical C++ PCG implementation, which
 * has many additional features and is preferable if you can use C++ in
 * your project.
 *
 * Much of the derivation was performed mechanically.  In particular, the
 * output functions were generated by compiling the C++ output functions
 * into LLVM bitcode and then transforming that using the LLVM C backend
 * (from https://github.com/draperlaboratory/llvm-cbe), and then
 * postprocessing and hand editing the output.
 *
 * Much of the remaining code was generated by C-preprocessor metaprogramming.
 ','line_number':24,'multiline':True]['text':' We could instead use macros PCG_INLINE and PCG_EXTERN_INLINE','line_number':51,'multiline':False]['text':' but better to just reject ancient C code.','line_number':52,'multiline':False]['text':'
 * Rotate helper functions.
 ','line_number':59,'multiline':True]['text':' Unfortunately, clang is kinda pathetic when it comes to properly
 * recognizing idiomatic rotate code, so for clang we actually provide
 * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss.
 ','line_number':64,'multiline':True]['text':' For whatever reason, clang actually *does* generate rotq by','line_number':96,'multiline':False]['text':' itself, so we don't need this code.','line_number':97,'multiline':False]['text':'
 * Output functions.  These are the core of the PCG generation scheme.
 ','line_number':111,'multiline':True]['text':' XSH RS','line_number':115,'multiline':False]['text':' XSH RR','line_number':136,'multiline':False]['text':' RXS M XS','line_number':156,'multiline':False]['text':' 327738287884841127335028083622016905945','line_number':184,'multiline':False]['text':' XSL RR (only defined for >= 64 bits)','line_number':189,'multiline':False]['text':' XSL RR RR (only defined for >= 64 bits)','line_number':203,'multiline':False]['text':'
   * Static initialization constants (if you can't call srandom for some
   * bizarre reason).
   ','line_number':244,'multiline':True]['text':' Representations for the oneseq, mcg, and unique variants ','line_number':299,'multiline':True]['text':' Representations setseq variants ','line_number':323,'multiline':True]['text':' Multi-step advance functions (jump-ahead, jump-back) ','line_number':352,'multiline':True]['text':' Functions to advance the underlying LCG, one version for each size and
 * each style.  These functions are considered semi-private.  There is rarely
 * a good reason to call them directly.
 ','line_number':368,'multiline':True]['text':' Functions to seed the RNG state, one version for each size and each
 * style.  Unlike the step functions, regular users can and should call
 * these functions.
 ','line_number':586,'multiline':True]['text':' Now, finally we create each of the individual generators. We provide
 * a random_r function that provides a random number of the appropriate
 * type (using the full range of the type) and a boundedrand_r version
 * that provides
 *
 * Implementation notes for boundedrand_r:
 *
 *     To avoid bias, we need to make the range of the RNG a multiple of
 *     bound, which we do by dropping output less than a threshold.
 *     Let's consider a 32-bit case...  A naive scheme to calculate the
 *     threshold would be to do
 *
 *         uint32_t threshold = 0x100000000ull % bound;
 *
 *     but 64-bit div/mod is slower than 32-bit div/mod (especially on
 *     32-bit platforms).  In essence, we do
 *
 *         uint32_t threshold = (0x100000000ull-bound) % bound;
 *
 *     because this version will calculate the same modulus, but the LHS
 *     value is less than 2^32.
 *
 *     (Note that using modulo is only wise for good RNGs, poorer RNGs
 *     such as raw LCGs do better using a technique based on division.)
 *     Empricical tests show that division is preferable to modulus for
 *     reducting the range of an RNG.  It's faster, and sometimes it can
 *     even be statistically preferable.
 ','line_number':743,'multiline':True]['text':' Generation functions for XSH RS ','line_number':772,'multiline':True]['text':' Generation functions for XSH RR ','line_number':1052,'multiline':True]['text':' Generation functions for RXS M XS (no MCG versions because they
 * don't make sense when you want to use the entire state)
 ','line_number':1332,'multiline':True]['text':' Generation functions for XSL RR (only defined for "large" types) ','line_number':1589,'multiline':True]['text':' Generation functions for XSL RR RR (only defined for "large" types) ','line_number':1737,'multiline':True]['text':'// Typedefs','line_number':1854,'multiline':False]['text':'// random_r','line_number':1859,'multiline':False]['text':'// boundedrand_r','line_number':1864,'multiline':False]['text':'// srandom_r','line_number':1869,'multiline':False]['text':'// advance_r','line_number':1874,'multiline':False]['text':'// Typedefs','line_number':1881,'multiline':False]['text':'// random_r','line_number':1886,'multiline':False]['text':'// boundedrand_r','line_number':1891,'multiline':False]['text':'// srandom_r','line_number':1896,'multiline':False]['text':'// advance_r','line_number':1901,'multiline':False]['text':'// Typedefs','line_number':1908,'multiline':False]['text':'// random_r','line_number':1913,'multiline':False]['text':'// boundedrand_r','line_number':1918,'multiline':False]['text':'// srandom_r','line_number':1923,'multiline':False]['text':'// advance_r','line_number':1928,'multiline':False]['text':'// Typedefs','line_number':1942,'multiline':False]['text':'// random_r','line_number':1947,'multiline':False]['text':'// boundedrand_r','line_number':1952,'multiline':False]['text':'// srandom_r','line_number':1957,'multiline':False]['text':'// advance_r','line_number':1962,'multiline':False]['text':'
 * Static initialization constants (if you can't call srandom for some
 * bizarre reason).
 ','line_number':1988,'multiline':True]['text':' PCG_VARIANTS_H_INCLUDED','line_number':2025,'multiline':False]