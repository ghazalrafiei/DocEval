['text':'
 * NOTE: This is generated code. Look in numpy/linalg/lapack_lite for
 *       information on remaking this file.
 ','line_number':1,'multiline':True]['text':'
f2c knows the exact rules for precedence, and so omits parentheses where not
strictly necessary. Since this is generated code, we don't really care if
it's readable, and we know what is written is correct. So don't warn about
them.
','line_number':19,'multiline':True]['text':' Table of constant values ','line_number':30,'multiline':True]['text':' Subroutine ','line_number':35,'multiline':True]['text':' System generated locals ','line_number':38,'multiline':True]['text':' Local variables ','line_number':42,'multiline':True]['text':'
    Purpose
    =======

       CAXPY constant times a vector plus a vector.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':47,'multiline':True]['text':' Parameter adjustments ','line_number':62,'multiline':True]['text':' Function Body ','line_number':66,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':77,'multiline':True]['text':' L10: ','line_number':101,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':105,'multiline':True]['text':' L30: ','line_number':117,'multiline':True]['text':' caxpy_ ','line_number':120,'multiline':True]['text':' Subroutine ','line_number':122,'multiline':True]['text':' System generated locals ','line_number':125,'multiline':True]['text':' Local variables ','line_number':128,'multiline':True]['text':'
    Purpose
    =======

       CCOPY copies a vector x to a vector y.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':132,'multiline':True]['text':' Parameter adjustments ','line_number':147,'multiline':True]['text':' Function Body ','line_number':151,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':159,'multiline':True]['text':' L10: ','line_number':179,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':183,'multiline':True]['text':' L30: ','line_number':191,'multiline':True]['text':' ccopy_ ','line_number':194,'multiline':True]['text':' Complex ','line_number':196,'multiline':True]['text':' System generated locals ','line_number':199,'multiline':True]['text':' Local variables ','line_number':203,'multiline':True]['text':'
    Purpose
    =======

       forms the dot product of two vectors, conjugating the first
       vector.

    Further Details
    ===============

       jack dongarra, linpack,  3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':208,'multiline':True]['text':' Parameter adjustments ','line_number':224,'multiline':True]['text':' Function Body ','line_number':228,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':238,'multiline':True]['text':' L10: ','line_number':261,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':266,'multiline':True]['text':' L30: ','line_number':277,'multiline':True]['text':' cdotc_ ','line_number':281,'multiline':True]['text':' Complex ','line_number':283,'multiline':True]['text':' System generated locals ','line_number':286,'multiline':True]['text':' Local variables ','line_number':290,'multiline':True]['text':'
    Purpose
    =======

       CDOTU forms the dot product of two vectors.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':295,'multiline':True]['text':' Parameter adjustments ','line_number':310,'multiline':True]['text':' Function Body ','line_number':314,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':324,'multiline':True]['text':' L10: ','line_number':347,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':352,'multiline':True]['text':' L30: ','line_number':363,'multiline':True]['text':' cdotu_ ','line_number':367,'multiline':True]['text':' Subroutine ','line_number':369,'multiline':True]['text':' System generated locals ','line_number':373,'multiline':True]['text':' Local variables ','line_number':378,'multiline':True]['text':' Subroutine ','line_number':385,'multiline':True]['text':'
    Purpose
    =======

    CGEMM  performs one of the matrix-matrix operations

       C := alpha*op( A )*op( B ) + beta*C,

    where  op( X ) is one of

       op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),

    alpha and beta are scalars, and A, B and C are matrices, with op( A )
    an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

    Arguments
    ==========

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n',  op( A ) = A.

                TRANSA = 'T' or 't',  op( A ) = A'.

                TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).

             Unchanged on exit.

    TRANSB - CHARACTER*1.
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:

                TRANSB = 'N' or 'n',  op( B ) = B.

                TRANSB = 'T' or 't',  op( B ) = B'.

                TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).

             Unchanged on exit.

    M      - INTEGER.
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
             Unchanged on exit.

    B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
             Unchanged on exit.

    BETA   - COMPLEX         .
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
             Unchanged on exit.

    C      - COMPLEX          array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
       conjugated or transposed, set  CONJA and CONJB  as true if  A  and
       B  respectively are to be  transposed but  not conjugated  and set
       NROWA and  NROWB  as the number of rows and  columns  of  A
       and the number of rows of  B  respectively.
','line_number':388,'multiline':True]['text':' Parameter adjustments ','line_number':520,'multiline':True]['text':' Function Body ','line_number':531,'multiline':True]['text':'     Test the input parameters. ','line_number':547,'multiline':True]['text':'     Quick return if possible. ','line_number':572,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':579,'multiline':True]['text':' L10: ','line_number':589,'multiline':True]['text':' L20: ','line_number':591,'multiline':True]['text':' L30: ','line_number':604,'multiline':True]['text':' L40: ','line_number':606,'multiline':True]['text':'     Start the operations. ','line_number':612,'multiline':True]['text':'           Form  C := alpha*A*B + beta*C. ','line_number':617,'multiline':True]['text':' L50: ','line_number':626,'multiline':True]['text':' L60: ','line_number':637,'multiline':True]['text':' L70: ','line_number':660,'multiline':True]['text':' L80: ','line_number':663,'multiline':True]['text':' L90: ','line_number':665,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*B + beta*C. ','line_number':669,'multiline':True]['text':' L100: ','line_number':685,'multiline':True]['text':' L110: ','line_number':705,'multiline':True]['text':' L120: ','line_number':707,'multiline':True]['text':'           Form  C := alpha*A'*B + beta*C ','line_number':711,'multiline':True]['text':' L130: ','line_number':727,'multiline':True]['text':' L140: ','line_number':747,'multiline':True]['text':' L150: ','line_number':749,'multiline':True]['text':'           Form  C := alpha*A*conjg( B' ) + beta*C. ','line_number':755,'multiline':True]['text':' L160: ','line_number':764,'multiline':True]['text':' L170: ','line_number':775,'multiline':True]['text':' L180: ','line_number':798,'multiline':True]['text':' L190: ','line_number':801,'multiline':True]['text':' L200: ','line_number':803,'multiline':True]['text':'           Form  C := alpha*A*B'          + beta*C ','line_number':807,'multiline':True]['text':' L210: ','line_number':816,'multiline':True]['text':' L220: ','line_number':827,'multiline':True]['text':' L230: ','line_number':850,'multiline':True]['text':' L240: ','line_number':853,'multiline':True]['text':' L250: ','line_number':855,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*conjg( B' ) + beta*C. ','line_number':861,'multiline':True]['text':' L260: ','line_number':876,'multiline':True]['text':' L270: ','line_number':896,'multiline':True]['text':' L280: ','line_number':898,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*B' + beta*C ','line_number':902,'multiline':True]['text':' L290: ','line_number':918,'multiline':True]['text':' L300: ','line_number':938,'multiline':True]['text':' L310: ','line_number':940,'multiline':True]['text':'           Form  C := alpha*A'*conjg( B' ) + beta*C ','line_number':946,'multiline':True]['text':' L320: ','line_number':962,'multiline':True]['text':' L330: ','line_number':982,'multiline':True]['text':' L340: ','line_number':984,'multiline':True]['text':'           Form  C := alpha*A'*B' + beta*C ','line_number':988,'multiline':True]['text':' L350: ','line_number':1004,'multiline':True]['text':' L360: ','line_number':1024,'multiline':True]['text':' L370: ','line_number':1026,'multiline':True]['text':'     End of CGEMM . ','line_number':1033,'multiline':True]['text':' cgemm_ ','line_number':1035,'multiline':True]['text':' Subroutine ','line_number':1037,'multiline':True]['text':' System generated locals ','line_number':1041,'multiline':True]['text':' Local variables ','line_number':1045,'multiline':True]['text':' Subroutine ','line_number':1050,'multiline':True]['text':'
    Purpose
    =======

    CGEMV performs one of the matrix-vector operations

       y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or

       y := alpha*conjg( A' )*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    Arguments
    ==========

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.

                TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.

                TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    X      - COMPLEX          array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - COMPLEX         .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - COMPLEX          array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':1054,'multiline':True]['text':' Parameter adjustments ','line_number':1155,'multiline':True]['text':' Function Body ','line_number':1162,'multiline':True]['text':'     Quick return if possible. ','line_number':1183,'multiline':True]['text':'
       Set  LENX  and  LENY, the lengths of the vectors x and y, and set
       up the start points in  X  and  Y.
','line_number':1192,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.

       First form  y := beta*y.
','line_number':1215,'multiline':True]['text':' L10: ','line_number':1229,'multiline':True]['text':' L20: ','line_number':1240,'multiline':True]['text':' L30: ','line_number':1251,'multiline':True]['text':' L40: ','line_number':1263,'multiline':True]['text':'        Form  y := alpha*A*x + y. ','line_number':1273,'multiline':True]['text':' L50: ','line_number':1297,'multiline':True]['text':' L60: ','line_number':1301,'multiline':True]['text':' L70: ','line_number':1326,'multiline':True]['text':' L80: ','line_number':1330,'multiline':True]['text':'        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y. ','line_number':1335,'multiline':True]['text':' L90: ','line_number':1352,'multiline':True]['text':' L100: ','line_number':1364,'multiline':True]['text':' L110: ','line_number':1374,'multiline':True]['text':' L120: ','line_number':1392,'multiline':True]['text':' L130: ','line_number':1405,'multiline':True]['text':' L140: ','line_number':1415,'multiline':True]['text':'     End of CGEMV . ','line_number':1422,'multiline':True]['text':' cgemv_ ','line_number':1424,'multiline':True]['text':' Subroutine ','line_number':1426,'multiline':True]['text':' System generated locals ','line_number':1429,'multiline':True]['text':' Local variables ','line_number':1433,'multiline':True]['text':' Subroutine ','line_number':1436,'multiline':True]['text':'
    Purpose
    =======

    CGERC  performs the rank 1 operation

       A := alpha*x*conjg( y' ) + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':1439,'multiline':True]['text':' Parameter adjustments ','line_number':1517,'multiline':True]['text':' Function Body ','line_number':1524,'multiline':True]['text':'     Quick return if possible. ','line_number':1542,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':1548,'multiline':True]['text':' L10: ','line_number':1576,'multiline':True]['text':' L20: ','line_number':1580,'multiline':True]['text':' L30: ','line_number':1607,'multiline':True]['text':' L40: ','line_number':1611,'multiline':True]['text':'     End of CGERC . ','line_number':1617,'multiline':True]['text':' cgerc_ ','line_number':1619,'multiline':True]['text':' Subroutine ','line_number':1621,'multiline':True]['text':' System generated locals ','line_number':1624,'multiline':True]['text':' Local variables ','line_number':1628,'multiline':True]['text':' Subroutine ','line_number':1631,'multiline':True]['text':'
    Purpose
    =======

    CGERU  performs the rank 1 operation

       A := alpha*x*y' + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':1634,'multiline':True]['text':' Parameter adjustments ','line_number':1712,'multiline':True]['text':' Function Body ','line_number':1719,'multiline':True]['text':'     Quick return if possible. ','line_number':1737,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':1743,'multiline':True]['text':' L10: ','line_number':1771,'multiline':True]['text':' L20: ','line_number':1775,'multiline':True]['text':' L30: ','line_number':1802,'multiline':True]['text':' L40: ','line_number':1806,'multiline':True]['text':'     End of CGERU . ','line_number':1812,'multiline':True]['text':' cgeru_ ','line_number':1814,'multiline':True]['text':' Subroutine ','line_number':1816,'multiline':True]['text':' System generated locals ','line_number':1820,'multiline':True]['text':' Local variables ','line_number':1825,'multiline':True]['text':' Subroutine ','line_number':1829,'multiline':True]['text':'
    Purpose
    =======

    CHEMV  performs the matrix-vector  operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n hermitian matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - COMPLEX         .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':1832,'multiline':True]['text':' Parameter adjustments ','line_number':1931,'multiline':True]['text':' Function Body ','line_number':1938,'multiline':True]['text':'     Quick return if possible. ','line_number':1956,'multiline':True]['text':'     Set up the start points in  X  and  Y. ','line_number':1963,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.

       First form  y := beta*y.
','line_number':1976,'multiline':True]['text':' L10: ','line_number':1991,'multiline':True]['text':' L20: ','line_number':2002,'multiline':True]['text':' L30: ','line_number':2013,'multiline':True]['text':' L40: ','line_number':2025,'multiline':True]['text':'        Form  y  when A is stored in upper triangle. ','line_number':2035,'multiline':True]['text':' L50: ','line_number':2061,'multiline':True]['text':' L60: ','line_number':2073,'multiline':True]['text':' L70: ','line_number':2105,'multiline':True]['text':' L80: ','line_number':2119,'multiline':True]['text':'        Form  y  when A is stored in lower triangle. ','line_number':2124,'multiline':True]['text':' L90: ','line_number':2157,'multiline':True]['text':' L100: ','line_number':2165,'multiline':True]['text':' L110: ','line_number':2204,'multiline':True]['text':' L120: ','line_number':2214,'multiline':True]['text':'     End of CHEMV . ','line_number':2221,'multiline':True]['text':' chemv_ ','line_number':2223,'multiline':True]['text':' Subroutine ','line_number':2225,'multiline':True]['text':' System generated locals ','line_number':2228,'multiline':True]['text':' Local variables ','line_number':2233,'multiline':True]['text':' Subroutine ','line_number':2237,'multiline':True]['text':'
    Purpose
    =======

    CHER2  performs the hermitian rank 2 operation

       A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,

    where alpha is a scalar, x and y are n element vectors and A is an n
    by n hermitian matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':2240,'multiline':True]['text':' Parameter adjustments ','line_number':2338,'multiline':True]['text':' Function Body ','line_number':2345,'multiline':True]['text':'     Quick return if possible. ','line_number':2363,'multiline':True]['text':'
       Set up the start points in X and Y if the increments are not both
       unity.
','line_number':2369,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.
','line_number':2389,'multiline':True]['text':'        Form  A  when A is stored in the upper triangle. ','line_number':2397,'multiline':True]['text':' L10: ','line_number':2432,'multiline':True]['text':' L20: ','line_number':2453,'multiline':True]['text':' L30: ','line_number':2492,'multiline':True]['text':' L40: ','line_number':2515,'multiline':True]['text':'        Form  A  when A is stored in the lower triangle. ','line_number':2520,'multiline':True]['text':' L50: ','line_number':2568,'multiline':True]['text':' L60: ','line_number':2576,'multiline':True]['text':' L70: ','line_number':2628,'multiline':True]['text':' L80: ','line_number':2638,'multiline':True]['text':'     End of CHER2 . ','line_number':2645,'multiline':True]['text':' cher2_ ','line_number':2647,'multiline':True]['text':' Subroutine ','line_number':2649,'multiline':True]['text':' System generated locals ','line_number':2653,'multiline':True]['text':' Local variables ','line_number':2659,'multiline':True]['text':' Subroutine ','line_number':2665,'multiline':True]['text':'
    Purpose
    =======

    CHER2K  performs one of the hermitian rank 2k operations

       C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) + beta*C,

    or

       C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A + beta*C,

    where  alpha and beta  are scalars with  beta  real,  C is an  n by n
    hermitian matrix and  A and B  are  n by k matrices in the first case
    and  k by n  matrices in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'    C := alpha*A*conjg( B' )          +
                                           conjg( alpha )*B*conjg( A' ) +
                                           beta*C.

                TRANS = 'C' or 'c'    C := alpha*conjg( A' )*B          +
                                           conjg( alpha )*conjg( B' )*A +
                                           beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - COMPLEX          array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.
       Ed Anderson, Cray Research Inc.

    =====================================================================


       Test the input parameters.
','line_number':2668,'multiline':True]['text':' Parameter adjustments ','line_number':2807,'multiline':True]['text':' Function Body ','line_number':2818,'multiline':True]['text':'     Quick return if possible. ','line_number':2848,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':2855,'multiline':True]['text':' L10: ','line_number':2866,'multiline':True]['text':' L20: ','line_number':2868,'multiline':True]['text':' L30: ','line_number':2880,'multiline':True]['text':' L40: ','line_number':2886,'multiline':True]['text':' L50: ','line_number':2897,'multiline':True]['text':' L60: ','line_number':2899,'multiline':True]['text':' L70: ','line_number':2915,'multiline':True]['text':' L80: ','line_number':2917,'multiline':True]['text':'     Start the operations. ','line_number':2924,'multiline':True]['text':'
          Form  C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) +
                     C.
','line_number':2928,'multiline':True]['text':' L90: ','line_number':2941,'multiline':True]['text':' L100: ','line_number':2951,'multiline':True]['text':' L110: ','line_number':2997,'multiline':True]['text':' L120: ','line_number':3013,'multiline':True]['text':' L130: ','line_number':3015,'multiline':True]['text':' L140: ','line_number':3025,'multiline':True]['text':' L150: ','line_number':3035,'multiline':True]['text':' L160: ','line_number':3081,'multiline':True]['text':' L170: ','line_number':3097,'multiline':True]['text':' L180: ','line_number':3099,'multiline':True]['text':'
          Form  C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A +
                     C.
','line_number':3104,'multiline':True]['text':' L190: ','line_number':3132,'multiline':True]['text':' L200: ','line_number':3195,'multiline':True]['text':' L210: ','line_number':3197,'multiline':True]['text':' L220: ','line_number':3222,'multiline':True]['text':' L230: ','line_number':3285,'multiline':True]['text':' L240: ','line_number':3287,'multiline':True]['text':'     End of CHER2K. ','line_number':3294,'multiline':True]['text':' cher2k_ ','line_number':3296,'multiline':True]['text':' Subroutine ','line_number':3298,'multiline':True]['text':' System generated locals ','line_number':3302,'multiline':True]['text':' Local variables ','line_number':3308,'multiline':True]['text':' Subroutine ','line_number':3315,'multiline':True]['text':'
    Purpose
    =======

    CHERK  performs one of the hermitian rank k operations

       C := alpha*A*conjg( A' ) + beta*C,

    or

       C := alpha*conjg( A' )*A + beta*C,

    where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
    matrix and  A  is an  n by k  matrix in the  first case and a  k by n
    matrix in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*conjg( A' ) + beta*C.

                TRANS = 'C' or 'c'   C := alpha*conjg( A' )*A + beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - COMPLEX          array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.
       Ed Anderson, Cray Research Inc.

    =====================================================================


       Test the input parameters.
','line_number':3318,'multiline':True]['text':' Parameter adjustments ','line_number':3438,'multiline':True]['text':' Function Body ','line_number':3446,'multiline':True]['text':'     Quick return if possible. ','line_number':3474,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':3480,'multiline':True]['text':' L10: ','line_number':3491,'multiline':True]['text':' L20: ','line_number':3493,'multiline':True]['text':' L30: ','line_number':3505,'multiline':True]['text':' L40: ','line_number':3511,'multiline':True]['text':' L50: ','line_number':3522,'multiline':True]['text':' L60: ','line_number':3524,'multiline':True]['text':' L70: ','line_number':3540,'multiline':True]['text':' L80: ','line_number':3542,'multiline':True]['text':'     Start the operations. ','line_number':3549,'multiline':True]['text':'        Form  C := alpha*A*conjg( A' ) + beta*C. ','line_number':3553,'multiline':True]['text':' L90: ','line_number':3563,'multiline':True]['text':' L100: ','line_number':3573,'multiline':True]['text':' L110: ','line_number':3603,'multiline':True]['text':' L120: ','line_number':3614,'multiline':True]['text':' L130: ','line_number':3616,'multiline':True]['text':' L140: ','line_number':3626,'multiline':True]['text':' L150: ','line_number':3640,'multiline':True]['text':' L160: ','line_number':3674,'multiline':True]['text':' L170: ','line_number':3677,'multiline':True]['text':' L180: ','line_number':3679,'multiline':True]['text':'        Form  C := alpha*conjg( A' )*A + beta*C. ','line_number':3684,'multiline':True]['text':' L190: ','line_number':3701,'multiline':True]['text':' L200: ','line_number':3716,'multiline':True]['text':' L210: ','line_number':3727,'multiline':True]['text':' L220: ','line_number':3739,'multiline':True]['text':' L230: ','line_number':3753,'multiline':True]['text':' L240: ','line_number':3777,'multiline':True]['text':' L250: ','line_number':3792,'multiline':True]['text':' L260: ','line_number':3794,'multiline':True]['text':'     End of CHERK . ','line_number':3801,'multiline':True]['text':' cherk_ ','line_number':3803,'multiline':True]['text':' Subroutine ','line_number':3805,'multiline':True]['text':' System generated locals ','line_number':3808,'multiline':True]['text':' Local variables ','line_number':3812,'multiline':True]['text':'
    Purpose
    =======

       CSCAL scales a vector by a constant.

    Further Details
    ===============

       jack dongarra, linpack,  3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':3816,'multiline':True]['text':' Parameter adjustments ','line_number':3832,'multiline':True]['text':' Function Body ','line_number':3835,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':3843,'multiline':True]['text':' L10: ','line_number':3854,'multiline':True]['text':'        code for increment equal to 1 ','line_number':3858,'multiline':True]['text':' L30: ','line_number':3868,'multiline':True]['text':' cscal_ ','line_number':3871,'multiline':True]['text':' Subroutine ','line_number':3873,'multiline':True]['text':' System generated locals ','line_number':3876,'multiline':True]['text':' Local variables ','line_number':3880,'multiline':True]['text':'
    Purpose
    =======

    CSROT applies a plane rotation, where the cos and sin (c and s) are real
    and the vectors cx and cy are singlecomplex.
    jack dongarra, linpack, 3/11/78.

    Arguments
    ==========

    N        (input) INTEGER
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
             Unchanged on exit.

    CX       (input) COMPLEX array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.

    INCX     (input) INTEGER
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
             Unchanged on exit.

    CY       (input) COMPLEX array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.

    INCY     (input) INTEGER
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
             Unchanged on exit.

    C        (input) REAL
             On entry, C specifies the cosine, cos.
             Unchanged on exit.

    S        (input) REAL
             On entry, S specifies the sine, sin.
             Unchanged on exit.

    =====================================================================
','line_number':3885,'multiline':True]['text':' Parameter adjustments ','line_number':3935,'multiline':True]['text':' Function Body ','line_number':3939,'multiline':True]['text':'
          code for unequal increments or equal increments not equal
            to 1
','line_number':3947,'multiline':True]['text':' L10: ','line_number':3979,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':3983,'multiline':True]['text':' L30: ','line_number':4003,'multiline':True]['text':' csrot_ ','line_number':4006,'multiline':True]['text':' Subroutine ','line_number':4008,'multiline':True]['text':' System generated locals ','line_number':4010,'multiline':True]['text':' Local variables ','line_number':4015,'multiline':True]['text':'
    Purpose
    =======

       CSSCAL scales a complex vector by a real constant.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':4019,'multiline':True]['text':' Parameter adjustments ','line_number':4035,'multiline':True]['text':' Function Body ','line_number':4038,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':4046,'multiline':True]['text':' L10: ','line_number':4058,'multiline':True]['text':'        code for increment equal to 1 ','line_number':4062,'multiline':True]['text':' L30: ','line_number':4073,'multiline':True]['text':' csscal_ ','line_number':4076,'multiline':True]['text':' Subroutine ','line_number':4078,'multiline':True]['text':' System generated locals ','line_number':4081,'multiline':True]['text':' Local variables ','line_number':4084,'multiline':True]['text':'
    Purpose
    =======

      CSWAP interchanges two vectors.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':4089,'multiline':True]['text':' Parameter adjustments ','line_number':4104,'multiline':True]['text':' Function Body ','line_number':4108,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':4116,'multiline':True]['text':' L10: ','line_number':4140,'multiline':True]['text':'       code for both increments equal to 1 ','line_number':4144,'multiline':True]['text':' L30: ','line_number':4155,'multiline':True]['text':' cswap_ ','line_number':4158,'multiline':True]['text':' Subroutine ','line_number':4160,'multiline':True]['text':' System generated locals ','line_number':4164,'multiline':True]['text':' Local variables ','line_number':4169,'multiline':True]['text':' Subroutine ','line_number':4176,'multiline':True]['text':'
    Purpose
    =======

    CTRMM  performs one of the matrix-matrix operations

       B := alpha*op( A )*B,   or   B := alpha*B*op( A )

    where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:

                SIDE = 'L' or 'l'   B := alpha*op( A )*B.

                SIDE = 'R' or 'r'   B := alpha*B*op( A ).

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - COMPLEX          array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':4180,'multiline':True]['text':' Parameter adjustments ','line_number':4304,'multiline':True]['text':' Function Body ','line_number':4312,'multiline':True]['text':'     Quick return if possible. ','line_number':4348,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':4354,'multiline':True]['text':' L10: ','line_number':4363,'multiline':True]['text':' L20: ','line_number':4365,'multiline':True]['text':'     Start the operations. ','line_number':4370,'multiline':True]['text':'           Form  B := alpha*A*B. ','line_number':4375,'multiline':True]['text':' L30: ','line_number':4400,'multiline':True]['text':' L40: ','line_number':4412,'multiline':True]['text':' L50: ','line_number':4414,'multiline':True]['text':' L60: ','line_number':4449,'multiline':True]['text':' L70: ','line_number':4452,'multiline':True]['text':' L80: ','line_number':4454,'multiline':True]['text':'           Form  B := alpha*A'*B   or   B := alpha*conjg( A' )*B. ','line_number':4459,'multiline':True]['text':' L90: ','line_number':4485,'multiline':True]['text':' L100: ','line_number':4505,'multiline':True]['text':' L110: ','line_number':4513,'multiline':True]['text':' L120: ','line_number':4515,'multiline':True]['text':' L130: ','line_number':4542,'multiline':True]['text':' L140: ','line_number':4562,'multiline':True]['text':' L150: ','line_number':4570,'multiline':True]['text':' L160: ','line_number':4572,'multiline':True]['text':'           Form  B := alpha*B*A. ','line_number':4579,'multiline':True]['text':' L170: ','line_number':4599,'multiline':True]['text':' L180: ','line_number':4621,'multiline':True]['text':' L190: ','line_number':4624,'multiline':True]['text':' L200: ','line_number':4626,'multiline':True]['text':' L210: ','line_number':4647,'multiline':True]['text':' L220: ','line_number':4669,'multiline':True]['text':' L230: ','line_number':4672,'multiline':True]['text':' L240: ','line_number':4674,'multiline':True]['text':'           Form  B := alpha*B*A'   or   B := alpha*B*conjg( A' ). ','line_number':4679,'multiline':True]['text':' L250: ','line_number':4712,'multiline':True]['text':' L260: ','line_number':4715,'multiline':True]['text':' L270: ','line_number':4742,'multiline':True]['text':' L280: ','line_number':4745,'multiline':True]['text':' L290: ','line_number':4777,'multiline':True]['text':' L300: ','line_number':4780,'multiline':True]['text':' L310: ','line_number':4807,'multiline':True]['text':' L320: ','line_number':4810,'multiline':True]['text':'     End of CTRMM . ','line_number':4818,'multiline':True]['text':' ctrmm_ ','line_number':4820,'multiline':True]['text':' Subroutine ','line_number':4822,'multiline':True]['text':' System generated locals ','line_number':4825,'multiline':True]['text':' Local variables ','line_number':4829,'multiline':True]['text':' Subroutine ','line_number':4833,'multiline':True]['text':'
    Purpose
    =======

    CTRMV  performs one of the matrix-vector operations

       x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,

    where x is an n element vector and  A is an n by n unit, or non-unit,
    upper or lower triangular matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   x := A*x.

                TRANS = 'T' or 't'   x := A'*x.

                TRANS = 'C' or 'c'   x := conjg( A' )*x.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':4837,'multiline':True]['text':' Parameter adjustments ','line_number':4936,'multiline':True]['text':' Function Body ','line_number':4942,'multiline':True]['text':'     Quick return if possible. ','line_number':4964,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':4973,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':4984,'multiline':True]['text':'        Form  x := A*x. ','line_number':4991,'multiline':True]['text':' L10: ','line_number':5012,'multiline':True]['text':' L20: ','line_number':5024,'multiline':True]['text':' L30: ','line_number':5047,'multiline':True]['text':' L40: ','line_number':5060,'multiline':True]['text':' L50: ','line_number':5081,'multiline':True]['text':' L60: ','line_number':5093,'multiline':True]['text':' L70: ','line_number':5116,'multiline':True]['text':' L80: ','line_number':5129,'multiline':True]['text':'        Form  x := A'*x  or  x := conjg( A' )*x. ','line_number':5135,'multiline':True]['text':' L90: ','line_number':5159,'multiline':True]['text':' L100: ','line_number':5178,'multiline':True]['text':' L110: ','line_number':5183,'multiline':True]['text':' L120: ','line_number':5209,'multiline':True]['text':' L130: ','line_number':5229,'multiline':True]['text':' L140: ','line_number':5235,'multiline':True]['text':' L150: ','line_number':5262,'multiline':True]['text':' L160: ','line_number':5282,'multiline':True]['text':' L170: ','line_number':5287,'multiline':True]['text':' L180: ','line_number':5315,'multiline':True]['text':' L190: ','line_number':5336,'multiline':True]['text':' L200: ','line_number':5342,'multiline':True]['text':'     End of CTRMV . ','line_number':5350,'multiline':True]['text':' ctrmv_ ','line_number':5352,'multiline':True]['text':' Subroutine ','line_number':5354,'multiline':True]['text':' System generated locals ','line_number':5358,'multiline':True]['text':' Local variables ','line_number':5363,'multiline':True]['text':' Subroutine ','line_number':5370,'multiline':True]['text':'
    Purpose
    =======

    CTRSM  solves one of the matrix equations

       op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).

    The matrix X is overwritten on B.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:

                SIDE = 'L' or 'l'   op( A )*X = alpha*B.

                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX         .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - COMPLEX          array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':5374,'multiline':True]['text':' Parameter adjustments ','line_number':5500,'multiline':True]['text':' Function Body ','line_number':5508,'multiline':True]['text':'     Quick return if possible. ','line_number':5544,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':5550,'multiline':True]['text':' L10: ','line_number':5559,'multiline':True]['text':' L20: ','line_number':5561,'multiline':True]['text':'     Start the operations. ','line_number':5566,'multiline':True]['text':'           Form  B := alpha*inv( A )*B. ','line_number':5571,'multiline':True]['text':' L30: ','line_number':5585,'multiline':True]['text':' L40: ','line_number':5609,'multiline':True]['text':' L50: ','line_number':5612,'multiline':True]['text':' L60: ','line_number':5614,'multiline':True]['text':' L70: ','line_number':5628,'multiline':True]['text':' L80: ','line_number':5653,'multiline':True]['text':' L90: ','line_number':5656,'multiline':True]['text':' L100: ','line_number':5658,'multiline':True]['text':'
             Form  B := alpha*inv( A' )*B
             or    B := alpha*inv( conjg( A' ) )*B.
','line_number':5663,'multiline':True]['text':' L110: ','line_number':5689,'multiline':True]['text':' L120: ','line_number':5706,'multiline':True]['text':' L130: ','line_number':5716,'multiline':True]['text':' L140: ','line_number':5718,'multiline':True]['text':' L150: ','line_number':5740,'multiline':True]['text':' L160: ','line_number':5757,'multiline':True]['text':' L170: ','line_number':5767,'multiline':True]['text':' L180: ','line_number':5769,'multiline':True]['text':'           Form  B := alpha*B*inv( A ). ','line_number':5776,'multiline':True]['text':' L190: ','line_number':5790,'multiline':True]['text':' L200: ','line_number':5809,'multiline':True]['text':' L210: ','line_number':5812,'multiline':True]['text':' L220: ','line_number':5825,'multiline':True]['text':' L230: ','line_number':5828,'multiline':True]['text':' L240: ','line_number':5841,'multiline':True]['text':' L250: ','line_number':5860,'multiline':True]['text':' L260: ','line_number':5863,'multiline':True]['text':' L270: ','line_number':5876,'multiline':True]['text':' L280: ','line_number':5879,'multiline':True]['text':'
             Form  B := alpha*B*inv( A' )
             or    B := alpha*B*inv( conjg( A' ) ).
','line_number':5884,'multiline':True]['text':' L290: ','line_number':5908,'multiline':True]['text':' L300: ','line_number':5933,'multiline':True]['text':' L310: ','line_number':5936,'multiline':True]['text':' L320: ','line_number':5947,'multiline':True]['text':' L330: ','line_number':5950,'multiline':True]['text':' L340: ','line_number':5972,'multiline':True]['text':' L350: ','line_number':5997,'multiline':True]['text':' L360: ','line_number':6000,'multiline':True]['text':' L370: ','line_number':6011,'multiline':True]['text':' L380: ','line_number':6014,'multiline':True]['text':'     End of CTRSM . ','line_number':6022,'multiline':True]['text':' ctrsm_ ','line_number':6024,'multiline':True]['text':' Subroutine ','line_number':6026,'multiline':True]['text':' System generated locals ','line_number':6029,'multiline':True]['text':' Local variables ','line_number':6033,'multiline':True]['text':' Subroutine ','line_number':6037,'multiline':True]['text':'
    Purpose
    =======

    CTRSV  solves one of the systems of equations

       A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,

    where b and x are n element vectors and A is an n by n unit, or
    non-unit, upper or lower triangular matrix.

    No test for singularity or near-singularity is included in this
    routine. Such tests must be performed before calling this routine.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the equations to be solved as
             follows:

                TRANS = 'N' or 'n'   A*x = b.

                TRANS = 'T' or 't'   A'*x = b.

                TRANS = 'C' or 'c'   conjg( A' )*x = b.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - COMPLEX          array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX          array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':6041,'multiline':True]['text':' Parameter adjustments ','line_number':6143,'multiline':True]['text':' Function Body ','line_number':6149,'multiline':True]['text':'     Quick return if possible. ','line_number':6171,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':6180,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':6191,'multiline':True]['text':'        Form  x := inv( A )*x. ','line_number':6198,'multiline':True]['text':' L10: ','line_number':6222,'multiline':True]['text':' L20: ','line_number':6225,'multiline':True]['text':' L30: ','line_number':6251,'multiline':True]['text':' L40: ','line_number':6255,'multiline':True]['text':' L50: ','line_number':6282,'multiline':True]['text':' L60: ','line_number':6285,'multiline':True]['text':' L70: ','line_number':6313,'multiline':True]['text':' L80: ','line_number':6317,'multiline':True]['text':'        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x. ','line_number':6323,'multiline':True]['text':' L90: ','line_number':6342,'multiline':True]['text':' L100: ','line_number':6359,'multiline':True]['text':' L110: ','line_number':6369,'multiline':True]['text':' L120: ','line_number':6390,'multiline':True]['text':' L130: ','line_number':6408,'multiline':True]['text':' L140: ','line_number':6419,'multiline':True]['text':' L150: ','line_number':6438,'multiline':True]['text':' L160: ','line_number':6455,'multiline':True]['text':' L170: ','line_number':6465,'multiline':True]['text':' L180: ','line_number':6486,'multiline':True]['text':' L190: ','line_number':6504,'multiline':True]['text':' L200: ','line_number':6515,'multiline':True]['text':'     End of CTRSV . ','line_number':6523,'multiline':True]['text':' ctrsv_ ','line_number':6525,'multiline':True]['text':' Subroutine ','line_number':6527,'multiline':True]['text':' System generated locals ','line_number':6530,'multiline':True]['text':' Local variables ','line_number':6533,'multiline':True]['text':'
    Purpose
    =======

       DAXPY constant times a vector plus a vector.
       uses unrolled loops for increments equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':6537,'multiline':True]['text':' Parameter adjustments ','line_number':6553,'multiline':True]['text':' Function Body ','line_number':6557,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':6568,'multiline':True]['text':' L10: ','line_number':6586,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':6590,'multiline':True]['text':' L30: ','line_number':6605,'multiline':True]['text':' L50: ','line_number':6618,'multiline':True]['text':' daxpy_ ','line_number':6621,'multiline':True]['text':' System generated locals ','line_number':6625,'multiline':True]['text':'
    Purpose
    =======

    DCABS1 computes absolute value of a double singlecomplex number

    =====================================================================
','line_number':6628,'multiline':True]['text':' dcabs1_ ','line_number':6640,'multiline':True]['text':' Subroutine ','line_number':6642,'multiline':True]['text':' System generated locals ','line_number':6645,'multiline':True]['text':' Local variables ','line_number':6648,'multiline':True]['text':'
    Purpose
    =======

       DCOPY copies a vector, x, to a vector, y.
       uses unrolled loops for increments equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':6652,'multiline':True]['text':' Parameter adjustments ','line_number':6668,'multiline':True]['text':' Function Body ','line_number':6672,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':6680,'multiline':True]['text':' L10: ','line_number':6698,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':6702,'multiline':True]['text':' L30: ','line_number':6717,'multiline':True]['text':' L50: ','line_number':6733,'multiline':True]['text':' dcopy_ ','line_number':6736,'multiline':True]['text':' System generated locals ','line_number':6741,'multiline':True]['text':' Local variables ','line_number':6745,'multiline':True]['text':'
    Purpose
    =======

       DDOT forms the dot product of two vectors.
       uses unrolled loops for increments equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':6750,'multiline':True]['text':' Parameter adjustments ','line_number':6766,'multiline':True]['text':' Function Body ','line_number':6770,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':6780,'multiline':True]['text':' L10: ','line_number':6798,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':6803,'multiline':True]['text':' L30: ','line_number':6818,'multiline':True]['text':' L50: ','line_number':6830,'multiline':True]['text':' ddot_ ','line_number':6835,'multiline':True]['text':' Subroutine ','line_number':6837,'multiline':True]['text':' System generated locals ','line_number':6842,'multiline':True]['text':' Local variables ','line_number':6846,'multiline':True]['text':' Subroutine ','line_number':6852,'multiline':True]['text':'
    Purpose
    =======

    DGEMM  performs one of the matrix-matrix operations

       C := alpha*op( A )*op( B ) + beta*C,

    where  op( X ) is one of

       op( X ) = X   or   op( X ) = X',

    alpha and beta are scalars, and A, B and C are matrices, with op( A )
    an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

    Arguments
    ==========

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n',  op( A ) = A.

                TRANSA = 'T' or 't',  op( A ) = A'.

                TRANSA = 'C' or 'c',  op( A ) = A'.

             Unchanged on exit.

    TRANSB - CHARACTER*1.
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:

                TRANSB = 'N' or 'n',  op( B ) = B.

                TRANSB = 'T' or 't',  op( B ) = B'.

                TRANSB = 'C' or 'c',  op( B ) = B'.

             Unchanged on exit.

    M      - INTEGER.
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
             Unchanged on exit.

    B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
             Unchanged on exit.

    C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
       transposed and set  NROWA and  NROWB  as the number of rows
       and  columns of  A  and the  number of  rows  of  B  respectively.
','line_number':6855,'multiline':True]['text':' Parameter adjustments ','line_number':6985,'multiline':True]['text':' Function Body ','line_number':6996,'multiline':True]['text':'     Test the input parameters. ','line_number':7010,'multiline':True]['text':'     Quick return if possible. ','line_number':7037,'multiline':True]['text':'     And if  alpha.eq.zero. ','line_number':7043,'multiline':True]['text':' L10: ','line_number':7052,'multiline':True]['text':' L20: ','line_number':7054,'multiline':True]['text':' L30: ','line_number':7062,'multiline':True]['text':' L40: ','line_number':7064,'multiline':True]['text':'     Start the operations. ','line_number':7070,'multiline':True]['text':'           Form  C := alpha*A*B + beta*C. ','line_number':7075,'multiline':True]['text':' L50: ','line_number':7083,'multiline':True]['text':' L60: ','line_number':7089,'multiline':True]['text':' L70: ','line_number':7100,'multiline':True]['text':' L80: ','line_number':7103,'multiline':True]['text':' L90: ','line_number':7105,'multiline':True]['text':'           Form  C := alpha*A'*B + beta*C ','line_number':7109,'multiline':True]['text':' L100: ','line_number':7119,'multiline':True]['text':' L110: ','line_number':7127,'multiline':True]['text':' L120: ','line_number':7129,'multiline':True]['text':'           Form  C := alpha*A*B' + beta*C ','line_number':7135,'multiline':True]['text':' L130: ','line_number':7143,'multiline':True]['text':' L140: ','line_number':7149,'multiline':True]['text':' L150: ','line_number':7160,'multiline':True]['text':' L160: ','line_number':7163,'multiline':True]['text':' L170: ','line_number':7165,'multiline':True]['text':'           Form  C := alpha*A'*B' + beta*C ','line_number':7169,'multiline':True]['text':' L180: ','line_number':7179,'multiline':True]['text':' L190: ','line_number':7187,'multiline':True]['text':' L200: ','line_number':7189,'multiline':True]['text':'     End of DGEMM . ','line_number':7196,'multiline':True]['text':' dgemm_ ','line_number':7198,'multiline':True]['text':' Subroutine ','line_number':7200,'multiline':True]['text':' System generated locals ','line_number':7204,'multiline':True]['text':' Local variables ','line_number':7207,'multiline':True]['text':' Subroutine ','line_number':7212,'multiline':True]['text':'
    Purpose
    =======

    DGEMV  performs one of the matrix-vector operations

       y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    Arguments
    ==========

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.

                TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.

                TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    X      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':7215,'multiline':True]['text':' Parameter adjustments ','line_number':7314,'multiline':True]['text':' Function Body ','line_number':7321,'multiline':True]['text':'     Quick return if possible. ','line_number':7342,'multiline':True]['text':'
       Set  LENX  and  LENY, the lengths of the vectors x and y, and set
       up the start points in  X  and  Y.
','line_number':7348,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.

       First form  y := beta*y.
','line_number':7371,'multiline':True]['text':' L10: ','line_number':7384,'multiline':True]['text':' L20: ','line_number':7390,'multiline':True]['text':' L30: ','line_number':7400,'multiline':True]['text':' L40: ','line_number':7407,'multiline':True]['text':'        Form  y := alpha*A*x + y. ','line_number':7417,'multiline':True]['text':' L50: ','line_number':7428,'multiline':True]['text':' L60: ','line_number':7432,'multiline':True]['text':' L70: ','line_number':7444,'multiline':True]['text':' L80: ','line_number':7448,'multiline':True]['text':'        Form  y := alpha*A'*x + y. ','line_number':7453,'multiline':True]['text':' L90: ','line_number':7463,'multiline':True]['text':' L100: ','line_number':7467,'multiline':True]['text':' L110: ','line_number':7478,'multiline':True]['text':' L120: ','line_number':7482,'multiline':True]['text':'     End of DGEMV . ','line_number':7489,'multiline':True]['text':' dgemv_ ','line_number':7491,'multiline':True]['text':' Subroutine ','line_number':7493,'multiline':True]['text':' System generated locals ','line_number':7497,'multiline':True]['text':' Local variables ','line_number':7500,'multiline':True]['text':' Subroutine ','line_number':7503,'multiline':True]['text':'
    Purpose
    =======

    DGER   performs the rank 1 operation

       A := alpha*x*y' + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':7506,'multiline':True]['text':' Parameter adjustments ','line_number':7584,'multiline':True]['text':' Function Body ','line_number':7591,'multiline':True]['text':'     Quick return if possible. ','line_number':7609,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':7615,'multiline':True]['text':' L10: ','line_number':7633,'multiline':True]['text':' L20: ','line_number':7637,'multiline':True]['text':' L30: ','line_number':7654,'multiline':True]['text':' L40: ','line_number':7658,'multiline':True]['text':'     End of DGER  . ','line_number':7664,'multiline':True]['text':' dger_ ','line_number':7666,'multiline':True]['text':' System generated locals ','line_number':7670,'multiline':True]['text':' Local variables ','line_number':7674,'multiline':True]['text':'
    Purpose
    =======

    DNRM2 returns the euclidean norm of a vector via the function
    name, so that

       DNRM2 := sqrt( x'*x )

    Further Details
    ===============

    -- This version written on 25-October-1982.
       Modified on 14-October-1993 to inline the call to DLASSQ.
       Sven Hammarling, Nag Ltd.

    =====================================================================
','line_number':7679,'multiline':True]['text':' Parameter adjustments ','line_number':7698,'multiline':True]['text':' Function Body ','line_number':7701,'multiline':True]['text':'
          The following loop is equivalent to this call to the LAPACK
          auxiliary routine:
          CALL DLASSQ( N, X, INCX, SCALE, SSQ )
','line_number':7709,'multiline':True]['text':' Computing 2nd power ','line_number':7721,'multiline':True]['text':' Computing 2nd power ','line_number':7726,'multiline':True]['text':' L10: ','line_number':7731,'multiline':True]['text':'     End of DNRM2. ','line_number':7739,'multiline':True]['text':' dnrm2_ ','line_number':7741,'multiline':True]['text':' Subroutine ','line_number':7743,'multiline':True]['text':' System generated locals ','line_number':7746,'multiline':True]['text':' Local variables ','line_number':7749,'multiline':True]['text':'
    Purpose
    =======

       DROT applies a plane rotation.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':7754,'multiline':True]['text':' Parameter adjustments ','line_number':7769,'multiline':True]['text':' Function Body ','line_number':7773,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':7781,'multiline':True]['text':' L10: ','line_number':7801,'multiline':True]['text':'       code for both increments equal to 1 ','line_number':7805,'multiline':True]['text':' L30: ','line_number':7813,'multiline':True]['text':' drot_ ','line_number':7816,'multiline':True]['text':' Subroutine ','line_number':7818,'multiline':True]['text':' System generated locals ','line_number':7821,'multiline':True]['text':' Local variables ','line_number':7824,'multiline':True]['text':'
    Purpose
    =======

       DSCAL scales a vector by a constant.
       uses unrolled loops for increment equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':7828,'multiline':True]['text':' Parameter adjustments ','line_number':7845,'multiline':True]['text':' Function Body ','line_number':7848,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':7856,'multiline':True]['text':' L10: ','line_number':7863,'multiline':True]['text':'
          code for increment equal to 1


          clean-up loop
','line_number':7867,'multiline':True]['text':' L30: ','line_number':7882,'multiline':True]['text':' L50: ','line_number':7896,'multiline':True]['text':' dscal_ ','line_number':7899,'multiline':True]['text':' Subroutine ','line_number':7901,'multiline':True]['text':' System generated locals ','line_number':7904,'multiline':True]['text':' Local variables ','line_number':7907,'multiline':True]['text':'
    Purpose
    =======

       interchanges two vectors.
       uses unrolled loops for increments equal one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':7912,'multiline':True]['text':' Parameter adjustments ','line_number':7928,'multiline':True]['text':' Function Body ','line_number':7932,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':7940,'multiline':True]['text':' L10: ','line_number':7960,'multiline':True]['text':'
         code for both increments equal to 1


         clean-up loop
','line_number':7964,'multiline':True]['text':' L30: ','line_number':7981,'multiline':True]['text':' L50: ','line_number':7999,'multiline':True]['text':' dswap_ ','line_number':8002,'multiline':True]['text':' Subroutine ','line_number':8004,'multiline':True]['text':' System generated locals ','line_number':8008,'multiline':True]['text':' Local variables ','line_number':8011,'multiline':True]['text':' Subroutine ','line_number':8015,'multiline':True]['text':'
    Purpose
    =======

    DSYMV  performs the matrix-vector  operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n symmetric matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':8018,'multiline':True]['text':' Parameter adjustments ','line_number':8115,'multiline':True]['text':' Function Body ','line_number':8122,'multiline':True]['text':'     Quick return if possible. ','line_number':8140,'multiline':True]['text':'     Set up the start points in  X  and  Y. ','line_number':8146,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.

       First form  y := beta*y.
','line_number':8159,'multiline':True]['text':' L10: ','line_number':8173,'multiline':True]['text':' L20: ','line_number':8179,'multiline':True]['text':' L30: ','line_number':8189,'multiline':True]['text':' L40: ','line_number':8196,'multiline':True]['text':'        Form  y  when A is stored in upper triangle. ','line_number':8206,'multiline':True]['text':' L50: ','line_number':8217,'multiline':True]['text':' L60: ','line_number':8220,'multiline':True]['text':' L70: ','line_number':8237,'multiline':True]['text':' L80: ','line_number':8242,'multiline':True]['text':'        Form  y  when A is stored in lower triangle. ','line_number':8247,'multiline':True]['text':' L90: ','line_number':8259,'multiline':True]['text':' L100: ','line_number':8262,'multiline':True]['text':' L110: ','line_number':8280,'multiline':True]['text':' L120: ','line_number':8285,'multiline':True]['text':'     End of DSYMV . ','line_number':8292,'multiline':True]['text':' dsymv_ ','line_number':8294,'multiline':True]['text':' Subroutine ','line_number':8296,'multiline':True]['text':' System generated locals ','line_number':8300,'multiline':True]['text':' Local variables ','line_number':8303,'multiline':True]['text':' Subroutine ','line_number':8307,'multiline':True]['text':'
    Purpose
    =======

    DSYR2  performs the symmetric rank 2 operation

       A := alpha*x*y' + alpha*y*x' + A,

    where alpha is a scalar, x and y are n element vectors and A is an n
    by n symmetric matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':8310,'multiline':True]['text':' Parameter adjustments ','line_number':8405,'multiline':True]['text':' Function Body ','line_number':8412,'multiline':True]['text':'     Quick return if possible. ','line_number':8430,'multiline':True]['text':'
       Set up the start points in X and Y if the increments are not both
       unity.
','line_number':8436,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.
','line_number':8456,'multiline':True]['text':'        Form  A  when A is stored in the upper triangle. ','line_number':8464,'multiline':True]['text':' L10: ','line_number':8476,'multiline':True]['text':' L20: ','line_number':8479,'multiline':True]['text':' L30: ','line_number':8495,'multiline':True]['text':' L40: ','line_number':8500,'multiline':True]['text':'        Form  A  when A is stored in the lower triangle. ','line_number':8505,'multiline':True]['text':' L50: ','line_number':8517,'multiline':True]['text':' L60: ','line_number':8520,'multiline':True]['text':' L70: ','line_number':8536,'multiline':True]['text':' L80: ','line_number':8541,'multiline':True]['text':'     End of DSYR2 . ','line_number':8548,'multiline':True]['text':' dsyr2_ ','line_number':8550,'multiline':True]['text':' Subroutine ','line_number':8552,'multiline':True]['text':' System generated locals ','line_number':8556,'multiline':True]['text':' Local variables ','line_number':8560,'multiline':True]['text':' Subroutine ','line_number':8566,'multiline':True]['text':'
    Purpose
    =======

    DSYR2K  performs one of the symmetric rank 2k operations

       C := alpha*A*B' + alpha*B*A' + beta*C,

    or

       C := alpha*A'*B + alpha*B'*A + beta*C,

    where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
    and  A and B  are  n by k  matrices  in the  first  case  and  k by n
    matrices in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*B' + alpha*B*A' +
                                          beta*C.

                TRANS = 'T' or 't'   C := alpha*A'*B + alpha*B'*A +
                                          beta*C.

                TRANS = 'C' or 'c'   C := alpha*A'*B + alpha*B'*A +
                                          beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.


    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':8569,'multiline':True]['text':' Parameter adjustments ','line_number':8704,'multiline':True]['text':' Function Body ','line_number':8715,'multiline':True]['text':'     Quick return if possible. ','line_number':8745,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':8751,'multiline':True]['text':' L10: ','line_number':8761,'multiline':True]['text':' L20: ','line_number':8763,'multiline':True]['text':' L30: ','line_number':8771,'multiline':True]['text':' L40: ','line_number':8773,'multiline':True]['text':' L50: ','line_number':8783,'multiline':True]['text':' L60: ','line_number':8785,'multiline':True]['text':' L70: ','line_number':8793,'multiline':True]['text':' L80: ','line_number':8795,'multiline':True]['text':'     Start the operations. ','line_number':8802,'multiline':True]['text':'        Form  C := alpha*A*B' + alpha*B*A' + C. ','line_number':8806,'multiline':True]['text':' L90: ','line_number':8815,'multiline':True]['text':' L100: ','line_number':8821,'multiline':True]['text':' L110: ','line_number':8834,'multiline':True]['text':' L120: ','line_number':8837,'multiline':True]['text':' L130: ','line_number':8839,'multiline':True]['text':' L140: ','line_number':8848,'multiline':True]['text':' L150: ','line_number':8854,'multiline':True]['text':' L160: ','line_number':8867,'multiline':True]['text':' L170: ','line_number':8870,'multiline':True]['text':' L180: ','line_number':8872,'multiline':True]['text':'        Form  C := alpha*A'*B + alpha*B'*A + C. ','line_number':8877,'multiline':True]['text':' L190: ','line_number':8890,'multiline':True]['text':' L200: ','line_number':8899,'multiline':True]['text':' L210: ','line_number':8901,'multiline':True]['text':' L220: ','line_number':8914,'multiline':True]['text':' L230: ','line_number':8923,'multiline':True]['text':' L240: ','line_number':8925,'multiline':True]['text':'     End of DSYR2K. ','line_number':8932,'multiline':True]['text':' dsyr2k_ ','line_number':8934,'multiline':True]['text':' Subroutine ','line_number':8936,'multiline':True]['text':' System generated locals ','line_number':8940,'multiline':True]['text':' Local variables ','line_number':8943,'multiline':True]['text':' Subroutine ','line_number':8949,'multiline':True]['text':'
    Purpose
    =======

    DSYRK  performs one of the symmetric rank k operations

       C := alpha*A*A' + beta*C,

    or

       C := alpha*A'*A + beta*C,

    where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
    and  A  is an  n by k  matrix in the first case and a  k by n  matrix
    in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*A' + beta*C.

                TRANS = 'T' or 't'   C := alpha*A'*A + beta*C.

                TRANS = 'C' or 'c'   C := alpha*A'*A + beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':8952,'multiline':True]['text':' Parameter adjustments ','line_number':9068,'multiline':True]['text':' Function Body ','line_number':9076,'multiline':True]['text':'     Quick return if possible. ','line_number':9104,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':9110,'multiline':True]['text':' L10: ','line_number':9120,'multiline':True]['text':' L20: ','line_number':9122,'multiline':True]['text':' L30: ','line_number':9130,'multiline':True]['text':' L40: ','line_number':9132,'multiline':True]['text':' L50: ','line_number':9142,'multiline':True]['text':' L60: ','line_number':9144,'multiline':True]['text':' L70: ','line_number':9152,'multiline':True]['text':' L80: ','line_number':9154,'multiline':True]['text':'     Start the operations. ','line_number':9161,'multiline':True]['text':'        Form  C := alpha*A*A' + beta*C. ','line_number':9165,'multiline':True]['text':' L90: ','line_number':9174,'multiline':True]['text':' L100: ','line_number':9180,'multiline':True]['text':' L110: ','line_number':9191,'multiline':True]['text':' L120: ','line_number':9194,'multiline':True]['text':' L130: ','line_number':9196,'multiline':True]['text':' L140: ','line_number':9205,'multiline':True]['text':' L150: ','line_number':9211,'multiline':True]['text':' L160: ','line_number':9222,'multiline':True]['text':' L170: ','line_number':9225,'multiline':True]['text':' L180: ','line_number':9227,'multiline':True]['text':'        Form  C := alpha*A'*A + beta*C. ','line_number':9232,'multiline':True]['text':' L190: ','line_number':9243,'multiline':True]['text':' L200: ','line_number':9251,'multiline':True]['text':' L210: ','line_number':9253,'multiline':True]['text':' L220: ','line_number':9264,'multiline':True]['text':' L230: ','line_number':9272,'multiline':True]['text':' L240: ','line_number':9274,'multiline':True]['text':'     End of DSYRK . ','line_number':9281,'multiline':True]['text':' dsyrk_ ','line_number':9283,'multiline':True]['text':' Subroutine ','line_number':9285,'multiline':True]['text':' System generated locals ','line_number':9289,'multiline':True]['text':' Local variables ','line_number':9292,'multiline':True]['text':' Subroutine ','line_number':9299,'multiline':True]['text':'
    Purpose
    =======

    DTRMM  performs one of the matrix-matrix operations

       B := alpha*op( A )*B,   or   B := alpha*B*op( A ),

    where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:

                SIDE = 'L' or 'l'   B := alpha*op( A )*B.

                SIDE = 'R' or 'r'   B := alpha*B*op( A ).

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = A'.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':9303,'multiline':True]['text':' Parameter adjustments ','line_number':9427,'multiline':True]['text':' Function Body ','line_number':9435,'multiline':True]['text':'     Quick return if possible. ','line_number':9470,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':9476,'multiline':True]['text':' L10: ','line_number':9484,'multiline':True]['text':' L20: ','line_number':9486,'multiline':True]['text':'     Start the operations. ','line_number':9491,'multiline':True]['text':'           Form  B := alpha*A*B. ','line_number':9496,'multiline':True]['text':' L30: ','line_number':9509,'multiline':True]['text':' L40: ','line_number':9516,'multiline':True]['text':' L50: ','line_number':9518,'multiline':True]['text':' L60: ','line_number':9534,'multiline':True]['text':' L70: ','line_number':9537,'multiline':True]['text':' L80: ','line_number':9539,'multiline':True]['text':'           Form  B := alpha*A'*B. ','line_number':9544,'multiline':True]['text':' L90: ','line_number':9557,'multiline':True]['text':' L100: ','line_number':9560,'multiline':True]['text':' L110: ','line_number':9562,'multiline':True]['text':' L120: ','line_number':9576,'multiline':True]['text':' L130: ','line_number':9579,'multiline':True]['text':' L140: ','line_number':9581,'multiline':True]['text':'           Form  B := alpha*B*A. ','line_number':9588,'multiline':True]['text':' L150: ','line_number':9599,'multiline':True]['text':' L160: ','line_number':9609,'multiline':True]['text':' L170: ','line_number':9612,'multiline':True]['text':' L180: ','line_number':9614,'multiline':True]['text':' L190: ','line_number':9626,'multiline':True]['text':' L200: ','line_number':9636,'multiline':True]['text':' L210: ','line_number':9639,'multiline':True]['text':' L220: ','line_number':9641,'multiline':True]['text':'           Form  B := alpha*B*A'. ','line_number':9646,'multiline':True]['text':' L230: ','line_number':9659,'multiline':True]['text':' L240: ','line_number':9662,'multiline':True]['text':' L250: ','line_number':9672,'multiline':True]['text':' L260: ','line_number':9675,'multiline':True]['text':' L270: ','line_number':9687,'multiline':True]['text':' L280: ','line_number':9690,'multiline':True]['text':' L290: ','line_number':9700,'multiline':True]['text':' L300: ','line_number':9703,'multiline':True]['text':'     End of DTRMM . ','line_number':9711,'multiline':True]['text':' dtrmm_ ','line_number':9713,'multiline':True]['text':' Subroutine ','line_number':9715,'multiline':True]['text':' System generated locals ','line_number':9718,'multiline':True]['text':' Local variables ','line_number':9721,'multiline':True]['text':' Subroutine ','line_number':9725,'multiline':True]['text':'
    Purpose
    =======

    DTRMV  performs one of the matrix-vector operations

       x := A*x,   or   x := A'*x,

    where x is an n element vector and  A is an n by n unit, or non-unit,
    upper or lower triangular matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   x := A*x.

                TRANS = 'T' or 't'   x := A'*x.

                TRANS = 'C' or 'c'   x := A'*x.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':9729,'multiline':True]['text':' Parameter adjustments ','line_number':9828,'multiline':True]['text':' Function Body ','line_number':9834,'multiline':True]['text':'     Quick return if possible. ','line_number':9856,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':9864,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':9875,'multiline':True]['text':'        Form  x := A*x. ','line_number':9882,'multiline':True]['text':' L10: ','line_number':9893,'multiline':True]['text':' L20: ','line_number':9899,'multiline':True]['text':' L30: ','line_number':9912,'multiline':True]['text':' L40: ','line_number':9919,'multiline':True]['text':' L50: ','line_number':9930,'multiline':True]['text':' L60: ','line_number':9936,'multiline':True]['text':' L70: ','line_number':9949,'multiline':True]['text':' L80: ','line_number':9956,'multiline':True]['text':'        Form  x := A'*x. ','line_number':9962,'multiline':True]['text':' L90: ','line_number':9973,'multiline':True]['text':' L100: ','line_number':9976,'multiline':True]['text':' L110: ','line_number':9989,'multiline':True]['text':' L120: ','line_number':9993,'multiline':True]['text':' L130: ','line_number':10007,'multiline':True]['text':' L140: ','line_number':10010,'multiline':True]['text':' L150: ','line_number':10025,'multiline':True]['text':' L160: ','line_number':10029,'multiline':True]['text':'     End of DTRMV . ','line_number':10037,'multiline':True]['text':' dtrmv_ ','line_number':10039,'multiline':True]['text':' Subroutine ','line_number':10041,'multiline':True]['text':' System generated locals ','line_number':10045,'multiline':True]['text':' Local variables ','line_number':10048,'multiline':True]['text':' Subroutine ','line_number':10055,'multiline':True]['text':'
    Purpose
    =======

    DTRSM  solves one of the matrix equations

       op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'.

    The matrix X is overwritten on B.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:

                SIDE = 'L' or 'l'   op( A )*X = alpha*B.

                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = A'.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.


    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':10059,'multiline':True]['text':' Parameter adjustments ','line_number':10186,'multiline':True]['text':' Function Body ','line_number':10194,'multiline':True]['text':'     Quick return if possible. ','line_number':10229,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':10235,'multiline':True]['text':' L10: ','line_number':10243,'multiline':True]['text':' L20: ','line_number':10245,'multiline':True]['text':'     Start the operations. ','line_number':10250,'multiline':True]['text':'           Form  B := alpha*inv( A )*B. ','line_number':10255,'multiline':True]['text':' L30: ','line_number':10265,'multiline':True]['text':' L40: ','line_number':10277,'multiline':True]['text':' L50: ','line_number':10280,'multiline':True]['text':' L60: ','line_number':10282,'multiline':True]['text':' L70: ','line_number':10292,'multiline':True]['text':' L80: ','line_number':10305,'multiline':True]['text':' L90: ','line_number':10308,'multiline':True]['text':' L100: ','line_number':10310,'multiline':True]['text':'           Form  B := alpha*inv( A' )*B. ','line_number':10315,'multiline':True]['text':' L110: ','line_number':10326,'multiline':True]['text':' L120: ','line_number':10332,'multiline':True]['text':' L130: ','line_number':10334,'multiline':True]['text':' L140: ','line_number':10344,'multiline':True]['text':' L150: ','line_number':10350,'multiline':True]['text':' L160: ','line_number':10352,'multiline':True]['text':'           Form  B := alpha*B*inv( A ). ','line_number':10359,'multiline':True]['text':' L170: ','line_number':10369,'multiline':True]['text':' L180: ','line_number':10379,'multiline':True]['text':' L190: ','line_number':10382,'multiline':True]['text':' L200: ','line_number':10389,'multiline':True]['text':' L210: ','line_number':10392,'multiline':True]['text':' L220: ','line_number':10401,'multiline':True]['text':' L230: ','line_number':10411,'multiline':True]['text':' L240: ','line_number':10414,'multiline':True]['text':' L250: ','line_number':10421,'multiline':True]['text':' L260: ','line_number':10424,'multiline':True]['text':'           Form  B := alpha*B*inv( A' ). ','line_number':10429,'multiline':True]['text':' L270: ','line_number':10438,'multiline':True]['text':' L280: ','line_number':10449,'multiline':True]['text':' L290: ','line_number':10452,'multiline':True]['text':' L300: ','line_number':10459,'multiline':True]['text':' L310: ','line_number':10462,'multiline':True]['text':' L320: ','line_number':10472,'multiline':True]['text':' L330: ','line_number':10483,'multiline':True]['text':' L340: ','line_number':10486,'multiline':True]['text':' L350: ','line_number':10493,'multiline':True]['text':' L360: ','line_number':10496,'multiline':True]['text':'     End of DTRSM . ','line_number':10504,'multiline':True]['text':' dtrsm_ ','line_number':10506,'multiline':True]['text':' System generated locals ','line_number':10510,'multiline':True]['text':' Local variables ','line_number':10514,'multiline':True]['text':'
    Purpose
    =======

       DZASUM takes the sum of the absolute values.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10520,'multiline':True]['text':' Parameter adjustments ','line_number':10536,'multiline':True]['text':' Function Body ','line_number':10539,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':10549,'multiline':True]['text':' L10: ','line_number':10556,'multiline':True]['text':'        code for increment equal to 1 ','line_number':10561,'multiline':True]['text':' L30: ','line_number':10567,'multiline':True]['text':' dzasum_ ','line_number':10571,'multiline':True]['text':' System generated locals ','line_number':10575,'multiline':True]['text':' Local variables ','line_number':10579,'multiline':True]['text':'
    Purpose
    =======

    DZNRM2 returns the euclidean norm of a vector via the function
    name, so that

       DZNRM2 := sqrt( conjg( x' )*x )

    Further Details
    ===============

    -- This version written on 25-October-1982.
       Modified on 14-October-1993 to inline the call to ZLASSQ.
       Sven Hammarling, Nag Ltd.

    =====================================================================
','line_number':10584,'multiline':True]['text':' Parameter adjustments ','line_number':10603,'multiline':True]['text':' Function Body ','line_number':10606,'multiline':True]['text':'
          The following loop is equivalent to this call to the LAPACK
          auxiliary routine:
          CALL ZLASSQ( N, X, INCX, SCALE, SSQ )
','line_number':10612,'multiline':True]['text':' Computing 2nd power ','line_number':10626,'multiline':True]['text':' Computing 2nd power ','line_number':10631,'multiline':True]['text':' Computing 2nd power ','line_number':10639,'multiline':True]['text':' Computing 2nd power ','line_number':10644,'multiline':True]['text':' L10: ','line_number':10649,'multiline':True]['text':'     End of DZNRM2. ','line_number':10657,'multiline':True]['text':' dznrm2_ ','line_number':10659,'multiline':True]['text':' System generated locals ','line_number':10663,'multiline':True]['text':' Local variables ','line_number':10666,'multiline':True]['text':'
    Purpose
    =======

       ICAMAX finds the index of element having max. absolute value.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10672,'multiline':True]['text':' Parameter adjustments ','line_number':10688,'multiline':True]['text':' Function Body ','line_number':10691,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':10704,'multiline':True]['text':' L10: ','line_number':10718,'multiline':True]['text':'        code for increment equal to 1 ','line_number':10722,'multiline':True]['text':' icamax_ ','line_number':10737,'multiline':True]['text':' System generated locals ','line_number':10741,'multiline':True]['text':' Local variables ','line_number':10745,'multiline':True]['text':'
    Purpose
    =======

       IDAMAX finds the index of element having max. absolute value.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10750,'multiline':True]['text':' Parameter adjustments ','line_number':10766,'multiline':True]['text':' Function Body ','line_number':10769,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':10782,'multiline':True]['text':' L10: ','line_number':10796,'multiline':True]['text':'        code for increment equal to 1 ','line_number':10800,'multiline':True]['text':' idamax_ ','line_number':10815,'multiline':True]['text':' System generated locals ','line_number':10819,'multiline':True]['text':' Local variables ','line_number':10823,'multiline':True]['text':'
    Purpose
    =======

       ISAMAX finds the index of element having max. absolute value.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10828,'multiline':True]['text':' Parameter adjustments ','line_number':10844,'multiline':True]['text':' Function Body ','line_number':10847,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':10860,'multiline':True]['text':' L10: ','line_number':10874,'multiline':True]['text':'        code for increment equal to 1 ','line_number':10878,'multiline':True]['text':' isamax_ ','line_number':10893,'multiline':True]['text':' System generated locals ','line_number':10897,'multiline':True]['text':' Local variables ','line_number':10900,'multiline':True]['text':'
    Purpose
    =======

       IZAMAX finds the index of element having max. absolute value.

    Further Details
    ===============

       jack dongarra, 1/15/85.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10906,'multiline':True]['text':' Parameter adjustments ','line_number':10922,'multiline':True]['text':' Function Body ','line_number':10925,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':10938,'multiline':True]['text':' L10: ','line_number':10952,'multiline':True]['text':'        code for increment equal to 1 ','line_number':10956,'multiline':True]['text':' izamax_ ','line_number':10971,'multiline':True]['text':' Subroutine ','line_number':10973,'multiline':True]['text':' System generated locals ','line_number':10976,'multiline':True]['text':' Local variables ','line_number':10979,'multiline':True]['text':'
    Purpose
    =======

       SAXPY constant times a vector plus a vector.
       uses unrolled loop for increments equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':10983,'multiline':True]['text':' Parameter adjustments ','line_number':10999,'multiline':True]['text':' Function Body ','line_number':11003,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':11014,'multiline':True]['text':' L10: ','line_number':11032,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':11036,'multiline':True]['text':' L30: ','line_number':11051,'multiline':True]['text':' L50: ','line_number':11064,'multiline':True]['text':' saxpy_ ','line_number':11067,'multiline':True]['text':' System generated locals ','line_number':11071,'multiline':True]['text':'
    Purpose
    =======

    SCABS1 computes absolute value of a complex number

    =====================================================================
','line_number':11075,'multiline':True]['text':' scabs1_ ','line_number':11086,'multiline':True]['text':' System generated locals ','line_number':11090,'multiline':True]['text':' Local variables ','line_number':11094,'multiline':True]['text':'
    Purpose
    =======

       SCASUM takes the sum of the absolute values of a complex vector and
       returns a single precision result.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':11099,'multiline':True]['text':' Parameter adjustments ','line_number':11116,'multiline':True]['text':' Function Body ','line_number':11119,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':11129,'multiline':True]['text':' L10: ','line_number':11138,'multiline':True]['text':'        code for increment equal to 1 ','line_number':11143,'multiline':True]['text':' L30: ','line_number':11151,'multiline':True]['text':' scasum_ ','line_number':11155,'multiline':True]['text':' System generated locals ','line_number':11159,'multiline':True]['text':' Local variables ','line_number':11163,'multiline':True]['text':'
    Purpose
    =======

    SCNRM2 returns the euclidean norm of a vector via the function
    name, so that

       SCNRM2 := sqrt( conjg( x' )*x )

    Further Details
    ===============

    -- This version written on 25-October-1982.
       Modified on 14-October-1993 to inline the call to CLASSQ.
       Sven Hammarling, Nag Ltd.

    =====================================================================
','line_number':11168,'multiline':True]['text':' Parameter adjustments ','line_number':11187,'multiline':True]['text':' Function Body ','line_number':11190,'multiline':True]['text':'
          The following loop is equivalent to this call to the LAPACK
          auxiliary routine:
          CALL CLASSQ( N, X, INCX, SCALE, SSQ )
','line_number':11196,'multiline':True]['text':' Computing 2nd power ','line_number':11210,'multiline':True]['text':' Computing 2nd power ','line_number':11215,'multiline':True]['text':' Computing 2nd power ','line_number':11223,'multiline':True]['text':' Computing 2nd power ','line_number':11228,'multiline':True]['text':' L10: ','line_number':11233,'multiline':True]['text':'     End of SCNRM2. ','line_number':11241,'multiline':True]['text':' scnrm2_ ','line_number':11243,'multiline':True]['text':' Subroutine ','line_number':11245,'multiline':True]['text':' System generated locals ','line_number':11248,'multiline':True]['text':' Local variables ','line_number':11251,'multiline':True]['text':'
    Purpose
    =======

       SCOPY copies a vector, x, to a vector, y.
       uses unrolled loops for increments equal to 1.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':11255,'multiline':True]['text':' Parameter adjustments ','line_number':11271,'multiline':True]['text':' Function Body ','line_number':11275,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':11283,'multiline':True]['text':' L10: ','line_number':11301,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':11305,'multiline':True]['text':' L30: ','line_number':11320,'multiline':True]['text':' L50: ','line_number':11336,'multiline':True]['text':' scopy_ ','line_number':11339,'multiline':True]['text':' System generated locals ','line_number':11343,'multiline':True]['text':' Local variables ','line_number':11347,'multiline':True]['text':'
    Purpose
    =======

       SDOT forms the dot product of two vectors.
       uses unrolled loops for increments equal to one.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':11352,'multiline':True]['text':' Parameter adjustments ','line_number':11368,'multiline':True]['text':' Function Body ','line_number':11372,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':11382,'multiline':True]['text':' L10: ','line_number':11400,'multiline':True]['text':'
          code for both increments equal to 1


          clean-up loop
','line_number':11405,'multiline':True]['text':' L30: ','line_number':11420,'multiline':True]['text':' L50: ','line_number':11432,'multiline':True]['text':' sdot_ ','line_number':11437,'multiline':True]['text':' Subroutine ','line_number':11439,'multiline':True]['text':' System generated locals ','line_number':11443,'multiline':True]['text':' Local variables ','line_number':11447,'multiline':True]['text':' Subroutine ','line_number':11453,'multiline':True]['text':'
    Purpose
    =======

    SGEMM  performs one of the matrix-matrix operations

       C := alpha*op( A )*op( B ) + beta*C,

    where  op( X ) is one of

       op( X ) = X   or   op( X ) = X',

    alpha and beta are scalars, and A, B and C are matrices, with op( A )
    an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

    Arguments
    ==========

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n',  op( A ) = A.

                TRANSA = 'T' or 't',  op( A ) = A'.

                TRANSA = 'C' or 'c',  op( A ) = A'.

             Unchanged on exit.

    TRANSB - CHARACTER*1.
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:

                TRANSB = 'N' or 'n',  op( B ) = B.

                TRANSB = 'T' or 't',  op( B ) = B'.

                TRANSB = 'C' or 'c',  op( B ) = B'.

             Unchanged on exit.

    M      - INTEGER.
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
             Unchanged on exit.

    B      - REAL             array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
             Unchanged on exit.

    BETA   - REAL            .
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
             Unchanged on exit.

    C      - REAL             array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
       transposed and set  NROWA and  NROWB  as the number of rows
       and  columns of  A  and the  number of  rows  of  B  respectively.
','line_number':11456,'multiline':True]['text':' Parameter adjustments ','line_number':11586,'multiline':True]['text':' Function Body ','line_number':11597,'multiline':True]['text':'     Test the input parameters. ','line_number':11611,'multiline':True]['text':'     Quick return if possible. ','line_number':11638,'multiline':True]['text':'     And if  alpha.eq.zero. ','line_number':11644,'multiline':True]['text':' L10: ','line_number':11653,'multiline':True]['text':' L20: ','line_number':11655,'multiline':True]['text':' L30: ','line_number':11663,'multiline':True]['text':' L40: ','line_number':11665,'multiline':True]['text':'     Start the operations. ','line_number':11671,'multiline':True]['text':'           Form  C := alpha*A*B + beta*C. ','line_number':11676,'multiline':True]['text':' L50: ','line_number':11684,'multiline':True]['text':' L60: ','line_number':11690,'multiline':True]['text':' L70: ','line_number':11701,'multiline':True]['text':' L80: ','line_number':11704,'multiline':True]['text':' L90: ','line_number':11706,'multiline':True]['text':'           Form  C := alpha*A'*B + beta*C ','line_number':11710,'multiline':True]['text':' L100: ','line_number':11720,'multiline':True]['text':' L110: ','line_number':11728,'multiline':True]['text':' L120: ','line_number':11730,'multiline':True]['text':'           Form  C := alpha*A*B' + beta*C ','line_number':11736,'multiline':True]['text':' L130: ','line_number':11744,'multiline':True]['text':' L140: ','line_number':11750,'multiline':True]['text':' L150: ','line_number':11761,'multiline':True]['text':' L160: ','line_number':11764,'multiline':True]['text':' L170: ','line_number':11766,'multiline':True]['text':'           Form  C := alpha*A'*B' + beta*C ','line_number':11770,'multiline':True]['text':' L180: ','line_number':11780,'multiline':True]['text':' L190: ','line_number':11788,'multiline':True]['text':' L200: ','line_number':11790,'multiline':True]['text':'     End of SGEMM . ','line_number':11797,'multiline':True]['text':' sgemm_ ','line_number':11799,'multiline':True]['text':' Subroutine ','line_number':11801,'multiline':True]['text':' System generated locals ','line_number':11805,'multiline':True]['text':' Local variables ','line_number':11808,'multiline':True]['text':' Subroutine ','line_number':11813,'multiline':True]['text':'
    Purpose
    =======

    SGEMV  performs one of the matrix-vector operations

       y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    Arguments
    ==========

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.

                TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.

                TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    X      - REAL             array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - REAL             array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':11816,'multiline':True]['text':' Parameter adjustments ','line_number':11915,'multiline':True]['text':' Function Body ','line_number':11922,'multiline':True]['text':'     Quick return if possible. ','line_number':11943,'multiline':True]['text':'
       Set  LENX  and  LENY, the lengths of the vectors x and y, and set
       up the start points in  X  and  Y.
','line_number':11949,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.

       First form  y := beta*y.
','line_number':11972,'multiline':True]['text':' L10: ','line_number':11985,'multiline':True]['text':' L20: ','line_number':11991,'multiline':True]['text':' L30: ','line_number':12001,'multiline':True]['text':' L40: ','line_number':12008,'multiline':True]['text':'        Form  y := alpha*A*x + y. ','line_number':12018,'multiline':True]['text':' L50: ','line_number':12029,'multiline':True]['text':' L60: ','line_number':12033,'multiline':True]['text':' L70: ','line_number':12045,'multiline':True]['text':' L80: ','line_number':12049,'multiline':True]['text':'        Form  y := alpha*A'*x + y. ','line_number':12054,'multiline':True]['text':' L90: ','line_number':12064,'multiline':True]['text':' L100: ','line_number':12068,'multiline':True]['text':' L110: ','line_number':12079,'multiline':True]['text':' L120: ','line_number':12083,'multiline':True]['text':'     End of SGEMV . ','line_number':12090,'multiline':True]['text':' sgemv_ ','line_number':12092,'multiline':True]['text':' Subroutine ','line_number':12094,'multiline':True]['text':' System generated locals ','line_number':12097,'multiline':True]['text':' Local variables ','line_number':12100,'multiline':True]['text':' Subroutine ','line_number':12103,'multiline':True]['text':'
    Purpose
    =======

    SGER   performs the rank 1 operation

       A := alpha*x*y' + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - REAL             array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':12106,'multiline':True]['text':' Parameter adjustments ','line_number':12184,'multiline':True]['text':' Function Body ','line_number':12191,'multiline':True]['text':'     Quick return if possible. ','line_number':12209,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':12215,'multiline':True]['text':' L10: ','line_number':12233,'multiline':True]['text':' L20: ','line_number':12237,'multiline':True]['text':' L30: ','line_number':12254,'multiline':True]['text':' L40: ','line_number':12258,'multiline':True]['text':'     End of SGER  . ','line_number':12264,'multiline':True]['text':' sger_ ','line_number':12266,'multiline':True]['text':' System generated locals ','line_number':12270,'multiline':True]['text':' Local variables ','line_number':12274,'multiline':True]['text':'
    Purpose
    =======

    SNRM2 returns the euclidean norm of a vector via the function
    name, so that

       SNRM2 := sqrt( x'*x ).

    Further Details
    ===============

    -- This version written on 25-October-1982.
       Modified on 14-October-1993 to inline the call to SLASSQ.
       Sven Hammarling, Nag Ltd.

    =====================================================================
','line_number':12279,'multiline':True]['text':' Parameter adjustments ','line_number':12298,'multiline':True]['text':' Function Body ','line_number':12301,'multiline':True]['text':'
          The following loop is equivalent to this call to the LAPACK
          auxiliary routine:
          CALL SLASSQ( N, X, INCX, SCALE, SSQ )
','line_number':12309,'multiline':True]['text':' Computing 2nd power ','line_number':12321,'multiline':True]['text':' Computing 2nd power ','line_number':12326,'multiline':True]['text':' L10: ','line_number':12331,'multiline':True]['text':'     End of SNRM2. ','line_number':12339,'multiline':True]['text':' snrm2_ ','line_number':12341,'multiline':True]['text':' Subroutine ','line_number':12343,'multiline':True]['text':' System generated locals ','line_number':12346,'multiline':True]['text':' Local variables ','line_number':12349,'multiline':True]['text':'
    Purpose
    =======

       applies a plane rotation.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':12354,'multiline':True]['text':' Parameter adjustments ','line_number':12369,'multiline':True]['text':' Function Body ','line_number':12373,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':12381,'multiline':True]['text':' L10: ','line_number':12401,'multiline':True]['text':'       code for both increments equal to 1 ','line_number':12405,'multiline':True]['text':' L30: ','line_number':12413,'multiline':True]['text':' srot_ ','line_number':12416,'multiline':True]['text':' Subroutine ','line_number':12418,'multiline':True]['text':' System generated locals ','line_number':12420,'multiline':True]['text':' Local variables ','line_number':12423,'multiline':True]['text':'
    Purpose
    =======

       scales a vector by a constant.
       uses unrolled loops for increment equal to 1.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':12427,'multiline':True]['text':' Parameter adjustments ','line_number':12444,'multiline':True]['text':' Function Body ','line_number':12447,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':12455,'multiline':True]['text':' L10: ','line_number':12462,'multiline':True]['text':'
          code for increment equal to 1


          clean-up loop
','line_number':12466,'multiline':True]['text':' L30: ','line_number':12481,'multiline':True]['text':' L50: ','line_number':12495,'multiline':True]['text':' sscal_ ','line_number':12498,'multiline':True]['text':' Subroutine ','line_number':12500,'multiline':True]['text':' System generated locals ','line_number':12503,'multiline':True]['text':' Local variables ','line_number':12506,'multiline':True]['text':'
    Purpose
    =======

       interchanges two vectors.
       uses unrolled loops for increments equal to 1.

    Further Details
    ===============

       jack dongarra, linpack, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':12511,'multiline':True]['text':' Parameter adjustments ','line_number':12527,'multiline':True]['text':' Function Body ','line_number':12531,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':12539,'multiline':True]['text':' L10: ','line_number':12559,'multiline':True]['text':'
         code for both increments equal to 1


         clean-up loop
','line_number':12563,'multiline':True]['text':' L30: ','line_number':12580,'multiline':True]['text':' L50: ','line_number':12598,'multiline':True]['text':' sswap_ ','line_number':12601,'multiline':True]['text':' Subroutine ','line_number':12603,'multiline':True]['text':' System generated locals ','line_number':12607,'multiline':True]['text':' Local variables ','line_number':12610,'multiline':True]['text':' Subroutine ','line_number':12614,'multiline':True]['text':'
    Purpose
    =======

    SSYMV  performs the matrix-vector  operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n symmetric matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':12617,'multiline':True]['text':' Parameter adjustments ','line_number':12714,'multiline':True]['text':' Function Body ','line_number':12721,'multiline':True]['text':'     Quick return if possible. ','line_number':12739,'multiline':True]['text':'     Set up the start points in  X  and  Y. ','line_number':12745,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.

       First form  y := beta*y.
','line_number':12758,'multiline':True]['text':' L10: ','line_number':12772,'multiline':True]['text':' L20: ','line_number':12778,'multiline':True]['text':' L30: ','line_number':12788,'multiline':True]['text':' L40: ','line_number':12795,'multiline':True]['text':'        Form  y  when A is stored in upper triangle. ','line_number':12805,'multiline':True]['text':' L50: ','line_number':12816,'multiline':True]['text':' L60: ','line_number':12819,'multiline':True]['text':' L70: ','line_number':12836,'multiline':True]['text':' L80: ','line_number':12841,'multiline':True]['text':'        Form  y  when A is stored in lower triangle. ','line_number':12846,'multiline':True]['text':' L90: ','line_number':12858,'multiline':True]['text':' L100: ','line_number':12861,'multiline':True]['text':' L110: ','line_number':12879,'multiline':True]['text':' L120: ','line_number':12884,'multiline':True]['text':'     End of SSYMV . ','line_number':12891,'multiline':True]['text':' ssymv_ ','line_number':12893,'multiline':True]['text':' Subroutine ','line_number':12895,'multiline':True]['text':' System generated locals ','line_number':12898,'multiline':True]['text':' Local variables ','line_number':12901,'multiline':True]['text':' Subroutine ','line_number':12905,'multiline':True]['text':'
    Purpose
    =======

    SSYR2  performs the symmetric rank 2 operation

       A := alpha*x*y' + alpha*y*x' + A,

    where alpha is a scalar, x and y are n element vectors and A is an n
    by n symmetric matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':12908,'multiline':True]['text':' Parameter adjustments ','line_number':13003,'multiline':True]['text':' Function Body ','line_number':13010,'multiline':True]['text':'     Quick return if possible. ','line_number':13028,'multiline':True]['text':'
       Set up the start points in X and Y if the increments are not both
       unity.
','line_number':13034,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.
','line_number':13054,'multiline':True]['text':'        Form  A  when A is stored in the upper triangle. ','line_number':13062,'multiline':True]['text':' L10: ','line_number':13074,'multiline':True]['text':' L20: ','line_number':13077,'multiline':True]['text':' L30: ','line_number':13093,'multiline':True]['text':' L40: ','line_number':13098,'multiline':True]['text':'        Form  A  when A is stored in the lower triangle. ','line_number':13103,'multiline':True]['text':' L50: ','line_number':13115,'multiline':True]['text':' L60: ','line_number':13118,'multiline':True]['text':' L70: ','line_number':13134,'multiline':True]['text':' L80: ','line_number':13139,'multiline':True]['text':'     End of SSYR2 . ','line_number':13146,'multiline':True]['text':' ssyr2_ ','line_number':13148,'multiline':True]['text':' Subroutine ','line_number':13150,'multiline':True]['text':' System generated locals ','line_number':13154,'multiline':True]['text':' Local variables ','line_number':13158,'multiline':True]['text':' Subroutine ','line_number':13164,'multiline':True]['text':'
    Purpose
    =======

    SSYR2K  performs one of the symmetric rank 2k operations

       C := alpha*A*B' + alpha*B*A' + beta*C,

    or

       C := alpha*A'*B + alpha*B'*A + beta*C,

    where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
    and  A and B  are  n by k  matrices  in the  first  case  and  k by n
    matrices in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*B' + alpha*B*A' +
                                          beta*C.

                TRANS = 'T' or 't'   C := alpha*A'*B + alpha*B'*A +
                                          beta*C.

                TRANS = 'C' or 'c'   C := alpha*A'*B + alpha*B'*A +
                                          beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    B      - REAL             array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - REAL             array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.


    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':13167,'multiline':True]['text':' Parameter adjustments ','line_number':13302,'multiline':True]['text':' Function Body ','line_number':13313,'multiline':True]['text':'     Quick return if possible. ','line_number':13343,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':13349,'multiline':True]['text':' L10: ','line_number':13359,'multiline':True]['text':' L20: ','line_number':13361,'multiline':True]['text':' L30: ','line_number':13369,'multiline':True]['text':' L40: ','line_number':13371,'multiline':True]['text':' L50: ','line_number':13381,'multiline':True]['text':' L60: ','line_number':13383,'multiline':True]['text':' L70: ','line_number':13391,'multiline':True]['text':' L80: ','line_number':13393,'multiline':True]['text':'     Start the operations. ','line_number':13400,'multiline':True]['text':'        Form  C := alpha*A*B' + alpha*B*A' + C. ','line_number':13404,'multiline':True]['text':' L90: ','line_number':13413,'multiline':True]['text':' L100: ','line_number':13419,'multiline':True]['text':' L110: ','line_number':13433,'multiline':True]['text':' L120: ','line_number':13436,'multiline':True]['text':' L130: ','line_number':13438,'multiline':True]['text':' L140: ','line_number':13447,'multiline':True]['text':' L150: ','line_number':13453,'multiline':True]['text':' L160: ','line_number':13467,'multiline':True]['text':' L170: ','line_number':13470,'multiline':True]['text':' L180: ','line_number':13472,'multiline':True]['text':'        Form  C := alpha*A'*B + alpha*B'*A + C. ','line_number':13477,'multiline':True]['text':' L190: ','line_number':13490,'multiline':True]['text':' L200: ','line_number':13499,'multiline':True]['text':' L210: ','line_number':13501,'multiline':True]['text':' L220: ','line_number':13514,'multiline':True]['text':' L230: ','line_number':13523,'multiline':True]['text':' L240: ','line_number':13525,'multiline':True]['text':'     End of SSYR2K. ','line_number':13532,'multiline':True]['text':' ssyr2k_ ','line_number':13534,'multiline':True]['text':' Subroutine ','line_number':13536,'multiline':True]['text':' System generated locals ','line_number':13540,'multiline':True]['text':' Local variables ','line_number':13543,'multiline':True]['text':' Subroutine ','line_number':13549,'multiline':True]['text':'
    Purpose
    =======

    SSYRK  performs one of the symmetric rank k operations

       C := alpha*A*A' + beta*C,

    or

       C := alpha*A'*A + beta*C,

    where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
    and  A  is an  n by k  matrix in the first case and a  k by n  matrix
    in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*A' + beta*C.

                TRANS = 'T' or 't'   C := alpha*A'*A + beta*C.

                TRANS = 'C' or 'c'   C := alpha*A'*A + beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - REAL            .
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - REAL             array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':13552,'multiline':True]['text':' Parameter adjustments ','line_number':13668,'multiline':True]['text':' Function Body ','line_number':13676,'multiline':True]['text':'     Quick return if possible. ','line_number':13704,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':13710,'multiline':True]['text':' L10: ','line_number':13720,'multiline':True]['text':' L20: ','line_number':13722,'multiline':True]['text':' L30: ','line_number':13730,'multiline':True]['text':' L40: ','line_number':13732,'multiline':True]['text':' L50: ','line_number':13742,'multiline':True]['text':' L60: ','line_number':13744,'multiline':True]['text':' L70: ','line_number':13752,'multiline':True]['text':' L80: ','line_number':13754,'multiline':True]['text':'     Start the operations. ','line_number':13761,'multiline':True]['text':'        Form  C := alpha*A*A' + beta*C. ','line_number':13765,'multiline':True]['text':' L90: ','line_number':13774,'multiline':True]['text':' L100: ','line_number':13780,'multiline':True]['text':' L110: ','line_number':13791,'multiline':True]['text':' L120: ','line_number':13794,'multiline':True]['text':' L130: ','line_number':13796,'multiline':True]['text':' L140: ','line_number':13805,'multiline':True]['text':' L150: ','line_number':13811,'multiline':True]['text':' L160: ','line_number':13822,'multiline':True]['text':' L170: ','line_number':13825,'multiline':True]['text':' L180: ','line_number':13827,'multiline':True]['text':'        Form  C := alpha*A'*A + beta*C. ','line_number':13832,'multiline':True]['text':' L190: ','line_number':13843,'multiline':True]['text':' L200: ','line_number':13851,'multiline':True]['text':' L210: ','line_number':13853,'multiline':True]['text':' L220: ','line_number':13864,'multiline':True]['text':' L230: ','line_number':13872,'multiline':True]['text':' L240: ','line_number':13874,'multiline':True]['text':'     End of SSYRK . ','line_number':13881,'multiline':True]['text':' ssyrk_ ','line_number':13883,'multiline':True]['text':' Subroutine ','line_number':13885,'multiline':True]['text':' System generated locals ','line_number':13889,'multiline':True]['text':' Local variables ','line_number':13892,'multiline':True]['text':' Subroutine ','line_number':13899,'multiline':True]['text':'
    Purpose
    =======

    STRMM  performs one of the matrix-matrix operations

       B := alpha*op( A )*B,   or   B := alpha*B*op( A ),

    where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:

                SIDE = 'L' or 'l'   B := alpha*op( A )*B.

                SIDE = 'R' or 'r'   B := alpha*B*op( A ).

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = A'.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - REAL             array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':13903,'multiline':True]['text':' Parameter adjustments ','line_number':14027,'multiline':True]['text':' Function Body ','line_number':14035,'multiline':True]['text':'     Quick return if possible. ','line_number':14070,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':14076,'multiline':True]['text':' L10: ','line_number':14084,'multiline':True]['text':' L20: ','line_number':14086,'multiline':True]['text':'     Start the operations. ','line_number':14091,'multiline':True]['text':'           Form  B := alpha*A*B. ','line_number':14096,'multiline':True]['text':' L30: ','line_number':14109,'multiline':True]['text':' L40: ','line_number':14116,'multiline':True]['text':' L50: ','line_number':14118,'multiline':True]['text':' L60: ','line_number':14134,'multiline':True]['text':' L70: ','line_number':14137,'multiline':True]['text':' L80: ','line_number':14139,'multiline':True]['text':'           Form  B := alpha*A'*B. ','line_number':14144,'multiline':True]['text':' L90: ','line_number':14157,'multiline':True]['text':' L100: ','line_number':14160,'multiline':True]['text':' L110: ','line_number':14162,'multiline':True]['text':' L120: ','line_number':14176,'multiline':True]['text':' L130: ','line_number':14179,'multiline':True]['text':' L140: ','line_number':14181,'multiline':True]['text':'           Form  B := alpha*B*A. ','line_number':14188,'multiline':True]['text':' L150: ','line_number':14199,'multiline':True]['text':' L160: ','line_number':14209,'multiline':True]['text':' L170: ','line_number':14212,'multiline':True]['text':' L180: ','line_number':14214,'multiline':True]['text':' L190: ','line_number':14226,'multiline':True]['text':' L200: ','line_number':14236,'multiline':True]['text':' L210: ','line_number':14239,'multiline':True]['text':' L220: ','line_number':14241,'multiline':True]['text':'           Form  B := alpha*B*A'. ','line_number':14246,'multiline':True]['text':' L230: ','line_number':14259,'multiline':True]['text':' L240: ','line_number':14262,'multiline':True]['text':' L250: ','line_number':14272,'multiline':True]['text':' L260: ','line_number':14275,'multiline':True]['text':' L270: ','line_number':14287,'multiline':True]['text':' L280: ','line_number':14290,'multiline':True]['text':' L290: ','line_number':14300,'multiline':True]['text':' L300: ','line_number':14303,'multiline':True]['text':'     End of STRMM . ','line_number':14311,'multiline':True]['text':' strmm_ ','line_number':14313,'multiline':True]['text':' Subroutine ','line_number':14315,'multiline':True]['text':' System generated locals ','line_number':14318,'multiline':True]['text':' Local variables ','line_number':14321,'multiline':True]['text':' Subroutine ','line_number':14325,'multiline':True]['text':'
    Purpose
    =======

    STRMV  performs one of the matrix-vector operations

       x := A*x,   or   x := A'*x,

    where x is an n element vector and  A is an n by n unit, or non-unit,
    upper or lower triangular matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   x := A*x.

                TRANS = 'T' or 't'   x := A'*x.

                TRANS = 'C' or 'c'   x := A'*x.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - REAL             array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':14329,'multiline':True]['text':' Parameter adjustments ','line_number':14428,'multiline':True]['text':' Function Body ','line_number':14434,'multiline':True]['text':'     Quick return if possible. ','line_number':14456,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':14464,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':14475,'multiline':True]['text':'        Form  x := A*x. ','line_number':14482,'multiline':True]['text':' L10: ','line_number':14493,'multiline':True]['text':' L20: ','line_number':14499,'multiline':True]['text':' L30: ','line_number':14512,'multiline':True]['text':' L40: ','line_number':14519,'multiline':True]['text':' L50: ','line_number':14530,'multiline':True]['text':' L60: ','line_number':14536,'multiline':True]['text':' L70: ','line_number':14549,'multiline':True]['text':' L80: ','line_number':14556,'multiline':True]['text':'        Form  x := A'*x. ','line_number':14562,'multiline':True]['text':' L90: ','line_number':14573,'multiline':True]['text':' L100: ','line_number':14576,'multiline':True]['text':' L110: ','line_number':14589,'multiline':True]['text':' L120: ','line_number':14593,'multiline':True]['text':' L130: ','line_number':14607,'multiline':True]['text':' L140: ','line_number':14610,'multiline':True]['text':' L150: ','line_number':14625,'multiline':True]['text':' L160: ','line_number':14629,'multiline':True]['text':'     End of STRMV . ','line_number':14637,'multiline':True]['text':' strmv_ ','line_number':14639,'multiline':True]['text':' Subroutine ','line_number':14641,'multiline':True]['text':' System generated locals ','line_number':14645,'multiline':True]['text':' Local variables ','line_number':14648,'multiline':True]['text':' Subroutine ','line_number':14655,'multiline':True]['text':'
    Purpose
    =======

    STRSM  solves one of the matrix equations

       op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'.

    The matrix X is overwritten on B.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:

                SIDE = 'L' or 'l'   op( A )*X = alpha*B.

                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = A'.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - REAL            .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - REAL             array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - REAL             array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.


    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':14659,'multiline':True]['text':' Parameter adjustments ','line_number':14786,'multiline':True]['text':' Function Body ','line_number':14794,'multiline':True]['text':'     Quick return if possible. ','line_number':14829,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':14835,'multiline':True]['text':' L10: ','line_number':14843,'multiline':True]['text':' L20: ','line_number':14845,'multiline':True]['text':'     Start the operations. ','line_number':14850,'multiline':True]['text':'           Form  B := alpha*inv( A )*B. ','line_number':14855,'multiline':True]['text':' L30: ','line_number':14865,'multiline':True]['text':' L40: ','line_number':14877,'multiline':True]['text':' L50: ','line_number':14880,'multiline':True]['text':' L60: ','line_number':14882,'multiline':True]['text':' L70: ','line_number':14892,'multiline':True]['text':' L80: ','line_number':14905,'multiline':True]['text':' L90: ','line_number':14908,'multiline':True]['text':' L100: ','line_number':14910,'multiline':True]['text':'           Form  B := alpha*inv( A' )*B. ','line_number':14915,'multiline':True]['text':' L110: ','line_number':14926,'multiline':True]['text':' L120: ','line_number':14932,'multiline':True]['text':' L130: ','line_number':14934,'multiline':True]['text':' L140: ','line_number':14944,'multiline':True]['text':' L150: ','line_number':14950,'multiline':True]['text':' L160: ','line_number':14952,'multiline':True]['text':'           Form  B := alpha*B*inv( A ). ','line_number':14959,'multiline':True]['text':' L170: ','line_number':14969,'multiline':True]['text':' L180: ','line_number':14979,'multiline':True]['text':' L190: ','line_number':14982,'multiline':True]['text':' L200: ','line_number':14989,'multiline':True]['text':' L210: ','line_number':14992,'multiline':True]['text':' L220: ','line_number':15001,'multiline':True]['text':' L230: ','line_number':15011,'multiline':True]['text':' L240: ','line_number':15014,'multiline':True]['text':' L250: ','line_number':15021,'multiline':True]['text':' L260: ','line_number':15024,'multiline':True]['text':'           Form  B := alpha*B*inv( A' ). ','line_number':15029,'multiline':True]['text':' L270: ','line_number':15038,'multiline':True]['text':' L280: ','line_number':15049,'multiline':True]['text':' L290: ','line_number':15052,'multiline':True]['text':' L300: ','line_number':15059,'multiline':True]['text':' L310: ','line_number':15062,'multiline':True]['text':' L320: ','line_number':15072,'multiline':True]['text':' L330: ','line_number':15083,'multiline':True]['text':' L340: ','line_number':15086,'multiline':True]['text':' L350: ','line_number':15093,'multiline':True]['text':' L360: ','line_number':15096,'multiline':True]['text':'     End of STRSM . ','line_number':15104,'multiline':True]['text':' strsm_ ','line_number':15106,'multiline':True]['text':' Subroutine ','line_number':15108,'multiline':True]['text':' System generated locals ','line_number':15111,'multiline':True]['text':' Local variables ','line_number':15115,'multiline':True]['text':'
    Purpose
    =======

       ZAXPY constant times a vector plus a vector.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':15120,'multiline':True]['text':' Parameter adjustments ','line_number':15135,'multiline':True]['text':' Function Body ','line_number':15139,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':15150,'multiline':True]['text':' L10: ','line_number':15174,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':15178,'multiline':True]['text':' L30: ','line_number':15190,'multiline':True]['text':' zaxpy_ ','line_number':15193,'multiline':True]['text':' Subroutine ','line_number':15195,'multiline':True]['text':' System generated locals ','line_number':15198,'multiline':True]['text':' Local variables ','line_number':15201,'multiline':True]['text':'
    Purpose
    =======

       ZCOPY copies a vector, x, to a vector, y.

    Further Details
    ===============

       jack dongarra, linpack, 4/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':15205,'multiline':True]['text':' Parameter adjustments ','line_number':15220,'multiline':True]['text':' Function Body ','line_number':15224,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':15232,'multiline':True]['text':' L10: ','line_number':15252,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':15256,'multiline':True]['text':' L30: ','line_number':15264,'multiline':True]['text':' zcopy_ ','line_number':15267,'multiline':True]['text':' Double Complex ','line_number':15269,'multiline':True]['text':' System generated locals ','line_number':15272,'multiline':True]['text':' Local variables ','line_number':15276,'multiline':True]['text':'
    Purpose
    =======

    ZDOTC forms the dot product of a vector.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':15281,'multiline':True]['text':' Parameter adjustments ','line_number':15296,'multiline':True]['text':' Function Body ','line_number':15300,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':15310,'multiline':True]['text':' L10: ','line_number':15333,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':15338,'multiline':True]['text':' L30: ','line_number':15349,'multiline':True]['text':' zdotc_ ','line_number':15353,'multiline':True]['text':' Double Complex ','line_number':15355,'multiline':True]['text':' System generated locals ','line_number':15358,'multiline':True]['text':' Local variables ','line_number':15362,'multiline':True]['text':'
    Purpose
    =======

       ZDOTU forms the dot product of two vectors.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':15367,'multiline':True]['text':' Parameter adjustments ','line_number':15382,'multiline':True]['text':' Function Body ','line_number':15386,'multiline':True]['text':'
          code for unequal increments or equal increments
            not equal to 1
','line_number':15396,'multiline':True]['text':' L10: ','line_number':15419,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':15424,'multiline':True]['text':' L30: ','line_number':15435,'multiline':True]['text':' zdotu_ ','line_number':15439,'multiline':True]['text':' Subroutine ','line_number':15441,'multiline':True]['text':' System generated locals ','line_number':15444,'multiline':True]['text':' Local variables ','line_number':15448,'multiline':True]['text':'
    Purpose
    =======

    Applies a plane rotation, where the cos and sin (c and s) are real
    and the vectors cx and cy are complex.
    jack dongarra, linpack, 3/11/78.

    Arguments
    ==========

    N        (input) INTEGER
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
             Unchanged on exit.

    CX       (input) COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.

    INCX     (input) INTEGER
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
             Unchanged on exit.

    CY       (input) COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.

    INCY     (input) INTEGER
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
             Unchanged on exit.

    C        (input) DOUBLE PRECISION
             On entry, C specifies the cosine, cos.
             Unchanged on exit.

    S        (input) DOUBLE PRECISION
             On entry, S specifies the sine, sin.
             Unchanged on exit.

   =====================================================================
','line_number':15453,'multiline':True]['text':' Parameter adjustments ','line_number':15503,'multiline':True]['text':' Function Body ','line_number':15507,'multiline':True]['text':'
          code for unequal increments or equal increments not equal
            to 1
','line_number':15515,'multiline':True]['text':' L10: ','line_number':15547,'multiline':True]['text':'        code for both increments equal to 1 ','line_number':15551,'multiline':True]['text':' L30: ','line_number':15571,'multiline':True]['text':' zdrot_ ','line_number':15574,'multiline':True]['text':' Subroutine ','line_number':15576,'multiline':True]['text':' System generated locals ','line_number':15579,'multiline':True]['text':' Local variables ','line_number':15583,'multiline':True]['text':'
    Purpose
    =======

       ZDSCAL scales a vector by a constant.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':15587,'multiline':True]['text':' Parameter adjustments ','line_number':15603,'multiline':True]['text':' Function Body ','line_number':15606,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':15614,'multiline':True]['text':' L10: ','line_number':15626,'multiline':True]['text':'        code for increment equal to 1 ','line_number':15630,'multiline':True]['text':' L30: ','line_number':15641,'multiline':True]['text':' zdscal_ ','line_number':15644,'multiline':True]['text':' Subroutine ','line_number':15646,'multiline':True]['text':' System generated locals ','line_number':15651,'multiline':True]['text':' Local variables ','line_number':15656,'multiline':True]['text':' Subroutine ','line_number':15663,'multiline':True]['text':'
    Purpose
    =======

    ZGEMM  performs one of the matrix-matrix operations

       C := alpha*op( A )*op( B ) + beta*C,

    where  op( X ) is one of

       op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),

    alpha and beta are scalars, and A, B and C are matrices, with op( A )
    an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

    Arguments
    ==========

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n',  op( A ) = A.

                TRANSA = 'T' or 't',  op( A ) = A'.

                TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).

             Unchanged on exit.

    TRANSB - CHARACTER*1.
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:

                TRANSB = 'N' or 'n',  op( B ) = B.

                TRANSB = 'T' or 't',  op( B ) = B'.

                TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).

             Unchanged on exit.

    M      - INTEGER.
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
             Unchanged on exit.

    B      - COMPLEX*16       array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
             Unchanged on exit.

    BETA   - COMPLEX*16      .
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
             Unchanged on exit.

    C      - COMPLEX*16       array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
       conjugated or transposed, set  CONJA and CONJB  as true if  A  and
       B  respectively are to be  transposed but  not conjugated  and set
       NROWA and  NROWB  as the number of rows and  columns  of  A
       and the number of rows of  B  respectively.
','line_number':15666,'multiline':True]['text':' Parameter adjustments ','line_number':15798,'multiline':True]['text':' Function Body ','line_number':15809,'multiline':True]['text':'     Test the input parameters. ','line_number':15825,'multiline':True]['text':'     Quick return if possible. ','line_number':15850,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':15857,'multiline':True]['text':' L10: ','line_number':15867,'multiline':True]['text':' L20: ','line_number':15869,'multiline':True]['text':' L30: ','line_number':15882,'multiline':True]['text':' L40: ','line_number':15884,'multiline':True]['text':'     Start the operations. ','line_number':15890,'multiline':True]['text':'           Form  C := alpha*A*B + beta*C. ','line_number':15895,'multiline':True]['text':' L50: ','line_number':15904,'multiline':True]['text':' L60: ','line_number':15915,'multiline':True]['text':' L70: ','line_number':15938,'multiline':True]['text':' L80: ','line_number':15941,'multiline':True]['text':' L90: ','line_number':15943,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*B + beta*C. ','line_number':15947,'multiline':True]['text':' L100: ','line_number':15963,'multiline':True]['text':' L110: ','line_number':15983,'multiline':True]['text':' L120: ','line_number':15985,'multiline':True]['text':'           Form  C := alpha*A'*B + beta*C ','line_number':15989,'multiline':True]['text':' L130: ','line_number':16005,'multiline':True]['text':' L140: ','line_number':16025,'multiline':True]['text':' L150: ','line_number':16027,'multiline':True]['text':'           Form  C := alpha*A*conjg( B' ) + beta*C. ','line_number':16033,'multiline':True]['text':' L160: ','line_number':16042,'multiline':True]['text':' L170: ','line_number':16053,'multiline':True]['text':' L180: ','line_number':16076,'multiline':True]['text':' L190: ','line_number':16079,'multiline':True]['text':' L200: ','line_number':16081,'multiline':True]['text':'           Form  C := alpha*A*B'          + beta*C ','line_number':16085,'multiline':True]['text':' L210: ','line_number':16094,'multiline':True]['text':' L220: ','line_number':16105,'multiline':True]['text':' L230: ','line_number':16128,'multiline':True]['text':' L240: ','line_number':16131,'multiline':True]['text':' L250: ','line_number':16133,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*conjg( B' ) + beta*C. ','line_number':16139,'multiline':True]['text':' L260: ','line_number':16154,'multiline':True]['text':' L270: ','line_number':16174,'multiline':True]['text':' L280: ','line_number':16176,'multiline':True]['text':'           Form  C := alpha*conjg( A' )*B' + beta*C ','line_number':16180,'multiline':True]['text':' L290: ','line_number':16196,'multiline':True]['text':' L300: ','line_number':16216,'multiline':True]['text':' L310: ','line_number':16218,'multiline':True]['text':'           Form  C := alpha*A'*conjg( B' ) + beta*C ','line_number':16224,'multiline':True]['text':' L320: ','line_number':16240,'multiline':True]['text':' L330: ','line_number':16260,'multiline':True]['text':' L340: ','line_number':16262,'multiline':True]['text':'           Form  C := alpha*A'*B' + beta*C ','line_number':16266,'multiline':True]['text':' L350: ','line_number':16282,'multiline':True]['text':' L360: ','line_number':16302,'multiline':True]['text':' L370: ','line_number':16304,'multiline':True]['text':'     End of ZGEMM . ','line_number':16311,'multiline':True]['text':' zgemm_ ','line_number':16313,'multiline':True]['text':' Subroutine ','line_number':16315,'multiline':True]['text':' System generated locals ','line_number':16320,'multiline':True]['text':' Local variables ','line_number':16324,'multiline':True]['text':' Subroutine ','line_number':16329,'multiline':True]['text':'
    Purpose
    =======

    ZGEMV  performs one of the matrix-vector operations

       y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or

       y := alpha*conjg( A' )*x + beta*y,

    where alpha and beta are scalars, x and y are vectors and A is an
    m by n matrix.

    Arguments
    ==========

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.

                TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.

                TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    X      - COMPLEX*16       array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - COMPLEX*16      .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - COMPLEX*16       array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':16333,'multiline':True]['text':' Parameter adjustments ','line_number':16434,'multiline':True]['text':' Function Body ','line_number':16441,'multiline':True]['text':'     Quick return if possible. ','line_number':16462,'multiline':True]['text':'
       Set  LENX  and  LENY, the lengths of the vectors x and y, and set
       up the start points in  X  and  Y.
','line_number':16471,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.

       First form  y := beta*y.
','line_number':16494,'multiline':True]['text':' L10: ','line_number':16508,'multiline':True]['text':' L20: ','line_number':16519,'multiline':True]['text':' L30: ','line_number':16530,'multiline':True]['text':' L40: ','line_number':16542,'multiline':True]['text':'        Form  y := alpha*A*x + y. ','line_number':16552,'multiline':True]['text':' L50: ','line_number':16576,'multiline':True]['text':' L60: ','line_number':16580,'multiline':True]['text':' L70: ','line_number':16605,'multiline':True]['text':' L80: ','line_number':16609,'multiline':True]['text':'        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y. ','line_number':16614,'multiline':True]['text':' L90: ','line_number':16631,'multiline':True]['text':' L100: ','line_number':16643,'multiline':True]['text':' L110: ','line_number':16653,'multiline':True]['text':' L120: ','line_number':16671,'multiline':True]['text':' L130: ','line_number':16684,'multiline':True]['text':' L140: ','line_number':16694,'multiline':True]['text':'     End of ZGEMV . ','line_number':16701,'multiline':True]['text':' zgemv_ ','line_number':16703,'multiline':True]['text':' Subroutine ','line_number':16705,'multiline':True]['text':' System generated locals ','line_number':16709,'multiline':True]['text':' Local variables ','line_number':16713,'multiline':True]['text':' Subroutine ','line_number':16716,'multiline':True]['text':'
    Purpose
    =======

    ZGERC  performs the rank 1 operation

       A := alpha*x*conjg( y' ) + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':16719,'multiline':True]['text':' Parameter adjustments ','line_number':16797,'multiline':True]['text':' Function Body ','line_number':16804,'multiline':True]['text':'     Quick return if possible. ','line_number':16822,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':16828,'multiline':True]['text':' L10: ','line_number':16856,'multiline':True]['text':' L20: ','line_number':16860,'multiline':True]['text':' L30: ','line_number':16887,'multiline':True]['text':' L40: ','line_number':16891,'multiline':True]['text':'     End of ZGERC . ','line_number':16897,'multiline':True]['text':' zgerc_ ','line_number':16899,'multiline':True]['text':' Subroutine ','line_number':16901,'multiline':True]['text':' System generated locals ','line_number':16905,'multiline':True]['text':' Local variables ','line_number':16909,'multiline':True]['text':' Subroutine ','line_number':16912,'multiline':True]['text':'
    Purpose
    =======

    ZGERU  performs the rank 1 operation

       A := alpha*x*y' + A,

    where alpha is a scalar, x is an m element vector, y is an n element
    vector and A is an m by n matrix.

    Arguments
    ==========

    M      - INTEGER.
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':16915,'multiline':True]['text':' Parameter adjustments ','line_number':16993,'multiline':True]['text':' Function Body ','line_number':17000,'multiline':True]['text':'     Quick return if possible. ','line_number':17018,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':17024,'multiline':True]['text':' L10: ','line_number':17052,'multiline':True]['text':' L20: ','line_number':17056,'multiline':True]['text':' L30: ','line_number':17083,'multiline':True]['text':' L40: ','line_number':17087,'multiline':True]['text':'     End of ZGERU . ','line_number':17093,'multiline':True]['text':' zgeru_ ','line_number':17095,'multiline':True]['text':' Subroutine ','line_number':17097,'multiline':True]['text':' System generated locals ','line_number':17101,'multiline':True]['text':' Local variables ','line_number':17106,'multiline':True]['text':' Subroutine ','line_number':17110,'multiline':True]['text':'
    Purpose
    =======

    ZHEMV  performs the matrix-vector  operation

       y := alpha*A*x + beta*y,

    where alpha and beta are scalars, x and y are n element vectors and
    A is an n by n hermitian matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    BETA   - COMPLEX*16      .
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
             Unchanged on exit.

    Y      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':17113,'multiline':True]['text':' Parameter adjustments ','line_number':17212,'multiline':True]['text':' Function Body ','line_number':17219,'multiline':True]['text':'     Quick return if possible. ','line_number':17237,'multiline':True]['text':'     Set up the start points in  X  and  Y. ','line_number':17244,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.

       First form  y := beta*y.
','line_number':17257,'multiline':True]['text':' L10: ','line_number':17272,'multiline':True]['text':' L20: ','line_number':17283,'multiline':True]['text':' L30: ','line_number':17294,'multiline':True]['text':' L40: ','line_number':17306,'multiline':True]['text':'        Form  y  when A is stored in upper triangle. ','line_number':17316,'multiline':True]['text':' L50: ','line_number':17342,'multiline':True]['text':' L60: ','line_number':17354,'multiline':True]['text':' L70: ','line_number':17386,'multiline':True]['text':' L80: ','line_number':17400,'multiline':True]['text':'        Form  y  when A is stored in lower triangle. ','line_number':17405,'multiline':True]['text':' L90: ','line_number':17438,'multiline':True]['text':' L100: ','line_number':17446,'multiline':True]['text':' L110: ','line_number':17485,'multiline':True]['text':' L120: ','line_number':17495,'multiline':True]['text':'     End of ZHEMV . ','line_number':17502,'multiline':True]['text':' zhemv_ ','line_number':17504,'multiline':True]['text':' Subroutine ','line_number':17506,'multiline':True]['text':' System generated locals ','line_number':17510,'multiline':True]['text':' Local variables ','line_number':17515,'multiline':True]['text':' Subroutine ','line_number':17519,'multiline':True]['text':'
    Purpose
    =======

    ZHER2  performs the hermitian rank 2 operation

       A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,

    where alpha is a scalar, x and y are n element vectors and A is an n
    by n hermitian matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:

                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
             Unchanged on exit.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Y      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
             Unchanged on exit.

    INCY   - INTEGER.
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':17522,'multiline':True]['text':' Parameter adjustments ','line_number':17620,'multiline':True]['text':' Function Body ','line_number':17627,'multiline':True]['text':'     Quick return if possible. ','line_number':17645,'multiline':True]['text':'
       Set up the start points in X and Y if the increments are not both
       unity.
','line_number':17651,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through the triangular part
       of A.
','line_number':17671,'multiline':True]['text':'        Form  A  when A is stored in the upper triangle. ','line_number':17679,'multiline':True]['text':' L10: ','line_number':17714,'multiline':True]['text':' L20: ','line_number':17735,'multiline':True]['text':' L30: ','line_number':17774,'multiline':True]['text':' L40: ','line_number':17797,'multiline':True]['text':'        Form  A  when A is stored in the lower triangle. ','line_number':17802,'multiline':True]['text':' L50: ','line_number':17850,'multiline':True]['text':' L60: ','line_number':17858,'multiline':True]['text':' L70: ','line_number':17910,'multiline':True]['text':' L80: ','line_number':17920,'multiline':True]['text':'     End of ZHER2 . ','line_number':17927,'multiline':True]['text':' zher2_ ','line_number':17929,'multiline':True]['text':' Subroutine ','line_number':17931,'multiline':True]['text':' System generated locals ','line_number':17935,'multiline':True]['text':' Local variables ','line_number':17941,'multiline':True]['text':' Subroutine ','line_number':17947,'multiline':True]['text':'
    Purpose
    =======

    ZHER2K  performs one of the hermitian rank 2k operations

       C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) + beta*C,

    or

       C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A + beta*C,

    where  alpha and beta  are scalars with  beta  real,  C is an  n by n
    hermitian matrix and  A and B  are  n by k matrices in the first case
    and  k by n  matrices in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'    C := alpha*A*conjg( B' )          +
                                           conjg( alpha )*B*conjg( A' ) +
                                           beta*C.

                TRANS = 'C' or 'c'    C := alpha*conjg( A' )*B          +
                                           conjg( alpha )*conjg( B' )*A +
                                           beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16         .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    B      - COMPLEX*16       array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
             Unchanged on exit.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - DOUBLE PRECISION            .
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - COMPLEX*16          array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
       Ed Anderson, Cray Research Inc.

    =====================================================================


       Test the input parameters.
','line_number':17950,'multiline':True]['text':' Parameter adjustments ','line_number':18089,'multiline':True]['text':' Function Body ','line_number':18100,'multiline':True]['text':'     Quick return if possible. ','line_number':18130,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':18137,'multiline':True]['text':' L10: ','line_number':18148,'multiline':True]['text':' L20: ','line_number':18150,'multiline':True]['text':' L30: ','line_number':18162,'multiline':True]['text':' L40: ','line_number':18168,'multiline':True]['text':' L50: ','line_number':18179,'multiline':True]['text':' L60: ','line_number':18181,'multiline':True]['text':' L70: ','line_number':18197,'multiline':True]['text':' L80: ','line_number':18199,'multiline':True]['text':'     Start the operations. ','line_number':18206,'multiline':True]['text':'
          Form  C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) +
                     C.
','line_number':18210,'multiline':True]['text':' L90: ','line_number':18223,'multiline':True]['text':' L100: ','line_number':18233,'multiline':True]['text':' L110: ','line_number':18279,'multiline':True]['text':' L120: ','line_number':18295,'multiline':True]['text':' L130: ','line_number':18297,'multiline':True]['text':' L140: ','line_number':18307,'multiline':True]['text':' L150: ','line_number':18317,'multiline':True]['text':' L160: ','line_number':18363,'multiline':True]['text':' L170: ','line_number':18379,'multiline':True]['text':' L180: ','line_number':18381,'multiline':True]['text':'
          Form  C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A +
                     C.
','line_number':18386,'multiline':True]['text':' L190: ','line_number':18414,'multiline':True]['text':' L200: ','line_number':18477,'multiline':True]['text':' L210: ','line_number':18479,'multiline':True]['text':' L220: ','line_number':18504,'multiline':True]['text':' L230: ','line_number':18567,'multiline':True]['text':' L240: ','line_number':18569,'multiline':True]['text':'     End of ZHER2K. ','line_number':18576,'multiline':True]['text':' zher2k_ ','line_number':18578,'multiline':True]['text':' Subroutine ','line_number':18580,'multiline':True]['text':' System generated locals ','line_number':18584,'multiline':True]['text':' Local variables ','line_number':18590,'multiline':True]['text':' Subroutine ','line_number':18597,'multiline':True]['text':'
    Purpose
    =======

    ZHERK  performs one of the hermitian rank k operations

       C := alpha*A*conjg( A' ) + beta*C,

    or

       C := alpha*conjg( A' )*A + beta*C,

    where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
    matrix and  A  is an  n by k  matrix in the  first case and a  k by n
    matrix in the second case.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:

                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.

                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry,  TRANS  specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   C := alpha*A*conjg( A' ) + beta*C.

                TRANS = 'C' or 'c'   C := alpha*conjg( A' )*A + beta*C.

             Unchanged on exit.

    N      - INTEGER.
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
             Unchanged on exit.

    K      - INTEGER.
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
             Unchanged on exit.

    ALPHA  - DOUBLE PRECISION            .
             On entry, ALPHA specifies the scalar alpha.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
             Unchanged on exit.

    BETA   - DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
             Unchanged on exit.

    C      - COMPLEX*16          array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.

    LDC    - INTEGER.
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
       Ed Anderson, Cray Research Inc.

    =====================================================================


       Test the input parameters.
','line_number':18600,'multiline':True]['text':' Parameter adjustments ','line_number':18720,'multiline':True]['text':' Function Body ','line_number':18728,'multiline':True]['text':'     Quick return if possible. ','line_number':18756,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':18762,'multiline':True]['text':' L10: ','line_number':18773,'multiline':True]['text':' L20: ','line_number':18775,'multiline':True]['text':' L30: ','line_number':18787,'multiline':True]['text':' L40: ','line_number':18793,'multiline':True]['text':' L50: ','line_number':18804,'multiline':True]['text':' L60: ','line_number':18806,'multiline':True]['text':' L70: ','line_number':18822,'multiline':True]['text':' L80: ','line_number':18824,'multiline':True]['text':'     Start the operations. ','line_number':18831,'multiline':True]['text':'        Form  C := alpha*A*conjg( A' ) + beta*C. ','line_number':18835,'multiline':True]['text':' L90: ','line_number':18845,'multiline':True]['text':' L100: ','line_number':18855,'multiline':True]['text':' L110: ','line_number':18885,'multiline':True]['text':' L120: ','line_number':18896,'multiline':True]['text':' L130: ','line_number':18898,'multiline':True]['text':' L140: ','line_number':18908,'multiline':True]['text':' L150: ','line_number':18922,'multiline':True]['text':' L160: ','line_number':18956,'multiline':True]['text':' L170: ','line_number':18959,'multiline':True]['text':' L180: ','line_number':18961,'multiline':True]['text':'        Form  C := alpha*conjg( A' )*A + beta*C. ','line_number':18966,'multiline':True]['text':' L190: ','line_number':18983,'multiline':True]['text':' L200: ','line_number':18998,'multiline':True]['text':' L210: ','line_number':19009,'multiline':True]['text':' L220: ','line_number':19021,'multiline':True]['text':' L230: ','line_number':19035,'multiline':True]['text':' L240: ','line_number':19059,'multiline':True]['text':' L250: ','line_number':19074,'multiline':True]['text':' L260: ','line_number':19076,'multiline':True]['text':'     End of ZHERK . ','line_number':19083,'multiline':True]['text':' zherk_ ','line_number':19085,'multiline':True]['text':' Subroutine ','line_number':19087,'multiline':True]['text':' System generated locals ','line_number':19090,'multiline':True]['text':' Local variables ','line_number':19094,'multiline':True]['text':'
    Purpose
    =======

       ZSCAL scales a vector by a constant.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 3/93 to return if incx .le. 0.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':19098,'multiline':True]['text':' Parameter adjustments ','line_number':19114,'multiline':True]['text':' Function Body ','line_number':19117,'multiline':True]['text':'        code for increment not equal to 1 ','line_number':19125,'multiline':True]['text':' L10: ','line_number':19136,'multiline':True]['text':'        code for increment equal to 1 ','line_number':19140,'multiline':True]['text':' L30: ','line_number':19150,'multiline':True]['text':' zscal_ ','line_number':19153,'multiline':True]['text':' Subroutine ','line_number':19155,'multiline':True]['text':' System generated locals ','line_number':19158,'multiline':True]['text':' Local variables ','line_number':19161,'multiline':True]['text':'
    Purpose
    =======

       ZSWAP interchanges two vectors.

    Further Details
    ===============

       jack dongarra, 3/11/78.
       modified 12/3/93, array(1) declarations changed to array(*)

    =====================================================================
','line_number':19166,'multiline':True]['text':' Parameter adjustments ','line_number':19181,'multiline':True]['text':' Function Body ','line_number':19185,'multiline':True]['text':'
         code for unequal increments or equal increments not equal
           to 1
','line_number':19193,'multiline':True]['text':' L10: ','line_number':19217,'multiline':True]['text':'       code for both increments equal to 1 ','line_number':19221,'multiline':True]['text':' L30: ','line_number':19232,'multiline':True]['text':' zswap_ ','line_number':19235,'multiline':True]['text':' Subroutine ','line_number':19237,'multiline':True]['text':' System generated locals ','line_number':19241,'multiline':True]['text':' Local variables ','line_number':19246,'multiline':True]['text':' Subroutine ','line_number':19253,'multiline':True]['text':'
    Purpose
    =======

    ZTRMM  performs one of the matrix-matrix operations

       B := alpha*op( A )*B,   or   B := alpha*B*op( A )

    where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:

                SIDE = 'L' or 'l'   B := alpha*op( A )*B.

                SIDE = 'R' or 'r'   B := alpha*B*op( A ).

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - COMPLEX*16       array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':19257,'multiline':True]['text':' Parameter adjustments ','line_number':19381,'multiline':True]['text':' Function Body ','line_number':19389,'multiline':True]['text':'     Quick return if possible. ','line_number':19425,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':19431,'multiline':True]['text':' L10: ','line_number':19440,'multiline':True]['text':' L20: ','line_number':19442,'multiline':True]['text':'     Start the operations. ','line_number':19447,'multiline':True]['text':'           Form  B := alpha*A*B. ','line_number':19452,'multiline':True]['text':' L30: ','line_number':19477,'multiline':True]['text':' L40: ','line_number':19489,'multiline':True]['text':' L50: ','line_number':19491,'multiline':True]['text':' L60: ','line_number':19526,'multiline':True]['text':' L70: ','line_number':19529,'multiline':True]['text':' L80: ','line_number':19531,'multiline':True]['text':'           Form  B := alpha*A'*B   or   B := alpha*conjg( A' )*B. ','line_number':19536,'multiline':True]['text':' L90: ','line_number':19562,'multiline':True]['text':' L100: ','line_number':19582,'multiline':True]['text':' L110: ','line_number':19590,'multiline':True]['text':' L120: ','line_number':19592,'multiline':True]['text':' L130: ','line_number':19619,'multiline':True]['text':' L140: ','line_number':19639,'multiline':True]['text':' L150: ','line_number':19647,'multiline':True]['text':' L160: ','line_number':19649,'multiline':True]['text':'           Form  B := alpha*B*A. ','line_number':19656,'multiline':True]['text':' L170: ','line_number':19676,'multiline':True]['text':' L180: ','line_number':19698,'multiline':True]['text':' L190: ','line_number':19701,'multiline':True]['text':' L200: ','line_number':19703,'multiline':True]['text':' L210: ','line_number':19724,'multiline':True]['text':' L220: ','line_number':19746,'multiline':True]['text':' L230: ','line_number':19749,'multiline':True]['text':' L240: ','line_number':19751,'multiline':True]['text':'           Form  B := alpha*B*A'   or   B := alpha*B*conjg( A' ). ','line_number':19756,'multiline':True]['text':' L250: ','line_number':19789,'multiline':True]['text':' L260: ','line_number':19792,'multiline':True]['text':' L270: ','line_number':19819,'multiline':True]['text':' L280: ','line_number':19822,'multiline':True]['text':' L290: ','line_number':19854,'multiline':True]['text':' L300: ','line_number':19857,'multiline':True]['text':' L310: ','line_number':19884,'multiline':True]['text':' L320: ','line_number':19887,'multiline':True]['text':'     End of ZTRMM . ','line_number':19895,'multiline':True]['text':' ztrmm_ ','line_number':19897,'multiline':True]['text':' Subroutine ','line_number':19899,'multiline':True]['text':' System generated locals ','line_number':19902,'multiline':True]['text':' Local variables ','line_number':19906,'multiline':True]['text':' Subroutine ','line_number':19910,'multiline':True]['text':'
    Purpose
    =======

    ZTRMV  performs one of the matrix-vector operations

       x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,

    where x is an n element vector and  A is an n by n unit, or non-unit,
    upper or lower triangular matrix.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the operation to be performed as
             follows:

                TRANS = 'N' or 'n'   x := A*x.

                TRANS = 'T' or 't'   x := A'*x.

                TRANS = 'C' or 'c'   x := conjg( A' )*x.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':19914,'multiline':True]['text':' Parameter adjustments ','line_number':20013,'multiline':True]['text':' Function Body ','line_number':20019,'multiline':True]['text':'     Quick return if possible. ','line_number':20041,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':20050,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':20061,'multiline':True]['text':'        Form  x := A*x. ','line_number':20068,'multiline':True]['text':' L10: ','line_number':20089,'multiline':True]['text':' L20: ','line_number':20101,'multiline':True]['text':' L30: ','line_number':20124,'multiline':True]['text':' L40: ','line_number':20137,'multiline':True]['text':' L50: ','line_number':20158,'multiline':True]['text':' L60: ','line_number':20170,'multiline':True]['text':' L70: ','line_number':20193,'multiline':True]['text':' L80: ','line_number':20206,'multiline':True]['text':'        Form  x := A'*x  or  x := conjg( A' )*x. ','line_number':20212,'multiline':True]['text':' L90: ','line_number':20236,'multiline':True]['text':' L100: ','line_number':20255,'multiline':True]['text':' L110: ','line_number':20260,'multiline':True]['text':' L120: ','line_number':20286,'multiline':True]['text':' L130: ','line_number':20306,'multiline':True]['text':' L140: ','line_number':20312,'multiline':True]['text':' L150: ','line_number':20339,'multiline':True]['text':' L160: ','line_number':20359,'multiline':True]['text':' L170: ','line_number':20364,'multiline':True]['text':' L180: ','line_number':20392,'multiline':True]['text':' L190: ','line_number':20413,'multiline':True]['text':' L200: ','line_number':20419,'multiline':True]['text':'     End of ZTRMV . ','line_number':20427,'multiline':True]['text':' ztrmv_ ','line_number':20429,'multiline':True]['text':' Subroutine ','line_number':20431,'multiline':True]['text':' System generated locals ','line_number':20435,'multiline':True]['text':' Local variables ','line_number':20440,'multiline':True]['text':' Subroutine ','line_number':20447,'multiline':True]['text':'
    Purpose
    =======

    ZTRSM  solves one of the matrix equations

       op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,

    where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

       op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).

    The matrix X is overwritten on B.

    Arguments
    ==========

    SIDE   - CHARACTER*1.
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:

                SIDE = 'L' or 'l'   op( A )*X = alpha*B.

                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.

             Unchanged on exit.

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANSA - CHARACTER*1.
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:

                TRANSA = 'N' or 'n'   op( A ) = A.

                TRANSA = 'T' or 't'   op( A ) = A'.

                TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    M      - INTEGER.
             On entry, M specifies the number of rows of B. M must be at
             least zero.
             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
             Unchanged on exit.

    ALPHA  - COMPLEX*16      .
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
             Unchanged on exit.

    B      - COMPLEX*16       array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.

    LDB    - INTEGER.
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
             Unchanged on exit.

    Further Details
    ===============

    Level 3 Blas routine.

    -- Written on 8-February-1989.
       Jack Dongarra, Argonne National Laboratory.
       Iain Duff, AERE Harwell.
       Jeremy Du Croz, Numerical Algorithms Group Ltd.
       Sven Hammarling, Numerical Algorithms Group Ltd.

    =====================================================================


       Test the input parameters.
','line_number':20451,'multiline':True]['text':' Parameter adjustments ','line_number':20577,'multiline':True]['text':' Function Body ','line_number':20585,'multiline':True]['text':'     Quick return if possible. ','line_number':20621,'multiline':True]['text':'     And when  alpha.eq.zero. ','line_number':20627,'multiline':True]['text':' L10: ','line_number':20636,'multiline':True]['text':' L20: ','line_number':20638,'multiline':True]['text':'     Start the operations. ','line_number':20643,'multiline':True]['text':'           Form  B := alpha*inv( A )*B. ','line_number':20648,'multiline':True]['text':' L30: ','line_number':20662,'multiline':True]['text':' L40: ','line_number':20686,'multiline':True]['text':' L50: ','line_number':20689,'multiline':True]['text':' L60: ','line_number':20691,'multiline':True]['text':' L70: ','line_number':20705,'multiline':True]['text':' L80: ','line_number':20730,'multiline':True]['text':' L90: ','line_number':20733,'multiline':True]['text':' L100: ','line_number':20735,'multiline':True]['text':'
             Form  B := alpha*inv( A' )*B
             or    B := alpha*inv( conjg( A' ) )*B.
','line_number':20740,'multiline':True]['text':' L110: ','line_number':20766,'multiline':True]['text':' L120: ','line_number':20783,'multiline':True]['text':' L130: ','line_number':20793,'multiline':True]['text':' L140: ','line_number':20795,'multiline':True]['text':' L150: ','line_number':20817,'multiline':True]['text':' L160: ','line_number':20834,'multiline':True]['text':' L170: ','line_number':20844,'multiline':True]['text':' L180: ','line_number':20846,'multiline':True]['text':'           Form  B := alpha*B*inv( A ). ','line_number':20853,'multiline':True]['text':' L190: ','line_number':20867,'multiline':True]['text':' L200: ','line_number':20886,'multiline':True]['text':' L210: ','line_number':20889,'multiline':True]['text':' L220: ','line_number':20902,'multiline':True]['text':' L230: ','line_number':20905,'multiline':True]['text':' L240: ','line_number':20918,'multiline':True]['text':' L250: ','line_number':20937,'multiline':True]['text':' L260: ','line_number':20940,'multiline':True]['text':' L270: ','line_number':20953,'multiline':True]['text':' L280: ','line_number':20956,'multiline':True]['text':'
             Form  B := alpha*B*inv( A' )
             or    B := alpha*B*inv( conjg( A' ) ).
','line_number':20961,'multiline':True]['text':' L290: ','line_number':20985,'multiline':True]['text':' L300: ','line_number':21010,'multiline':True]['text':' L310: ','line_number':21013,'multiline':True]['text':' L320: ','line_number':21024,'multiline':True]['text':' L330: ','line_number':21027,'multiline':True]['text':' L340: ','line_number':21049,'multiline':True]['text':' L350: ','line_number':21074,'multiline':True]['text':' L360: ','line_number':21077,'multiline':True]['text':' L370: ','line_number':21088,'multiline':True]['text':' L380: ','line_number':21091,'multiline':True]['text':'     End of ZTRSM . ','line_number':21099,'multiline':True]['text':' ztrsm_ ','line_number':21101,'multiline':True]['text':' Subroutine ','line_number':21103,'multiline':True]['text':' System generated locals ','line_number':21106,'multiline':True]['text':' Local variables ','line_number':21110,'multiline':True]['text':' Subroutine ','line_number':21114,'multiline':True]['text':'
    Purpose
    =======

    ZTRSV  solves one of the systems of equations

       A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,

    where b and x are n element vectors and A is an n by n unit, or
    non-unit, upper or lower triangular matrix.

    No test for singularity or near-singularity is included in this
    routine. Such tests must be performed before calling this routine.

    Arguments
    ==========

    UPLO   - CHARACTER*1.
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:

                UPLO = 'U' or 'u'   A is an upper triangular matrix.

                UPLO = 'L' or 'l'   A is a lower triangular matrix.

             Unchanged on exit.

    TRANS  - CHARACTER*1.
             On entry, TRANS specifies the equations to be solved as
             follows:

                TRANS = 'N' or 'n'   A*x = b.

                TRANS = 'T' or 't'   A'*x = b.

                TRANS = 'C' or 'c'   conjg( A' )*x = b.

             Unchanged on exit.

    DIAG   - CHARACTER*1.
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:

                DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.

             Unchanged on exit.

    N      - INTEGER.
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
             Unchanged on exit.

    A      - COMPLEX*16       array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
             Unchanged on exit.

    LDA    - INTEGER.
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
             Unchanged on exit.

    X      - COMPLEX*16       array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.

    INCX   - INTEGER.
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
             Unchanged on exit.

    Further Details
    ===============

    Level 2 Blas routine.

    -- Written on 22-October-1986.
       Jack Dongarra, Argonne National Lab.
       Jeremy Du Croz, Nag Central Office.
       Sven Hammarling, Nag Central Office.
       Richard Hanson, Sandia National Labs.

    =====================================================================


       Test the input parameters.
','line_number':21118,'multiline':True]['text':' Parameter adjustments ','line_number':21220,'multiline':True]['text':' Function Body ','line_number':21226,'multiline':True]['text':'     Quick return if possible. ','line_number':21248,'multiline':True]['text':'
       Set up the start point in X if the increment is not unity. This
       will be  ( N - 1 )*INCX  too small for descending loops.
','line_number':21257,'multiline':True]['text':'
       Start the operations. In this version the elements of A are
       accessed sequentially with one pass through A.
','line_number':21268,'multiline':True]['text':'        Form  x := inv( A )*x. ','line_number':21275,'multiline':True]['text':' L10: ','line_number':21299,'multiline':True]['text':' L20: ','line_number':21302,'multiline':True]['text':' L30: ','line_number':21328,'multiline':True]['text':' L40: ','line_number':21332,'multiline':True]['text':' L50: ','line_number':21359,'multiline':True]['text':' L60: ','line_number':21362,'multiline':True]['text':' L70: ','line_number':21390,'multiline':True]['text':' L80: ','line_number':21394,'multiline':True]['text':'        Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x. ','line_number':21400,'multiline':True]['text':' L90: ','line_number':21419,'multiline':True]['text':' L100: ','line_number':21436,'multiline':True]['text':' L110: ','line_number':21446,'multiline':True]['text':' L120: ','line_number':21467,'multiline':True]['text':' L130: ','line_number':21485,'multiline':True]['text':' L140: ','line_number':21496,'multiline':True]['text':' L150: ','line_number':21515,'multiline':True]['text':' L160: ','line_number':21532,'multiline':True]['text':' L170: ','line_number':21542,'multiline':True]['text':' L180: ','line_number':21563,'multiline':True]['text':' L190: ','line_number':21581,'multiline':True]['text':' L200: ','line_number':21592,'multiline':True]['text':'     End of ZTRSV . ','line_number':21600,'multiline':True]['text':' ztrsv_ ','line_number':21602,'multiline':True]