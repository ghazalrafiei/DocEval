['text':'
 * Python Universal Functions Object -- Math for all types, plus fast
 * arrays math
 *
 * Full description
 *
 * This supports mathematical (and Boolean) functions on arrays and other python
 * objects.  Math on large arrays of basic C types is rather efficient.
 *
 * Travis E. Oliphant  2005, 2006 oliphant@ee.byu.edu (oliphant.travis@ieee.org)
 * Brigham Young University
 *
 * based on the
 *
 * Original Implementation:
 * Copyright (c) 1995, 1996, 1997 Jim Hugunin, hugunin@mit.edu
 *
 * with inspiration and code from
 * Numarray
 * Space Science Telescope Institute
 * J. Todd Miller
 * Perry Greenfield
 * Rick White
 *
 ','line_number':1,'multiline':True]['text':' TODO: Only for `NpyIter_GetTransferFlags` until it is public ','line_number':64,'multiline':True]['text':'********* PRINTF DEBUG TRACING *************','line_number':68,'multiline':True]['text':'********************************************','line_number':82,'multiline':True]['text':' The input arguments to the ufunc, a tuple ','line_number':85,'multiline':True]['text':' The output arguments, a tuple. If no non-None outputs are
                       provided, then this is NULL. ','line_number':86,'multiline':True]['text':' C representation of the context argument to __array_wrap__ ','line_number':90,'multiline':True]['text':' Get the arg tuple to pass in the context argument to __array_wrap__.
 *
 * Output arguments are only passed if at least one is non-None.
 ','line_number':97,'multiline':True]['text':' ---------------------------------------------------------------- ','line_number':112,'multiline':True]['text':'UFUNC_API','line_number':125,'multiline':True]['text':'
     * non-clearing get was only added in 1.9 so this function always cleared
     * keep it so just in case third party code relied on the clearing
     ','line_number':129,'multiline':True]['text':' Checking the status flag clears it ','line_number':138,'multiline':True]['text':'UFUNC_API','line_number':139,'multiline':True]['text':'
 * This function analyzes the input arguments and determines an appropriate
 * method (__array_wrap__) function to call, taking it
 * from the input with the highest priority. Return NULL if no argument
 * defines the method.
 ','line_number':147,'multiline':True]['text':' If we have some methods defined, find the one of highest priority ','line_number':184,'multiline':True]['text':'
 * Returns an incref'ed pointer to the proper __array_wrap__
 * method for a ufunc output argument, given the output argument `obj`, and the
 * method chosen from the inputs `input_method`.
 ','line_number':206,'multiline':True]['text':'
             * No need to wrap regular arrays - None signals to not call
             * wrap/prepare at all
             ','line_number':217,'multiline':True]['text':' Use the wrap/prepare method of the output if it's callable ','line_number':232,'multiline':True]['text':' Fall back on the input's wrap/prepare ','line_number':237,'multiline':True]['text':' Called at module initialization to set the matmul ufunc output flags ','line_number':255,'multiline':True]['text':'
     * The default output flag NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE allows
     * perfectly overlapping input and output (in-place operations). While
     * correct for the common mathematical operations, this assumption is
     * incorrect in the general case and specifically in the case of matmul.
     *
     * NPY_ITER_UPDATEIFCOPY is added by default in
     * PyUFunc_GeneralizedFunction, which is the variant called for gufuncs
     * with a signature
     *
     * Enabling NPY_ITER_WRITEONLY can prevent a copy in some cases.
     ','line_number':263,'multiline':True]['text':'
 * Set per-operand flags according to desired input or output flags.
 * op_flags[i] for i in input (as determined by ufunc->nin) will be
 * merged with op_in_flags, perhaps overriding per-operand flags set
 * in previous stages.
 * op_flags[i] for i in output will be set to op_out_flags only if previously
 * unset.
 * The input flag behavior preserves backward compatibility, while the
 * output flag behaviour is the "correct" one for maximum flexibility.
 ','line_number':283,'multiline':True]['text':' Set up the flags ','line_number':300,'multiline':True]['text':'
         * If READWRITE flag has been set for this operand,
         * then clear default READONLY flag
         ','line_number':303,'multiline':True]['text':'
 * This function analyzes the input arguments
 * and determines an appropriate __array_wrap__ function to call
 * for the outputs.
 *
 * If an output argument is provided, then it is wrapped
 * with its own __array_wrap__ not with the one determined by
 * the input arguments.
 *
 * if the provided output argument is already an array,
 * the wrapping function is None (which means no wrapping will
 * be done --- not even PyArray_Return).
 *
 * A NULL is placed in output_wrap for outputs that
 * should just have PyArray_Return called.
 ','line_number':316,'multiline':True]['text':'
     * If a 'subok' parameter is passed and isn't True, don't wrap but put None
     * into slots with out arguments which means return the out argument
     ','line_number':339,'multiline':True]['text':'
     * Determine the wrapping function given by the input arrays
     * (could be NULL).
     ','line_number':347,'multiline':True]['text':'
     * For all the output arrays decide what to do.
     *
     * 1) Use the wrap function determined from the input arrays
     * This is the default if the output array is not
     * passed in.
     *
     * 2) Use the __array_wrap__ method of the output object
     * passed in. -- this is special cased for
     * exact ndarray so that no PyArray_Return is
     * done in that case.
     ','line_number':353,'multiline':True]['text':'
 * Apply the __array_wrap__ function with the given array and content.
 *
 * Interprets wrap=None and wrap=NULL as intended by _find_array_wrap
 *
 * Steals a reference to obj and wrap.
 * Pass context=NULL to indicate there is no context.
 ','line_number':383,'multiline':True]['text':' default behavior ','line_number':395,'multiline':True]['text':' Convert the context object to a tuple, if present ','line_number':406,'multiline':True]['text':' Call the method with appropriate context ','line_number':413,'multiline':True]['text':' try __array_wrap__(obj, context) ','line_number':425,'multiline':True]['text':' try __array_wrap__(obj) if the context argument is not accepted  ','line_number':429,'multiline':True]['text':' Return the position of next non-white-space char in the string ','line_number':445,'multiline':True]['text':'
 * Convert a string into a number
 ','line_number':468,'multiline':True]['text':' not a well formed number ','line_number':478,'multiline':True]['text':' len(str) too long ','line_number':482,'multiline':True]['text':'
 * Return the ending position of a variable name including optional modifier
 ','line_number':488,'multiline':True]['text':'
 * Returns 1 if the dimension names pointed by s1 and s2 are the same,
 * otherwise returns 0.
 ','line_number':504,'multiline':True]['text':'
 * Sets the following fields in the PyUFuncObject 'ufunc':
 *
 * Field             Type                     Array Length
 * core_enabled      int (effectively bool)   N/A
 * core_num_dim_ix   int                      N/A
 * core_dim_flags    npy_uint32 *             core_num_dim_ix
 * core_dim_sizes    npy_intp *               core_num_dim_ix
 * core_num_dims     int *                    nargs (i.e. nin+nout)
 * core_offsets      int *                    nargs
 * core_dim_ixs      int *                    sum(core_num_dims)
 * core_signature    char *                   strlen(signature) + 1
 *
 * The function assumes that the values that are arrays have not
 * been set already, and sets these pointers to memory allocated
 * with PyArray_malloc.  These are freed when the ufunc dealloc
 * method is called.
 *
 * Returns 0 unless an error occurred.
 ','line_number':521,'multiline':True]['text':' number of dimension of the current argument ','line_number':546,'multiline':True]['text':' index into core_num_dims&core_offsets ','line_number':547,'multiline':True]['text':' index into core_dim_ixs ','line_number':548,'multiline':True]['text':' Allocate sufficient memory to store pointers to all dimension names ','line_number':562,'multiline':True]['text':' The next three items will be shrunk later ','line_number':573,'multiline':True]['text':' loop over input/output arguments ','line_number':591,'multiline':True]['text':' expect "->" ','line_number':593,'multiline':True]['text':'
         * parse core dimensions of one argument,
         * e.g. "()", "(i)", or "(i,j)"
         ','line_number':601,'multiline':True]['text':' loop over core dimensions ','line_number':611,'multiline':True]['text':'
             * Is this a variable or a fixed size dimension?
             ','line_number':620,'multiline':True]['text':' Is this dimension flexible? ','line_number':633,'multiline':True]['text':'
             * Determine whether we already saw this dimension name,
             * get its index, and set its properties
             ','line_number':636,'multiline':True]['text':'
             * If a new dimension, store its properties; if old, check consistency.
             ','line_number':647,'multiline':True]['text':'
             * The list of input arguments (or output arguments) was
             * only read partially
             ','line_number':696,'multiline':True]['text':' check for trivial core-signature, e.g. "(),()->()" ','line_number':720,'multiline':True]['text':'
 * Checks if 'obj' is a valid output array for a ufunc, i.e. it is
 * either None or a writeable array, increments its reference count
 * and stores a pointer to it in 'store'. Returns 0 on success, sets
 * an exception and returns -1 on failure.
 ','line_number':737,'multiline':True]['text':' Translate None to NULL ','line_number':747,'multiline':True]['text':' If it's an array, store it ','line_number':751,'multiline':True]['text':'******** GENERIC UFUNC USING ITERATOR ********','line_number':766,'multiline':True]['text':'
 * Produce a name for the ufunc, if one is not already set
 * This is used in the PyUFunc_handlefperr machinery, and in error messages
 ','line_number':768,'multiline':True]['text':'
 * Converters for use in parsing of keywords arguments.
 ','line_number':778,'multiline':True]['text':'
     * Optimization: where=True is the same as no where argument.
     * This lets us document True as the default.
     ','line_number':812,'multiline':True]['text':' PyArray_FromAny steals reference to dtype, even on failure ','line_number':824,'multiline':True]['text':'
 * Due to the array override, do the actual parameter conversion
 * only in this step. This function takes the reference objects and
 * parses them into the desired values.
 * This function cleans up after itself and NULLs references on error,
 * however, the caller has to ensure that `out_op[0:nargs]` and `out_whermeask`
 * are NULL initialized.
 ','line_number':834,'multiline':True]['text':' PyArray of bool ','line_number':851,'multiline':True]['text':' Convert and fill in input arguments ','line_number':859,'multiline':True]['text':' Convert the input to an array and check for special cases ','line_number':873,'multiline':True]['text':'
             * TODO: If nin == 1 we don't promote!  This has exactly the effect
             *       that right now integers can still go to object/uint64 and
             *       their behavior is thus unchanged for unary ufuncs (like
             *       isnan).  This is not ideal, but pragmatic...
             *       We should eventually have special loops for isnan and once
             *       we do, we may just deprecate all remaining ones (e.g.
             *       `negative(2**100)` not working as it is an object.)
             *
             *       This is issue is part of the NEP 50 adoption.
             ','line_number':883,'multiline':True]['text':' TODO: A subclass of int, float, complex could reach here and','line_number':899,'multiline':False]['text':'       it should not be flagged as "weak" if it does.','line_number':900,'multiline':False]['text':' TODO: Is this equivalent/better by removing the logic which enforces','line_number':910,'multiline':False]['text':'       that we always use weak promotion in the core?','line_number':911,'multiline':False]['text':' Skip use of special dtypes ','line_number':913,'multiline':True]['text':'
         * Handle the "weak" Python scalars/literals.  We use a special DType
         * for these.
         * Further, we mark the operation array with a special flag to indicate
         * this.  This is because the legacy dtype resolution makes use of
         * `np.can_cast(operand, dtype)`.  The flag is local to this use, but
         * necessary to propagate the information to the legacy type resolution.
         ','line_number':916,'multiline':True]['text':'
                 * When `np.array(integer)` is not the default integer (mainly
                 * object dtype), this confuses many type resolvers.  Simply
                 * forcing a default integer array is unfortunately easiest.
                 * In this disables the optional NEP 50 warnings, but in
                 * practice when this happens we should _usually_ pick the
                 * default integer loop and that raises an error.
                 * (An exception is `float64(1.) + 10**100` which silently
                 * will give a float64 result rather than a Python float.)
                 *
                 * TODO: Just like the general dual NEP 50/legacy promotion
                 * support this is meant as a temporary hack for NumPy 1.25.
                 ','line_number':927,'multiline':True]['text':' Convert and fill in output arguments ','line_number':960,'multiline':True]['text':'
     * Convert most arguments manually here, since it is easier to handle
     * the ufunc override if we first parse only to objects.
     ','line_number':975,'multiline':True]['text':'
 * This checks whether a trivial loop is ok,
 * making copies of scalar and one dimensional operands if that will
 * help.
 *
 * Returns 1 if a trivial loop is ok, 0 if it is not, and
 * -1 if there is an error.
 ','line_number':1006,'multiline':True]['text':'
         * If the dtype doesn't match, or the array isn't aligned,
         * indicate that the trivial loop can't be done.
         ','line_number':1023,'multiline':True]['text':' A proper error during a cast check, should be rare ','line_number':1037,'multiline':True]['text':' NOTE: Could possibly implement non-zero view offsets ','line_number':1041,'multiline':True]['text':'
                 * ArrayMethod flagged to ignore casting (logical funcs
                 * can  force cast to bool)
                 ','line_number':1046,'multiline':True]['text':' the cast is not safe enough ','line_number':1052,'multiline':True]['text':'
             * If op[j] is a scalar or small one dimensional
             * array input, make a copy to keep the opportunity
             * for a trivial loop.  Outputs are not copied here.
             ','line_number':1056,'multiline':True]['text':'
 * Check whether a trivial loop is possible and call the innerloop if it is.
 * A trivial loop is defined as one where a single strided inner-loop call
 * is possible.
 *
 * This function only supports a single output (due to the overlap check).
 * It always accepts 0-D arrays and will broadcast them.  The function
 * cannot broadcast any other array (as it requires a single stride).
 * The function accepts all 1-D arrays, and N-D arrays that are either all
 * C- or all F-contiguous.
 * NOTE: Broadcast outputs are implicitly rejected in the overlap detection.
 *
 * Returns -2 if a trivial loop is not possible, 0 on success and -1 on error.
 ','line_number':1083,'multiline':True]['text':' The order of all N-D contiguous operands, can be fixed by `order` ','line_number':1106,'multiline':True]['text':' The out argument may be NULL (and only that one); fill later ','line_number':1121,'multiline':True]['text':' Special case 0-D since we can handle broadcasting using a 0-stride ','line_number':1128,'multiline':True]['text':' First non 0-D op: fix dimensions, shape (order is fixed later) ','line_number':1134,'multiline':True]['text':' dimension mismatch (except 0-d input ops) ','line_number':1140,'multiline':True]['text':' shape mismatch ','line_number':1144,'multiline':True]['text':' contiguous ','line_number':1151,'multiline':True]['text':' This op must match the operation order (and be contiguous) ','line_number':1153,'multiline':True]['text':' N-dimensional op must be contiguous ','line_number':1157,'multiline':True]['text':' op fixes order ','line_number':1160,'multiline':True]['text':' If any input overlaps with the output, we use the full path. ','line_number':1179,'multiline':True]['text':' Check self-overlap (non 1-D are contiguous, perfect overlap is OK) ','line_number':1188,'multiline':True]['text':'
     * We can use the trivial (single inner-loop call) optimization
     * and `fixed_strides` holds the strides for that call.
     ','line_number':1196,'multiline':True]['text':' Nothing to do ','line_number':1203,'multiline':True]['text':'
     * An error should only be possible if `res != 0` is already set.
     * But this is not strictly correct for old-style ufuncs (e.g. `power`
     * released the GIL but manually set an Exception).
     ','line_number':1231,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':1241,'multiline':True]['text':'
 * Check casting: It would be nice to just move this into the iterator
 * or pass in the full cast information.  But this can special case
 * the logical functions and prints a better error message.
 ','line_number':1249,'multiline':True]['text':'
         * In this case the legacy type resolution was definitely called
         * and we do not need to check (astropy/pyerfa relied on this).
         ','line_number':1260,'multiline':True]['text':'
 * The ufunc loop implementation for both normal ufunc calls and masked calls
 * when the iterator has to be used.
 *
 * See `PyUFunc_GenericFunctionInternal` for more information (where this is
 * called from).
 ','line_number':1280,'multiline':True]['text':'
         * NOTE: In the masked version, we consider the output read-write,
         *       this gives a best-effort of preserving the input, but does
         *       not always work.  It could allow the operand to be copied
         *       due to copy-if-overlap, but only if it was passed in.
         ','line_number':1305,'multiline':True]['text':' mask ','line_number':1314,'multiline':True]['text':'
     * Allocate the iterator.  Because the types of the inputs
     * were already checked, we use the casting rule 'unsafe' which
     * is faster to calculate.
     ','line_number':1328,'multiline':True]['text':' Set newly allocated arrays as outputs ','line_number':1344,'multiline':True]['text':' Only do the loop if the iteration size is non-zero ','line_number':1353,'multiline':True]['text':'
     * Get the inner loop, with the possibility of specialization
     * based on the fixed strides.
     ','line_number':1362,'multiline':True]['text':' Get the variables needed for the loop ','line_number':1387,'multiline':True]['text':' The reset may copy the first buffer chunk, which could cause FPEs ','line_number':1409,'multiline':True]['text':' Execute the loop ','line_number':1417,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':1428,'multiline':True]['text':'
 * Validate that operands have enough dimensions, accounting for
 * possible flexible dimensions that may be absent.
 ','line_number':1440,'multiline':True]['text':' We've too few, but some dimensions might be flexible ','line_number':1458,'multiline':True]['text':'
                         * Found a dimension that can be ignored. Flag that
                         * it is missing, and unflag that it can be ignored,
                         * since we are doing so already.
                         ','line_number':1465,'multiline':True]['text':'
                         * Reduce the number of core dimensions for all
                         * operands that use this one (including ours),
                         * and check whether we're now OK.
                         ','line_number':1472,'multiline':True]['text':'
 * Check whether any of the outputs of a gufunc has core dimensions.
 ','line_number':1506,'multiline':True]['text':'
 * Check whether the gufunc can be used with axis, i.e., that there is only
 * a single, shared core dimension (which means that operands either have
 * that dimension, or have no core dimensions).  Returns 0 if all is fine,
 * and sets an error and returns -1 if not.
 ','line_number':1520,'multiline':True]['text':'
 * Check whether the gufunc can be used with keepdims, i.e., that all its
 * input arguments have the same number of core dimension, and all output
 * arguments have no core dimensions. Returns 0 if all is fine, and sets
 * an error and returns -1 if not.
 ','line_number':1541,'multiline':True]['text':'
 * Interpret a possible axes keyword argument, using it to fill the remap_axis
 * array which maps default to actual axes for each operand, indexed as
 * as remap_axis[iop][iaxis]. The default axis order has first all broadcast
 * axes and then the core axes the gufunc operates on.
 *
 * Returns 0 on success, and -1 on failure
 ','line_number':1570,'multiline':True]['text':'
         * Get axes tuple for operand. If not a tuple already, make it one if
         * there is only one axis (its content is checked later).
         ','line_number':1620,'multiline':True]['text':' must have been a tuple with too many entries. ','line_number':1627,'multiline':True]['text':' If input is not an integer tell user that a tuple is needed ','line_number':1649,'multiline':True]['text':' If it is a single integer, inform user that more are needed ','line_number':1656,'multiline':True]['text':'
         * Now create the remap, starting with the core dimensions, and then
         * adding the remaining broadcast axes that are to be iterated over.
         ','line_number':1667,'multiline':True]['text':'
         * Fill the op_nbroadcast=op_ndim-op_ncore axes not yet set,
         * using have_seen_axis to skip over entries set above.
         ','line_number':1690,'multiline':True]['text':'
         * Check whether we are actually remapping anything. Here,
         * op_axis can only equal axis if all broadcast axes were the same
         * (i.e., the while loop above was never entered).
         ','line_number':1700,'multiline':True]['text':' end of for(iop) loop over operands ','line_number':1713,'multiline':True]['text':'
 * Simplified version of the above, using axis to fill the remap_axis
 * array, which maps default to actual axes for each operand, indexed as
 * as remap_axis[iop][iaxis]. The default axis order has first all broadcast
 * axes and then the core axes the gufunc operates on.
 *
 * Returns 0 on success, and -1 on failure
 ','line_number':1717,'multiline':True]['text':' _check_axis_support ensures core_num_dims is 0 or 1 ','line_number':1739,'multiline':True]['text':' ensure we don't modify axis_int ','line_number':1750,'multiline':True]['text':' Are we actually remapping away from last axis? ','line_number':1754,'multiline':True]['text':' end of for(iop) loop over operands ','line_number':1766,'multiline':True]['text':'
 * Validate the core dimensions of all the operands, and collect all of
 * the labelled core dimensions into 'core_dim_sizes'.
 *
 * Returns 0 on success, and -1 on failure
 *
 * The behavior has been changed in NumPy 1.16.0, and the following
 * requirements must be fulfilled or an error will be raised:
 *  * Arguments, both input and output, must have at least as many
 *    dimensions as the corresponding number of core dimensions. In
 *    versions before 1.10, 1's were prepended to the shape as needed.
 *  * Core dimensions with same labels must have exactly matching sizes.
 *    In versions before 1.10, core dimensions of size 1 would broadcast
 *    against other core dimensions with the same label.
 *  * All core dimensions must have their size specified by a passed in
 *    input or output argument. In versions before 1.10, core dimensions in
 *    an output argument that were not specified in an input argument,
 *    and whose size could not be inferred from a passed in output
 *    argument, would have their size set to 1.
 *  * Core dimensions may be fixed, new in NumPy 1.16
 ','line_number':1774,'multiline':True]['text':' checked before this routine gets called ','line_number':1811,'multiline':True]['text':'
             * Make sure every core dimension exactly matches all other core
             * dimensions with the same label. Note that flexible dimensions
             * may have been removed at this point, if so, they are marked
             * with UFUNC_CORE_DIM_MISSING.
             ','line_number':1814,'multiline':True]['text':' can only happen if flexible; dimension missing altogether ','line_number':1826,'multiline':True]['text':' for indexing in dimensions ','line_number':1829,'multiline':True]['text':'
     * Make sure no core dimension is unspecified.
     ','line_number':1854,'multiline':True]['text':' check all cases where the size has not yet been set ','line_number':1864,'multiline':True]['text':'
                 * Oops, this dimension was never specified
                 * (can only happen if output op not given)
                 ','line_number':1866,'multiline':True]['text':'
 * Returns a new reference to the ufunc identity.  Note that this identity
 * is only a default identity value stored on the ufunc, since the invidiual
 * ufunc loop (ArrayMethod) is queried for the actual identity.
 *
 * TODO: store a reference in the ufunc object itself, rather than
 *       constructing one each time
 ','line_number':1883,'multiline':True]['text':'
 * Copy over parts of the ufunc structure that may need to be
 * changed during execution.  Returns 0 on success; -1 otherwise.
 ','line_number':1927,'multiline':True]['text':' Use remapped axes for generalized ufunc ','line_number':1960,'multiline':True]['text':' These parameters come from a TLS global ','line_number':1973,'multiline':True]['text':' The dimensions which get passed to the inner loop ','line_number':1976,'multiline':True]['text':' The strides which get passed to the inner loop ','line_number':1978,'multiline':True]['text':' Auxiliary data allocated by the ufuncimpl (ArrayMethod) ','line_number':1980,'multiline':True]['text':' The sizes of the core dimensions (# entries is ufunc->core_num_dim_ix) ','line_number':1983,'multiline':True]['text':' swapping around of axes ','line_number':1986,'multiline':True]['text':' Initialize possibly variable parts to the values from the ufunc ','line_number':2003,'multiline':True]['text':'
     * If keepdims was passed in (and thus changed from the initial value
     * on top), check the gufunc is suitable, i.e., that its inputs share
     * the same number of core dimensions, and its outputs have none.
     ','line_number':2010,'multiline':True]['text':'
     * If keepdims is set and true, which means all input dimensions are
     * the same, signal that all output dimensions will be the same too.
     ','line_number':2027,'multiline':True]['text':' keepdims was not set or was false; no adjustment necessary ','line_number':2038,'multiline':True]['text':'
     * Check that operands have the minimum dimensions required.
     * (Just checks core; broadcast dimensions are tested by the iterator.)
     ','line_number':2041,'multiline':True]['text':'
     * Figure out the number of iteration dimensions, which
     * is the broadcast result of all the non-core dimensions.
     * (We do allow outputs to broadcast inputs currently, if they are given.
     * This is in line with what normal ufuncs do.)
     ','line_number':2050,'multiline':True]['text':' Possibly remap axes. ','line_number':2067,'multiline':True]['text':' Collect the lengths of the labelled core dimensions ','line_number':2094,'multiline':True]['text':'
     * Figure out the number of iterator creation dimensions,
     * which is the broadcast dimensions + all the core dimensions of
     * the outputs, so that the iterator can allocate those output
     * dimensions following the rules of order='F', for example.
     ','line_number':2100,'multiline':True]['text':' Fill in the initial part of 'iter_shape' ','line_number':2118,'multiline':True]['text':' Fill in op_axes for all the operands ','line_number':2123,'multiline':True]['text':' Broadcast all the unspecified dimensions normally ','line_number':2134,'multiline':True]['text':'
         * Any output core dimensions shape should be ignored, so we add
         * it as a Reduce dimension (which can be broadcast with the rest).
         * These will be removed before the actual iteration for gufuncs.
         ','line_number':2145,'multiline':True]['text':' Except for when it belongs to this output ','line_number':2154,'multiline':True]['text':'
             * Fill in 'iter_shape' and 'op_axes' for the core dimensions
             * of this output. Here, we have to be careful: if keepdims
             * was used, then the axes are not real core dimensions, but
             * are being added back for broadcasting, so their size is 1.
             * If the axis was removed, we should skip altogether.
             ','line_number':2158,'multiline':True]['text':' skip it ','line_number':2178,'multiline':True]['text':' Get the buffersize and errormask ','line_number':2200,'multiline':True]['text':'
     * We don't write to all elements, and the iterator may make
     * UPDATEIFCOPY temporary copies. The output arrays (unless they are
     * allocated by the iterator itself) must be considered READWRITE by the
     * iterator, so that the elements we don't write to are copied to the
     * possible temporary array.
     ','line_number':2208,'multiline':True]['text':'
     * Set up the iterator per-op flags.  For generalized ufuncs, we
     * can't do buffering, so must COPY or UPDATEIFCOPY.
     ','line_number':2221,'multiline':True]['text':' Create the iterator ','line_number':2232,'multiline':True]['text':' Fill in any allocated outputs ','line_number':2242,'multiline':True]['text':'
     * Set up the inner strides array. Because we're not doing
     * buffering, the strides are fixed throughout the looping.
     ','line_number':2252,'multiline':True]['text':' Copy the strides after the first nop ','line_number':2267,'multiline':True]['text':'
         * Need to use the arrays in the iterator, not op, because
         * a copy with a different-sized type may have been made.
         ','line_number':2270,'multiline':True]['text':'
         * Could be negative if flexible dims are used, but not for
         * keepdims, since those dimensions are allocated in arr.
         ','line_number':2277,'multiline':True]['text':'
             * Force zero stride when the shape is 1 (always the case for
             * for missing dimensions), so that broadcasting works right.
             ','line_number':2287,'multiline':True]['text':'
         * Only used for threading, if negative (this means that it is
         * larger then ssize_t before axes removal) assume that the actual
         * problem is large enough to be threaded usefully.
         ','line_number':2308,'multiline':True]['text':' Remove all the core output dimensions from the iterator ','line_number':2316,'multiline':True]['text':'
     * The first nop strides are for the inner loop (but only can
     * copy them after removing the core axes).  The strides will not change
     * if the iterator is not buffered (they are effectively fixed).
     * Supporting buffering would make sense, but probably would have to be
     * done in the inner-loop itself (not the iterator).
     ','line_number':2332,'multiline':True]['text':' Final preparation of the arraymethod call ','line_number':2343,'multiline':True]['text':' Start with the floating-point exception flags cleared ','line_number':2359,'multiline':True]['text':' Do the ufunc loop ','line_number':2366,'multiline':True]['text':' Get the variables needed for the loop ','line_number':2372,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':2396,'multiline':True]['text':' These parameters come from a TLS global ','line_number':2435,'multiline':True]['text':' Get the buffersize and errormask ','line_number':2440,'multiline':True]['text':' Set up the flags. ','line_number':2446,'multiline':True]['text':' Set up the flags. ','line_number':2454,'multiline':True]['text':' Final preparation of the arraymethod call ','line_number':2461,'multiline':True]['text':' Do the ufunc loop ','line_number':2468,'multiline':True]['text':'
         * This checks whether a trivial loop is ok, making copies of
         * scalar and one dimensional operands if that should help.
         ','line_number':2487,'multiline':True]['text':' Try to handle everything without using the (heavy) iterator ','line_number':2497,'multiline':True]['text':'
 * Promote and resolve a reduction like operation.
 *
 * @param ufunc
 * @param arr The operation array
 * @param out The output array or NULL if not provided.  Note that NumPy always
 *        used out to mean the same as `dtype=out.dtype` and never passed
 *        the array itself to the type-resolution.
 * @param signature The DType signature, which may already be set due to the
 *        dtype passed in by the user, or the special cases (add, multiply).
 *        (Contains strong references and may be modified.)
 * @param enforce_uniform_args If `NPY_TRUE` fully uniform dtypes/descriptors
 *        are enforced as required for accumulate and (currently) reduceat.
 * @param out_descrs New references to the resolved descriptors (on success).
 * @param method The ufunc method, "reduce", "reduceat", or "accumulate".

 * @returns ufuncimpl The `ArrayMethod` implementation to use. Or NULL if an
 *          error occurred.
 ','line_number':2511,'multiline':True]['text':'
      * If no dtype is specified and out is not specified, we override the
      * integer and bool dtype used for add and multiply.
      *
      * TODO: The following should be handled by a promoter!
      ','line_number':2537,'multiline':True]['text':'
         * For integer types --- make sure at least a long
         * is used for add and multiply reduction to avoid overflow
         ','line_number':2544,'multiline':True]['text':' we always fill it here ','line_number':2566,'multiline':True]['text':'
     * Note that the `ops` is not really correct.  But legacy resolution
     * cannot quite handle the correct ops (e.g. a NULL first item if `out`
     * is NULL) so we pass `arr` instead in that case.
     ','line_number':2570,'multiline':True]['text':'
     * TODO: This is a dangerous hack, that works by relying on the GIL, it is
     *       terrible, terrifying, and trusts that nobody does crazy stuff
     *       in their type-resolvers.
     *       By mutating the `out` dimension, we ensure that reduce-likes
     *       live in a future without value-based promotion even when legacy
     *       promotion has to be used.
     ','line_number':2577,'multiline':True]['text':'
     * TODO: If `out` is not provided, arguably `initial` could define
     *       the first DType (and maybe also the out one), that way
     *       `np.add.reduce([1, 2, 3], initial=3.4)` would return a float
     *       value.  As of 1.20, it returned an integer, so that should
     *       probably go to an error/warning first.
     ','line_number':2591,'multiline':True]['text':' DTypes may currently get filled in fallbacks and XDECREF for error: ','line_number':2615,'multiline':True]['text':'
     * Find the correct descriptors for the operation.  We use unsafe casting
     * for historic reasons: The logic ufuncs required it to cast everything to
     * boolean.  However, we now special case the logical ufuncs, so that the
     * casting safety could in principle be set to the default same-kind.
     * (although this should possibly happen through a deprecation)
     ','line_number':2623,'multiline':True]['text':'
     * The first operand and output should be the same array, so they should
     * be identical.  The second argument can be different for reductions,
     * but is checked to be identical for accumulate and reduceat.
     * Ideally, the type-resolver ensures that all are identical, but we do
     * not enforce this here strictly.  Otherwise correct handling of
     * byte-order changes (or metadata) requires a lot of care; see gh-20699.
     ','line_number':2635,'multiline':True]['text':' TODO: This really should _not_ be unsafe casting (same above)! ','line_number':2653,'multiline':True]['text':' Get the number of operands, to determine whether "where" is used ','line_number':2681,'multiline':True]['text':' Path currently not available for masked ','line_number':2689,'multiline':True]['text':' Skip any first-visit elements ','line_number':2693,'multiline':True]['text':' Turn the two items into three for the inner loop ','line_number':2706,'multiline':True]['text':' Advance loop, and abort on error (or finish) ','line_number':2721,'multiline':True]['text':' When skipping is done break and continue with faster loop ','line_number':2726,'multiline':True]['text':' Turn the two items into three for the inner loop ','line_number':2734,'multiline':True]['text':'
 * The implementation of the reduction operators with the new iterator
 * turned into a bit of a long function here, but I think the design
 * of this part needs to be changed to be more like einsum, so it may
 * not be worth refactoring it too much.  Consider this timing:
 *
 * >>> a = arange(10000)
 *
 * >>> timeit sum(a)
 * 10000 loops, best of 3: 17 us per loop
 *
 * >>> timeit einsum("i->",a)
 * 100000 loops, best of 3: 13.5 us per loop
 *
 * The axes must already be bounds-checked by the calling function,
 * this function does not validate them.
 ','line_number':2760,'multiline':True]['text':' These parameters come from a TLS global ','line_number':2787,'multiline':True]['text':' Create an array of flags for reduction ','line_number':2794,'multiline':True]['text':' These parameters come from a TLS global ','line_number':2852,'multiline':True]['text':' Take a reference to out for later returning ','line_number':2869,'multiline':True]['text':'
     * The below code assumes that all descriptors are interchangeable, we
     * allow them to not be strictly identical (but they typically should be)
     ','line_number':2880,'multiline':True]['text':' This can be removed, but the initial element copy needs fixing ','line_number':2888,'multiline':True]['text':' Set up the op_axes for the outer loop ','line_number':2909,'multiline':True]['text':' The per-operand flags for the outer loop ','line_number':2915,'multiline':True]['text':' We can't buffer, so must do UPDATEIFCOPY ','line_number':2926,'multiline':True]['text':' If input and output overlap in memory, use iterator to figure it out ','line_number':2933,'multiline':True]['text':'
         * The way accumulate is set up, we can't do buffering,
         * so make a copy instead when necessary.
         ','line_number':2944,'multiline':True]['text':'
         * Add some more flags.
         *
         * The accumulation outer loop is 'elementwise' over the array, so turn
         * on NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE. That is, in-place
         * accumulate(x, out=x) is safe to do without temporary copies.
         ','line_number':2950,'multiline':True]['text':' In case COPY or UPDATEIFCOPY occurred ','line_number':2969,'multiline':True]['text':' Get the output from the iterator if it was allocated ','line_number':2981,'multiline':True]['text':' Start with the floating-point exception flags cleared ','line_number':3018,'multiline':True]['text':'
     * If the reduction axis has size zero, either return the reduction
     * unit for UFUNC_REDUCE, or return the zero-sized output array
     * for UFUNC_ACCUMULATE.
     ','line_number':3022,'multiline':True]['text':' Get the variables needed for the loop ','line_number':3044,'multiline':True]['text':' Execute the loop with just the outer iterator ','line_number':3052,'multiline':True]['text':'
             * Copy the first element to start the reduction.
             *
             * Output (dataptr[0]) and input (dataptr[1]) may point to
             * the same memory, e.g. np.add.accumulate(a, out=a).
             ','line_number':3073,'multiline':True]['text':'
                 * Incref before decref to avoid the possibility of the
                 * reference count being zero temporarily.
                 ','line_number':3080,'multiline':True]['text':' Turn the two items into three for the inner loop ','line_number':3094,'multiline':True]['text':' Execute the loop with no iterators ','line_number':3111,'multiline':True]['text':' Turn the two items into three for the inner loop ','line_number':3128,'multiline':True]['text':'
         * Copy the first element to start the reduction.
         *
         * Output (dataptr[0]) and input (dataptr[1]) may point to the
         * same memory, e.g. np.add.accumulate(a, out=a).
         ','line_number':3133,'multiline':True]['text':'
             * Incref before decref to avoid the possibility of the
             * reference count being zero temporarily.
             ','line_number':3140,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':3184,'multiline':True]['text':'
 * Reduceat performs a reduce over an axis using the indices as a guide
 *
 * op.reduceat(array,indices)  computes
 * op.reduce(array[indices[i]:indices[i+1]]
 * for i=0..end with an implicit indices[i+1]=len(array)
 * assumed when i=end-1
 *
 * if indices[i+1] <= indices[i]+1
 * then the result is array[indices[i]] for that value
 *
 * op.accumulate(array) is the same as
 * op.reduceat(array,indices)[::2]
 * where indices is range(len(array)-1) with a zero placed in every other sample
 * indices = zeros(len(array)*2-1)
 * indices[1::2] = range(1,len(array))
 *
 * output shape is based on the size of indices
 *
 * TODO: Reduceat duplicates too much code from accumulate!
 ','line_number':3208,'multiline':True]['text':' The reduceat indices - ind must be validated outside this call ','line_number':3248,'multiline':True]['text':' These parameters comefrom a TLS global ','line_number':3255,'multiline':True]['text':' Check for out-of-bounds values in indices array ','line_number':3264,'multiline':True]['text':' Take a reference to out for later returning ','line_number':3287,'multiline':True]['text':'
     * The below code assumes that all descriptors are interchangeable, we
     * allow them to not be strictly identical (but they typically should be)
     ','line_number':3298,'multiline':True]['text':' This can be removed, but the initial element copy needs fixing ','line_number':3306,'multiline':True]['text':' Set up the op_axes for the outer loop ','line_number':3327,'multiline':True]['text':' Use the i-th iteration dimension to match up ind ','line_number':3329,'multiline':True]['text':'
         * The way reduceat is set up, we can't do buffering,
         * so make a copy instead when necessary using
         * the UPDATEIFCOPY flag
         ','line_number':3359,'multiline':True]['text':' The per-operand flags for the outer loop ','line_number':3365,'multiline':True]['text':' Remove the inner loop axis from the outer iterator ','line_number':3388,'multiline':True]['text':' In case COPY or UPDATEIFCOPY occurred ','line_number':3396,'multiline':True]['text':'
         * Allocate the output for when there's no outer iterator, we always
         * use the outer_iteration path when `out` is passed.
         ','line_number':3407,'multiline':True]['text':' The reduce axis does not advance here in the strided-loop ','line_number':3429,'multiline':True]['text':' Start with the floating-point exception flags cleared ','line_number':3440,'multiline':True]['text':'
     * If the output has zero elements, return now.
     ','line_number':3444,'multiline':True]['text':' Get the variables needed for the loop ','line_number':3464,'multiline':True]['text':' Execute the loop with just the outer iterator ','line_number':3471,'multiline':True]['text':'
                 * Copy the first element to start the reduction.
                 *
                 * Output (dataptr[0]) and input (dataptr[1]) may point
                 * to the same memory, e.g.
                 * np.add.reduceat(a, np.arange(len(a)), out=a).
                 ','line_number':3497,'multiline':True]['text':'
                     * Incref before decref to avoid the possibility of
                     * the reference count being zero temporarily.
                     ','line_number':3505,'multiline':True]['text':' Inner loop like REDUCE ','line_number':3519,'multiline':True]['text':'
             * Copy the first element to start the reduction.
             *
             * Output (dataptr[0]) and input (dataptr[1]) may point to
             * the same memory, e.g.
             * np.add.reduceat(a, np.arange(len(a)), out=a).
             ','line_number':3556,'multiline':True]['text':'
                 * Incref before decref to avoid the possibility of the
                 * reference count being zero temporarily.
                 ','line_number':3564,'multiline':True]['text':' Inner loop like REDUCE ','line_number':3578,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':3605,'multiline':True]['text':' Can be an array if it only has one output ','line_number':3664,'multiline':True]['text':'
 * Convert function which replaces np._NoValue with NULL.
 * As a converter returns 0 on error and 1 on success.
 ','line_number':3681,'multiline':True]['text':' forward declaration ','line_number':3703,'multiline':True]['text':'
 * This code handles reduce, reduceat, and accumulate
 * (accumulate and reduce are special cases of the more general reduceat
 * but they are handled separately for speed)
 ','line_number':3706,'multiline':True]['text':'
     * Perform argument parsing, but start by only extracting. This is
     * just to preserve the behaviour that __array_ufunc__ did not perform
     * any checks on arguments, and we could change this or change it for
     * certain parameters.
     ','line_number':3755,'multiline':True]['text':' Prepare inputs for PyUfunc_CheckOverride ','line_number':3775,'multiline':True]['text':' Prepare input for PyUfunc_CheckOverride ','line_number':3793,'multiline':True]['text':' Prepare input for PyUfunc_CheckOverride ','line_number':3814,'multiline':True]['text':' Normalize output for PyUFunc_CheckOverride and conversion. ','line_number':3822,'multiline':True]['text':' in this branch, out is always wrapped in a tuple. ','line_number':3824,'multiline':True]['text':' Ensure that out_obj is the array, not the tuple: ','line_number':3836,'multiline':True]['text':' We now have all the information required to check for Overrides ','line_number':3842,'multiline':True]['text':' Finish parsing of all parameters (no matter which reduce-like) ','line_number':3855,'multiline':True]['text':' Use `_get_dtype` because `dtype` is a DType and not the instance ','line_number':3866,'multiline':True]['text':' Ensure input is an array ','line_number':3882,'multiline':True]['text':' Convert the 'axis' parameter into a list of axes ','line_number':3890,'multiline':True]['text':' apply defaults ','line_number':3892,'multiline':True]['text':' Convert 'None' into all the axes ','line_number':3902,'multiline':True]['text':' Try to interpret axis as an integer ','line_number':3928,'multiline':True]['text':' TODO: PyNumber_Index would be good to use here ','line_number':3930,'multiline':True]['text':'
         * As a special case for backwards compatibility in 'sum',
         * 'prod', et al, also allow a reduction for scalars even
         * though this is technically incorrect.
         ','line_number':3934,'multiline':True]['text':' Wrap and return the output ','line_number':3997,'multiline':True]['text':' Find __array_wrap__ - note that these rules are different to the
         * normal ufunc path
         ','line_number':3999,'multiline':True]['text':'
 * Perform a basic check on `dtype`, `sig`, and `signature` since only one
 * may be set.  If `sig` is used, writes it into `out_signature` (which should
 * be set to `signature_obj` so that following code only requires to handle
 * `signature_obj`).
 *
 * Does NOT incref the output!  This only copies the borrowed references
 * gotten during the argument parsing.
 *
 * This function does not do any normalization of the input dtype tuples,
 * this happens after the array-ufunc override check currently.
 ','line_number':4037,'multiline':True]['text':' dtype needs to be converted, delay after the override check ','line_number':4075,'multiline':True]['text':'
 * Note: This function currently lets DType classes pass, but in general
 * the class (not the descriptor instance) is the preferred input, so the
 * parsing should eventually be adapted to prefer classes and possible
 * deprecated instances. (Users should not notice that much, since `np.float64`
 * or "float64" usually denotes the DType class rather than the instance.)
 ','line_number':4081,'multiline':True]['text':' TODO: this path was unreachable when added. ','line_number':4101,'multiline':True]['text':' This does not warn about `metadata`, but units is important. ','line_number':4110,'multiline':True]['text':'
 * Finish conversion parsing of the DType signature.  NumPy always only
 * honored the type number for passed in descriptors/dtypes.
 * The `dtype` argument is interpreted as the first output DType (not
 * descriptor).
 * Unlike the dtype of an `out` array, it influences loop selection!
 *
 * It is the callers responsibility to clean `signature` and NULL it before
 * calling.
 ','line_number':4130,'multiline':True]['text':' If `dtype=None` is passed, no need to do anything ','line_number':4153,'multiline':True]['text':' This may be allowed (NumPy does not do this)? ','line_number':4157,'multiline':True]['text':' Fill in specified_types from the tuple or string (signature_obj) ','line_number':4175,'multiline':True]['text':'
             * Special handling, because we deprecate this path.  The path
             * probably mainly existed since the `dtype=obj` was passed through
             * as `(obj,)` and parsed later.
             ','line_number':4179,'multiline':True]['text':' Use the same logic as for `dtype=` ','line_number':4194,'multiline':True]['text':'
                     * We reject abstract input signatures for now.  These
                     * can probably be defined by finding the common DType with
                     * the actual input and using the result of this for the
                     * promotion.
                     ','line_number':4215,'multiline':True]['text':' `signature="l"` is the same as `dtype="l"` ','line_number':4266,'multiline':True]['text':'
 * Fill in the actual descriptors used for the operation.  This function
 * supports falling back to the legacy `ufunc->type_resolver`.
 *
 * We guarantee the array-method that all passed in descriptors are of the
 * correct DType instance (i.e. a string can just fetch the length, it doesn't
 * need to "cast" to string first).
 ','line_number':4293,'multiline':True]['text':'
         * Allow a somewhat more powerful approach which:
         * 1. Has access to scalars (currently only ever Python ones)
         * 2. Can in principle customize `PyArray_CastDescrToDType()`
         *    (also because we want to avoid calling it for the scalars).
         ','line_number':4315,'multiline':True]['text':' For abstract DTypes, we might want to change what this is ','line_number':4328,'multiline':True]['text':'
                 * TODO: We may wish to allow any scalar here.  Checking for
                 *       abstract assumes this works out for Python scalars,
                 *       which is the important case (especially for now).
                 *
                 * One possible check would be `DType->type == type(obj)`.
                 ','line_number':4335,'multiline':True]['text':' currently ignored ','line_number':4349,'multiline':True]['text':'
             * The dtype may mismatch the signature, in which case we need
             * to make it fit before calling the resolution.
             ','line_number':4362,'multiline':True]['text':' only this much is initialized ','line_number':4369,'multiline':True]['text':' The default: use the `ufuncimpl` as nature intended it ','line_number':4376,'multiline':True]['text':' currently ignored ','line_number':4377,'multiline':True]['text':'
         * Fall-back to legacy resolver using `operands`, used exclusively
         * for datetime64/timedelta64 and custom ufuncs (in pyerfa/astropy).
         ','line_number':4384,'multiline':True]['text':' TODO: Currently impossible to reach (specialized unsafe loop) ','line_number':4397,'multiline':True]['text':'*
 * Wraps all outputs and returns the result (which may be NULL on error).
 *
 * Use __array_wrap__ on all outputs
 * if present on one of the input arguments.
 * If present for multiple inputs:
 * use __array_wrap__ of input object with largest
 * __array_priority__ (default = 0.0)
 *
 * Exception:  we should not wrap outputs for items already
 * passed in as output-arguments.  These items should either
 * be left unwrapped or wrapped by calling their own __array_wrap__
 * routine.
 *
 * For each output argument, wrap will be either
 * NULL --- call PyArray_Return() -- default if no output arguments given
 * None --- array-object passed in don't call PyArray_Return
 * method --- the __array_wrap__ method to call.
 *
 * @param ufunc
 * @param full_args Original inputs and outputs
 * @param subok Whether subclasses are allowed
 * @param result_arrays The ufunc result(s).  REFERENCES ARE STOLEN!
 ','line_number':4414,'multiline':True]['text':' wrap outputs ','line_number':4447,'multiline':True]['text':' Was DECREF'ed and (probably) wrapped ','line_number':4456,'multiline':True]['text':'
 * Main ufunc call implementation.
 *
 * This implementation makes use of the "fastcall" way of passing keyword
 * arguments and is called directly from `ufunc_generic_vectorcall` when
 * Python has `tp_vectorcall` (Python 3.8+).
 * If `tp_vectorcall` is not available, the dictionary `kwargs` are unpacked in
 * `ufunc_generic_call` with fairly little overhead.
 ','line_number':4489,'multiline':True]['text':' All following variables are cleared in the `fail` error path ','line_number':4506,'multiline':True]['text':' Initialize all arrays (we usually only need a small part) ','line_number':4514,'multiline':True]['text':'
     * Note that the input (and possibly output) arguments are passed in as
     * positional arguments. We extract these first and check for `out`
     * passed by keyword later.
     * Outputs and inputs are stored in `full_args.in` and `full_args.out`
     * as tuples (or NULL when no outputs are passed).
     ','line_number':4520,'multiline':True]['text':' Check number of arguments ','line_number':4528,'multiline':True]['text':' Fetch input arguments. ','line_number':4537,'multiline':True]['text':'
     * If there are more arguments, they define the out args. Otherwise
     * full_args.out is NULL for now, and the `out` kwarg may still be passed.
     ','line_number':4543,'multiline':True]['text':'
     * We have now extracted (but not converted) the input arguments.
     * To simplify overrides, extract all other arguments (as objects only)
     ','line_number':4577,'multiline':True]['text':' Skip parsing if there are no keyword arguments, nothing left to do ','line_number':4587,'multiline':True]['text':' Handle `out` arguments passed by keyword ','line_number':4629,'multiline':True]['text':'
         * Only one of signature, sig, and dtype should be passed. If `sig`
         * was passed, this puts it into `signature_obj` instead (these
         * are borrowed references).
         ','line_number':4641,'multiline':True]['text':' We now have all the information required to check for Overrides ','line_number':4659,'multiline':True]['text':' Outer uses special preparation of inputs (expand dims) ','line_number':4674,'multiline':True]['text':'
     * Parse the passed `dtype` or `signature` into an array containing
     * PyArray_DTypeMeta and/or None.
     ','line_number':4682,'multiline':True]['text':' We need to know if it was passed ','line_number':4694,'multiline':True]['text':' extract operand related information: ','line_number':4699,'multiline':True]['text':' extract general information: ','line_number':4704,'multiline':True]['text':'
     * Note that part of the promotion is to the complete the signature
     * (until here it only represents the fixed part and is usually NULLs).
     *
     * After promotion, we could push the following logic into the ArrayMethod
     * in the future.  For now, we do it here.  The type resolution step can
     * be shared between the ufunc and gufunc code.
     ','line_number':4713,'multiline':True]['text':' Find the correct descriptors for the operation ','line_number':4729,'multiline':True]['text':'
         * Python integers need to be cast specially.  For other python
         * scalars it does not hurt either.  It would be nice to never create
         * the array in this case, but that is difficult until value-based
         * promotion rules are gone.  (After that, we may get away with using
         * dummy arrays rather than real arrays for the legacy resolvers.)
         ','line_number':4736,'multiline':True]['text':'
             * If descriptor matches, no need to convert, but integers may
             * have been too large.
             ','line_number':4748,'multiline':True]['text':' Otherwise, replace the operand with a new array ','line_number':4757,'multiline':True]['text':'
     * Do the final preparations and call the inner-loop.
     ','line_number':4774,'multiline':True]['text':'
     * Clear all variables which are not needed any further.
     * (From here on, we cannot `goto fail` any more.)
     ','line_number':4791,'multiline':True]['text':' The following steals the references to the outputs: ','line_number':4804,'multiline':True]['text':'
 * Implement vectorcallfunc which should be defined with Python 3.8+.
 * In principle this could be backported, but the speed gain seems moderate
 * since ufunc calls often do not have keyword arguments and always have
 * a large overhead. The only user would potentially be cython probably.
 ','line_number':4826,'multiline':True]['text':'
     * Unlike METH_FASTCALL, `len_args` may have a flag to signal that
     * args[-1] may be (temporarily) used. So normalize it here.
     ','line_number':4836,'multiline':True]['text':'UFUNC_API','line_number':4845,'multiline':True]['text':' Find the location of the matching signature ','line_number':4854,'multiline':True]['text':'UFUNC_API','line_number':4874,'multiline':True]['text':'UFUNC_API','line_number':4885,'multiline':True]['text':'UFUNC_API','line_number':4898,'multiline':True]['text':'
     * We use GC_New here for ufunc->obj, but do not use GC_Track since
     * ufunc->obj is still NULL at the end of this function.
     * See ufunc_frompyfunc where ufunc->obj is set and GC_Track is called.
     ','line_number':4917,'multiline':True]['text':' Type resolution and inner loop selection functions ','line_number':4957,'multiline':True]['text':'
         * Work around a test that seems to do this right now, it should not
         * be a valid ufunc at all though, so. TODO: Remove...
         ','line_number':4970,'multiline':True]['text':'
         * Add all legacy wrapping loops here. This is normally not necessary,
         * but makes sense.  It could also help/be needed to avoid issues with
         * ambiguous loops such as: `OO->?` and `OO->O` where in theory the
         * wrong loop could be picked if only the second one is added.
         ','line_number':5006,'multiline':True]['text':' These DTypes are immortal and adding INCREFs: so borrow it ','line_number':5016,'multiline':True]['text':'
     * TODO: I tried adding a default promoter here (either all object for
     *       some special cases, or all homogeneous).  Those are reasonable
     *       defaults, but short-cut a deprecated SciPy loop, where the
     *       homogeneous loop `ddd->d` was deprecated, but an inhomogeneous
     *       one `dld->d` should be picked.
     *       The default promoter *is* a reasonable default, but switched that
     *       behaviour.
     *       Another problem appeared due to buggy type-resolution for
     *       datetimes, this meant that `timedelta.sum(dtype="f8")` returned
     *       datetimes (and not floats or error), arguably wrong, but...
     ','line_number':5027,'multiline':True]['text':'
 * This is the first-part of the CObject structure.
 *
 * I don't think this will change, but if it should, then
 * this needs to be fixed.  The exposed C-API was insufficient
 * because I needed to replace the pointer and it wouldn't
 * let me with a destructor set (even though it works fine
 * with the destructor).
 ','line_number':5043,'multiline':True]['text':' return 1 if arg1 > arg2, 0 if arg1 == arg2, and -1 if arg1 < arg2 ','line_number':5059,'multiline':True]['text':'
 * This frees the linked-list structure when the CObject
 * is destroyed (removed from the internal dictionary)
','line_number':5075,'multiline':True]['text':'
 * This function allows the user to register a 1-d loop with an already
 * created ufunc. This function is similar to RegisterLoopForType except
 * that it allows a 1-d loop to be registered with PyArray_Descr objects
 * instead of dtype type num values. This allows a 1-d loop to be registered
 * for a structured array dtype or a custom dtype. The ufunc is called
 * whenever any of it's input arguments match the user_dtype argument.
 *
 * ufunc      - ufunc object created from call to PyUFunc_FromFuncAndData
 * user_dtype - dtype that ufunc will be registered with
 * function   - 1-d loop function pointer
 * arg_dtypes - array of dtype objects describing the ufunc operands
 * data       - arbitrary data pointer passed in to loop function
 *
 * returns 0 on success, -1 for failure
 ','line_number':5108,'multiline':True]['text':'UFUNC_API','line_number':5124,'multiline':True]['text':'UFUNC_API','line_number':5231,'multiline':True]['text':' DType can't be deleted... ','line_number':5273,'multiline':True]['text':' DType can't be deleted... ','line_number':5280,'multiline':True]['text':'
     * We add the loop to the list of all loops and promoters.  If the
     * equivalent loop was already added, skip this.
     * Note that even then the ufunc is still modified: The legacy ArrayMethod
     * already looks up the inner-loop from the ufunc (and this is replaced
     * below!).
     * If the existing one is not a legacy ArrayMethod, we raise currently:
     * A new-style loop should not be replaced by an old-style one.
     ','line_number':5289,'multiline':True]['text':' The loop was already added ','line_number':5320,'multiline':True]['text':' Clearing sets it to NULL for the error paths ','line_number':5331,'multiline':True]['text':' Get entry for this user-defined type','line_number':5341,'multiline':True]['text':' If it's not there, then make one and return. ','line_number':5346,'multiline':True]['text':'
         * There is already at least 1 loop. Place this one in
         * lexicographic order.  If the next one signature
         * is exactly like this one, then just replace.
         * Otherwise insert.
         ','line_number':5360,'multiline':True]['text':' just replace it with new function ','line_number':5379,'multiline':True]['text':'
             * insert it before the current one by hacking the internals
             * of cobject to replace the function pointer --- can't use
             * CObject API because destructor is set.
             ','line_number':5386,'multiline':True]['text':' place this at front ','line_number':5393,'multiline':True]['text':'*****************************************************************************
 ***                          UFUNC METHODS                                 ***
 ****************************************************************************','line_number':5456,'multiline':True]['text':'
 * op.outer(a,b) is equivalent to op(a[:,NewAxis,NewAxis,etc.],b)
 * where a has b.ndim NewAxis terms appended.
 *
 * The result has dimensions a.ndim + b.ndim
 ','line_number':5461,'multiline':True]['text':' DEPRECATED 2020-05-13, NumPy 1.20 ','line_number':5512,'multiline':True]['text':' DEPRECATED 2020-05-13, NumPy 1.20 ','line_number':5529,'multiline':True]['text':' Construct new shape from ap1 and ap2 and then reshape ','line_number':5544,'multiline':True]['text':' Helper for ufunc_at, below ','line_number':5619,'multiline':True]['text':' NewFromDescr steals a reference ','line_number':5624,'multiline':True]['text':'
 * Use an indexed loop to do the work
 * Returns 0 if successful
 ','line_number':5631,'multiline':True]['text':' 
         * The value of iter->fancy_dims[0] is added to negative indexes
         * inside the inner loop
         ','line_number':5669,'multiline':True]['text':' Start with the floating-point exception flags cleared ','line_number':5713,'multiline':True]['text':'
     * Iterate over first and second operands and call ufunc
     * for each pair of inputs
     ','line_number':5722,'multiline':True]['text':' one element at a time, no stride required but read by innerloop ','line_number':5729,'multiline':True]['text':'
         * Set up data pointers for either one or two input operands.
         * The output data pointer points to the first operand data.
         ','line_number':5732,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':5760,'multiline':True]['text':' Set up the flags ','line_number':5800,'multiline':True]['text':'
     * Create NpyIter object to "iterate" over single element of each input
     * operand. This is an easy way to reuse the NpyIter logic for dealing
     * with certain cases like casting operands to correct dtype. On each
     * iteration over the MapIterArray object created above, we'll take the
     * current data pointers from that and reset this NpyIter object using
     * those data pointers, and then trigger a buffer copy. The buffer data
     * pointers from the NpyIter object will then be passed to the inner loop
     * function.
     ','line_number':5821,'multiline':True]['text':' will fail only on memory allocation errors ','line_number':5843,'multiline':True]['text':' can not really happen, iter_buffer creation is tightly controlled ','line_number':5852,'multiline':True]['text':' Start with the floating-point exception flags cleared ','line_number':5863,'multiline':True]['text':'
     * Iterate over first and second operands and call ufunc
     * for each pair of inputs
     ','line_number':5872,'multiline':True]['text':' one element at a time, no stride required but read by innerloop ','line_number':5880,'multiline':True]['text':'
         * Set up data pointers for either one or two input operands.
         * The output data pointer points to the first operand data.
         ','line_number':5883,'multiline':True]['text':' Reset NpyIter data pointers which will trigger a buffer copy ','line_number':5897,'multiline':True]['text':'
         * Call to iternext triggers copy from buffer back to output array
         * after innerloop puts result in buffer.
         ','line_number':5911,'multiline':True]['text':' NOTE: We could check float errors even when `res < 0` ','line_number':5929,'multiline':True]['text':'
 * Call ufunc only on selected array items and store result in first operand.
 * For add ufunc, method call is equivalent to op1[idx] += op2 with no
 * buffering of the first operand.
 * Arguments:
 * op1 - First operand to ufunc
 * idx - Indices that are applied to first operand. Equivalent to op1[idx].
 * op2 - Second operand to ufunc (if needed). Must be able to broadcast
 *       over first operand.
 ','line_number':5939,'multiline':True]['text':' override vars ','line_number':5963,'multiline':True]['text':' start with fail condition so "goto fail" will error ','line_number':5966,'multiline':True]['text':' Create second operand from number array if needed. ','line_number':6023,'multiline':True]['text':' Do all the dtype handling and find the correct ufuncimpl ','line_number':6038,'multiline':True]['text':'
         * Create dtypes array for either one or two input operands.
         * Compare to the logic in `convert_ufunc_arguments`.
         * TODO: It may be good to review some of this behaviour, since the
         *       operand array is special (it is written to) similar to reductions.
         *       Using unsafe-casting as done here, is likely not desirable.
         ','line_number':6043,'multiline':True]['text':' both are legacy and only one is 0-D: force legacy ','line_number':6067,'multiline':True]['text':' Find the correct operation_descrs for the operation ','line_number':6089,'multiline':True]['text':' May be updateifcopied on overlap ','line_number':6106,'multiline':True]['text':'
         * May need to swap axes so that second operand is
         * iterated over correctly
         ','line_number':6109,'multiline':True]['text':' only on memory allocation failure ','line_number':6116,'multiline':True]['text':'
         * Create array iter object for second operand that
         * "matches" the map iter object for the first operand.
         * Then we can just iterate over the first and second
         * operands at the same time and not have to worry about
         * picking the correct elements from each operand to apply
         * the ufunc to.
         ','line_number':6121,'multiline':True]['text':' Use contiguous strides; if there is such a loop it may be faster ','line_number':6142,'multiline':True]['text':' check no casting, alignment ','line_number':6155,'multiline':True]['text':' output casting ','line_number':6160,'multiline':True]['text':'
         * Try to use trivial loop (1d, no casting, aligned) if
         * - the matching info has a indexed loop
         * - idx must be exactly one integer index array
         * - all operands are 1d
         * A future enhancement could loosen the restriction on 1d operands
         * by adding an iteration loop inside trivial_at_loop
         ','line_number':6175,'multiline':True]['text':' Couldn't use the fastest path, use the faster path ','line_number':6192,'multiline':True]['text':'
     * An error should only be possible if needs_api is true or `res != 0`,
     * but this is not strictly correct for old-style ufuncs
     * (e.g. `power` released the GIL but manually set an Exception).
     ','line_number':6212,'multiline':True]['text':' iter_buffer has already been deallocated, don't use NpyIter_Dealloc ','line_number':6218,'multiline':True]['text':' Should move to flags, but lets keep it bools for now: ','line_number':6234,'multiline':True]['text':'
 * Python entry-point to ufunc promotion and dtype/descr resolution.
 *
 * This function does most of the work required to execute ufunc without
 * actually executing it.
 * This can be very useful for downstream libraries that reimplement NumPy
 * functionality, such as Numba or Dask.
 ','line_number':6262,'multiline':True]['text':'
     * Legacy type resolvers expect NumPy arrays as input.  Until NEP 50 is
     * adopted, it is most convenient to ensure that we have an "array" object
     * before calling the type promotion.  Eventually, this hack may be moved
     * into the legacy type resolution code itself (probably after NumPy stops
     * using legacy type resolution itself for the most part).
     *
     * We make the pretty safe assumptions here that:
     * - Nobody will actually do anything with the array objects besides
     *   checking the descriptor or calling CanCast.
     * - No type resolver will cause weird paths that mess with our promotion
     *   state (or mind us messing with it).
     ','line_number':6296,'multiline':True]['text':' This entry-point to promotion lives in the NEP 50 future: ','line_number':6317,'multiline':True]['text':'
         * We create dummy arrays for now.  It should be OK to make this
         * truly "dummy" (not even proper objects), but that is a hack better
         * left for the legacy_type_resolution wrapper when NEP 50 is done.
         ','line_number':6336,'multiline':True]['text':' Explicitly allow int, float, and complex for the "weak" types. ','line_number':6359,'multiline':True]['text':' Find the correct descriptors for the operation ','line_number':6418,'multiline':True]['text':' reduction ','line_number':6430,'multiline':True]['text':' Result will be (dtype_tuple, call_info), so move it and clear result ','line_number':6460,'multiline':True]['text':' We may have to return the context: ','line_number':6464,'multiline':True]['text':'
     * We create a capsule with NumPy 1.24 in the name to signal that it is
     * prone to change in version updates (it doesn't have to).
     * This capsule is documented in the `ufunc._resolve_dtypes_and_context`
     * docstring.
     ','line_number':6476,'multiline':True]['text':' cleanup and return ','line_number':6502,'multiline':True]['text':' Cannot have a context with NULL inside... ','line_number':6556,'multiline':True]['text':'
     * Strict conversion of fixed_strides, None, or tuple of int or None.
     ','line_number':6572,'multiline':True]['text':' Lower level methods: ','line_number':6638,'multiline':True]['text':'
     * The following two functions are public API, but underscored since they
     * are C-user specific and allow direct access to the core of ufunc loops.
     * (See their documentation for API stability.)
     ','line_number':6642,'multiline':True]['text':' sentinel ','line_number':6653,'multiline':True]['text':'*****************************************************************************
 ***                           UFUNC GETSET                                 ***
 ****************************************************************************','line_number':6657,'multiline':True]['text':'
     * Put docstring first or FindMethod finds it... could so some
     * introspection on name and nin + nout to automate the first part
     * of it the doc string shouldn't need the calling convention
     ','line_number':6689,'multiline':True]['text':' return a list with types grouped input->output ','line_number':6733,'multiline':True]['text':'
 * Docstring is now set from python
 * static char *Ufunctype__doc__ = NULL;
 ','line_number':6788,'multiline':True]['text':' Sentinel ','line_number':6820,'multiline':True]['text':'*****************************************************************************
 ***                        UFUNC TYPE OBJECT                               ***
 ****************************************************************************','line_number':6824,'multiline':True]['text':' End of code for ufunc objects ','line_number':6845,'multiline':True]