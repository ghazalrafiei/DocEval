['text':'
 * This file implements core functionality for NumPy datetime.
 *
 * Written by Mark Wiebe (mwwiebe@gmail.com)
 * Copyright (c) 2011 by Enthought, Inc.
 *
 * See LICENSE.txt for the license.
 ','line_number':1,'multiline':True]['text':'
 * Computes the python `ret, d = divmod(d, unit)`.
 *
 * Note that GCC is smart enough at -O2 to eliminate the `if(*d < 0)` branch
 * for subsequent calls to this command - it is able to deduce that `*d >= 0`.
 ','line_number':37,'multiline':True]['text':'
 * Imports the PyDateTime functions so we can create these objects.
 * This is called during module initialization
 ','line_number':71,'multiline':True]['text':' Exported as DATETIMEUNITS in multiarraymodule.c ','line_number':81,'multiline':True]['text':' Days per month, regular year and leap year ','line_number':100,'multiline':True]['text':'
 * Returns 1 if the given year is a leap year, 0 otherwise.
 ','line_number':106,'multiline':True]['text':' year % 4 == 0 ','line_number':112,'multiline':True]['text':'
 * Calculates the days offset from the 1970 epoch.
 ','line_number':117,'multiline':True]['text':' Adjust for leap years ','line_number':130,'multiline':True]['text':'
         * 1968 is the closest leap year before 1970.
         * Exclude the current year, so add 1.
         ','line_number':132,'multiline':True]['text':' Add one day for each 4 years ','line_number':137,'multiline':True]['text':' 1900 is the closest previous year divisible by 100 ','line_number':139,'multiline':True]['text':' Subtract one day for each 100 years ','line_number':141,'multiline':True]['text':' 1600 is the closest previous year divisible by 400 ','line_number':143,'multiline':True]['text':' Add one day for each 400 years ','line_number':145,'multiline':True]['text':'
         * 1972 is the closest later year after 1970.
         * Include the current year, so subtract 2.
         ','line_number':149,'multiline':True]['text':' Subtract one day for each 4 years ','line_number':154,'multiline':True]['text':' 2000 is the closest later year divisible by 100 ','line_number':156,'multiline':True]['text':' Add one day for each 100 years ','line_number':158,'multiline':True]['text':' 2000 is also the closest later year divisible by 400 ','line_number':160,'multiline':True]['text':' Subtract one day for each 400 years ','line_number':161,'multiline':True]['text':' Add the months ','line_number':168,'multiline':True]['text':' Add the days ','line_number':173,'multiline':True]['text':'
 * Calculates the minutes offset from the 1970 epoch.
 ','line_number':179,'multiline':True]['text':'
 * Modifies '*days_' to be the day offset within the year,
 * and returns the year.
 ','line_number':192,'multiline':True]['text':' Adjust so it's relative to the year 2000 (divisible by 400) ','line_number':200,'multiline':True]['text':' Break down the 400 year cycle to get the year and day within the year ','line_number':204,'multiline':True]['text':' Work out the year/day within the 400 year cycle ','line_number':207,'multiline':True]['text':' Extracts the month number from a 'datetime64[D]' value ','line_number':225,'multiline':True]['text':' Should never get here ','line_number':244,'multiline':True]['text':'
 * Fills in the year, month, day in 'dts' based on the days
 * offset from 1970.
 ','line_number':248,'multiline':True]['text':'NUMPY_API
 *
 * Converts a datetime from a datetimestruct to a datetime based
 * on some metadata. The date is assumed to be valid.
 *
 * TODO: If meta->num is really big, there could be overflow
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':272,'multiline':True]['text':' If the datetimestruct is NaT, return NaT ','line_number':289,'multiline':True]['text':' Cannot instantiate a datetime with generic units ','line_number':295,'multiline':True]['text':' Truncate to the year ','line_number':304,'multiline':True]['text':' Truncate to the month ','line_number':308,'multiline':True]['text':' Otherwise calculate the number of days to start ','line_number':312,'multiline':True]['text':' Truncate to weeks ','line_number':317,'multiline':True]['text':' only 2.6 hours ','line_number':374,'multiline':True]['text':' only 9.2 secs ','line_number':384,'multiline':True]['text':' Something got corrupted ','line_number':394,'multiline':True]['text':' Divide by the multiplier ','line_number':401,'multiline':True]['text':'NUMPY_API
 * Create a datetime value from a filled datetime struct and resolution unit.
 *
 * TO BE REMOVED - NOT USED INTERNALLY.
 ','line_number':416,'multiline':True]['text':'NUMPY_API
 * Create a timedelta value from a filled timedelta struct and resolution unit.
 *
 * TO BE REMOVED - NOT USED INTERNALLY.
 ','line_number':431,'multiline':True]['text':'NUMPY_API
 *
 * Converts a datetime based on the given metadata into a datetimestruct
 ','line_number':446,'multiline':True]['text':' Initialize the output to all zeros ','line_number':457,'multiline':True]['text':' NaT is signaled in the year ','line_number':463,'multiline':True]['text':' Datetimes can't be in generic units ','line_number':469,'multiline':True]['text':' TODO: Change to a mechanism that avoids the potential overflow ','line_number':477,'multiline':True]['text':'
     * Note that care must be taken with the / and % operators
     * for negative values.
     ','line_number':480,'multiline':True]['text':' A week is 7 days ','line_number':495,'multiline':True]['text':' entire range is only +- 2.6 hours ','line_number':563,'multiline':True]['text':' entire range is only +- 9.2 seconds ','line_number':580,'multiline':True]['text':'NUMPY_API
 * Fill the datetime struct from the value and resolution unit.
 *
 * TO BE REMOVED - NOT USED INTERNALLY.
 ','line_number':607,'multiline':True]['text':'
 * FIXME: Overflow is not handled at all
 *   To convert from Years or Months,
 *   multiplication by the average is done
 ','line_number':623,'multiline':True]['text':'NUMPY_API
 * Fill the timedelta struct from the timedelta value and resolution unit.
 *
 * TO BE REMOVED - NOT USED INTERNALLY.
 ','line_number':629,'multiline':True]['text':'
 * Creates a datetime or timedelta dtype using a copy of the provided metadata.
 ','line_number':645,'multiline':True]['text':' Create a default datetime or timedelta ','line_number':654,'multiline':True]['text':' Copy the metadata ','line_number':671,'multiline':True]['text':'
 * Creates a datetime or timedelta dtype using the given unit.
 ','line_number':677,'multiline':True]['text':'
 * This function returns a pointer to the DateTimeMetaData
 * contained within the provided datetime dtype.
 ','line_number':689,'multiline':True]['text':' strtol does not know whether to put a const qualifier on endptr, wrap
 * it so we can put this cast in one place.
 ','line_number':705,'multiline':True]['text':'
 * Converts a substring given by 'str' and 'len' into
 * a date time unit multiplier + enum value, which are populated
 * into out_meta. Other metadata is left along.
 *
 * 'metastr' is only used in the error message, and may be NULL.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':713,'multiline':True]['text':' First comes an optional integer multiplier ','line_number':731,'multiline':True]['text':' check for 32-bit integer overflow','line_number':737,'multiline':False]['text':' Next comes the unit itself, followed by either '/' or the string end ','line_number':746,'multiline':True]['text':' Next comes an optional integer denominator ','line_number':762,'multiline':True]['text':' If the '/' exists, there must be a number followed by ']' ','line_number':766,'multiline':True]['text':'
 * Parses the metadata string into the metadata C structure.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':800,'multiline':True]['text':' Treat the empty string as generic units ','line_number':811,'multiline':True]['text':' The metadata string must start with a '[' ','line_number':819,'multiline':True]['text':' Parse the extended unit inside the [] ','line_number':833,'multiline':True]['text':'
 * Converts a datetype dtype string into a dtype descr object.
 * The "type" string should be NULL-terminated.
 ','line_number':862,'multiline':True]['text':'
     * First validate that the root is correct,
     * and get the metadata string address
     ','line_number':881,'multiline':True]['text':' Parse the metadata string into a metadata struct ','line_number':912,'multiline':True]['text':' NPY_FR_Y ','line_number':922,'multiline':True]['text':' NPY_FR_M ','line_number':924,'multiline':True]['text':' NPY_FR_W ','line_number':926,'multiline':True]['text':' Gap for removed NPY_FR_B ','line_number':928,'multiline':True]['text':' NPY_FR_D ','line_number':930,'multiline':True]['text':' NPY_FR_h ','line_number':932,'multiline':True]['text':' NPY_FR_m ','line_number':934,'multiline':True]['text':' >=NPY_FR_s ','line_number':936,'multiline':True]['text':'
 * Translate divisors into multiples of smaller units.
 * 'metastr' is used for the error message if the divisor doesn't work,
 * and can be NULL if the metadata didn't come from a string.
 *
 * This function only affects the 'base' and 'num' values in the metadata.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':942,'multiline':True]['text':' _multiplies_table only has entries up to NPY_FR_s ','line_number':974,'multiline':True]['text':'
 * Lookup table for factors between datetime units, except
 * for years and months.
 ','line_number':1019,'multiline':True]['text':' Years - not used ','line_number':1025,'multiline':True]['text':' Months - not used ','line_number':1026,'multiline':True]['text':' Weeks -> Days ','line_number':1027,'multiline':True]['text':' Business Days - was removed but a gap still exists in the enum ','line_number':1028,'multiline':True]['text':' Days -> Hours ','line_number':1029,'multiline':True]['text':' Hours -> Minutes ','line_number':1030,'multiline':True]['text':' Minutes -> Seconds ','line_number':1031,'multiline':True]['text':' Attoseconds are the smallest base unit ','line_number':1038,'multiline':True]['text':' Generic units don't have a conversion ','line_number':1039,'multiline':True]['text':'
 * Returns the scale factor between the units. Does not validate
 * that bigbase represents larger units than littlebase, or that
 * the units are not generic.
 *
 * Returns 0 if there is an overflow.
 ','line_number':1042,'multiline':True]['text':'
         * Detect overflow by disallowing the top 16 bits to be 1.
         * That allows a margin of error much bigger than any of
         * the datetime factors.
         ','line_number':1057,'multiline':True]['text':' Euclidean algorithm on two positive numbers ','line_number':1070,'multiline':True]['text':'
 * Computes the conversion factor to convert data with 'src_meta' metadata
 * into data with 'dst_meta' metadata.
 *
 * If overflow occurs, both out_num and out_denom are set to 0, but
 * no error is set.
 ','line_number':1090,'multiline':True]['text':' Generic units change to the destination with no conversion factor ','line_number':1105,'multiline':True]['text':'
     * Converting to a generic unit from something other than a generic
     * unit is an error.
     ','line_number':1111,'multiline':True]['text':'
         * Conversions between years/months and other units use
         * the factor averaged over the 400 year leap year cycle.
         ','line_number':1136,'multiline':True]['text':' Year -> Day ','line_number':1149,'multiline':True]['text':' Day -> dst_base ','line_number':1152,'multiline':True]['text':' Month -> Day ','line_number':1162,'multiline':True]['text':' Day -> dst_base ','line_number':1165,'multiline':True]['text':' If something overflowed, make both num and denom 0 ','line_number':1174,'multiline':True]['text':' Swap the numerator and denominator if necessary ','line_number':1186,'multiline':True]['text':' Return as a fraction in reduced form ','line_number':1196,'multiline':True]['text':'
 * Determines whether the 'divisor' metadata divides evenly into
 * the 'dividend' metadata.
 ','line_number':1202,'multiline':True]['text':'
     * Any unit can always divide into generic units. In other words, we
     * should be able to convert generic units into any more specific unit.
     ','line_number':1214,'multiline':True]['text':'
     * However, generic units cannot always divide into more specific units.
     * We cannot safely convert datetimes with units back into generic units.
     ','line_number':1221,'multiline':True]['text':' If the bases are different, factor in a conversion ','line_number':1232,'multiline':True]['text':'
         * Years and Months are incompatible with
         * all other units (except years and months are compatible
         * with each other).
         ','line_number':1234,'multiline':True]['text':' Could do something complicated here ','line_number':1247,'multiline':True]['text':' Could do something complicated here ','line_number':1259,'multiline':True]['text':' Could do something complicated here ','line_number':1268,'multiline':True]['text':' Take the greater base (unit sizes are decreasing in enum) ','line_number':1273,'multiline':True]['text':' Crude, incomplete check for overflow ','line_number':1288,'multiline':True]['text':'
 * This provides the casting rules for the DATETIME data type units.
 ','line_number':1296,'multiline':True]['text':' Allow anything with unsafe casting ','line_number':1305,'multiline':True]['text':'
         * Can cast between all units with 'same_kind' casting.
         ','line_number':1309,'multiline':True]['text':'
         * Casting is only allowed towards more precise units with 'safe'
         * casting.
         ','line_number':1320,'multiline':True]['text':' Enforce equality with 'no' or 'equiv' casting ','line_number':1332,'multiline':True]['text':'
 * This provides the casting rules for the TIMEDELTA data type units.
 *
 * Notably, there is a barrier between the nonlinear years and
 * months units, and all the other units.
 ','line_number':1338,'multiline':True]['text':' Allow anything with unsafe casting ','line_number':1350,'multiline':True]['text':'
         * Only enforce the 'date units' vs 'time units' barrier with
         * 'same_kind' casting.
         ','line_number':1354,'multiline':True]['text':'
         * Enforce the 'date units' vs 'time units' barrier and that
         * casting is only allowed towards more precise units with
         * 'safe' casting.
         ','line_number':1367,'multiline':True]['text':' Enforce equality with 'no' or 'equiv' casting ','line_number':1382,'multiline':True]['text':'
 * This provides the casting rules for the DATETIME data type metadata.
 ','line_number':1388,'multiline':True]['text':'
 * This provides the casting rules for the TIMEDELTA data type metadata.
 ','line_number':1415,'multiline':True]['text':'
 * Tests whether a datetime64 can be cast from the source metadata
 * to the destination metadata according to the specified casting rule.
 *
 * Returns -1 if an exception was raised, 0 otherwise.
 ','line_number':1442,'multiline':True]['text':'
 * Tests whether a timedelta64 can be cast from the source metadata
 * to the destination metadata according to the specified casting rule.
 *
 * Returns -1 if an exception was raised, 0 otherwise.
 ','line_number':1476,'multiline':True]['text':'
 * Computes the GCD of the two date-time metadata values. Raises
 * an exception if there is no reasonable GCD, such as with
 * years and days.
 *
 * The result is placed in 'out_meta'.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':1510,'multiline':True]['text':' If either unit is generic, adopt the metadata from the other one ','line_number':1530,'multiline':True]['text':' First validate that the units have a reasonable GCD ','line_number':1543,'multiline':True]['text':'
         * Years and Months are incompatible with
         * all other units (except years and months are compatible
         * with each other).
         ','line_number':1548,'multiline':True]['text':' Don't multiply num1 since there is no even factor ','line_number':1563,'multiline':True]['text':' Don't multiply num2 since there is no even factor ','line_number':1576,'multiline':True]['text':' Don't multiply num1 since there is no even factor ','line_number':1585,'multiline':True]['text':' Don't multiply num2 since there is no even factor ','line_number':1594,'multiline':True]['text':' Take the greater base (unit sizes are decreasing in enum) ','line_number':1598,'multiline':True]['text':' Compute the GCD of the resulting multipliers ','line_number':1615,'multiline':True]['text':' Fill the 'out_meta' values ','line_number':1618,'multiline':True]['text':'
     * We do not use `DTypePromotionError` below.  The reason this is that a
     * `DTypePromotionError` indicates that `arr_dt1 != arr_dt2` for
     * all values, but this is wrong for "0".  This could be changed but
     * for now we consider them errors that occur _while_ promoting.
     ','line_number':1627,'multiline':True]['text':'
 * Both type1 and type2 must be either NPY_DATETIME or NPY_TIMEDELTA.
 * Applies the type promotion rules between the two types, returning
 * the promoted type.
 ','line_number':1670,'multiline':True]['text':' Create a DATETIME or TIMEDELTA dtype ','line_number':1687,'multiline':True]['text':'
     * Get the metadata GCD, being strict about nonlinear units for
     * timedelta and relaxed for datetime.
     ','line_number':1694,'multiline':True]['text':'
 * Converts a substring given by 'str' and 'len' into
 * a date time unit enum value. The 'metastr' parameter
 * is used for error messages, and may be NULL.
 *
 * Returns NPY_DATETIMEUNIT on success, NPY_FR_ERROR on failure.
 ','line_number':1711,'multiline':True]['text':' Use switch statements so the compiler can make it fast ','line_number':1721,'multiline':True]['text':' All the two-letter units are variants of seconds ','line_number':1740,'multiline':True]['text':' greek small letter mu, utf8-encoded ','line_number':1758,'multiline':True]['text':' If nothing matched, it's an error ','line_number':1765,'multiline':True]['text':'
 * Converts a metadata tuple into a datetime metadata C struct.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':1798,'multiline':True]['text':' Allow bytes format strings: convert to unicode ','line_number':1827,'multiline':True]['text':' Convert the values to longs ','line_number':1853,'multiline':True]['text':'
     * The event metadata was removed way back in numpy 1.7 (cb4545), but was
     * not deprecated at the time.
     ','line_number':1859,'multiline':True]['text':' (unit, num, event) ','line_number':1864,'multiline':True]['text':' Numpy 1.14, 2017-08-11 ','line_number':1866,'multiline':True]['text':' (unit, num, den, event) ','line_number':1873,'multiline':True]['text':' if (event == 1) ','line_number':1877,'multiline':True]['text':' if the event data is not 1, it had semantics different to how
             * datetime types now behave, which are no longer respected.
             ','line_number':1888,'multiline':True]['text':' Numpy 1.14, 2017-08-11 ','line_number':1901,'multiline':True]['text':'
 * Converts an input object into datetime metadata. The input
 * may be either a string or a tuple.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':1931,'multiline':True]['text':' Get a UTF8 string ','line_number':1946,'multiline':True]['text':' Allow bytes format strings: convert to unicode ','line_number':1949,'multiline':True]['text':'
 * Return the datetime metadata as a Unicode object.
 *
 * Returns new reference, NULL on error.
 *
 * If 'skip_brackets' is true, skips the '[]'.
 *
 ','line_number':1989,'multiline':True]['text':' Without brackets, give a string "generic" ','line_number':2004,'multiline':True]['text':' But with brackets, return nothing ','line_number':2008,'multiline':True]['text':'
 * Adjusts a datetimestruct based on a seconds offset. Assumes
 * the current values are valid.
 ','line_number':2043,'multiline':True]['text':'
 * Adjusts a datetimestruct based on a minutes offset. Assumes
 * the current values are valid.
 ','line_number':2057,'multiline':True]['text':' propagate invalid minutes into hour and day changes ','line_number':2068,'multiline':True]['text':' propagate invalid days into month and year changes ','line_number':2072,'multiline':True]['text':'NUMPY_API
 *
 * Tests for and converts a Python datetime.datetime or datetime.date
 * object into a NumPy npy_datetimestruct.
 *
 * While the C API has PyDate_* and PyDateTime_* functions, the following
 * implementation just asks for attributes, and thus supports
 * datetime duck typing. The tzinfo time zone conversion would require
 * this style of access anyway.
 *
 * 'out_bestunit' gives a suggested unit based on whether the object
 *      was a datetime.date or datetime.datetime object.
 *
 * If 'apply_tzinfo' is 1, this function uses the tzinfo to convert
 * to UTC time, otherwise it returns the struct with the local time.
 *
 * Returns -1 on error, 0 on success, and 1 (with no error set)
 * if obj doesn't have the needed date or datetime attributes.
 ','line_number':2095,'multiline':True]['text':' Initialize the output to all zeros ','line_number':2122,'multiline':True]['text':' Need at least year/month/day attributes ','line_number':2127,'multiline':True]['text':' Get the year ','line_number':2134,'multiline':True]['text':' Get the month ','line_number':2146,'multiline':True]['text':' Get the day ','line_number':2158,'multiline':True]['text':' Validate that the month and day are valid for the year ','line_number':2170,'multiline':True]['text':' Check for time attributes (if not there, return success as a date) ','line_number':2180,'multiline':True]['text':' The best unit for date is 'D' ','line_number':2185,'multiline':True]['text':' Get the hour ','line_number':2192,'multiline':True]['text':' Get the minute ','line_number':2204,'multiline':True]['text':' Get the second ','line_number':2216,'multiline':True]['text':' Get the microsecond ','line_number':2228,'multiline':True]['text':' Apply the time zone offset if it exists ','line_number':2247,'multiline':True]['text':' 2016-01-14, 1.11 ','line_number':2260,'multiline':True]['text':' The utcoffset function should return a timedelta ','line_number':2269,'multiline':True]['text':'
             * The timedelta should have a function "total_seconds"
             * which contains the value we want.
             ','line_number':2277,'multiline':True]['text':' Rounding here is no worse than the integer division below.
             * Only whole minute offsets are supported by numpy anyway.
             ','line_number':2286,'multiline':True]['text':' Convert to a minutes offset and apply it ','line_number':2296,'multiline':True]['text':' The resolution of Python's datetime is 'us' ','line_number':2303,'multiline':True]['text':'
 * Gets a tzoffset in minutes by calling the fromutc() function on
 * the Python datetime.tzinfo object.
 ','line_number':2324,'multiline':True]['text':' Create a Python datetime to give to the timezone object ','line_number':2334,'multiline':True]['text':' Convert the datetime from UTC to local time ','line_number':2341,'multiline':True]['text':' Convert the local datetime into a datetimestruct ','line_number':2348,'multiline':True]['text':' Calculate the tzoffset as the difference between the datetimes ','line_number':2356,'multiline':True]['text':'
 * Converts a PyObject * into a datetime, in any of the forms supported.
 *
 * If the units metadata isn't known ahead of time, set meta->base
 * to -1, and this function will populate meta with either default
 * values or values from the input object.
 *
 * The 'casting' parameter is used to control what kinds of inputs
 * are accepted, and what happens. For example, with 'unsafe' casting,
 * unrecognized inputs are converted to 'NaT' instead of throwing an error,
 * while with 'safe' casting an error will be thrown if any precision
 * from the input will be thrown away.
 *
 * Returns -1 on error, 0 on success.
 ','line_number':2361,'multiline':True]['text':' Convert to an UTF8 string for the date parser ','line_number':2383,'multiline':True]['text':' Parse the ISO date ','line_number':2402,'multiline':True]['text':' Use the detected unit if none was specified ','line_number':2412,'multiline':True]['text':' Do no conversion on raw integers ','line_number':2426,'multiline':True]['text':' Don't allow conversion from an integer without specifying a unit ','line_number':2428,'multiline':True]['text':' Datetime scalar ','line_number':2440,'multiline':True]['text':' Copy the scalar directly if units weren't specified ','line_number':2444,'multiline':True]['text':' Otherwise do a casting transformation ','line_number':2451,'multiline':True]['text':' Allow NaT (not-a-time) values to slip through any rule ','line_number':2453,'multiline':True]['text':' Datetime zero-dimensional array ','line_number':2466,'multiline':True]['text':' Copy the value directly if units weren't specified ','line_number':2483,'multiline':True]['text':' Otherwise do a casting transformation ','line_number':2490,'multiline':True]['text':' Allow NaT (not-a-time) values to slip through any rule ','line_number':2492,'multiline':True]['text':' Convert from a Python date or datetime object ','line_number':2504,'multiline':True]['text':' Use the detected unit if none was specified ','line_number':2515,'multiline':True]['text':'
     * With unsafe casting, convert unrecognized objects into NaT
     * and with same_kind casting, convert None into NaT
     ','line_number':2537,'multiline':True]['text':'
 * Converts a PyObject * into a timedelta, in any of the forms supported
 *
 * If the units metadata isn't known ahead of time, set meta->base
 * to -1, and this function will populate meta with either default
 * values or values from the input object.
 *
 * The 'casting' parameter is used to control what kinds of inputs
 * are accepted, and what happens. For example, with 'unsafe' casting,
 * unrecognized inputs are converted to 'NaT' instead of throwing an error,
 * while with 'safe' casting an error will be thrown if any precision
 * from the input will be thrown away.
 *
 * Returns -1 on error, 0 on success.
 ','line_number':2557,'multiline':True]['text':' Convert to an UTF8 string for the date parser ','line_number':2580,'multiline':True]['text':' Check for a NaT string ','line_number':2599,'multiline':True]['text':' Parse as an integer ','line_number':2607,'multiline':True]['text':' Use generic units if none was specified ','line_number':2619,'multiline':True]['text':' Do no conversion on raw integers ','line_number':2628,'multiline':True]['text':' Use the default unit if none was specified ','line_number':2630,'multiline':True]['text':' Timedelta scalar ','line_number':2642,'multiline':True]['text':' Copy the scalar directly if units weren't specified ','line_number':2646,'multiline':True]['text':' Otherwise do a casting transformation ','line_number':2653,'multiline':True]['text':' Allow NaT (not-a-time) values to slip through any rule ','line_number':2655,'multiline':True]['text':' Timedelta zero-dimensional array ','line_number':2668,'multiline':True]['text':' Copy the value directly if units weren't specified ','line_number':2685,'multiline':True]['text':' Otherwise do a casting transformation ','line_number':2692,'multiline':True]['text':' Allow NaT (not-a-time) values to slip through any rule ','line_number':2694,'multiline':True]['text':' Convert from a Python timedelta object ','line_number':2706,'multiline':True]['text':' Get the days ','line_number':2716,'multiline':True]['text':' Get the seconds ','line_number':2728,'multiline':True]['text':' Get the microseconds ','line_number':2740,'multiline':True]['text':' Use microseconds if none was specified ','line_number':2754,'multiline':True]['text':'
             * Detect the largest unit where every value after is zero,
             * to allow safe casting to seconds if microseconds is zero,
             * for instance.
             ','line_number':2764,'multiline':True]['text':' Switch back to microseconds for the casting operation ','line_number':2798,'multiline':True]['text':'
     * With unsafe casting, convert unrecognized objects into NaT
     * and with same_kind casting, convert None into NaT
     ','line_number':2806,'multiline':True]['text':' Use the default unit if none was specified ','line_number':2820,'multiline':True]['text':'
 * Converts a datetime into a PyObject *.
 *
 * Not-a-time is returned as the string "NaT".
 * For days or coarser, returns a datetime.date.
 * For microseconds or coarser, returns a datetime.datetime.
 * For units finer than microseconds, returns an integer.
 ','line_number':2839,'multiline':True]['text':'
     * Convert NaT (not-a-time) and any value with generic units
     * into None.
     ','line_number':2853,'multiline':True]['text':' If the type's precision is greater than microseconds, return an int ','line_number':2861,'multiline':True]['text':' Convert to a datetimestruct ','line_number':2866,'multiline':True]['text':'
     * If the year is outside the range of years supported by Python's
     * datetime, or the datetime64 falls on a leap second,
     * return a raw int.
     ','line_number':2871,'multiline':True]['text':' If the type's precision is greater than days, return a datetime ','line_number':2880,'multiline':True]['text':' Otherwise return a date ','line_number':2885,'multiline':True]['text':'
 * Converts a timedelta into a PyObject *.
 *
 * Not-a-time is returned as the string "NaT".
 * For microseconds or coarser, returns a datetime.timedelta.
 * For units finer than microseconds, returns an integer.
 ','line_number':2893,'multiline':True]['text':'
     * Convert NaT (not-a-time) into None.
     ','line_number':2906,'multiline':True]['text':'
     * If the type's precision is greater than microseconds, is
     * Y/M/B (nonlinear units), or is generic units, return an int
     ','line_number':2913,'multiline':True]['text':' Apply the unit multiplier (TODO: overflow treatment...) ','line_number':2926,'multiline':True]['text':' Convert to days/seconds/useconds ','line_number':2929,'multiline':True]['text':' unreachable, handled by the `if` above','line_number':2960,'multiline':False]['text':'
     * If it would overflow the datetime.timedelta days, return a raw int
     ','line_number':2964,'multiline':True]['text':'
 * Returns true if the datetime metadata matches
 ','line_number':2975,'multiline':True]['text':' For generic units, the num is ignored ','line_number':3001,'multiline':True]['text':'
 * Casts a single datetime from having src_meta metadata into
 * dst_meta metadata.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3010,'multiline':True]['text':' If the metadata is the same, short-circuit the conversion ','line_number':3024,'multiline':True]['text':' Otherwise convert through a datetimestruct ','line_number':3031,'multiline':True]['text':'
 * Casts a single timedelta from having src_meta metadata into
 * dst_meta metadata.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3044,'multiline':True]['text':' If the metadata is the same, short-circuit the conversion ','line_number':3058,'multiline':True]['text':' Get the conversion factor ','line_number':3065,'multiline':True]['text':' Apply the scaling ','line_number':3072,'multiline':True]['text':'
 * Returns true if the object is something that is best considered
 * a Datetime, false otherwise.
 ','line_number':3083,'multiline':True]['text':'
 * Returns true if the object is something that is best considered
 * a Timedelta, false otherwise.
 ','line_number':3098,'multiline':True]['text':'
 * Returns true if the object is something that is best considered
 * a Datetime or Timedelta, false otherwise.
 ','line_number':3111,'multiline':True]['text':'
 * Converts an array of PyObject * into datetimes and/or timedeltas,
 * based on the values in type_nums.
 *
 * If inout_meta->base is -1, uses GCDs to calculate the metadata, filling
 * in 'inout_meta' with the resulting metadata. Otherwise uses the provided
 * 'inout_meta' for all the conversions.
 *
 * When obj[i] is NULL, out_value[i] will be set to NPY_DATETIME_NAT.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3123,'multiline':True]['text':' No values trivially succeeds ','line_number':3145,'multiline':True]['text':' Use the inputs to resolve the unit metadata if requested ','line_number':3150,'multiline':True]['text':' Allocate an array of metadata corresponding to the objects ','line_number':3152,'multiline':True]['text':' Convert all the objects into timedeltas or datetimes ','line_number':3159,'multiline':True]['text':' NULL -> NaT ','line_number':3164,'multiline':True]['text':' Merge all the metadatas, starting with the first one ','line_number':3192,'multiline':True]['text':' Convert all the values into the resolved unit metadata ','line_number':3207,'multiline':True]['text':' Otherwise convert to the provided unit metadata ','line_number':3227,'multiline':True]['text':' Convert all the objects into timedeltas or datetimes ','line_number':3229,'multiline':True]['text':' NULL -> NaT ','line_number':3231,'multiline':True]['text':'
     * First normalize the input parameters so there is no Py_None,
     * and start is moved to stop if stop is unspecified.
     ','line_number':3264,'multiline':True]['text':' If start was NULL or None, raise an exception ','line_number':3274,'multiline':True]['text':' Step must not be a Datetime ','line_number':3285,'multiline':True]['text':' Check if the units of the given dtype are generic, in which
     * case we use the code path that detects the units
     ','line_number':3292,'multiline':True]['text':'
         * If the dtype specified is in generic units, detect the
         * units from the input parameters.
         ','line_number':3312,'multiline':True]['text':' Otherwise use the provided metadata ','line_number':3320,'multiline':True]['text':' Set up to convert the objects to a common datetime unit metadata ','line_number':3344,'multiline':True]['text':' Convert all the arguments
     *
     * Both datetime and timedelta are stored as int64, so they can
     * share value variables.
     ','line_number':3365,'multiline':True]['text':' If no start was provided, default to 0 ','line_number':3375,'multiline':True]['text':' enforced above ','line_number':3377,'multiline':True]['text':' If no step was provided, default to 1 ','line_number':3382,'multiline':True]['text':'
     * In the case of arange(datetime, timedelta), convert
     * the timedelta into a datetime by adding the start datetime.
     ','line_number':3387,'multiline':True]['text':' Now start, stop, and step have their values and matching metadata ','line_number':3395,'multiline':True]['text':' Calculate the array length ','line_number':3404,'multiline':True]['text':' Create the dtype of the result ','line_number':3421,'multiline':True]['text':' Create the result array ','line_number':3432,'multiline':True]['text':' Extract the data pointer ','line_number':3442,'multiline':True]['text':' Create the timedeltas or datetimes ','line_number':3445,'multiline':True]['text':'
 * Examines all the strings in the given string array, and parses them
 * to find the right metadata.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3456,'multiline':True]['text':' Handle zero-sized arrays specially ','line_number':3477,'multiline':True]['text':' Use unsafe casting to allow unicode -> ascii string ','line_number':3487,'multiline':True]['text':' Get the resulting string length ','line_number':3508,'multiline':True]['text':' Allocate a buffer for strings which fill the buffer completely ','line_number':3511,'multiline':True]['text':' The iteration loop ','line_number':3519,'multiline':True]['text':' Get the inner loop data/stride/count values ','line_number':3521,'multiline':True]['text':' The inner loop ','line_number':3527,'multiline':True]['text':' Replicating strnlen with memchr, because Mac OS X lacks it ','line_number':3529,'multiline':True]['text':' If the string is all full, use the buffer ','line_number':3532,'multiline':True]['text':' Otherwise parse the data in place ','line_number':3545,'multiline':True]['text':' Combine it with 'meta' ','line_number':3557,'multiline':True]['text':'
 * Recursively determines the metadata for an NPY_DATETIME dtype.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3581,'multiline':True]['text':' Combine it with 'meta' ','line_number':3592,'multiline':True]['text':' String -> parse it to find out ','line_number':3600,'multiline':True]['text':' If it's a value error, clear the error ','line_number':3610,'multiline':True]['text':' Otherwise propagate the error ','line_number':3617,'multiline':True]['text':' Combine it with 'meta' ','line_number':3623,'multiline':True]['text':' Python datetime object -> 'us' ','line_number':3631,'multiline':True]['text':' Combine it with 'meta' ','line_number':3638,'multiline':True]['text':' Python date object -> 'D' ','line_number':3646,'multiline':True]['text':' Combine it with 'meta' ','line_number':3653,'multiline':True]['text':' Otherwise ignore it ','line_number':3661,'multiline':True]['text':'
 * handler function for PyDelta values
 * which may also be in a 0 dimensional
 * NumPy array
 ','line_number':3667,'multiline':True]['text':' Combine it with 'meta' ','line_number':3680,'multiline':True]['text':'
 * Recursively determines the metadata for an NPY_TIMEDELTA dtype.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':3688,'multiline':True]['text':' Datetime scalar -> use its metadata ','line_number':3696,'multiline':True]['text':' Combine it with 'meta' ','line_number':3700,'multiline':True]['text':' String -> parse it to find out ','line_number':3708,'multiline':True]['text':' No timedelta parser yet ','line_number':3710,'multiline':True]['text':' Python timedelta object -> 'us' ','line_number':3713,'multiline':True]['text':' Otherwise ignore it ','line_number':3717,'multiline':True]['text':'
 * Examines all the objects in the given Python object by
 * recursively descending the sequence structure. Returns a
 * datetime or timedelta type with metadata based on the data.
 ','line_number':3723,'multiline':True]['text':'
 * Describes casting within datetimes or timedelta
 ','line_number':3761,'multiline':True]['text':' This is a within-dtype cast, which currently must handle byteswapping ','line_number':3772,'multiline':True]['text':' handle some common metric prefix conversions','line_number':3801,'multiline':False]['text':' 1000 fold conversions','line_number':3802,'multiline':False]['text':' 10^6 fold conversions','line_number':3805,'multiline':False]['text':' 10^9 fold conversions','line_number':3808,'multiline':False]['text':' TODO: This is actually an invalid cast (casting will error) ','line_number':3824,'multiline':True]['text':' jump between time units and date units is unsafe for timedelta ','line_number':3828,'multiline':True]['text':' Casting to a more precise unit is currently considered safe ','line_number':3834,'multiline':True]['text':' If it divides, we consider it to be a safe cast ','line_number':3836,'multiline':True]['text':'
         * If the metadata matches, use the low-level copy or copy-swap
         * functions. (If they do not match, but swapping is necessary this
         * path is hit recursively.)
         ','line_number':3863,'multiline':True]['text':' Handles datetime<->timedelta type resolution (both directions) ','line_number':3913,'multiline':True]['text':'
     * Mostly NPY_UNSAFE_CASTING is not true, the cast will fail.
     * TODO: Once ufuncs use dtype specific promotion rules,
     *       this is likely unnecessary
     ','line_number':3938,'multiline':True]['text':' In the current setup both strings and unicode casts support all outputs ','line_number':3947,'multiline':True]['text':'
         * At the time of writing, NumPy does not check the length here,
         * but will error if filling fails.
         ','line_number':3957,'multiline':True]['text':' Find the correct string length, possibly based on the unit ','line_number':3965,'multiline':True]['text':'
             * This is arguably missing space for the unit, e.g. for:
             * `np.timedelta64(1231234342124, 'ms')`
             ','line_number':3973,'multiline':True]['text':' NOTE: This doesn't actually work, and will error during the cast ','line_number':4037,'multiline':True]['text':' We currently support byte-swapping, so any (unicode) string is OK ','line_number':4050,'multiline':True]['text':'
 * This registers the castingimpl for all datetime related casts.
 ','line_number':4088,'multiline':True]['text':'
     * Casting between timedelta and datetime uses legacy casting loops, but
     * custom dtype resolution (to handle copying of the time unit).
     ','line_number':4131,'multiline':True]['text':'
     * Cast from numeric types to times.  These use the cast functions
     * as stored on the datatype, which should be replaced at some point.
     * Some of these casts can fail (casting to unitless datetime), but these
     * are rather special.
     ','line_number':4157,'multiline':True]['text':' timedelta casts like int64 right now... ','line_number':4181,'multiline':True]['text':'
     * Cast times to string and unicode
     ','line_number':4199,'multiline':True]['text':'
     * Casts can error and need API (unicodes needs it for string->unicode).
     * Unicode handling is currently implemented via a legacy cast.
     * Datetime->string has its own fast cast while timedelta->string uses
     * the legacy fallback.
     ','line_number':4203,'multiline':True]['text':' Strided loop differs for the two ','line_number':4211,'multiline':True]['text':'
     * Cast strings to timedelta are currently only legacy casts
     ','line_number':4240,'multiline':True]['text':'
     * Cast strings to datetime
     ','line_number':4252,'multiline':True]['text':' The default type resolution should work fine. ','line_number':4258,'multiline':True]['text':'
     * Unicode handling is currently implemented via a legacy cast, which
     * requires the Python API.
     ','line_number':4273,'multiline':True]