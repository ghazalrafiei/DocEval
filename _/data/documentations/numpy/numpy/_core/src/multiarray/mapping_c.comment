['text':' TODO: Only for `NpyIter_GetTransferFlags` until it is public ','line_number':29,'multiline':True]['text':' HAS_FANCY can be mixed with HAS_0D_BOOL, be careful when to use & or == ','line_number':40,'multiline':True]['text':' NOTE: Only set if it is neither fancy nor purely integer index! ','line_number':43,'multiline':True]['text':'
 * Indicate that this is a fancy index that comes from a 0d boolean.
 * This means that the index does not operate along a real axis. The
 * corresponding index type is just HAS_FANCY.
 ','line_number':45,'multiline':True]['text':'*****************************************************************************
 ***                    IMPLEMENT MAPPING PROTOCOL                          ***
 ****************************************************************************','line_number':56,'multiline':True]['text':' -------------------------------------------------------------- ','line_number':72,'multiline':True]['text':'
 * Helper for `PyArray_MapIterSwapAxes` (and related), see its documentation.
 ','line_number':75,'multiline':True]['text':'
     * For getting the array the tuple for transpose is
     * (n1,...,n1+n2-1,0,...,n1-1,n1+n2,...,n3-1)
     * n1 is the number of dimensions of the broadcast index array
     * n2 is the number of dimensions skipped at the start
     * n3 is the number of dimensions of the result
     ','line_number':81,'multiline':True]['text':'
     * For setting the array the tuple for transpose is
     * (n2,...,n1+n2-1,0,...,n2-1,n1+n2,...n3-1)
     ','line_number':89,'multiline':True]['text':' axes to insert at ','line_number':94,'multiline':True]['text':' use n1 as the boundary if getting but n2 if setting ','line_number':97,'multiline':True]['text':'
 * Swap the axes to or from their inserted form. MapIter always puts the
 * advanced (array) indices first in the iteration. But if they are
 * consecutive, will insert/transpose them back before returning.
 * This is stored as `mit->consec != 0` (the place where they are inserted)
 * For assignments, the opposite happens: The values to be assigned are
 * transposed (getmap=1 instead of getmap=0). `getmap=0` and `getmap=1`
 * undo the other operation.
 ','line_number':115,'multiline':True]['text':'
     * arr might not have the right number of dimensions
     * and need to be reshaped first by prepending ones
     ','line_number':135,'multiline':True]['text':'*
 * Unpack a tuple into an array of new references. Returns the number of objects
 * unpacked.
 *
 * Useful if a tuple is being iterated over multiple times, or for a code path
 * that doesn't always want the overhead of allocating a tuple.
 ','line_number':171,'multiline':True]['text':' Unpack a single scalar index, taking a new reference to match unpack_tuple ','line_number':195,'multiline':True]['text':'*
 * Turn an index argument into a c-array of `PyObject *`s, one for each index.
 *
 * When a tuple is passed, the tuple elements are unpacked into the buffer.
 * Anything else is handled by unpack_scalar().
 *
 * @param  index     The index object, which may or may not be a tuple. This is
 *                   a borrowed reference.
 * @param  result    An empty buffer of PyObject* to write each index component
 *                   to. The references written are new.
 * @param  result_n  The length of the result buffer
 *
 * @returns          The number of items in `result`, or -1 if an error occurred.
 *                   The entries in `result` at and beyond this index should be
 *                   assumed to contain garbage, even if they were initialized
 *                   to NULL, so are not safe to Py_XDECREF. Use multi_DECREF to
 *                   dispose of them.
 ','line_number':204,'multiline':True]['text':' It is likely that the logic here can be simplified. See the discussion
     * on https://github.com/numpy/numpy/pull/21029
     ','line_number':225,'multiline':True]['text':' Fast route for passing a tuple ','line_number':229,'multiline':True]['text':'
     * Passing a tuple subclass - coerce to the base type. This incurs an
     * allocation, but doesn't need to be a fast path anyway. Note that by
     * calling `PySequence_Tuple`, we ensure that the subclass `__iter__` is
     * called.
     ','line_number':234,'multiline':True]['text':'*
 * Prepare an npy_index_object from the python slicing object.
 *
 * This function handles all index preparations with the exception
 * of field access. It fills the array of index_info structs correctly.
 * It already handles the boolean array special case for fancy indexing,
 * i.e. if the index type is boolean, it is exactly one matching boolean
 * array. If the index type is fancy, the boolean array is already
 * converted to integer arrays. There is (as before) no checking of the
 * boolean dimension.
 *
 * Checks everything but the bounds.
 *
 * @param the array being indexed
 * @param the index object
 * @param index info struct being filled (size of NPY_MAXDIMS * 2 + 1)
 * @param number of indices found
 * @param dimension of the indexing result
 * @param dimension of the fancy/advanced indices part
 * @param whether to allow the boolean special case
 *
 * @returns the index_type or -1 on failure and fills the number of indices.
 ','line_number':253,'multiline':True]['text':'
     * The choice of only unpacking `2*NPY_MAXDIMS` items is historic.
     * The longest "reasonable" index that produces a result of <= 32 dimensions
     * is `(0,)*ncu.MAXDIMS + (None,)*ncu.MAXDIMS`. Longer indices can exist, but
     * are uncommon.
     ','line_number':293,'multiline':True]['text':'
     * Parse all indices into the `indices` array of index_info structs
     ','line_number':306,'multiline':True]['text':'*** Try the cascade of possible indices ***','line_number':324,'multiline':True]['text':' Index is an ellipsis (`...`) ','line_number':326,'multiline':True]['text':' At most one ellipsis in an index ','line_number':328,'multiline':True]['text':' number of slices it is worth, won't update if it is 0: ','line_number':337,'multiline':True]['text':' the used and new ndim will be found later ','line_number':341,'multiline':True]['text':' Index is np.newaxis/None ','line_number':348,'multiline':True]['text':' Index is a slice object. ','line_number':361,'multiline':True]['text':'
         * Special case to allow 0-d boolean indexing with scalars.
         * Should be removed after boolean as integer deprecation.
         * Since this is always an error if it was not a boolean, we can
         * allow the 0-d special case before the rest.
         ','line_number':374,'multiline':True]['text':'
             * Single integer index, there are two cases here.
             * It could be an array, a 0-d array is handled
             * a bit weird however, so need to special case it.
             *
             * Check for integers first, purely for performance
             ','line_number':381,'multiline':True]['text':'
         * At this point, we must have an index array (or array-like).
         * It might still be a (purely) bool special case, a 0-d integer
         * array (an array scalar) or something invalid.
         ','line_number':407,'multiline':True]['text':' TODO: Should maybe replace the error here? ','line_number':417,'multiline':True]['text':'
             * For example an empty list can be cast to an integer array,
             * however it will default to a float one.
             ','line_number':421,'multiline':True]['text':' Check if the array is valid and fill the information ','line_number':444,'multiline':True]['text':'
             * There are two types of boolean indices (which are equivalent,
             * for the most part though). A single boolean index of matching
             * shape is a boolean index. If this is not the case, it is
             * instead expanded into (multiple) integer array indices.
             ','line_number':446,'multiline':True]['text':'
                 * If shapes match exactly, this can be optimized as a single
                 * boolean index. When the dimensions are identical but the shapes are not,
                 * this is always an error. The check ensures that these errors are raised
                 * and match those of the generic path.
                 ','line_number':455,'multiline':True]['text':' keep track anyway, just to be complete ','line_number':470,'multiline':True]['text':'
                 * This can actually be well defined. A new axis is added,
                 * but at the same time no axis is "used". So if we have True,
                 * we add a new axis (a bit like with np.newaxis). If it is
                 * False, we add a new axis, but this axis has 0 entries.
                 ','line_number':479,'multiline':True]['text':' TODO: The faster way can be n = ((npy_bool *)PyArray_BYTES(arr))[0] != 0 ','line_number':489,'multiline':True]['text':' Convert the boolean array into multiple integer ones ','line_number':517,'multiline':True]['text':' Check that we will not run out of indices to store new ones ','line_number':525,'multiline':True]['text':' Add the arrays from the nonzero result to the index ','line_number':536,'multiline':True]['text':' All added indices have 1 dimension ','line_number':548,'multiline':True]['text':' Normal case of an integer array ','line_number':555,'multiline':True]['text':'
                 * A 0-d integer array is an array scalar and can
                 * be dealt with the HAS_SCALAR_ARRAY flag.
                 * We could handle 0-d arrays early on, but this makes
                 * sure that array-likes or odder arrays are always
                 * handled right.
                 ','line_number':558,'multiline':True]['text':'
         * The array does not have a valid type.
         ','line_number':596,'multiline':True]['text':' The input was an array already ','line_number':600,'multiline':True]['text':' The input was not an array, so give a general error message ','line_number':605,'multiline':True]['text':'
     * Compare dimension of the index to the real ndim. this is
     * to find the ellipsis value or append an ellipsis if necessary.
     ','line_number':615,'multiline':True]['text':'
             * There is no ellipsis yet, but it is not a full index
             * so we append an ellipsis to the end.
             ','line_number':626,'multiline':True]['text':'
         * 0-d index into 0-d array, i.e. array[()]
         * We consider this an integer index. Which means it will return
         * the scalar.
         * This makes sense, because then array[...] gives
         * an array and array[()] gives the scalar.
         ','line_number':650,'multiline':True]['text':' HAS_SCALAR_ARRAY requires cleaning up the index_type ','line_number':661,'multiline':True]['text':' clear as info is unnecessary and makes life harder later ','line_number':663,'multiline':True]['text':' A full integer index sees array scalars as part of itself ','line_number':667,'multiline':True]['text':'
     * At this point indices are all set correctly, no bounds checking
     * has been made and the new array may still have more dimensions
     * than is possible and boolean indexing arrays may have an incorrect shape.
     *
     * Check this now so we do not have to worry about it later.
     * It can happen for fancy indexing or with newaxis.
     * This means broadcasting errors in the case of too many dimensions
     * take less priority.
     ','line_number':673,'multiline':True]['text':'
         * If we had a fancy index, we may have had a boolean array index.
         * So check if this had the correct shape now that we can find out
         * which axes it acts on.
         ','line_number':692,'multiline':True]['text':'*
 * Check if self has memory overlap with one of the index arrays, or with extra_op.
 *
 * @returns 1 if memory overlap found, 0 if not.
 ','line_number':744,'multiline':True]['text':'*
 * Get pointer for an integer index.
 *
 * For a purely integer index, set ptr to the memory address.
 * Returns 0 on success, -1 on failure.
 * The caller must ensure that the index is a full integer
 * one.
 *
 * @param Array being indexed
 * @param result pointer
 * @param parsed index information
 * @param number of indices
 *
 * @return 0 on success -1 on failure
 ','line_number':777,'multiline':True]['text':'*
 * Get view into an array using all non-array indices.
 *
 * For any index, get a view of the subspace into the original
 * array. If there are no fancy indices, this is the result of
 * the indexing operation.
 * Ensure_array allows to fetch a safe subspace view for advanced
 * indexing.
 *
 * @param Array being indexed
 * @param resulting array (new reference)
 * @param parsed index information
 * @param number of indices
 * @param Whether result should inherit the type from self
 *
 * @return 0 on success -1 on failure
 ','line_number':808,'multiline':True]['text':' for slice parsing ','line_number':835,'multiline':True]['text':' TODO: Always points to start then, could change that ','line_number':866,'multiline':True]['text':' Fancy and 0-d boolean indices are ignored here ','line_number':883,'multiline':True]['text':' Create the new view and set the base array ','line_number':893,'multiline':True]['text':'
 * Implements boolean indexing. This produces a one-dimensional
 * array which picks out all of the elements of 'self' for which
 * the corresponding element of 'op' is True.
 *
 * This operation is somewhat unfortunate, because to produce
 * a one-dimensional output array, it has to choose a particular
 * iteration order, in the case of NumPy that is always C order even
 * though this function allows different choices.
 ','line_number':910,'multiline':True]['text':' Allocate the output of the boolean indexing ','line_number':933,'multiline':True]['text':' not same as *dtype* if the DType class replaces dtypes ','line_number':938,'multiline':True]['text':' Create an iterator for the data ','line_number':947,'multiline':True]['text':' Set up the iterator ','line_number':963,'multiline':True]['text':' Get a dtype transfer function ','line_number':975,'multiline':True]['text':'
         * TODO: Ignoring cast flags, since this is only ever a copy. In
         *       principle that may not be quite right in some future?
         ','line_number':978,'multiline':True]['text':' Get the values needed for the inner loop ','line_number':995,'multiline':True]['text':' Skip masked values ','line_number':1020,'multiline':True]['text':' Process unmasked values ','line_number':1025,'multiline':True]['text':' Should be practically impossible, since there is no cast ','line_number':1047,'multiline':True]['text':'
 * Implements boolean indexing assignment. This takes the one-dimensional
 * array 'v' and assigns its values to all of the elements of 'self' for which
 * the corresponding element of 'op' is True.
 *
 * This operation is somewhat unfortunate, because to match up with
 * a one-dimensional output array, it has to choose a particular
 * iteration order, in the case of NumPy that is always C order even
 * though this function allows different choices.
 *
 * Returns 0 on success, -1 on failure.
 ','line_number':1071,'multiline':True]['text':' Correction factor for broadcasting 'bmask' to 'self' ','line_number':1116,'multiline':True]['text':' Tweak the strides for 0-dim and broadcasting cases ','line_number':1122,'multiline':True]['text':' Create an iterator for the data ','line_number':1140,'multiline':True]['text':' Set up the iterator ','line_number':1157,'multiline':True]['text':' Get the values needed for the inner loop ','line_number':1168,'multiline':True]['text':' Get a dtype transfer function ','line_number':1181,'multiline':True]['text':' Skip masked values ','line_number':1212,'multiline':True]['text':' Process unmasked values ','line_number':1217,'multiline':True]['text':'
 * C-level integer indexing always returning an array and never a scalar.
 * Works also for subclasses, but it will not be called on one from the
 * Python API.
 *
 * This function does not accept negative indices because it is called by
 * PySequence_GetItem (through array_item) and that converts them to
 * positive indices.
 ','line_number':1253,'multiline':True]['text':' This is an error, but undo PySequence_GetItem fix for message ','line_number':1274,'multiline':True]['text':'
 * Python C-Api level item subscription (implementation for PySequence_GetItem)
 *
 * Negative indices are not accepted because PySequence_GetItem converts
 * them to positive indices before calling this.
 ','line_number':1290,'multiline':True]['text':' This is an error, but undo PySequence_GetItem fix for message ','line_number':1304,'multiline':True]['text':' make sure subscript always returns an array object ','line_number':1321,'multiline':True]['text':'
 * Attempts to subscript an array using a field name or list of field names.
 *
 * ret =  0, view != NULL: view points to the requested fields of arr
 * ret =  0, view == NULL: an error occurred
 * ret = -1, view == NULL: unrecognized input, this is not a field index.
 ','line_number':1328,'multiline':True]['text':' first check for a single field name ','line_number':1340,'multiline':True]['text':' get the field offset and dtype ','line_number':1346,'multiline':True]['text':' view the array at the new offset+dtype ','line_number':1359,'multiline':True]['text':' We do not preserve the dtype for a subarray one, only str ','line_number':1370,'multiline':True]['text':' next check for a list of field names ','line_number':1378,'multiline':True]['text':' quit if have a fake sequence-like, which errors on len()','line_number':1385,'multiline':True]['text':' 0-len list is handled elsewhere as an integer index ','line_number':1390,'multiline':True]['text':' check the items are strings ','line_number':1395,'multiline':True]['text':' Call into the dtype subscript ','line_number':1410,'multiline':True]['text':' We do not preserve the dtype for a subarray one, only str ','line_number':1425,'multiline':True]['text':'
 * General function for indexing a NumPy array with a Python object.
 ','line_number':1437,'multiline':True]['text':'
     * Index info array. We can have twice as many indices as dimensions
     * (because of None). The + 1 is to not need to check as much.
     ','line_number':1448,'multiline':True]['text':' return fields if op is a string index ','line_number':1459,'multiline':True]['text':' Prepare the indices ','line_number':1471,'multiline':True]['text':' Full integer index ','line_number':1479,'multiline':True]['text':' Because the index is full integer, we do not need to decref ','line_number':1487,'multiline':True]['text':' Single boolean array ','line_number':1491,'multiline':True]['text':' If it is only a single ellipsis, just return a view ','line_number':1499,'multiline':True]['text':'
         * TODO: Should this be a view or not? The only reason not would be
         *       optimization (i.e. of array[...] += 1) I think.
         *       Before, it was just self for a single ellipsis.
         ','line_number':1501,'multiline':True]['text':' A single ellipsis, so no need to decref ','line_number':1507,'multiline':True]['text':'
     * View based indexing.
     * There are two cases here. First we need to create a simple view,
     * second we need to create a (possibly invalid) view for the
     * subspace to the fancy index. This procedure is identical.
     ','line_number':1511,'multiline':True]['text':'
         * There is a scalar array, so we need to force a copy to simulate
         * fancy indexing.
         ','line_number':1525,'multiline':True]['text':' If there is no fancy indexing, we have the result ','line_number':1535,'multiline':True]['text':'
     * Special case for very simple 1-d fancy indexing, which however
     * is quite common. This saves not only a lot of setup time in the
     * iterator, but also is faster (must be exactly fancy because
     * we don't support 0-d booleans here)
     ','line_number':1542,'multiline':True]['text':' The array being indexed has one dimension and it is a fancy index ','line_number':1549,'multiline':True]['text':' Check if the index is simple enough ','line_number':1552,'multiline':True]['text':' Check if the type is equivalent to INTP ','line_number':1554,'multiline':True]['text':' Same order as indices ','line_number':1566,'multiline':True]['text':' We can assume the newly allocated result is aligned ','line_number':1576,'multiline':True]['text':' fancy indexing has to be used. And view is the subspace. ','line_number':1597,'multiline':True]['text':'
         * If it is one, the inner loop checks indices, otherwise
         * check indices beforehand, because it is much faster if
         * broadcasting occurs and most likely no big overhead.
         * The inner loop optimization skips index checks for size == 0 though.
         ','line_number':1610,'multiline':True]['text':' Reset the outer iterator ','line_number':1621,'multiline':True]['text':'
     * Alignment information (swapping is never needed, since we buffer),
     * could also check extra_op is buffered, but it should rarely matter.
     ','line_number':1626,'multiline':True]['text':'
     * NOTE: Getting never actually casts, so we currently do not bother to do
     *       the full checks (floating point errors) here (unlike assignment).
     ','line_number':1631,'multiline':True]['text':'
         * Get a dtype transfer function, since there are no
         * buffers, this is safe.
         ','line_number':1647,'multiline':True]['text':' May need a generic copy function (only for refs and odd sizes) ','line_number':1662,'multiline':True]['text':'
         * Need to create a new array as if the old one never existed.
         ','line_number':1688,'multiline':True]['text':' Clean up indices ','line_number':1713,'multiline':True]['text':'
 * Python C-Api level item assignment (implementation for PySequence_SetItem)
 *
 * Negative indices are not accepted because PySequence_SetItem converts
 * them to positive indices before calling this.
 ','line_number':1721,'multiline':True]['text':' This is an error, but undo PySequence_SetItem fix for message ','line_number':1747,'multiline':True]['text':'
 * General assignment with python indexing objects.
 ','line_number':1780,'multiline':True]['text':' When a subspace is used, casting is done manually. ','line_number':1796,'multiline':True]['text':' field access ','line_number':1808,'multiline':True]['text':' Prepare the indices ','line_number':1825,'multiline':True]['text':' Full integer index ','line_number':1833,'multiline':True]['text':' integers do not store objects in indices ','line_number':1842,'multiline':True]['text':' Single boolean array ','line_number':1846,'multiline':True]['text':'
     * Single ellipsis index, no need to create a new view.
     * Note that here, we do *not* go through self.__getitem__ for subclasses
     * (defchar array failed then, due to uninitialized values...)
     ','line_number':1871,'multiline':True]['text':'
             * CopyObject does not handle this case gracefully and
             * there is nothing to do. Removing the special case
             * will cause segfaults, though it is unclear what exactly
             * happens.
             ','line_number':1878,'multiline':True]['text':' we can just use self, but incref for error handling ','line_number':1886,'multiline':True]['text':'
     * WARNING: There is a huge special case here. If this is not a
     *          base class array, we have to get the view through its
     *          very own index machinery.
     *          Many subclasses should probably call __setitem__
     *          with a base class ndarray view to avoid this.
     ','line_number':1891,'multiline':True]['text':'
     * View based indexing.
     * There are two cases here. First we need to create a simple view,
     * second we need to create a (possibly invalid) view for the
     * subspace to the fancy index. This procedure is identical.
     ','line_number':1911,'multiline':True]['text':' If there is no fancy indexing, we have the array to assign to ','line_number':1928,'multiline':True]['text':'
         * If the array is of object converting the values to an array
         * might not be legal even though normal assignment works.
         * So allocate a temporary array of the right size and use the
         * normal assignment to handle this case.
         ','line_number':1937,'multiline':True]['text':' There is nothing fancy possible, so just make an array ','line_number':1947,'multiline':True]['text':'
     * Special case for very simple 1-d fancy indexing, which however
     * is quite common. This saves not only a lot of setup time in the
     * iterator, but also is faster (must be exactly fancy because
     * we don't support 0-d booleans here)
     ','line_number':1961,'multiline':True]['text':' The array being indexed has one dimension and it is a fancy index ','line_number':1969,'multiline':True]['text':' Check if the type is equivalent ','line_number':1971,'multiline':True]['text':'
                 * Either they are equivalent, or the values must
                 * be a scalar
                 ','line_number':1974,'multiline':True]['text':' Check if the type is equivalent to INTP ','line_number':1983,'multiline':True]['text':' trivial_set checks the index for us ','line_number':2000,'multiline':True]['text':'
     * NOTE: If tmp_arr was not allocated yet, mit should
     *       handle the allocation.
     *       The NPY_ITER_READWRITE is necessary for automatic
     *       allocation. Readwrite would not allow broadcasting
     *       correctly, but such an operand always has the full
     *       size anyway.
     ','line_number':2009,'multiline':True]['text':' Fill extra op, need to swap first ','line_number':2032,'multiline':True]['text':'
     * Alignment information (swapping is never needed, since we buffer),
     * could also check extra_op is buffered, but it should rarely matter.
     ','line_number':2050,'multiline':True]['text':'
         * Get a dtype transfer function, since there are no
         * buffers, this is safe.
         ','line_number':2069,'multiline':True]['text':' May need a generic copy function (only for refs and odd sizes) ','line_number':2084,'multiline':True]['text':' Can now reset the outer iterator (delayed bufalloc) ','line_number':2101,'multiline':True]['text':'
     * Could add a casting check, but apparently most assignments do
     * not care about safe casting.
     ','line_number':2106,'multiline':True]['text':' Clean up temporary variables and indices ','line_number':2124,'multiline':True]['text':'mp_length','line_number':2149,'multiline':True]['text':'mp_subscript','line_number':2150,'multiline':True]['text':'mp_ass_subscript','line_number':2151,'multiline':True]['text':'***************** End of Mapping Protocol *****************************','line_number':2154,'multiline':True]['text':'********************** Subscript Array Iterator *************************
 *                                                                        *
 * This object handles subscript behavior for array objects.              *
 *  It is an iterator object with a next method                           *
 *  It abstracts the n-dimensional mapping behavior to make the looping   *
 *     code more understandable (maybe)                                   *
 *     and so that indexing can be set up ahead of time                   *
 ','line_number':2156,'multiline':True]['text':'
 * This function takes a Boolean array and constructs index objects and
 * iterators as if nonzero(Bool) had been called
 *
 * Must not be called on a 0-d array.
 ','line_number':2165,'multiline':True]['text':'
     * pre-determine how many nonzero entries there are,
     * ignore dimensionality of input as its a CARRAY
     ','line_number':2198,'multiline':True]['text':' create count-sized index arrays for each dimension ','line_number':2204,'multiline':True]['text':'
     * Loop through the Boolean array  and copy coordinates
     * for non-zero entries
     ','line_number':2223,'multiline':True]['text':' Borrowed from ITER_NEXT macro ','line_number':2234,'multiline':True]['text':' Reset the map iterator to the beginning ','line_number':2260,'multiline':True]['text':'
 * This function needs to update the state of the map iterator
 * and point mit->dataptr to the memory-location of the next object
 *
 * Note that this function never handles an extra operand but provides
 * compatibility for an old (exposed) API.
 ','line_number':2308,'multiline':True]['text':'*
 * Fill information about the iterator. The MapIterObject does not
 * need to have any information set for this function to work.
 * (PyArray_MapIterSwapAxes requires also nd and nd_fancy info)
 *
 * Sets the following information:
 *    * mit->consec: The axis where the fancy indices need transposing to.
 *    * mit->iteraxes: The axis which the fancy index corresponds to.
 *    * mit-> fancy_dims: the dimension of `arr` along the indexed dimension
 *          for each fancy index.
 *    * mit->fancy_strides: the strides for the dimension being indexed
 *          by each fancy index.
 *    * mit->dimensions: Broadcast dimension of the fancy indices and
 *          the subspace iteration dimension.
 *
 * @param MapIterObject
 * @param The parsed indices object
 * @param Number of indices
 * @param The array that is being iterated
 *
 * @return 0 on success -1 on failure (broadcasting or too many fancy indices)
 ','line_number':2390,'multiline':True]['text':' dimension of index result (up to first fancy index) ','line_number':2418,'multiline':True]['text':' -1 init; 0 found fancy; 1 fancy stopped; 2 found not consecutive fancy ','line_number':2420,'multiline':True]['text':' integer and fancy indexes are transposed together ','line_number':2431,'multiline':True]['text':' there was no previous fancy index, so set consec ','line_number':2433,'multiline':True]['text':' there was already a non-fancy index after a fancy one ','line_number':2438,'multiline':True]['text':' consec_status == 0 means there was a fancy index before ','line_number':2445,'multiline':True]['text':' Before contunuing, ensure that there are not too fancy indices ','line_number':2451,'multiline':True]['text':' (iterating) fancy index, store the iterator ','line_number':2462,'multiline':True]['text':' Check broadcasting ','line_number':2468,'multiline':True]['text':' Fill from back, we know how many dims there are ','line_number':2470,'multiline':True]['text':' If it is 1, we can broadcast ','line_number':2476,'multiline':True]['text':' Does not exist ','line_number':2490,'multiline':True]['text':' advance curr_dim for non-fancy indices ','line_number':2499,'multiline':True]['text':' Fill dimension of subspace ','line_number':2513,'multiline':True]['text':' Declarations cannot follow labels, add empty statement.','line_number':2522,'multiline':False]['text':'
     * Attempt to set a meaningful exception. Could also find out
     * if a boolean index was converted.
     ','line_number':2523,'multiline':True]['text':'
 * Check whether the fancy indices are out of bounds.
 * Returns 0 on success and -1 on failure.
 * (Gets operands from the outer iterator, but iterates them independently)
 ','line_number':2559,'multiline':True]['text':'
         * When the outer iteration is empty, the indices broadcast to an
         * empty shape, and in this case we do not check if there are out
         * of bounds indices.
         * The code below does use the indices without broadcasting since
         * broadcasting only repeats values.
         ','line_number':2579,'multiline':True]['text':' See if it is possible to just trivially iterate the array ','line_number':2599,'multiline':True]['text':' Check if the type is equivalent to INTP ','line_number':2601,'multiline':True]['text':' release GIL if it was taken by nditer below ','line_number':2608,'multiline':True]['text':' GIL retake at end of function or if nditer path required ','line_number':2624,'multiline':True]['text':' Use NpyIter if the trivial iteration is not possible ','line_number':2628,'multiline':True]['text':' 2020-05-27, NumPy 1.20 ','line_number':2682,'multiline':True]['text':'
 * Create new mapiter.
 *
 * NOTE: The outer iteration (and subspace if requested buffered) is
 *       created with DELAY_BUFALLOC. It must be reset before usage!
 *
 * @param Index information filled by prepare_index.
 * @param Number of indices (gotten through prepare_index).
 * @param Kind of index (gotten through preprare_index).
 * @param NpyIter flags for an extra array. If 0 assume that there is no
 *        extra operand. NPY_ITER_ALLOCATE can make sense here.
 * @param Array being indexed
 * @param subspace (result of getting view for the indices)
 * @param Subspace iterator flags can be used to enable buffering.
 *        NOTE: When no subspace is necessary, the extra operand will
 *              always be buffered! Buffering the subspace when not
 *              necessary is very slow when the subspace is small.
 * @param Subspace operand flags (should just be 0 normally)
 * @param Operand iteration flags for the extra operand, this must not be
 *        0 if an extra operand should be used, otherwise it must be 0.
 *        Should be at least READONLY, WRITEONLY or READWRITE.
 * @param Extra operand. For getmap, this would be the result, for setmap
 *        this would be the arrays to get from.
 *        Can be NULL, and will be allocated in that case. However,
 *        it matches the mapiter iteration, so you have to call
 *        MapIterSwapAxes(mit, &extra_op, 1) on it.
 *        The operand has no effect on the shape.
 * @param Dtype for the extra operand, borrows the reference and must not
 *        be NULL (if extra_op_flags is not 0).
 *
 * @return A new MapIter (PyObject *) or NULL.
 ','line_number':2705,'multiline':True]['text':' For shape reporting on error ','line_number':2745,'multiline':True]['text':' NOTE: MAXARGS is the actual limit (2*NPY_MAXDIMS is index number one) ','line_number':2748,'multiline':True]['text':' borrowed references ','line_number':2751,'multiline':True]['text':' create new MapIter object ','line_number':2769,'multiline':True]['text':' set all attributes of mapiter to zero ','line_number':2776,'multiline':True]['text':'
     * The subspace, the part of the array which is not indexed by
     * arrays, needs to be iterated when the size of the subspace
     * is larger than 1. If it is one, it has only an effect on the
     * result shape. (Optimizes for example np.newaxis usage)
     ','line_number':2785,'multiline':True]['text':' Fill basic information about the mapiter ','line_number':2798,'multiline':True]['text':'
     * Set iteration information of the indexing arrays.
     ','line_number':2807,'multiline':True]['text':'
         * For MapIterArray, it is possible that there is no fancy index.
         * to support this case, add a dummy iterator.
         * Since it is 0-d its transpose, etc. does not matter.
         ','line_number':2823,'multiline':True]['text':' signal necessity to decref... ','line_number':2829,'multiline':True]['text':'
     * Now there are two general cases how extra_op is used:
     *   1. No subspace iteration is necessary, so the extra_op can
     *      be included into the index iterator (it will be buffered)
     *   2. Subspace iteration is necessary, so the extra op is iterated
     *      independently, and the iteration order is fixed at C (could
     *      also use Fortran order if the array is Fortran order).
     *      In this case the subspace iterator is not buffered.
     *
     * If subspace iteration is necessary and an extra_op was given,
     * it may also be necessary to transpose the extra_op (or signal
     * the transposing to the advanced iterator).
     ','line_number':2846,'multiline':True]['text':'
         * If we have an extra_op given, need to prepare it.
         *   1. Subclasses might mess with the shape, so need a baseclass
         *   2. Need to make sure the shape is compatible
         *   3. May need to remove leading 1s and transpose dimensions.
         *      Normal assignments allows broadcasting away leading 1s, but
         *      the transposing code does not like this.
         ','line_number':2861,'multiline':True]['text':'
             * Usual assignments allows removal of leading one dimensions.
             * (or equivalently adding of one dimensions to the array being
             * assigned to). To implement this, reshape the array.
             ','line_number':2881,'multiline':True]['text':'
         * If dimensions need to be prepended (and no swapaxis is needed),
         * use op_axes after extra_op is allocated for sure.
         ','line_number':2901,'multiline':True]['text':'
             * We are not using the subspace, so its size is 1.
             * All dimensions of the extra_op corresponding to the
             * subspace must be equal to 1.
             ','line_number':2913,'multiline':True]['text':'
     * If subspace is not NULL, NpyIter cannot allocate extra_op for us.
     * This is a bit of a kludge. A dummy iterator is created to find
     * the correct output shape and stride permutation.
     * TODO: This can at least partially be replaced, since the shape
     *       is found for broadcasting errors.
     ','line_number':2932,'multiline':True]['text':' Create an iterator, just to broadcast the arrays?! ','line_number':2952,'multiline':True]['text':'
             * nditer allows itemsize with npy_intp type, so it works
             * here, but it would *not* work directly, since elsize
             * is limited to int.
             ','line_number':2965,'multiline':True]['text':' Just use C-order strides (TODO: allow also F-order) ','line_number':2980,'multiline':True]['text':' shape is set, and strides is set up to mit->nd, set rest ','line_number':2988,'multiline':True]['text':'
         * Allocate new array. Note: Always base class, because
         * subclasses might mess with the shape.
         ','line_number':2997,'multiline':True]['text':'
     * The extra op is now either allocated, can be allocated by
     * NpyIter (no subspace) or is not used at all.
     *
     * Need to set the axis remapping for the extra_op. This needs
     * to cause ignoring of subspace dimensions and prepending -1
     * for broadcasting.
     ','line_number':3012,'multiline':True]['text':' (fills subspace dimensions too, but they are not unused) ','line_number':3025,'multiline':True]['text':'
     * NOTE: If for some reason someone wishes to use REDUCE_OK, be
     *       careful and fix the error message replacement at the end.
     ','line_number':3030,'multiline':True]['text':'
     * For a single 1-d operand, guarantee iteration order
     * (scipy used this). Note that subspace may be used.
     ','line_number':3040,'multiline':True]['text':' If external array is iterated, and no subspace is needed ','line_number':3048,'multiline':True]['text':'
         * NOTE: This small limitation should practically not matter.
         *       (replaces npyiter error)
         ','line_number':3056,'multiline':True]['text':' Use the axis remapping ','line_number':3077,'multiline':True]['text':' TODO: Maybe add test for the CORDER, and maybe also allow F ','line_number':3090,'multiline':True]['text':' NpyIter cleanup and information: ','line_number':3095,'multiline':True]['text':' Get the allocated extra_op ','line_number':3112,'multiline':True]['text':'
     * If extra_op is being tracked but subspace is used, we need
     * to create a dedicated iterator for the outer iteration of
     * the extra operand.
     ','line_number':3123,'multiline':True]['text':' Get the full dimension information ','line_number':3152,'multiline':True]['text':' Calculate total size of the MapIter ','line_number':3160,'multiline':True]['text':' Can now return early if no subspace is being used ','line_number':3168,'multiline':True]['text':' Fill in the last bit of mapiter information needed ','line_number':3175,'multiline':True]['text':'
     * Now just need to create the correct subspace iterator.
     ','line_number':3177,'multiline':True]['text':' We should iterate the extra_op as well ','line_number':3186,'multiline':True]['text':'
         * Buffering is never used here, but in case someone plugs it in
         * somewhere else, set the type correctly then.
         ','line_number':3192,'multiline':True]['text':'
     * Check whether the operand could not be broadcast and replace the error
     * in that case. This should however normally be found early with a
     * direct goto to broadcast_error
     ','line_number':3237,'multiline':True]['text':' (j < 0 is currently impossible, extra_op is reshaped) ','line_number':3250,'multiline':True]['text':' extra_op cannot be broadcast to the indexing result ','line_number':3253,'multiline':True]['text':' Report the shape of the original array if it exists ','line_number':3260,'multiline':True]['text':' Unscramble the iterator shape for reporting when `mit->consec` is used ','line_number':3272,'multiline':True]['text':'
 * Use advanced indexing to iterate an array.
 *
 * If copy_if_overlap != 0, check if `a` has memory overlap with any of the
 * arrays in `index` and with `extra_op`. If yes, make copies as appropriate
 * to avoid problems if `a` is modified during the iteration.
 * `iter->array` may contain a copied array (WRITEBACKIFCOPY set).
 ','line_number':3300,'multiline':True]['text':' Make a copy of the input array ','line_number':3328,'multiline':True]['text':' If it is not a pure fancy index, need to get the subspace ','line_number':3347,'multiline':True]['text':'
 * The mapiter object must be created new each time.  It does not work
 * to bind to a new array, and continue.
 *
 * This was the original intention, but currently that does not work.
 * Do not expose the MapIter_Type to Python.
 *
 * The original mapiter(indexobj); mapiter.bind(a); idea is now fully
 * removed. This is not very useful anyway, since mapiter is equivalent
 * to a[indexobj].flat but the latter gets to use slice syntax.
 ','line_number':3421,'multiline':True]