['text':' This compares scalarmath against ufuncs.','line_number':44,'multiline':False]['text':' list of types','line_number':53,'multiline':False]['text':' It was comparing the type numbers, but the new ufunc','line_number':62,'multiline':False]['text':' function-finding mechanism finds the lowest function','line_number':63,'multiline':False]['text':' to which both inputs can be cast - which produces 'l'','line_number':64,'multiline':False]['text':' when you do 'q' + 'b'.  The old function finding mechanism','line_number':65,'multiline':False]['text':' skipped ahead based on the first argument, but that','line_number':66,'multiline':False]['text':' does not produce properly symmetric results...','line_number':67,'multiline':False]['text':' test leak of scalar objects','line_number':79,'multiline':False]['text':' a leak would show up in valgrind as still-reachable of ~2.6MB','line_number':80,'multiline':False]['text':' array**scalar special case can have different result dtype','line_number':96,'multiline':False]['text':' (Other powers may have issues also, but are not hit here.)','line_number':97,'multiline':False]['text':' TODO: It would be nice to resolve this issue.','line_number':98,'multiline':False]['text':' ignore fpe's since they may just mismatch for integers anyway.','line_number':101,'multiline':False]['text':' Comparisons DeprecationWarnings replacing errors (2022-03):','line_number':103,'multiline':False]['text':' Same as above, but don't worry about sampling weird values so that we','line_number':133,'multiline':False]['text':' do not have to sample as much','line_number':134,'multiline':False]['text':' some power do weird things.','line_number':136,'multiline':False]['text':' Promotion for mixed int and float32/float16 must not go to float64','line_number':143,'multiline':False]['text':' But normal int / int true division goes to float64:','line_number':149,'multiline':False]['text':' For int16, result has to be ast least float32 (takes ufunc path):','line_number':151,'multiline':False]['text':' test alignments offsets for simd instructions','line_number':158,'multiline':False]['text':' alignments for vz + 2 * (vs - 1) + 1','line_number':159,'multiline':False]['text':' skip true divide for ints','line_number':177,'multiline':False]['text':' check data that is not aligned to element size','line_number':190,'multiline':False]['text':' i.e doubles are aligned to 4 bytes on i386','line_number':191,'multiline':False]['text':' Note that the combination of uint64 with a signed integer','line_number':220,'multiline':False]['text':' has common type np.float64. The other combinations should all','line_number':221,'multiline':False]['text':' raise a ValueError for integer ** negative integer.','line_number':222,'multiline':False]['text':' 1 ** -1 possible special case','line_number':225,'multiline':False]['text':' -1 ** -1 possible special case','line_number':235,'multiline':False]['text':' 2 ** -1 perhaps generic','line_number':245,'multiline':False]['text':' modular power is not implemented, so ensure it errors','line_number':272,'multiline':False]['text':' noqa: F841','line_number':276,'multiline':False]['text':' note that 3-operand power only dispatches on the first argument','line_number':278,'multiline':False]['text':' test that float results are exact for small integers. This also','line_number':313,'multiline':False]['text':' holds for the same integers scaled by powers of two.','line_number':314,'multiline':False]['text':' convert exact integer results from Python to float so that','line_number':323,'multiline':False]['text':' signed zero can be used, it is checked.','line_number':324,'multiline':False]['text':' use list comprehension so a_ and b_ are scalars','line_number':334,'multiline':False]['text':' gh-6127','line_number':340,'multiline':False]['text':' Equal assertion should hold when fmod is used','line_number':350,'multiline':False]['text':' Check remainder magnitude.','line_number':358,'multiline':False]['text':' Check nans, inf','line_number':367,'multiline':False]['text':' MSVC 2008 returns NaN here, so disable the check.','line_number':381,'multiline':False]['text':'rem = operator.mod(fone, finf)','line_number':382,'multiline':False]['text':'assert_(rem == fone, 'dt: %s' % dt)','line_number':383,'multiline':False]['text':' issue gh-12927','line_number':393,'multiline':False]['text':' this only applies to in-place floordiv //=, because the output type','line_number':394,'multiline':False]['text':' promotes to float which does not fit','line_number':395,'multiline':False]['text':' tupled (numerator, denominator, expected)','line_number':424,'multiline':False]['text':' for testing as expected == numerator/denominator','line_number':425,'multiline':False]['text':' check real and imag parts separately to avoid comparison','line_number':441,'multiline':False]['text':' in array context, which does not account for signed zeros','line_number':442,'multiline':False]['text':' tupled (numerator, denominator, expected)','line_number':449,'multiline':False]['text':' for testing as expected == numerator/denominator','line_number':450,'multiline':False]['text':' trigger branch: real(fabs(denom)) > imag(fabs(denom))','line_number':453,'multiline':False]['text':' followed by else condition as neither are == 0','line_number':454,'multiline':False]['text':' trigger branch: real(fabs(denom)) > imag(fabs(denom))','line_number':457,'multiline':False]['text':' followed by if condition as both are == 0','line_number':458,'multiline':False]['text':' is performed in test_zero_division(), so this is skipped','line_number':459,'multiline':False]['text':' trigger else if branch: real(fabs(denom)) < imag(fabs(denom))','line_number':461,'multiline':False]['text':' check real and imag parts separately to avoid comparison','line_number':469,'multiline':False]['text':' in array context, which does not account for signed zeros','line_number':470,'multiline':False]['text':' gh-627','line_number':509,'multiline':False]['text':' Produce a longdouble that would overflow a double,','line_number':533,'multiline':False]['text':' use exponent that avoids bug in Darwin pow function.','line_number':534,'multiline':False]['text':' All integer','line_number':548,'multiline':False]['text':'Unsigned integers','line_number':559,'multiline':False]['text':'unsigned vs signed','line_number':565,'multiline':False]['text':'Signed integers and floats','line_number':574,'multiline':False]['text':' Scalars should just return False and not give a warnings.','line_number':589,'multiline':False]['text':' The comparisons are flagged by pep8, ignore that.','line_number':590,'multiline':False]['text':' This is dubious (see below):','line_number':595,'multiline':False]['text':' This is dubious (see below):','line_number':600,'multiline':False]['text':' For documentation purposes, this is why the datetime is dubious.','line_number':604,'multiline':False]['text':' At the time of deprecation this was no behaviour change, but','line_number':605,'multiline':False]['text':' it has to be considered when the deprecations are done.','line_number':606,'multiline':False]['text':'class TestRepr:','line_number':610,'multiline':False]['text':'    def test_repr(self):','line_number':611,'multiline':False]['text':'        for t in types:','line_number':612,'multiline':False]['text':'            val = t(1197346475.0137341)','line_number':613,'multiline':False]['text':'            val_repr = repr(val)','line_number':614,'multiline':False]['text':'            val2 = eval(val_repr)','line_number':615,'multiline':False]['text':'            assert_equal( val, val2 )','line_number':616,'multiline':False]['text':' could add some more types to the list below','line_number':625,'multiline':False]['text':' Values from https://en.wikipedia.org/wiki/IEEE_754','line_number':627,'multiline':False]['text':' long double test cannot work, because eval goes through a python','line_number':646,'multiline':False]['text':' float','line_number':647,'multiline':False]['text':' sys.getsizeof() is not valid on PyPy','line_number':653,'multiline':False]['text':' Test that basic sequences get repeated when multiplied with','line_number':668,'multiline':False]['text':' numpy integers. And errors are raised when multiplied with others.','line_number':669,'multiline':False]['text':' Some of this behaviour may be controversial and could be open for','line_number':670,'multiline':False]['text':' change.','line_number':671,'multiline':False]['text':' can't default-construct void scalars','line_number':676,'multiline':False]['text':' Test that an array-like which does not know how to be multiplied','line_number':700,'multiline':False]['text':' does not attempt sequence repeat (raise TypeError).','line_number':701,'multiline':False]['text':' See also gh-7428.','line_number':702,'multiline':False]['text':' Test for simple ArrayLike above and memoryviews (original report)','line_number':709,'multiline':False]['text':' assert_equal() checks zero signedness','line_number':755,'multiline':False]['text':' gh-2449','line_number':813,'multiline':False]['text':' sign bit is preserved','line_number':822,'multiline':False]['text':' Result on scalars should be the same as on arrays','line_number':827,'multiline':False]['text':' Cast back to Python, in case the NumPy scalar has less precision','line_number':846,'multiline':False]['text':' If Python distinguishes different NaNs we do so too (gh-18833)','line_number':855,'multiline':False]['text':' Test some complex valued hashes specifically:','line_number':860,'multiline':False]['text':' This is/used to be tricky, because NumPy generally falls back to','line_number':912,'multiline':False]['text':' using the ufunc via `np.asarray()`, this effectively might do:','line_number':913,'multiline':False]['text':' longdouble + None','line_number':914,'multiline':False]['text':'   -> asarray(longdouble) + np.array(None, dtype=object)','line_number':915,'multiline':False]['text':'   -> asarray(longdouble).astype(object) + np.array(None, dtype=object)','line_number':916,'multiline':False]['text':' And after getting the scalars in the inner loop:','line_number':917,'multiline':False]['text':'   -> longdouble + None','line_number':918,'multiline':False]['text':'','line_number':919,'multiline':False]['text':' That would recurse infinitely.  Other scalars return the python object','line_number':920,'multiline':False]['text':' on cast, so this type of things works OK.','line_number':921,'multiline':False]['text':' (See `test_longdouble_operators_with_obj` for why longdouble is special)','line_number':936,'multiline':False]['text':' NEP 50 means that the result is clearly a (c)longdouble here:','line_number':937,'multiline':False]['text':' The above operators are not support for complex though...','line_number':939,'multiline':False]['text':' The minimum signed integer can "overflow" for some additional operations','line_number':972,'multiline':False]['text':' does not warn','line_number':988,'multiline':False]['text':' Note __op__ and __rop__ may be identical here:','line_number':1007,'multiline':False]['text':' inheritance has to override, or this is correctly lost:','line_number':1048,'multiline':False]['text':' inherited','line_number':1051,'multiline':False]['text':' Two independent subclasses do not really define an order.  This could','line_number':1053,'multiline':False]['text':' be attempted, but we do not since Python's `int` does neither:','line_number':1054,'multiline':False]['text':' inherited','line_number':1056,'multiline':False]['text':' Simple test to check longdouble and complex combinations, since these','line_number':1060,'multiline':False]['text':' need to go through promotion, which longdouble needs to be careful about.','line_number':1061,'multiline':False]['text':' Check that deferring is indicated using `__array_ufunc__`:','line_number':1077,'multiline':False]['text':' Just like normally, we should never presume we can modify the float.','line_number':1081,'multiline':False]['text':' module is not support for complex.  Do not test.','line_number':1086,'multiline':False]['text':' When no deferring is indicated, subclasses are handled normally.','line_number':1091,'multiline':False]['text':' Check for float32, as a float subclass float64 may behave differently','line_number':1094,'multiline':False]['text':' Same check for longdouble:','line_number':1104,'multiline':False]