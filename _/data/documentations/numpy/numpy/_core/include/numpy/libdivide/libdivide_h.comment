['text':' libdivide.h - Optimized integer division','line_number':1,'multiline':False]['text':' https://libdivide.com','line_number':2,'multiline':False]['text':'','line_number':3,'multiline':False]['text':' Copyright (C) 2010 - 2019 ridiculous_fish, <libdivide@ridiculousfish.com>','line_number':4,'multiline':False]['text':' Copyright (C) 2016 - 2019 Kim Walisch, <kim.walisch@gmail.com>','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' libdivide is dual-licensed under the Boost or zlib licenses.','line_number':7,'multiline':False]['text':' You may use libdivide under the terms of either of these.','line_number':8,'multiline':False]['text':' See LICENSE.txt for more details.','line_number':9,'multiline':False]['text':' disable warning C4146: unary minus operator applied','line_number':39,'multiline':False]['text':' to unsigned type, result still unsigned','line_number':40,'multiline':False]['text':' clang-cl on Windows does not yet support 128-bit division','line_number':51,'multiline':False]['text':' pack divider structs to prevent compilers from padding.','line_number':99,'multiline':False]['text':' This reduces memory usage by up to 43% when using a large','line_number':100,'multiline':False]['text':' array of libdivide dividers and improves performance','line_number':101,'multiline':False]['text':' by up to 10% because of reduced memory bandwidth.','line_number':102,'multiline':False]['text':' Explanation of the "more" field:','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':' * Bits 0-5 is the shift value (for shift path or mult path).','line_number':149,'multiline':False]['text':' * Bit 6 is the add indicator for mult path.','line_number':150,'multiline':False]['text':' * Bit 7 is set if the divisor is negative. We use bit 7 as the negative','line_number':151,'multiline':False]['text':'   divisor indicator so that we can efficiently use sign extension to','line_number':152,'multiline':False]['text':'   create a bitmask with all bits set to 1 (if the divisor is negative)','line_number':153,'multiline':False]['text':'   or 0 (if the divisor is positive).','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':' u32: [0-4] shift value','line_number':156,'multiline':False]['text':'      [5] ignored','line_number':157,'multiline':False]['text':'      [6] add indicator','line_number':158,'multiline':False]['text':'      magic number of 0 indicates shift path','line_number':159,'multiline':False]['text':'','line_number':160,'multiline':False]['text':' s32: [0-4] shift value','line_number':161,'multiline':False]['text':'      [5] ignored','line_number':162,'multiline':False]['text':'      [6] add indicator','line_number':163,'multiline':False]['text':'      [7] indicates negative divisor','line_number':164,'multiline':False]['text':'      magic number of 0 indicates shift path','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':' u64: [0-5] shift value','line_number':167,'multiline':False]['text':'      [6] add indicator','line_number':168,'multiline':False]['text':'      magic number of 0 indicates shift path','line_number':169,'multiline':False]['text':'','line_number':170,'multiline':False]['text':' s64: [0-5] shift value','line_number':171,'multiline':False]['text':'      [6] add indicator','line_number':172,'multiline':False]['text':'      [7] indicates negative divisor','line_number':173,'multiline':False]['text':'      magic number of 0 indicates shift path','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':' In s32 and s64 branchfree modes, the magic number is negated according to','line_number':176,'multiline':False]['text':' whether the divisor is negated. In branchfree strategy, it is not negated.','line_number':177,'multiline':False]['text':'////// Internal Utility Functions','line_number':216,'multiline':False]['text':' needs to be arithmetic shift','line_number':227,'multiline':False]['text':' full 128 bits are x0 * y0 + (x0 * y1 << 32) + (x1 * y0 << 32) + (x1 * y1 << 64)','line_number':240,'multiline':False]['text':' full 128 bits are x0 * y0 + (x0 * y1 << 32) + (x1 * y0 << 32) + (x1 * y1 << 64)','line_number':267,'multiline':False]['text':' Fast way to count leading zeros','line_number':284,'multiline':False]['text':' Fast way to count leading zeros','line_number':312,'multiline':False]['text':' libdivide_64_div_32_to_32: divides a 64-bit uint {u1, u0} by a 32-bit','line_number':328,'multiline':False]['text':' uint {v}. The result must fit in 32 bits.','line_number':329,'multiline':False]['text':' Returns the quotient directly and the remainder in *r','line_number':330,'multiline':False]['text':' libdivide_128_div_64_to_64: divides a 128-bit uint {u1, u0} by a 64-bit','line_number':348,'multiline':False]['text':' uint {v}. The result must fit in 64 bits.','line_number':349,'multiline':False]['text':' Returns the quotient directly and the remainder in *r','line_number':350,'multiline':False]['text':' Code taken from Hacker's Delight:','line_number':367,'multiline':False]['text':' http://www.hackersdelight.org/HDcode/divlu.c.','line_number':368,'multiline':False]['text':' License permits inclusion here per:','line_number':369,'multiline':False]['text':' http://www.hackersdelight.org/permissions.htm','line_number':370,'multiline':False]['text':' Number base (32 bits)','line_number':372,'multiline':False]['text':' Norm. dividend LSD's','line_number':373,'multiline':False]['text':' Norm. divisor digits','line_number':374,'multiline':False]['text':' Quotient digits','line_number':375,'multiline':False]['text':' Dividend digit pairs','line_number':376,'multiline':False]['text':' A remainder','line_number':377,'multiline':False]['text':' Shift amount for norm','line_number':378,'multiline':False]['text':' If overflow, set rem. to an impossible value,','line_number':380,'multiline':False]['text':' and return the largest possible quotient','line_number':381,'multiline':False]['text':' count leading zeros','line_number':387,'multiline':False]['text':' Normalize divisor','line_number':390,'multiline':False]['text':' Shift dividend left','line_number':393,'multiline':False]['text':' Avoid undefined behavior of (u0 >> 64).','line_number':395,'multiline':False]['text':' The behavior is undefined if the right operand is','line_number':396,'multiline':False]['text':' negative, or greater than or equal to the length','line_number':397,'multiline':False]['text':' in bits of the promoted left operand.','line_number':398,'multiline':False]['text':' Break divisor up into two 32-bit digits','line_number':403,'multiline':False]['text':' Break right half of dividend into two digits','line_number':407,'multiline':False]['text':' Compute the first quotient digit, q1','line_number':411,'multiline':False]['text':' Multiply and subtract','line_number':422,'multiline':False]['text':' Compute the second quotient digit','line_number':425,'multiline':False]['text':' Bitshift a u128 in place, left (signed_shift > 0) or right (signed_shift < 0)','line_number':441,'multiline':False]['text':' Computes a 128 / 128 -> 64 bit division, with a 128 bit remainder.','line_number':457,'multiline':False]['text':' Adapted from "Unsigned Doubleword Division" in Hacker's Delight','line_number':471,'multiline':False]['text':' We want to compute u / v','line_number':472,'multiline':False]['text':' divisor v is a 64 bit value, so we just need one 128/64 division','line_number':478,'multiline':False]['text':' Note that we are simpler than Hacker's Delight here, because we know','line_number':479,'multiline':False]['text':' the quotient fits in 64 bits whereas Hacker's Delight demands a full','line_number':480,'multiline':False]['text':' 128 bit quotient','line_number':481,'multiline':False]['text':' Here v >= 2**64','line_number':485,'multiline':False]['text':' We know that v.hi != 0, so count leading zeros is OK','line_number':486,'multiline':False]['text':' We have 0 <= n <= 63','line_number':487,'multiline':False]['text':' Normalize the divisor so its MSB is 1','line_number':490,'multiline':False]['text':' i.e. v1 = v1t >> 64','line_number':493,'multiline':False]['text':' To ensure no overflow','line_number':495,'multiline':False]['text':' Get quotient from divide unsigned insn.','line_number':499,'multiline':False]['text':' Undo normalization and division of u by 2.','line_number':503,'multiline':False]['text':' Make q0 correct or too small by 1','line_number':508,'multiline':False]['text':' Equivalent to `if (q0 != 0) q0 = q0 - 1;`','line_number':509,'multiline':False]['text':' borrow','line_number':511,'multiline':False]['text':' Now q0 is correct.','line_number':515,'multiline':False]['text':' Compute q0 * v as q0v','line_number':516,'multiline':False]['text':' = (q0.hi << 64 + q0.lo) * (v.hi << 64 + v.lo)','line_number':517,'multiline':False]['text':' = (q0.hi * v.hi << 128) + (q0.hi * v.lo << 64) +','line_number':518,'multiline':False]['text':'   (q0.lo * v.hi <<  64) + q0.lo * v.lo)','line_number':519,'multiline':False]['text':' Each term is 128 bit','line_number':520,'multiline':False]['text':' High half of full product (upper 128 bits!) are dropped','line_number':521,'multiline':False]['text':' Compute u - q0v as u_q0v','line_number':526,'multiline':False]['text':' This is the remainder','line_number':527,'multiline':False]['text':' second term is borrow','line_number':529,'multiline':False]['text':' Check if u_q0v >= v','line_number':532,'multiline':False]['text':' This checks if our remainder is larger than the divisor','line_number':533,'multiline':False]['text':' Increment q0','line_number':536,'multiline':False]['text':' carry','line_number':538,'multiline':False]['text':' Subtract v from remainder','line_number':540,'multiline':False]['text':'//////// UINT32','line_number':553,'multiline':False]['text':' Power of 2','line_number':563,'multiline':False]['text':' We need to subtract 1 from the shift value in case of an unsigned','line_number':565,'multiline':False]['text':' branchfree divider because there is a hardcoded right shift by 1','line_number':566,'multiline':False]['text':' in its division algorithm. Because of this we also need to add back','line_number':567,'multiline':False]['text':' 1 in its recovery algorithm.','line_number':568,'multiline':False]['text':' This power works if e < 2**floor_log_2_d.','line_number':579,'multiline':False]['text':' This power works','line_number':581,'multiline':False]['text':' We have to use the general 33-bit algorithm.  We need to compute','line_number':584,'multiline':False]['text':' (2**power) / d. However, we already have (2**(power-1))/d and','line_number':585,'multiline':False]['text':' its remainder.  By doubling both, and then correcting the','line_number':586,'multiline':False]['text':' remainder, we can compute the larger division.','line_number':587,'multiline':False]['text':' don't care about overflow here - in fact, we expect it','line_number':588,'multiline':False]['text':' result.more's shift should in general be ceil_log_2_d. But if we','line_number':596,'multiline':False]['text':' used the smaller power, we subtract one from the shift because we're','line_number':597,'multiline':False]['text':' using the smaller power. If we're using the larger power, we','line_number':598,'multiline':False]['text':' subtract one from the shift because it's taken care of by the add','line_number':599,'multiline':False]['text':' indicator. So floor_log_2_d happens to be correct in both cases.','line_number':600,'multiline':False]['text':' All upper bits are 0,','line_number':630,'multiline':False]['text':' don't need to mask them off.','line_number':631,'multiline':False]['text':' We compute q = n/d = n*m / 2^(32 + shift)','line_number':650,'multiline':False]['text':' Therefore we have d = 2^(32 + shift) / m','line_number':651,'multiline':False]['text':' We need to ceil it.','line_number':652,'multiline':False]['text':' We know d is not a power of 2, so m is not a power of 2,','line_number':653,'multiline':False]['text':' so we can just add 1 to the floor','line_number':654,'multiline':False]['text':' Here we wish to compute d = 2^(32+shift+1)/(m+2^32).','line_number':659,'multiline':False]['text':' Notice (m + 2^32) is a 33 bit number. Use 64 bit division for now','line_number':660,'multiline':False]['text':' Also note that shift may be as high as 31, so shift + 1 will','line_number':661,'multiline':False]['text':' overflow. So we have to compute it as 2^(32+shift)/(m+2^32), and','line_number':662,'multiline':False]['text':' then double the quotient and remainder.','line_number':663,'multiline':False]['text':' Note that the quotient is guaranteed <= 32 bits, but the remainder','line_number':666,'multiline':False]['text':' may need 33!','line_number':667,'multiline':False]['text':' We computed 2^(32+shift)/(m+2^32)','line_number':670,'multiline':False]['text':' Need to double it, and then add 1 to the quotient if doubling th','line_number':671,'multiline':False]['text':' remainder would increase the quotient.','line_number':672,'multiline':False]['text':' Note that rem<<1 cannot overflow, since rem < d and d is 33 bits','line_number':673,'multiline':False]['text':' We rounded down in gen (hence +1)','line_number':676,'multiline':False]['text':' Here we wish to compute d = 2^(32+shift+1)/(m+2^32).','line_number':688,'multiline':False]['text':' Notice (m + 2^32) is a 33 bit number. Use 64 bit division for now','line_number':689,'multiline':False]['text':' Also note that shift may be as high as 31, so shift + 1 will','line_number':690,'multiline':False]['text':' overflow. So we have to compute it as 2^(32+shift)/(m+2^32), and','line_number':691,'multiline':False]['text':' then double the quotient and remainder.','line_number':692,'multiline':False]['text':' Note that the quotient is guaranteed <= 32 bits, but the remainder','line_number':695,'multiline':False]['text':' may need 33!','line_number':696,'multiline':False]['text':' We computed 2^(32+shift)/(m+2^32)','line_number':699,'multiline':False]['text':' Need to double it, and then add 1 to the quotient if doubling th','line_number':700,'multiline':False]['text':' remainder would increase the quotient.','line_number':701,'multiline':False]['text':' Note that rem<<1 cannot overflow, since rem < d and d is 33 bits','line_number':702,'multiline':False]['text':' We rounded down in gen (hence +1)','line_number':705,'multiline':False]['text':'///////// UINT64','line_number':710,'multiline':False]['text':' Power of 2','line_number':720,'multiline':False]['text':' We need to subtract 1 from the shift value in case of an unsigned','line_number':722,'multiline':False]['text':' branchfree divider because there is a hardcoded right shift by 1','line_number':723,'multiline':False]['text':' in its division algorithm. Because of this we also need to add back','line_number':724,'multiline':False]['text':' 1 in its recovery algorithm.','line_number':725,'multiline':False]['text':' (1 << (64 + floor_log_2_d)) / d','line_number':731,'multiline':False]['text':' This power works if e < 2**floor_log_2_d.','line_number':737,'multiline':False]['text':' This power works','line_number':739,'multiline':False]['text':' We have to use the general 65-bit algorithm.  We need to compute','line_number':742,'multiline':False]['text':' (2**power) / d. However, we already have (2**(power-1))/d and','line_number':743,'multiline':False]['text':' its remainder. By doubling both, and then correcting the','line_number':744,'multiline':False]['text':' remainder, we can compute the larger division.','line_number':745,'multiline':False]['text':' don't care about overflow here - in fact, we expect it','line_number':746,'multiline':False]['text':' result.more's shift should in general be ceil_log_2_d. But if we','line_number':754,'multiline':False]['text':' used the smaller power, we subtract one from the shift because we're','line_number':755,'multiline':False]['text':' using the smaller power. If we're using the larger power, we','line_number':756,'multiline':False]['text':' subtract one from the shift because it's taken care of by the add','line_number':757,'multiline':False]['text':' indicator. So floor_log_2_d happens to be correct in both cases,','line_number':758,'multiline':False]['text':' which is why we do it outside of the if statement.','line_number':759,'multiline':False]['text':' All upper bits are 0,','line_number':789,'multiline':False]['text':' don't need to mask them off.','line_number':790,'multiline':False]['text':' We compute q = n/d = n*m / 2^(64 + shift)','line_number':809,'multiline':False]['text':' Therefore we have d = 2^(64 + shift) / m','line_number':810,'multiline':False]['text':' We need to ceil it.','line_number':811,'multiline':False]['text':' We know d is not a power of 2, so m is not a power of 2,','line_number':812,'multiline':False]['text':' so we can just add 1 to the floor','line_number':813,'multiline':False]['text':' Here we wish to compute d = 2^(64+shift+1)/(m+2^64).','line_number':818,'multiline':False]['text':' Notice (m + 2^64) is a 65 bit number. This gets hairy. See','line_number':819,'multiline':False]['text':' libdivide_u32_recover for more on what we do here.','line_number':820,'multiline':False]['text':' TODO: do something better than 128 bit math','line_number':821,'multiline':False]['text':' Full n is a (potentially) 129 bit value','line_number':823,'multiline':False]['text':' half_n is a 128 bit value','line_number':824,'multiline':False]['text':' Compute the hi half of half_n. Low half is 0.','line_number':825,'multiline':False]['text':' d is a 65 bit value. The high bit is always set to 1.','line_number':827,'multiline':False]['text':' Note that the quotient is guaranteed <= 64 bits,','line_number':829,'multiline':False]['text':' but the remainder may need 65!','line_number':830,'multiline':False]['text':' We computed 2^(64+shift)/(m+2^64)','line_number':833,'multiline':False]['text':' Double the remainder ('dr') and check if that is larger than d','line_number':834,'multiline':False]['text':' Note that d is a 65 bit value, so r1 is small and so r1 + r1','line_number':835,'multiline':False]['text':' cannot overflow','line_number':836,'multiline':False]['text':' last term is carry','line_number':838,'multiline':False]['text':' Here we wish to compute d = 2^(64+shift+1)/(m+2^64).','line_number':852,'multiline':False]['text':' Notice (m + 2^64) is a 65 bit number. This gets hairy. See','line_number':853,'multiline':False]['text':' libdivide_u32_recover for more on what we do here.','line_number':854,'multiline':False]['text':' TODO: do something better than 128 bit math','line_number':855,'multiline':False]['text':' Full n is a (potentially) 129 bit value','line_number':857,'multiline':False]['text':' half_n is a 128 bit value','line_number':858,'multiline':False]['text':' Compute the hi half of half_n. Low half is 0.','line_number':859,'multiline':False]['text':' d is a 65 bit value. The high bit is always set to 1.','line_number':861,'multiline':False]['text':' Note that the quotient is guaranteed <= 64 bits,','line_number':863,'multiline':False]['text':' but the remainder may need 65!','line_number':864,'multiline':False]['text':' We computed 2^(64+shift)/(m+2^64)','line_number':867,'multiline':False]['text':' Double the remainder ('dr') and check if that is larger than d','line_number':868,'multiline':False]['text':' Note that d is a 65 bit value, so r1 is small and so r1 + r1','line_number':869,'multiline':False]['text':' cannot overflow','line_number':870,'multiline':False]['text':' last term is carry','line_number':872,'multiline':False]['text':'///////// SINT32','line_number':879,'multiline':False]['text':' If d is a power of 2, or negative a power of 2, we have to use a shift.','line_number':888,'multiline':False]['text':' This is especially important because the magic algorithm fails for -1.','line_number':889,'multiline':False]['text':' To check if d is a power of 2 or its inverse, it suffices to check','line_number':890,'multiline':False]['text':' whether its absolute value has exactly one bit set. This works even for','line_number':891,'multiline':False]['text':' INT_MIN, because abs(INT_MIN) == INT_MIN, and INT_MIN has one bit set','line_number':892,'multiline':False]['text':' and is a power of 2.','line_number':893,'multiline':False]['text':' check if exactly one bit is set,','line_number':897,'multiline':False]['text':' don't care if absD is 0 since that's divide by zero','line_number':898,'multiline':False]['text':' Branchfree and normal paths are exactly the same','line_number':900,'multiline':False]['text':' the dividend here is 2**(floor_log_2_d + 31), so the low 32 bit word','line_number':907,'multiline':False]['text':' is 0 and the high word is floor_log_2_d - 1','line_number':908,'multiline':False]['text':' We are going to start with a power of floor_log_2_d - 1.','line_number':913,'multiline':False]['text':' This works if works if e < 2**floor_log_2_d.','line_number':914,'multiline':False]['text':' This power works','line_number':916,'multiline':False]['text':' We need to go one higher. This should not make proposed_m','line_number':919,'multiline':False]['text':' overflow, but it will make it negative when interpreted as an','line_number':920,'multiline':False]['text':' int32_t.','line_number':921,'multiline':False]['text':' Mark if we are negative. Note we only negate the magic number in the','line_number':931,'multiline':False]['text':' branchfull case.','line_number':932,'multiline':False]['text':' must be arithmetic shift and then sign extend','line_number':971,'multiline':False]['text':' q += (more < 0 ? -numer : numer)','line_number':973,'multiline':False]['text':' cast required to avoid UB','line_number':974,'multiline':False]['text':' must be arithmetic shift and then sign extend','line_number':987,'multiline':False]['text':' If q is non-negative, we have nothing to do','line_number':993,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is a power of','line_number':994,'multiline':False]['text':' 2, or (2**shift) if it is not a power of 2','line_number':995,'multiline':False]['text':' Now arithmetic right shift','line_number':1000,'multiline':False]['text':' Negate if needed','line_number':1002,'multiline':False]['text':' Unsigned math is much easier','line_number':1018,'multiline':False]['text':' We negate the magic number only in the branchfull case, and we don't','line_number':1019,'multiline':False]['text':' know which case we're in. However we have enough information to','line_number':1020,'multiline':False]['text':' determine the correct sign of the magic number. The divisor was','line_number':1021,'multiline':False]['text':' negative if LIBDIVIDE_NEGATIVE_DIVISOR is set. If ADD_MARKER is set,','line_number':1022,'multiline':False]['text':' the magic number's sign is opposite that of the divisor.','line_number':1023,'multiline':False]['text':' We want to compute the positive magic number.','line_number':1024,'multiline':False]['text':' Handle the power of 2 case (including branchfree)','line_number':1029,'multiline':False]['text':' this shift cannot exceed 30','line_number':1036,'multiline':False]['text':'/////////// SINT64','line_number':1048,'multiline':False]['text':' If d is a power of 2, or negative a power of 2, we have to use a shift.','line_number':1057,'multiline':False]['text':' This is especially important because the magic algorithm fails for -1.','line_number':1058,'multiline':False]['text':' To check if d is a power of 2 or its inverse, it suffices to check','line_number':1059,'multiline':False]['text':' whether its absolute value has exactly one bit set.  This works even for','line_number':1060,'multiline':False]['text':' INT_MIN, because abs(INT_MIN) == INT_MIN, and INT_MIN has one bit set','line_number':1061,'multiline':False]['text':' and is a power of 2.','line_number':1062,'multiline':False]['text':' check if exactly one bit is set,','line_number':1066,'multiline':False]['text':' don't care if absD is 0 since that's divide by zero','line_number':1067,'multiline':False]['text':' Branchfree and non-branchfree cases are the same','line_number':1069,'multiline':False]['text':' the dividend here is 2**(floor_log_2_d + 63), so the low 64 bit word','line_number':1073,'multiline':False]['text':' is 0 and the high word is floor_log_2_d - 1','line_number':1074,'multiline':False]['text':' We are going to start with a power of floor_log_2_d - 1.','line_number':1080,'multiline':False]['text':' This works if works if e < 2**floor_log_2_d.','line_number':1081,'multiline':False]['text':' This power works','line_number':1083,'multiline':False]['text':' We need to go one higher. This should not make proposed_m','line_number':1086,'multiline':False]['text':' overflow, but it will make it negative when interpreted as an','line_number':1087,'multiline':False]['text':' int32_t.','line_number':1088,'multiline':False]['text':' note that we only set the LIBDIVIDE_NEGATIVE_DIVISOR bit if we','line_number':1092,'multiline':False]['text':' also set ADD_MARKER this is an annoying optimization that','line_number':1093,'multiline':False]['text':' enables algorithm #4 to avoid the mask. However we always set it','line_number':1094,'multiline':False]['text':' in the branchfree case','line_number':1095,'multiline':False]['text':' Mark if we are negative','line_number':1101,'multiline':False]['text':' shift path','line_number':1129,'multiline':False]['text':' must be arithmetic shift and then sign-extend','line_number':1134,'multiline':False]['text':' must be arithmetic shift and then sign extend','line_number':1141,'multiline':False]['text':' q += (more < 0 ? -numer : numer)','line_number':1143,'multiline':False]['text':' cast required to avoid UB','line_number':1144,'multiline':False]['text':' must be arithmetic shift and then sign extend','line_number':1157,'multiline':False]['text':' If q is non-negative, we have nothing to do.','line_number':1163,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is a power of','line_number':1164,'multiline':False]['text':' 2, or (2**shift) if it is not a power of 2.','line_number':1165,'multiline':False]['text':' Arithmetic right shift','line_number':1170,'multiline':False]['text':' Negate if needed','line_number':1172,'multiline':False]['text':' shift path','line_number':1181,'multiline':False]['text':' Unsigned math is much easier','line_number':1188,'multiline':False]['text':'////// Internal Utility Functions','line_number':1221,'multiline':False]['text':' Here, b is assumed to contain one 32-bit value repeated.','line_number':1231,'multiline':False]['text':' b is one 32-bit value repeated.','line_number':1240,'multiline':False]['text':' Here, y is assumed to contain one 64-bit value repeated.','line_number':1249,'multiline':False]['text':' https://stackoverflow.com/a/28827013','line_number':1250,'multiline':False]['text':' y is one 64-bit value repeated.','line_number':1271,'multiline':False]['text':'//////// UINT32','line_number':1281,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1291,'multiline':False]['text':' return t >> denom->shift;','line_number':1292,'multiline':False]['text':'//////// UINT64','line_number':1309,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1319,'multiline':False]['text':' return t >> denom->shift;','line_number':1320,'multiline':False]['text':'//////// SINT32','line_number':1337,'multiline':False]['text':' q = numer + ((numer >> 31) & roundToZeroTweak);','line_number':1345,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1349,'multiline':False]['text':' must be arithmetic shift','line_number':1356,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1358,'multiline':False]['text':' q >>= shift','line_number':1361,'multiline':False]['text':' q += (q < 0)','line_number':1363,'multiline':False]['text':' must be arithmetic shift','line_number':1372,'multiline':False]['text':' q += numers','line_number':1375,'multiline':False]['text':' If q is non-negative, we have nothing to do','line_number':1377,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1378,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2','line_number':1379,'multiline':False]['text':' q_sign = q >> 31','line_number':1381,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1383,'multiline':False]['text':' q >>= shift','line_number':1384,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1385,'multiline':False]['text':'//////// SINT64','line_number':1389,'multiline':False]['text':' shift path','line_number':1394,'multiline':False]['text':' q = numer + ((numer >> 63) & roundToZeroTweak);','line_number':1398,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1402,'multiline':False]['text':' must be arithmetic shift','line_number':1409,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1411,'multiline':False]['text':' q >>= denom->mult_path.shift','line_number':1414,'multiline':False]['text':' q += (q < 0)','line_number':1416,'multiline':False]['text':' must be arithmetic shift','line_number':1425,'multiline':False]['text':' libdivide_mullhi_s64(numers, magic);','line_number':1428,'multiline':False]['text':' q += numers','line_number':1430,'multiline':False]['text':' If q is non-negative, we have nothing to do.','line_number':1432,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1433,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2.','line_number':1434,'multiline':False]['text':' q_sign = q >> 63','line_number':1436,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1438,'multiline':False]['text':' q >>= shift','line_number':1439,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1440,'multiline':False]['text':'////// Internal Utility Functions','line_number':1456,'multiline':False]['text':' Implementation of _mm256_srai_epi64(v, 63) (from AVX512).','line_number':1458,'multiline':False]['text':' Implementation of _mm256_srai_epi64 (from AVX512).','line_number':1465,'multiline':False]['text':' Here, b is assumed to contain one 32-bit value repeated.','line_number':1474,'multiline':False]['text':' b is one 32-bit value repeated.','line_number':1483,'multiline':False]['text':' Here, y is assumed to contain one 64-bit value repeated.','line_number':1492,'multiline':False]['text':' https://stackoverflow.com/a/28827013','line_number':1493,'multiline':False]['text':' x0l, x0h, x1l, x1h','line_number':1496,'multiline':False]['text':' y0l, y0h, y1l, y1h','line_number':1497,'multiline':False]['text':' x0l*y0l, x1l*y1l','line_number':1498,'multiline':False]['text':' x0l*y0h, x1l*y1h','line_number':1499,'multiline':False]['text':' x0h*y0l, x1h*y0l','line_number':1500,'multiline':False]['text':' x0h*y0h, x1h*y1h','line_number':1501,'multiline':False]['text':' y is one 64-bit value repeated.','line_number':1514,'multiline':False]['text':'//////// UINT32','line_number':1524,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1534,'multiline':False]['text':' return t >> denom->shift;','line_number':1535,'multiline':False]['text':'//////// UINT64','line_number':1552,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1562,'multiline':False]['text':' return t >> denom->shift;','line_number':1563,'multiline':False]['text':'//////// SINT32','line_number':1580,'multiline':False]['text':' q = numer + ((numer >> 31) & roundToZeroTweak);','line_number':1588,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1592,'multiline':False]['text':' must be arithmetic shift','line_number':1599,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1601,'multiline':False]['text':' q >>= shift','line_number':1604,'multiline':False]['text':' q += (q < 0)','line_number':1606,'multiline':False]['text':' must be arithmetic shift','line_number':1615,'multiline':False]['text':' q += numers','line_number':1618,'multiline':False]['text':' If q is non-negative, we have nothing to do','line_number':1620,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1621,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2','line_number':1622,'multiline':False]['text':' q_sign = q >> 31','line_number':1624,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1626,'multiline':False]['text':' q >>= shift','line_number':1627,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1628,'multiline':False]['text':'//////// SINT64','line_number':1632,'multiline':False]['text':' shift path','line_number':1637,'multiline':False]['text':' q = numer + ((numer >> 63) & roundToZeroTweak);','line_number':1641,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1645,'multiline':False]['text':' must be arithmetic shift','line_number':1652,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1654,'multiline':False]['text':' q >>= denom->mult_path.shift','line_number':1657,'multiline':False]['text':' q += (q < 0)','line_number':1659,'multiline':False]['text':' must be arithmetic shift','line_number':1668,'multiline':False]['text':' libdivide_mullhi_s64(numers, magic);','line_number':1671,'multiline':False]['text':' q += numers','line_number':1673,'multiline':False]['text':' If q is non-negative, we have nothing to do.','line_number':1675,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1676,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2.','line_number':1677,'multiline':False]['text':' q_sign = q >> 63','line_number':1679,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1681,'multiline':False]['text':' q >>= shift','line_number':1682,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1683,'multiline':False]['text':'////// Internal Utility Functions','line_number':1699,'multiline':False]['text':' Implementation of _mm_srai_epi64(v, 63) (from AVX512).','line_number':1701,'multiline':False]['text':' Implementation of _mm_srai_epi64 (from AVX512).','line_number':1708,'multiline':False]['text':' Here, b is assumed to contain one 32-bit value repeated.','line_number':1717,'multiline':False]['text':' SSE2 does not have a signed multiplication instruction, but we can convert','line_number':1726,'multiline':False]['text':' unsigned to signed pretty efficiently. Again, b is just a 32 bit value','line_number':1727,'multiline':False]['text':' repeated four times.','line_number':1728,'multiline':False]['text':' t1 = (a >> 31) & y, arithmetic shift','line_number':1731,'multiline':False]['text':' Here, y is assumed to contain one 64-bit value repeated.','line_number':1739,'multiline':False]['text':' https://stackoverflow.com/a/28827013','line_number':1740,'multiline':False]['text':' x0l, x0h, x1l, x1h','line_number':1743,'multiline':False]['text':' y0l, y0h, y1l, y1h','line_number':1744,'multiline':False]['text':' x0l*y0l, x1l*y1l','line_number':1745,'multiline':False]['text':' x0l*y0h, x1l*y1h','line_number':1746,'multiline':False]['text':' x0h*y0l, x1h*y0l','line_number':1747,'multiline':False]['text':' x0h*y0h, x1h*y1h','line_number':1748,'multiline':False]['text':' y is one 64-bit value repeated.','line_number':1761,'multiline':False]['text':'//////// UINT32','line_number':1771,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1781,'multiline':False]['text':' return t >> denom->shift;','line_number':1782,'multiline':False]['text':'//////// UINT64','line_number':1799,'multiline':False]['text':' uint32_t t = ((numer - q) >> 1) + q;','line_number':1809,'multiline':False]['text':' return t >> denom->shift;','line_number':1810,'multiline':False]['text':'//////// SINT32','line_number':1827,'multiline':False]['text':' q = numer + ((numer >> 31) & roundToZeroTweak);','line_number':1835,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1839,'multiline':False]['text':' must be arithmetic shift','line_number':1846,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1848,'multiline':False]['text':' q >>= shift','line_number':1851,'multiline':False]['text':' q += (q < 0)','line_number':1853,'multiline':False]['text':' must be arithmetic shift','line_number':1862,'multiline':False]['text':' q += numers','line_number':1865,'multiline':False]['text':' If q is non-negative, we have nothing to do','line_number':1867,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1868,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2','line_number':1869,'multiline':False]['text':' q_sign = q >> 31','line_number':1871,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1873,'multiline':False]['text':' q >>= shift','line_number':1874,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1875,'multiline':False]['text':'//////// SINT64','line_number':1879,'multiline':False]['text':' shift path','line_number':1884,'multiline':False]['text':' q = numer + ((numer >> 63) & roundToZeroTweak);','line_number':1888,'multiline':False]['text':' q = (q ^ sign) - sign;','line_number':1892,'multiline':False]['text':' must be arithmetic shift','line_number':1899,'multiline':False]['text':' q += ((numer ^ sign) - sign);','line_number':1901,'multiline':False]['text':' q >>= denom->mult_path.shift','line_number':1904,'multiline':False]['text':' q += (q < 0)','line_number':1906,'multiline':False]['text':' must be arithmetic shift','line_number':1915,'multiline':False]['text':' libdivide_mullhi_s64(numers, magic);','line_number':1918,'multiline':False]['text':' q += numers','line_number':1920,'multiline':False]['text':' If q is non-negative, we have nothing to do.','line_number':1922,'multiline':False]['text':' If q is negative, we want to add either (2**shift)-1 if d is','line_number':1923,'multiline':False]['text':' a power of 2, or (2**shift) if it is not a power of 2.','line_number':1924,'multiline':False]['text':' q_sign = q >> 63','line_number':1926,'multiline':False]['text':' q = q + (q_sign & mask)','line_number':1928,'multiline':False]['text':' q >>= shift','line_number':1929,'multiline':False]['text':' q = (q ^ sign) - sign','line_number':1930,'multiline':False]['text':'///////// C++ stuff','line_number':1936,'multiline':False]['text':' The C++ divider class is templated on both an integer type','line_number':1940,'multiline':False]['text':' (like uint64_t) and an algorithm type.','line_number':1941,'multiline':False]['text':' * BRANCHFULL is the default algorithm type.','line_number':1942,'multiline':False]['text':' * BRANCHFREE is the branchfree algorithm type.','line_number':1943,'multiline':False]['text':' The DISPATCHER_GEN() macro generates C++ methods (for the given integer','line_number':1966,'multiline':False]['text':' and algorithm types) that redirect to libdivide's C API.','line_number':1967,'multiline':False]['text':' The dispatcher selects a specific division algorithm for a given','line_number':1982,'multiline':False]['text':' type and ALGO using partial template specialization.','line_number':1983,'multiline':False]['text':' This is the main divider class for use by the user (C++ API).','line_number':1995,'multiline':False]['text':' The actual division algorithm is selected using the dispatcher struct','line_number':1996,'multiline':False]['text':' based on the integer and algorithm template parameters.','line_number':1997,'multiline':False]['text':' We leave the default constructor empty so that creating','line_number':2001,'multiline':False]['text':' an array of dividers and then initializing them','line_number':2002,'multiline':False]['text':' later doesn't slow us down.','line_number':2003,'multiline':False]['text':' Constructor that takes the divisor as a parameter','line_number':2006,'multiline':False]['text':' Divides n by the divisor','line_number':2009,'multiline':False]['text':' Recovers the divisor, returns the value that was','line_number':2014,'multiline':False]['text':' used to initialize this divider object.','line_number':2015,'multiline':False]['text':' Treats the vector as packed integer values with the same type as','line_number':2030,'multiline':False]['text':' the divider (e.g. s32, u32, s64, u64) and divides each of','line_number':2031,'multiline':False]['text':' them by the divider, returning the packed quotients.','line_number':2032,'multiline':False]['text':' Storage for the actual divisor','line_number':2039,'multiline':False]['text':' Overload of operator / for scalar division','line_number':2044,'multiline':False]['text':' Overload of operator /= for scalar division','line_number':2050,'multiline':False]['text':' Overload of operator / for vector division','line_number':2058,'multiline':False]['text':' Overload of operator /= for vector division','line_number':2063,'multiline':False]['text':' libdivdie::branchfree_divider<T>','line_number':2071,'multiline':False]['text':' namespace libdivide','line_number':2075,'multiline':False]['text':' __cplusplus','line_number':2077,'multiline':False]['text':' NUMPY_CORE_INCLUDE_NUMPY_LIBDIVIDE_LIBDIVIDE_H_','line_number':2079,'multiline':False]