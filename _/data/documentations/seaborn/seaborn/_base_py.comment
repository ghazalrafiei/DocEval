['text':' -- Default attributes that all SemanticMapping subclasses must set','line_number':32,'multiline':False]['text':' Whether the mapping is numeric, categorical, or datetime','line_number':34,'multiline':False]['text':' Ordered list of unique values in the input data','line_number':37,'multiline':False]['text':' A mapping from the data values to corresponding plot attributes','line_number':40,'multiline':False]['text':' TODO Putting this here so we can continue to use a lot of the','line_number':45,'multiline':False]['text':' logic that's built into the library, but the idea of this class','line_number':46,'multiline':False]['text':' is to move towards semantic mappings that are agnostic about the','line_number':47,'multiline':False]['text':' kind of plot they're going to be used to draw.','line_number':48,'multiline':False]['text':' Fully achieving that is going to take some thinking.','line_number':49,'multiline':False]['text':' Copied from _core/properties; eventually will be replaced for that.','line_number':54,'multiline':False]['text':' A specification of the colors that should appear in the plot','line_number':90,'multiline':False]['text':' An object that normalizes data values to [0, 1] range for color mapping','line_number':93,'multiline':False]['text':' A continuous colormap object for interpolating in a numeric context','line_number':96,'multiline':False]['text':' Our goal is to end up with a dictionary mapping every unique','line_number':132,'multiline':False]['text':' value in `data` to a color. We will also keep track of the','line_number':133,'multiline':False]['text':' metadata about this mapping we will need for, e.g., a legend','line_number':134,'multiline':False]['text':' --- Option 1: numeric mapping with a matplotlib colormap','line_number':136,'multiline':False]['text':' --- Option 2: categorical mapping using seaborn palette','line_number':145,'multiline':False]['text':' --- Option 3: datetime mapping','line_number':154,'multiline':False]['text':' TODO this needs actual implementation','line_number':157,'multiline':False]['text':' Casting data to list to handle differences in the way','line_number':160,'multiline':False]['text':' pandas and numpy represent datetime64 data','line_number':161,'multiline':False]['text':' Use a value that's in the original data vector','line_number':176,'multiline':False]['text':' Currently we only get here in scatterplot with hue_order,','line_number':181,'multiline':False]['text':' because scatterplot does not consider hue a grouping variable','line_number':182,'multiline':False]['text':' So unused hue levels are in the data, but not the lookup table','line_number':183,'multiline':False]['text':' Use the colormap to interpolate between existing datapoints','line_number':186,'multiline':False]['text':' (e.g. in the context of making a continuous legend)','line_number':187,'multiline':False]['text':' -- Identify the order and name of the levels','line_number':222,'multiline':False]['text':' -- Identify the set of colors to use','line_number':227,'multiline':False]['text':' The presence of a norm object overrides a dictionary of hues','line_number':258,'multiline':False]['text':' in specifying a numeric mapping, so we need to process it here.','line_number':259,'multiline':False]['text':' The levels are the sorted unique values in the data','line_number':267,'multiline':False]['text':' --- Sort out the colormap to use from the palette argument','line_number':270,'multiline':False]['text':' Default numeric palette is our default cubehelix palette','line_number':272,'multiline':False]['text':' TODO do we want to do something complicated to ensure contrast?','line_number':273,'multiline':False]['text':' Now sort out the data normalization','line_number':281,'multiline':False]['text':' An object that normalizes data values to [0, 1] range','line_number':300,'multiline':False]['text':' --- Option 1: numeric mapping','line_number':323,'multiline':False]['text':' --- Option 2: categorical mapping','line_number':331,'multiline':False]['text':' --- Option 3: datetime mapping','line_number':340,'multiline':False]['text':' TODO this needs an actual implementation','line_number':342,'multiline':False]['text':' Casting data to list to handle differences in the way','line_number':346,'multiline':False]['text':' pandas and numpy represent datetime64 data','line_number':347,'multiline':False]['text':' Dict inputs map existing data values to the size attribute','line_number':387,'multiline':False]['text':' List inputs give size values in the same order as the levels','line_number':396,'multiline':False]['text':' Tuple input sets the min, max size values','line_number':404,'multiline':False]['text':' Otherwise, we need to get the min, max size values from','line_number':416,'multiline':False]['text':' the plotter object we are attached to.','line_number':417,'multiline':False]['text':' TODO this is going to cause us trouble later, because we','line_number':419,'multiline':False]['text':' want to restructure things so that the plotter is generic','line_number':420,'multiline':False]['text':' across the visual representation of the data. But at this','line_number':421,'multiline':False]['text':' point, we don't know the visual representation. Likely we','line_number':422,'multiline':False]['text':' want to change the logic of this Mapping so that it gives','line_number':423,'multiline':False]['text':' points on a normalized range that then gets un-normalized','line_number':424,'multiline':False]['text':' when we know what we're drawing. But given the way the','line_number':425,'multiline':False]['text':' package works now, this way is cleanest.','line_number':426,'multiline':False]['text':' For categorical sizes, use regularly-spaced linear steps','line_number':429,'multiline':False]['text':' between the minimum and maximum sizes. Then reverse the','line_number':430,'multiline':False]['text':' ramp so that the largest value is used for the first entry','line_number':431,'multiline':False]['text':' in size_order, etc. This is because "ordered" categories','line_number':432,'multiline':False]['text':' are often though to go in decreasing priority.','line_number':433,'multiline':False]['text':' The presence of a norm object overrides a dictionary of sizes','line_number':442,'multiline':False]['text':' in specifying a numeric mapping, so we need to process it','line_number':443,'multiline':False]['text':' dictionary here','line_number':444,'multiline':False]['text':' The levels here will be the unique values in the data','line_number':451,'multiline':False]['text':' For numeric inputs, the size can be parametrized by','line_number':456,'multiline':False]['text':' the minimum and maximum artist values to map to. The','line_number':457,'multiline':False]['text':' norm object that gets set up next specifies how to','line_number':458,'multiline':False]['text':' do the mapping.','line_number':459,'multiline':False]['text':' When not provided, we get the size range from the plotter','line_number':474,'multiline':False]['text':' object we are attached to. See the note in the categorical','line_number':475,'multiline':False]['text':' method about how this is suboptimal for future development.','line_number':476,'multiline':False]['text':' Now that we know the minimum and maximum sizes that will get drawn,','line_number':479,'multiline':False]['text':' we need to map the data values that we have into that range. We will','line_number':480,'multiline':False]['text':' use a matplotlib Normalize class, which is typically used for numeric','line_number':481,'multiline':False]['text':' color mapping but works fine here too. It takes data values and maps','line_number':482,'multiline':False]['text':' them into a [0, 1] interval, potentially nonlinear-ly.','line_number':483,'multiline':False]['text':' Default is a linear function between the min and max data values','line_number':486,'multiline':False]['text':' It is also possible to give different limits in data space','line_number':489,'multiline':False]['text':' If provided with Normalize object, copy it so we can modify','line_number':495,'multiline':False]['text':' Set the mapping so all output values are in [0, 1]','line_number':498,'multiline':False]['text':' If the input range is not set, use the full range of the data','line_number':501,'multiline':False]['text':' Map from data values to [0, 1] range','line_number':505,'multiline':False]['text':' Now map from the scaled range into the artist units','line_number':508,'multiline':False]['text':' Style mapping is always treated as categorical','line_number':522,'multiline':False]['text':' Cast to list to handle numpy/pandas datetime quirks','line_number':539,'multiline':False]['text':' Find ordered unique values','line_number':543,'multiline':False]['text':' Build the paths matplotlib will use to draw the markers','line_number':553,'multiline':False]['text':' Mixture of filled and unfilled markers will show line art markers','line_number':562,'multiline':False]['text':' in the edge color, which defaults to white. This can be handled,','line_number':563,'multiline':False]['text':' but there would be additional complexity with specifying the','line_number':564,'multiline':False]['text':' weight of the line art markers without overwhelming the filled','line_number':565,'multiline':False]['text':' ones with the edges. So for now, we will disallow mixtures.','line_number':566,'multiline':False]['text':' =========================================================================== #','line_number':613,'multiline':False]['text':' Unused but needed in tests, ugh','line_number':624,'multiline':False]['text':' var_ordered is relevant only for categorical axis variables, and may','line_number':629,'multiline':False]['text':' be better handled by an internal axis information object that tracks','line_number':630,'multiline':False]['text':' such information and is set up by the scale_* methods. The analogous','line_number':631,'multiline':False]['text':' information for numeric axes would be information about log scales.','line_number':632,'multiline':False]['text':' alt., used DefaultDict','line_number':633,'multiline':False]['text':' TODO Lots of tests assume that these are called to initialize the','line_number':636,'multiline':False]['text':' mappings to default values on class initialization. I'd prefer to','line_number':637,'multiline':False]['text':' move away from that and only have a mapping when explicitly called.','line_number':638,'multiline':False]['text':' When dealing with long-form input, use the newer PlotData','line_number':675,'multiline':False]['text':' object (internal but introduced for the objects interface)','line_number':676,'multiline':False]['text':' to centralize / standardize data consumption logic.','line_number':677,'multiline':False]['text':' Raise if semantic or other variables are assigned in wide-form mode','line_number':717,'multiline':False]['text':' Determine if the data object actually has any data in it','line_number':725,'multiline':False]['text':' Then, determine if we have "flat" data (a single vector)','line_number':728,'multiline':False]['text':' Make an object with the structure of plot_data, but empty','line_number':740,'multiline':False]['text':' Handle flat data by converting to pandas Series and using the','line_number':746,'multiline':False]['text':' index and/or values to define x and/or y','line_number':747,'multiline':False]['text':' (Could be accomplished with a more general to_series() interface)','line_number':748,'multiline':False]['text':' Otherwise assume we have some collection of vectors.','line_number':768,'multiline':False]['text':' Handle Python sequences such that entries end up in the columns,','line_number':770,'multiline':False]['text':' not in the rows, of the intermediate wide DataFrame.','line_number':771,'multiline':False]['text':' One way to accomplish this is to convert to a dict of Series.','line_number':772,'multiline':False]['text':' TODO is there a safer/more generic way to ensure Series?','line_number':777,'multiline':False]['text':' sort of like np.asarray, but for pandas?','line_number':778,'multiline':False]['text':' Pandas requires that dict values either be Series objects','line_number':783,'multiline':False]['text':' or all have the same length, but we want to allow "ragged" inputs','line_number':784,'multiline':False]['text':' Otherwise, delegate to the pandas DataFrame constructor','line_number':788,'multiline':False]['text':' This is where we'd prefer to use a general interface that says','line_number':789,'multiline':False]['text':' "give me this data as a pandas DataFrame", so we can accept','line_number':790,'multiline':False]['text':' DataFrame objects from other libraries','line_number':791,'multiline':False]['text':' At this point we should reduce the dataframe to numeric cols','line_number':794,'multiline':False]['text':' Now melt the data to long form','line_number':800,'multiline':False]['text':' Assign names corresponding to plot semantics','line_number':822,'multiline':False]['text':' Define the variable names','line_number':826,'multiline':False]['text':' Remove redundant columns from plot_data','line_number':832,'multiline':False]['text':' TODO should this default to using all (non x/y?) semantics?','line_number':882,'multiline':False]['text':' or define grouping vars somewhere?','line_number':883,'multiline':False]['text':' Always insert faceting variables','line_number':891,'multiline':False]['text':' Reduce to the semantics used in this plot','line_number':898,'multiline':False]['text':' If the axis is ordered, then the axes in a possible','line_number':915,'multiline':False]['text':' facet grid are by definition "shared", or there is a','line_number':916,'multiline':False]['text':' single axis with a unique cat -> idx mapping.','line_number':917,'multiline':False]['text':' So we can just take the first converter object.','line_number':918,'multiline':False]['text':' Otherwise, the mappings may not be unique, but we can','line_number':921,'multiline':False]['text':' use the unique set of index values in comp_data.','line_number':922,'multiline':False]['text':' Pandas fails with singleton tuple inputs','line_number':945,'multiline':False]['text':' XXX we are adding this to allow backwards compatibility','line_number':951,'multiline':False]['text':' with the empty artists that old categorical plots would','line_number':952,'multiline':False]['text':' add (before 0.12), which we may decide to break, in which','line_number':953,'multiline':False]['text':' case this option could be removed','line_number':954,'multiline':False]['text':' Probably a good idea, but will need a bunch of tests updated','line_number':972,'multiline':False]['text':' Most of these tests should just use the external interface','line_number':973,'multiline':False]['text':' Then this can be re-enabled.','line_number':974,'multiline':False]['text':' raise AttributeError("No Axes attached to plotter")','line_number':975,'multiline':False]['text':' TODO this should happen in some centralized location','line_number':996,'multiline':False]['text':' it is similar to GH2419, but more complicated because','line_number':997,'multiline':False]['text':' supporting `order` in categorical plots is tricky','line_number':998,'multiline':False]['text':' Identify which "axis" variables we have defined','line_number':1063,'multiline':False]['text':' -- Verify the types of our x and y variables here.','line_number':1066,'multiline':False]['text':' This doesn't really make complete sense being here here, but it's a fine','line_number':1067,'multiline':False]['text':' place for it, given  the current system.','line_number':1068,'multiline':False]['text':' (Note that for some plots, there might be more complicated restrictions)','line_number':1069,'multiline':False]['text':' e.g. the categorical plots have their own check that as specific to the','line_number':1070,'multiline':False]['text':' non-categorical axis.','line_number':1071,'multiline':False]['text':' -- Get axis objects for each row in plot_data for type conversions and scaling','line_number':1086,'multiline':False]['text':' Simplest cases are that we have a single axes, all axes are shared,','line_number':1097,'multiline':False]['text':' or sharing is only on the orthogonal facet dimension. In these cases,','line_number':1098,'multiline':False]['text':' all datapoints get converted the same way, so use the first axis','line_number':1099,'multiline':False]['text':' Next simplest case is when no axes are shared, and we can','line_number':1105,'multiline':False]['text':' use the axis objects within each facet','line_number':1106,'multiline':False]['text':' In the more complicated case, the axes are shared within each','line_number':1112,'multiline':False]['text':' "file" of the facetgrid. In that case, we need to subset the data','line_number':1113,'multiline':False]['text':' for that file and assign it the first axis in the slice of the grid','line_number':1114,'multiline':False]['text':' Store the converter vector, which we use elsewhere (e.g comp_data)','line_number':1123,'multiline':False]['text':' Now actually update the matplotlib objects to do the conversion we want','line_number':1126,'multiline':False]['text':' -- Set numerical axis scales','line_number':1137,'multiline':False]['text':' First unpack the log_scale argument','line_number':1139,'multiline':False]['text':' Allow single value or x, y tuple','line_number':1143,'multiline':False]['text':' Now use it','line_number':1150,'multiline':False]['text':' For categorical y, we want the "first" level to be at the top of the axis','line_number':1160,'multiline':False]['text':' mpl < 3.1','line_number':1165,'multiline':False]['text':' TODO -- Add axes labels','line_number':1169,'multiline':False]['text':' It is a simplifying assumption that faceted axes will always have','line_number':1177,'multiline':False]['text':' the same scale (even if they are unshared and have distinct limits).','line_number':1178,'multiline':False]['text':' Nothing in the seaborn API allows you to create a FacetGrid with','line_number':1179,'multiline':False]['text':' a mixture of scales, although it's possible via matplotlib.','line_number':1180,'multiline':False]['text':' This is constraining, but no more so than previous behavior that','line_number':1181,'multiline':False]['text':' only (properly) handled log scales, and there are some places where','line_number':1182,'multiline':False]['text':' it would be much too complicated to use axes-specific transforms.','line_number':1183,'multiline':False]['text':' This case is more straightforward','line_number':1188,'multiline':False]['text':' TODO ax could default to None and use attached axes if present','line_number':1195,'multiline':False]['text':' but what to do about the case of facets? Currently using FacetGrid's','line_number':1196,'multiline':False]['text':' set_axis_labels method, which doesn't add labels to the interior even','line_number':1197,'multiline':False]['text':' when the axes are not shared. Maybe that makes sense?','line_number':1198,'multiline':False]['text':' Assign a legend title if there is only going to be one sub-legend,','line_number':1222,'multiline':False]['text':' otherwise, subtitles will be inserted into the texts list with an','line_number':1223,'multiline':False]['text':' invisible handle (which is a hack)','line_number':1224,'multiline':False]['text':' Don't allow color=None so we can set a neutral color for size/style legends','line_number':1254,'multiline':False]['text':' XXX If the scale_* methods are going to modify the plot_data structure, they','line_number':1337,'multiline':False]['text':' can't be called twice. That means that if they are called twice, they should','line_number':1338,'multiline':False]['text':' raise. Alternatively, we could store an original version of plot_data and each','line_number':1339,'multiline':False]['text':' time they are called they operate on the store, not the current state.','line_number':1340,'multiline':False]['text':' Default, defer to matplotlib','line_number':1344,'multiline':False]['text':' Feels needed to completeness, what should it do?','line_number':1350,'multiline':False]['text':' Perhaps handle log scaling? Set the ticker/formatter/limits?','line_number':1351,'multiline':False]['text':' Use pd.to_datetime to convert strings or numbers to datetime objects','line_number':1357,'multiline':False]['text':' Note, use day-resolution for numeric->datetime to match matplotlib','line_number':1358,'multiline':False]['text':' This method both modifies the internal representation of the data','line_number':1380,'multiline':False]['text':' (converting it to string) and sets some attributes on self. It might be','line_number':1381,'multiline':False]['text':' a good idea to have a separate object attached to self that contains the','line_number':1382,'multiline':False]['text':' information in those attributes (i.e. whether to enforce variable order','line_number':1383,'multiline':False]['text':' across facets, the order to use) similar to the SemanticMapping objects','line_number':1384,'multiline':False]['text':' we have for semantic variables. That object could also hold the converter','line_number':1385,'multiline':False]['text':' objects that get used, if we can decouple those from an existing axis','line_number':1386,'multiline':False]['text':' (cf. https://github.com/matplotlib/matplotlib/issues/19229).','line_number':1387,'multiline':False]['text':' There are some interactions with faceting information that would need','line_number':1388,'multiline':False]['text':' to be thought through, since the converts to use depend on facets.','line_number':1389,'multiline':False]['text':' If we go that route, these methods could become "borrowed" methods similar','line_number':1390,'multiline':False]['text':' to what happens with the alternate semantic mapper constructors, although','line_number':1391,'multiline':False]['text':' that approach is kind of fussy and confusing.','line_number':1392,'multiline':False]['text':' TODO this method could also set the grid state? Since we like to have no','line_number':1394,'multiline':False]['text':' grid on the categorical axis by default. Again, a case where we'll need to','line_number':1395,'multiline':False]['text':' store information until we use it, so best to have a way to collect the','line_number':1396,'multiline':False]['text':' attributes that this method sets.','line_number':1397,'multiline':False]['text':' TODO if we are going to set visual properties of the axes with these methods,','line_number':1399,'multiline':False]['text':' then we could do the steps currently in CategoricalPlotter._adjust_cat_axis','line_number':1400,'multiline':False]['text':' TODO another, and distinct idea, is to expose a cut= param here','line_number':1402,'multiline':False]['text':' Categorical plots can be "univariate" in which case they get an anonymous','line_number':1406,'multiline':False]['text':' category label on the opposite axis.','line_number':1407,'multiline':False]['text':' If the "categorical" variable has a numeric type, sort the rows so that','line_number':1413,'multiline':False]['text':' the default result from categorical_order has those values sorted after','line_number':1414,'multiline':False]['text':' they have been coerced to strings. The reason for this is so that later','line_number':1415,'multiline':False]['text':' we can get facet-wise orders that are correct.','line_number':1416,'multiline':False]['text':' XXX Should this also sort datetimes?','line_number':1417,'multiline':False]['text':' It feels more consistent, but technically will be a default change','line_number':1418,'multiline':False]['text':' If so, should also change categorical_order to behave that way','line_number':1419,'multiline':False]['text':' Now get a reference to the categorical data vector and remove na values','line_number':1423,'multiline':False]['text':' Get the initial categorical order, which we do before string','line_number':1426,'multiline':False]['text':' conversion to respect the original types of the order list.','line_number':1427,'multiline':False]['text':' Track whether the order is given explicitly so that we can know','line_number':1428,'multiline':False]['text':' whether or not to use the order constructed here downstream','line_number':1429,'multiline':False]['text':' Then convert data to strings. This is because in matplotlib,','line_number':1433,'multiline':False]['text':' "categorical" data really mean "string" data, so doing this artists','line_number':1434,'multiline':False]['text':' will be drawn on the categorical axis with a fixed scale.','line_number':1435,'multiline':False]['text':' TODO implement formatter here; check that it returns strings?','line_number':1436,'multiline':False]['text':' Update the levels list with the type-converted order variable','line_number':1444,'multiline':False]['text':' Now ensure that seaborn will use categorical rules internally','line_number':1447,'multiline':False]['text':' Put the string-typed categorical vector back into the plot_data structure','line_number':1450,'multiline':False]['text':' TODO we can replace this with typing.Literal on Python 3.8+','line_number':1464,'multiline':False]['text':' If a categorical dtype is set, infer categorical','line_number':1501,'multiline':False]['text':' Special-case all-na data, which is always "numeric"','line_number':1505,'multiline':False]['text':' At this point, drop nans to simplify further type inference','line_number':1509,'multiline':False]['text':' Special-case binary/boolean data, allow caller to determine','line_number':1512,'multiline':False]['text':' This triggers a numpy warning when vector has strings/objects','line_number':1513,'multiline':False]['text':' https://github.com/numpy/numpy/issues/6784','line_number':1514,'multiline':False]['text':' Because we reduce with .all(), we are agnostic about whether the','line_number':1515,'multiline':False]['text':' comparison returns a scalar or vector, so we will ignore the warning.','line_number':1516,'multiline':False]['text':' It triggers a separate DeprecationWarning when the vector has datetimes:','line_number':1517,'multiline':False]['text':' https://github.com/numpy/numpy/issues/13548','line_number':1518,'multiline':False]['text':' This is considered a bug by numpy and will likely go away.','line_number':1519,'multiline':False]['text':' .isin comparison is not guaranteed to be possible under NumPy','line_number':1528,'multiline':False]['text':' casting rules, depending on the (unknown) dtype of 'vector'','line_number':1529,'multiline':False]['text':' Defer to positive pandas tests','line_number':1532,'multiline':False]['text':' --- If we get to here, we need to check the entries','line_number':1539,'multiline':False]['text':' Check for a collection where everything is a number','line_number':1541,'multiline':False]['text':' Check for a collection where everything is a datetime','line_number':1552,'multiline':False]['text':' Otherwise, our final fallback is to consider things categorical','line_number':1563,'multiline':False]['text':' Start with dash specs that are well distinguishable','line_number':1668,'multiline':False]['text':' Now programmatically build as many as we need','line_number':1677,'multiline':False]['text':' Take combinations of long and short dashes','line_number':1681,'multiline':False]['text':' Interleave the combinations, reversing one of the streams','line_number':1685,'multiline':False]['text':' Now insert the gaps','line_number':1691,'multiline':False]['text':' Start with marker specs that are well distinguishable','line_number':1717,'multiline':False]['text':' Now generate more from regular polygons of increasing order','line_number':1730,'multiline':False]['text':' Convert to MarkerStyle object, using only exactly what we need','line_number':1742,'multiline':False]['text':' markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]','line_number':1743,'multiline':False]