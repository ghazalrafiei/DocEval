['text':' NOTE: assumes valid utf8 (but checks for overrun)','line_number':10,'multiline':False]['text':' copied from llama.cpp','line_number':11,'multiline':False]['text':' may overrun!','line_number':19,'multiline':False]['text':' literal string','line_number':141,'multiline':False]['text':' char range(s)','line_number':150,'multiline':False]['text':' rule reference','line_number':173,'multiline':False]['text':' grouping','line_number':179,'multiline':False]['text':' parse nested alternates into synthesized rule','line_number':180,'multiline':False]['text':' output reference to synthesized rule','line_number':185,'multiline':False]['text':' repetition operator','line_number':191,'multiline':False]['text':' apply transformation to previous symbol (last_sym_start to end) according to','line_number':196,'multiline':False]['text':' rewrite rules:','line_number':197,'multiline':False]['text':' S* --> S' ::= S S' |','line_number':198,'multiline':False]['text':' S+ --> S' ::= S S' | S','line_number':199,'multiline':False]['text':' S? --> S' ::= S |','line_number':200,'multiline':False]['text':' add preceding symbol to generated rule','line_number':203,'multiline':False]['text':' cause generated rule to recurse','line_number':207,'multiline':False]['text':' mark start of alternate def','line_number':210,'multiline':False]['text':' add preceding symbol as alternate only for '+' (otherwise empty)','line_number':213,'multiline':False]['text':' in original rule, replace previous symbol with reference to generated rule','line_number':220,'multiline':False]['text':' cop out of encoding UTF-8','line_number':292,'multiline':False]['text':' fprintf(file, "%zu: ", i);','line_number':406,'multiline':False]['text':' print_rule_binary(file, state.rules[i]);','line_number':407,'multiline':False]['text':' fprintf(file, "\n");','line_number':409,'multiline':False]